Copyright Isaac Jones 2003-2005.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
module Paths_Cabal (
	version,
	getBinDir, getLibDir, getDataDir, getLibexecDir,
	getDataFileName
	) where

import Data.Version

version = Version {versionBranch = [1,1,5,9,2], versionTags = []}

bindir     = "/usr/local/bin"
libdir     = "/usr/local/lib/hugs/packages/Cabal"
datadir    = "/usr/local/share/Cabal-1.1.5.9.2"
libexecdir = "/usr/local/libexec"

getBinDir, getLibDir, getDataDir, getLibexecDir :: IO FilePath
getBinDir = return bindir
getLibDir = return libdir
getDataDir = return datadir
getLibexecDir = return libexecdir

getDataFileName :: FilePath -> IO FilePath
getDataFileName name = return (datadir ++ "/" ++ name)
Copyright (c) 2003-2005, Isaac Jones, Simon Marlow, Martin Sj√∂gren,
                         Bjorn Bringert, Krasimir Angelov,
                         Malcolm Wallace, Ross Patterson
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Compiler
-- Copyright   :  Isaac Jones 2003-2004
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- Haskell implementations.

{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Compiler (
        -- * Haskell implementations
	CompilerFlavor(..), Compiler(..), showCompilerId,
	compilerBinaryName,
        -- * Support for language extensions
        Opt,
        extensionsToFlags,
        extensionsToGHCFlag, extensionsToHugsFlag,
        extensionsToNHCFlag, extensionsToJHCFlag,



  ) where

import Distribution.Version (Version(..), showVersion)
import Language.Haskell.Extension (Extension(..))

import Data.List (nub)





-- ------------------------------------------------------------
-- * Command Line Types and Exports
-- ------------------------------------------------------------

data CompilerFlavor
  = GHC | NHC | Hugs | HBC | Helium | JHC | OtherCompiler String
              deriving (Show, Read, Eq)

data Compiler = Compiler {compilerFlavor:: CompilerFlavor,
			  compilerVersion :: Version,
                          compilerPath  :: FilePath,
                          compilerPkgTool :: FilePath}
                deriving (Show, Read, Eq)

showCompilerId :: Compiler -> String
showCompilerId (Compiler f (Version [] _) _ _) = compilerBinaryName f
showCompilerId (Compiler f v _ _) = compilerBinaryName f ++ '-': showVersion v

compilerBinaryName :: CompilerFlavor -> String
compilerBinaryName GHC  = "ghc"
compilerBinaryName NHC  = "hmake" -- FIX: uses hmake for now
compilerBinaryName Hugs = "ffihugs"
compilerBinaryName JHC  = "jhc"
compilerBinaryName cmp  = error $ "Unsupported compiler: " ++ (show cmp)

-- ------------------------------------------------------------
-- * Extensions
-- ------------------------------------------------------------

-- |For the given compiler, return the unsupported extensions, and the
-- flags for the supported extensions.
extensionsToFlags :: CompilerFlavor -> [ Extension ] -> ([Extension], [Opt])
extensionsToFlags GHC exts = extensionsToGHCFlag exts
extensionsToFlags Hugs exts = extensionsToHugsFlag exts
extensionsToFlags NHC exts = extensionsToNHCFlag exts
extensionsToFlags JHC exts = extensionsToJHCFlag exts
extensionsToFlags _ exts = (exts, [])

-- |GHC: Return the unsupported extensions, and the flags for the supported extensions
extensionsToGHCFlag :: [ Extension ] -> ([Extension], [Opt])
extensionsToGHCFlag l
    = splitEither $ nub $ map extensionToGHCFlag l
    where
    extensionToGHCFlag :: Extension -> Either Extension String
    extensionToGHCFlag OverlappingInstances         = Right "-fallow-overlapping-instances"
    extensionToGHCFlag TypeSynonymInstances         = Right "-fglasgow-exts"
    extensionToGHCFlag TemplateHaskell              = Right "-fth"
    extensionToGHCFlag ForeignFunctionInterface     = Right "-fffi"
    extensionToGHCFlag NoMonomorphismRestriction    = Right "-fno-monomorphism-restriction"
    extensionToGHCFlag UndecidableInstances         = Right "-fallow-undecidable-instances"
    extensionToGHCFlag IncoherentInstances          = Right "-fallow-incoherent-instances"
    extensionToGHCFlag InlinePhase                  = Right "-finline-phase"
    extensionToGHCFlag ContextStack                 = Right "-fcontext-stack"
    extensionToGHCFlag Arrows                       = Right "-farrows"
    extensionToGHCFlag Generics                     = Right "-fgenerics"
    extensionToGHCFlag NoImplicitPrelude            = Right "-fno-implicit-prelude"
    extensionToGHCFlag ImplicitParams               = Right "-fimplicit-params"
    extensionToGHCFlag CPP                          = Right "-cpp"

    extensionToGHCFlag BangPatterns                 = Right "-fbang-patterns"
    extensionToGHCFlag RecursiveDo                  = Right "-fglasgow-exts"
    extensionToGHCFlag ParallelListComp             = Right "-fglasgow-exts"
    extensionToGHCFlag MultiParamTypeClasses        = Right "-fglasgow-exts"
    extensionToGHCFlag FunctionalDependencies       = Right "-fglasgow-exts"
    extensionToGHCFlag Rank2Types                   = Right "-fglasgow-exts"
    extensionToGHCFlag RankNTypes                   = Right "-fglasgow-exts"
    extensionToGHCFlag PolymorphicComponents        = Right "-fglasgow-exts"
    extensionToGHCFlag ExistentialQuantification    = Right "-fglasgow-exts"
    extensionToGHCFlag ScopedTypeVariables          = Right "-fglasgow-exts"
    extensionToGHCFlag FlexibleContexts             = Right "-fglasgow-exts"
    extensionToGHCFlag FlexibleInstances            = Right "-fglasgow-exts"
    extensionToGHCFlag EmptyDataDecls               = Right "-fglasgow-exts"
    extensionToGHCFlag PatternGuards                = Right "-fglasgow-exts"
    extensionToGHCFlag GeneralizedNewtypeDeriving   = Right "-fglasgow-exts"

    extensionToGHCFlag e@ExtensibleRecords          = Left e
    extensionToGHCFlag e@RestrictedTypeSynonyms     = Left e
    extensionToGHCFlag e@HereDocuments              = Left e
    extensionToGHCFlag e@NamedFieldPuns             = Left e

-- |NHC: Return the unsupported extensions, and the flags for the supported extensions
extensionsToNHCFlag :: [ Extension ] -> ([Extension], [Opt])
extensionsToNHCFlag l
    = splitEither $ nub $ map extensionToNHCFlag l
      where
      -- NHC doesn't enforce the monomorphism restriction at all.
      extensionToNHCFlag NoMonomorphismRestriction = Right ""
      extensionToNHCFlag ForeignFunctionInterface  = Right ""
      extensionToNHCFlag ExistentialQuantification = Right ""
      extensionToNHCFlag EmptyDataDecls            = Right ""
      extensionToNHCFlag NamedFieldPuns            = Right "-puns"
      extensionToNHCFlag CPP                       = Right "-cpp"
      extensionToNHCFlag e                         = Left e

-- |JHC: Return the unsupported extensions, and the flags for the supported extensions
extensionsToJHCFlag :: [ Extension ] -> ([Extension], [Opt])
extensionsToJHCFlag l = (es, filter (not . null) rs)
      where
      (es,rs) = splitEither $ nub $ map extensionToJHCFlag l
      extensionToJHCFlag TypeSynonymInstances       = Right ""
      extensionToJHCFlag ForeignFunctionInterface   = Right ""
      extensionToJHCFlag NoImplicitPrelude          = Right "--noprelude"
      extensionToJHCFlag CPP                        = Right "-fcpp"
      extensionToJHCFlag e                          = Left e

-- |Hugs: Return the unsupported extensions, and the flags for the supported extensions
extensionsToHugsFlag :: [ Extension ] -> ([Extension], [Opt])
extensionsToHugsFlag l
    = splitEither $ nub $ map extensionToHugsFlag l
      where
      extensionToHugsFlag OverlappingInstances       = Right "+o"
      extensionToHugsFlag IncoherentInstances        = Right "+oO"
      extensionToHugsFlag HereDocuments              = Right "+H"
      extensionToHugsFlag TypeSynonymInstances       = Right "-98"
      extensionToHugsFlag RecursiveDo                = Right "-98"
      extensionToHugsFlag ParallelListComp           = Right "-98"
      extensionToHugsFlag MultiParamTypeClasses      = Right "-98"
      extensionToHugsFlag FunctionalDependencies     = Right "-98"
      extensionToHugsFlag Rank2Types                 = Right "-98"
      extensionToHugsFlag PolymorphicComponents      = Right "-98"
      extensionToHugsFlag ExistentialQuantification  = Right "-98"
      extensionToHugsFlag ScopedTypeVariables        = Right "-98"
      extensionToHugsFlag ImplicitParams             = Right "-98"
      extensionToHugsFlag ExtensibleRecords          = Right "-98"
      extensionToHugsFlag RestrictedTypeSynonyms     = Right "-98"
      extensionToHugsFlag FlexibleContexts           = Right "-98"
      extensionToHugsFlag FlexibleInstances          = Right "-98"
      extensionToHugsFlag ForeignFunctionInterface   = Right ""
      extensionToHugsFlag EmptyDataDecls             = Right ""
      extensionToHugsFlag CPP                        = Right ""
      extensionToHugsFlag e                          = Left e

splitEither :: [Either a b] -> ([a], [b])
splitEither l = ([a | Left a <- l], [b | Right b <- l])

type Opt = String

-- ------------------------------------------------------------
-- * Testing
-- ------------------------------------------------------------





-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Extension
-- Copyright   :  Isaac Jones 2003-2004
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- Haskell language extensions

{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Extension
{-# DEPRECATED "Use modules Language.Haskell.Extension and Distribution.Compiler instead" #-}
       (Extension(..), Opt,
	extensionsToNHCFlag, extensionsToGHCFlag,
        extensionsToJHCFlag, extensionsToHugsFlag
  ) where

import Distribution.Compiler (Opt, extensionsToNHCFlag, extensionsToGHCFlag,
                              extensionsToJHCFlag, extensionsToHugsFlag)
import Language.Haskell.Extension (Extension(..))
{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.GetOpt
-- Copyright   :  (c) Sven Panne 2002-2005
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- This library provides facilities for parsing the command-line options
-- in a standalone program.  It is essentially a Haskell port of the GNU 
-- @getopt@ library.
--
-----------------------------------------------------------------------------

{-
Sven Panne <Sven.Panne@informatik.uni-muenchen.de> Oct. 1996 (small
changes Dec. 1997)

Two rather obscure features are missing: The Bash 2.0 non-option hack
(if you don't already know it, you probably don't want to hear about
it...) and the recognition of long options with a single dash
(e.g. '-help' is recognised as '--help', as long as there is no short
option 'h').

Other differences between GNU's getopt and this implementation:

* To enforce a coherent description of options and arguments, there
  are explanation fields in the option/argument descriptor.

* Error messages are now more informative, but no longer POSIX
  compliant... :-(

And a final Haskell advertisement: The GNU C implementation uses well
over 1100 lines, we need only 195 here, including a 46 line example! 
:-)
-}

-- #hide
module Distribution.GetOpt (
   -- * GetOpt
   getOpt, getOpt',
   usageInfo,
   ArgOrder(..),
   OptDescr(..),
   ArgDescr(..),

   -- * Example

   -- $example
) where



import System.Console.GetOpt








































































































































































































































{- $example

To hopefully illuminate the role of the different data
structures, here\'s the command-line options for a (very simple)
compiler:

>    module Opts where
>    
>    import Distribution.GetOpt
>    import Data.Maybe ( fromMaybe )
>    
>    data Flag 
>     = Verbose  | Version 
>     | Input String | Output String | LibDir String
>       deriving Show
>    
>    options :: [OptDescr Flag]
>    options =
>     [ Option ['v']     ["verbose"] (NoArg Verbose)       "chatty output on stderr"
>     , Option ['V','?'] ["version"] (NoArg Version)       "show version number"
>     , Option ['o']     ["output"]  (OptArg outp "FILE")  "output FILE"
>     , Option ['c']     []          (OptArg inp  "FILE")  "input FILE"
>     , Option ['L']     ["libdir"]  (ReqArg LibDir "DIR") "library directory"
>     ]
>    
>    inp,outp :: Maybe String -> Flag
>    outp = Output . fromMaybe "stdout"
>    inp  = Input  . fromMaybe "stdin"
>    
>    compilerOpts :: [String] -> IO ([Flag], [String])
>    compilerOpts argv = 
>       case getOpt Permute options argv of
>          (o,n,[]  ) -> return (o,n)
>          (_,_,errs) -> ioError (userError (concat errs ++ usageInfo header options))
>      where header = "Usage: ic [OPTION...] files..."

-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.InstalledPackageInfo
-- Copyright   :  (c) The University of Glasgow 2004
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  alpha
-- Portability :  portable
--
-- This is the information about an /installed/ package that
-- is communicated to the @hc-pkg@ program in order to register
-- a package.  @ghc-pkg@ now consumes this package format (as of verison
-- 6.4). This is specific to GHC at the moment.


{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of the University nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

-- This module is meant to be local-only to Distribution...

module Distribution.InstalledPackageInfo (
	InstalledPackageInfo(..),
	ParseResult(..),
	emptyInstalledPackageInfo,
	parseInstalledPackageInfo,
	showInstalledPackageInfo,
	showInstalledPackageInfoField,
  ) where

import Distribution.ParseUtils (
	StanzaField(..), singleStanza, ParseResult(..), LineNo,
	simpleField, listField, parseLicenseQ,
	parseFilePathQ, parseTokenQ, parseModuleNameQ, parsePackageNameQ,
	showFilePath, showToken, parseReadS, parseOptVersion, parseQuoted,
	showFreeText)
import Distribution.License 	( License(..) )
import Distribution.Compiler 	( Opt )
import Distribution.Package	( PackageIdentifier(..), showPackageId,
				  parsePackageId )
import Distribution.Version	( Version(..), showVersion )
import Distribution.Compat.ReadP as ReadP

import Control.Monad	( foldM )
import Text.PrettyPrint

-- -----------------------------------------------------------------------------
-- The InstalledPackageInfo type

data InstalledPackageInfo
   = InstalledPackageInfo {
	-- these parts are exactly the same as PackageDescription
	package           :: PackageIdentifier,
        license           :: License,
        copyright         :: String,
        maintainer        :: String,
	author            :: String,
        stability         :: String,
	homepage          :: String,
	pkgUrl            :: String,
	description       :: String,
	category          :: String,
	-- these parts are required by an installed package only:
        exposed           :: Bool,
	exposedModules	  :: [String],
	hiddenModules     :: [String],
        importDirs        :: [FilePath],  -- contain sources in case of Hugs
        libraryDirs       :: [FilePath],
        hsLibraries       :: [String],
        extraLibraries    :: [String],
	extraGHCiLibraries:: [String],    -- overrides extraLibraries for GHCi
        includeDirs       :: [FilePath],
        includes          :: [String],
        depends           :: [PackageIdentifier],
        hugsOptions	  :: [Opt],
        ccOptions	  :: [Opt],
        ldOptions	  :: [Opt],
        frameworkDirs     :: [FilePath],
        frameworks	  :: [String],
	haddockInterfaces :: [FilePath],
	haddockHTMLs      :: [FilePath]
    }
    deriving (Read, Show)

emptyInstalledPackageInfo :: InstalledPackageInfo
emptyInstalledPackageInfo
   = InstalledPackageInfo {
        package           = PackageIdentifier "" noVersion,
        license           = AllRightsReserved,
        copyright         = "",
        maintainer        = "",
	author		  = "",
        stability         = "",
	homepage	  = "",
	pkgUrl		  = "",
	description	  = "",
	category	  = "",
        exposed           = False,
	exposedModules	  = [],
	hiddenModules     = [],
        importDirs        = [],
        libraryDirs       = [],
        hsLibraries       = [],
        extraLibraries    = [],
        extraGHCiLibraries= [],
        includeDirs       = [],
        includes	  = [],
        depends           = [],
        hugsOptions       = [],
        ccOptions         = [],
        ldOptions         = [],
        frameworkDirs     = [],
        frameworks        = [],
	haddockInterfaces = [],
	haddockHTMLs      = []
    }

noVersion :: Version
noVersion = Version{ versionBranch=[], versionTags=[] }

-- -----------------------------------------------------------------------------
-- Parsing

parseInstalledPackageInfo :: String -> ParseResult InstalledPackageInfo
parseInstalledPackageInfo inp = do
  stLines <- singleStanza inp
	-- not interested in stanzas, so just allow blank lines in
	-- the package info.
  foldM (parseBasicStanza fields) emptyInstalledPackageInfo stLines

parseBasicStanza :: [StanzaField a]
		    -> a
		    -> (LineNo, String, String)
		    -> ParseResult a
parseBasicStanza ((StanzaField name _ set):fields) pkg (lineNo, f, val)
  | name == f = set lineNo val pkg
  | otherwise = parseBasicStanza fields pkg (lineNo, f, val)
parseBasicStanza [] pkg (_, _, _) = return pkg

-- -----------------------------------------------------------------------------
-- Pretty-printing

showInstalledPackageInfo :: InstalledPackageInfo -> String
showInstalledPackageInfo pkg = render (ppFields fields)
  where
    ppFields [] = empty
    ppFields ((StanzaField name get' _):flds) = 
	pprField name (get' pkg) $$ ppFields flds

showInstalledPackageInfoField
	:: String
	-> Maybe (InstalledPackageInfo -> String)
showInstalledPackageInfoField field
  = case [ (f,get') | (StanzaField f get' _) <- fields, f == field ] of
	[]      -> Nothing
	((f,get'):_) -> Just (render . pprField f . get')

pprField name field = text name <> colon <+> field

-- -----------------------------------------------------------------------------
-- Description of the fields, for parsing/printing

fields :: [StanzaField InstalledPackageInfo]
fields = basicStanzaFields ++ installedStanzaFields

basicStanzaFields :: [StanzaField InstalledPackageInfo]
basicStanzaFields =
 [ simpleField "name"
                           text                   parsePackageNameQ
                           (pkgName . package)    (\name pkg -> pkg{package=(package pkg){pkgName=name}})
 , simpleField "version"
                           (text . showVersion)   parseOptVersion 
                           (pkgVersion . package) (\ver pkg -> pkg{package=(package pkg){pkgVersion=ver}})
 , simpleField "license"
                           (text . show)          parseLicenseQ
                           license                (\l pkg -> pkg{license=l})
 , simpleField "copyright"
                           showFreeText           (munch (const True))
                           copyright              (\val pkg -> pkg{copyright=val})
 , simpleField "maintainer"
                           showFreeText           (munch (const True))
                           maintainer             (\val pkg -> pkg{maintainer=val})
 , simpleField "stability"
                           showFreeText           (munch (const True))
                           stability              (\val pkg -> pkg{stability=val})
 , simpleField "homepage"
                           showFreeText           (munch (const True))
                           homepage               (\val pkg -> pkg{homepage=val})
 , simpleField "package-url"
                           showFreeText           (munch (const True))
                           pkgUrl                 (\val pkg -> pkg{pkgUrl=val})
 , simpleField "description"
                           showFreeText           (munch (const True))
                           description            (\val pkg -> pkg{description=val})
 , simpleField "category"
                           showFreeText           (munch (const True))
                           category               (\val pkg -> pkg{category=val})
 , simpleField "author"
                           showFreeText           (munch (const True))
                           author                 (\val pkg -> pkg{author=val})
 ]

installedStanzaFields :: [StanzaField InstalledPackageInfo]
installedStanzaFields = [
   simpleField "exposed"
	(text.show) 	   parseReadS
	exposed     	   (\val pkg -> pkg{exposed=val})
 , listField   "exposed-modules"
	text               parseModuleNameQ
	exposedModules     (\xs    pkg -> pkg{exposedModules=xs})
 , listField   "hidden-modules"
	text               parseModuleNameQ
	hiddenModules      (\xs    pkg -> pkg{hiddenModules=xs})
 , listField   "import-dirs"
	showFilePath       parseFilePathQ
	importDirs         (\xs pkg -> pkg{importDirs=xs})
 , listField   "library-dirs"
	showFilePath       parseFilePathQ
	libraryDirs        (\xs pkg -> pkg{libraryDirs=xs})
 , listField   "hs-libraries"
	showFilePath       parseTokenQ
	hsLibraries        (\xs pkg -> pkg{hsLibraries=xs})
 , listField   "extra-libraries"
	showToken          parseTokenQ
	extraLibraries     (\xs pkg -> pkg{extraLibraries=xs})
 , listField   "extra-ghci-libraries"
	showToken          parseTokenQ
	extraGHCiLibraries (\xs pkg -> pkg{extraGHCiLibraries=xs})
 , listField   "include-dirs"
	showFilePath       parseFilePathQ
	includeDirs        (\xs pkg -> pkg{includeDirs=xs})
 , listField   "includes"
	showFilePath       parseFilePathQ
	includes           (\xs pkg -> pkg{includes=xs})
 , listField   "depends"
	(text.showPackageId)  parsePackageId'
	depends            (\xs pkg -> pkg{depends=xs})
 , listField   "hugs-options"
	showToken	   parseTokenQ
	hugsOptions        (\path  pkg -> pkg{hugsOptions=path})
 , listField   "cc-options"
	showToken	   parseTokenQ
	ccOptions          (\path  pkg -> pkg{ccOptions=path})
 , listField   "ld-options"
	showToken	   parseTokenQ
	ldOptions          (\path  pkg -> pkg{ldOptions=path})
 , listField   "framework-dirs"
	showFilePath       parseFilePathQ
	frameworkDirs      (\xs pkg -> pkg{frameworkDirs=xs})
 , listField   "frameworks"
	showToken          parseTokenQ
	frameworks         (\xs pkg -> pkg{frameworks=xs})
 , listField   "haddock-interfaces"
	showFilePath       parseFilePathQ
	haddockInterfaces  (\xs pkg -> pkg{haddockInterfaces=xs})
 , listField   "haddock-html"
	showFilePath       parseFilePathQ
	haddockHTMLs       (\xs pkg -> pkg{haddockHTMLs=xs})
 ]

parsePackageId' = parseQuoted parsePackageId <++ parsePackageId
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.License
-- Copyright   :  Isaac Jones 2003-2005
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- The License datatype.  For more information about these and other
-- open-source licenses, you may visit <http://www.opensource.org/>.
--
-- I am not a lawyer, but as a general guideline, most Haskell
-- software seems to be released under a BSD3 license, which is very
-- open and free.  If you don't want to restrict the use of your
-- software or its source code, use BSD3 or PublicDomain.

{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.License (
	License(..)
  ) where

-- |This datatype indicates the license under which your package is
-- released.  It is also wise to add your license to each source file.
-- The 'AllRightsReserved' constructor is not actually a license, but
-- states that you are not giving anyone else a license to use or
-- distribute your work.  The comments below are general guidelines.
-- Please read the licenses themselves and consult a lawyer if you are
-- unsure of your rights to release the software.

data License = GPL  -- ^GNU Public License. Source code must accompany alterations.
             | LGPL -- ^Lesser GPL, Less restrictive than GPL, useful for libraries.
             | BSD3 -- ^3-clause BSD license, newer, no advertising clause. Very free license.
             | BSD4 -- ^4-clause BSD license, older, with advertising clause.
             | PublicDomain -- ^Holder makes no claim to ownership, least restrictive license.
             | AllRightsReserved -- ^No rights are granted to others. Undistributable. Most restrictive.
             | {- ... | -} OtherLicense -- ^Some other license.
               deriving (Read, Show, Eq)
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Make
-- Copyright   :  Martin Sj&#xF6;gren 2004
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- Explanation: Uses the parsed command-line from Distribution.Setup
-- in order to build haskell tools using a backend build system based
-- on Make.

{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Make (
	module Distribution.Package,
	License(..), Version(..),
	defaultMain, defaultMainNoRead
  ) where

-- local
import Distribution.Package --must not specify imports, since we're exporting moule.
import Distribution.Program(defaultProgramConfiguration)
import Distribution.PackageDescription
import Distribution.Setup --(parseArgs, Action(..), optionHelpString)

import Distribution.Simple.Utils (die, maybeExit, defaultPackageDesc)

import Distribution.License (License(..))
import Distribution.Version (Version(..))

import System.Environment(getArgs)
import Data.List  ( intersperse )
import System.Cmd
import System.Exit

{-
Basic assumptions
-----------------
Obviously we assume that there is a configure script, and that after the
ConfigCmd has been run, there is a Makefile.

ConfigCmd:     We assume the configure script accepts:
		--with-hc
		--with-hc-pkg
		--prefix
		--bindir
		--libdir
		--libexecdir
		--datadir

BuildCmd:      We assume the default Makefile target will build everything

InstallCmd:    We assume there is an install target
               Note that we assume that this does *not* register the package!

CopyCmd:       We assume there is a copy target, and a variable $(destdir)
		The 'copy' target should probably just invoke make install recursively, eg.
			copy :
				$(MAKE) install prefix=$(destdir)/$(prefix) \
						bindir=$(destdir)/$(bindir) \
						...
		The reason we can't invoke make install directly here is that we don't
		know the value of $(prefix).

SDistCmd:      We assume there is an dist target

RegisterCmd:   We assume there is a register target and a variable $(user)

UnregisterCmd: We assume there is an unregister target

HaddockCmd:    We assume there is a "docs" or "doc" target

ProgramaticaCmd: We assume there is a "programatica" target
-}

exec :: String -> IO ExitCode
exec cmd = (putStrLn $ "-=-= Cabal executing: " ++ cmd ++ "=-=-")
           >> system cmd

defaultMain :: IO ()
defaultMain = defaultPackageDesc >>= readPackageDescription >>= defaultMainNoRead

defaultMainNoRead :: PackageDescription -> IO ()
defaultMainNoRead pkg_descr
    = do args <- getArgs
         (action, args) <- parseGlobalArgs defaultProgramConfiguration args
         case action of
            ConfigCmd flags -> do
                (flags, _, args) <- parseConfigureArgs defaultProgramConfiguration flags args []
                retVal <- exec $ unwords $
                  "./configure" : configureArgs flags ++ args
                if (retVal == ExitSuccess)
                  then putStrLn "Configure Succeeded."
                  else putStrLn "Configure failed."
                exitWith retVal

            CopyCmd copydest0 -> do
                ((CopyFlags copydest _), _, args) <- parseCopyArgs (CopyFlags copydest0 0) args []
                no_extra_flags args
		let cmd = case copydest of 
				NoCopyDest      -> "install"
				CopyTo path     -> "copy destdir=" ++ path
				CopyPrefix path -> "install prefix=" ++ path
					-- CopyPrefix is backwards compat, DEPRECATED
                maybeExit $ system $ ("make " ++ cmd)

            InstallCmd -> do
                ((InstallFlags _ _), _, args) <- parseInstallArgs emptyInstallFlags args []
                no_extra_flags args
                maybeExit $ system $ "make install"
                retVal <- exec "make register"
                if (retVal == ExitSuccess)
                  then putStrLn "Install Succeeded."
                  else putStrLn "Install failed."
                exitWith retVal

            HaddockCmd -> do 
                (_, _, args) <- parseHaddockArgs emptyHaddockFlags args []
                no_extra_flags args
                retVal <- exec "make docs"
                case retVal of
                 ExitSuccess -> do putStrLn "Haddock Succeeded"
                                   exitWith ExitSuccess
                 _ -> do retVal' <- exec "make doc"
                         case retVal' of
                          ExitSuccess -> do putStrLn "Haddock Succeeded"
                                            exitWith ExitSuccess
                          _ -> do putStrLn "Haddock Failed."
                                  exitWith retVal'

            BuildCmd -> basicCommand "Build" "make" (parseBuildArgs args [])

            CleanCmd -> basicCommand "Clean" "make clean" (parseCleanArgs args [])

            SDistCmd -> basicCommand "SDist" "make dist" (parseSDistArgs args [])

            RegisterCmd  -> basicCommand "Register" "make register"
                                           (parseRegisterArgs emptyRegisterFlags args [])

            UnregisterCmd -> basicCommand "Unregister" "make unregister"
                                           (parseUnregisterArgs emptyRegisterFlags args [])
            ProgramaticaCmd -> basicCommand "Programatica" "make programatica"
                                        (parseProgramaticaArgs args [])

            HelpCmd -> exitWith ExitSuccess -- this is handled elsewhere

-- |convinience function for repetitions above
basicCommand :: String  -- ^Command name
             -> String  -- ^Command command
             -> (IO (b, [a], [String]))   -- ^Command parser function
             -> IO ()
basicCommand commandName commandCommand commandParseFun = do 
                (_, _, args) <- commandParseFun
                no_extra_flags args
                retVal <- exec commandCommand
                putStrLn $ commandName ++ 
                    if (retVal == ExitSuccess)
                       then " Succeeded."
                       else " Failed."
                exitWith retVal

no_extra_flags :: [String] -> IO ()
no_extra_flags [] = return ()
no_extra_flags extra_flags  = 
  die $ "Unrecognised flags: " ++ concat (intersperse "," (extra_flags))
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Package
-- Copyright   :  Isaac Jones 2003-2004
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- Packages.

{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Package (
	PackageIdentifier(..),
	showPackageId, parsePackageId, parsePackageName,
  ) where

import Distribution.Version
import Distribution.Compat.ReadP as ReadP
import Data.Char ( isDigit, isAlphaNum )
import Data.List ( intersperse )

data PackageIdentifier
    = PackageIdentifier {
	pkgName    :: String,
	pkgVersion :: Version
     }
     deriving (Read, Show, Eq, Ord)

showPackageId :: PackageIdentifier -> String
showPackageId (PackageIdentifier n (Version [] _)) = n -- if no version, don't show version.
showPackageId pkgid = 
  pkgName pkgid ++ '-': showVersion (pkgVersion pkgid)

parsePackageName :: ReadP r String
parsePackageName = do ns <- sepBy1 component (char '-')
                      return (concat (intersperse "-" ns))
  where component = do 
	   cs <- munch1 isAlphaNum
	   if all isDigit cs then pfail else return cs
	-- each component must contain an alphabetic character, to avoid
	-- ambiguity in identifiers like foo-1 (the 1 is the version number).

parsePackageId :: ReadP r PackageIdentifier
parsePackageId = do 
  n <- parsePackageName
  v <- (ReadP.char '-' >> parseVersion) <++ return (Version [] [])
  return PackageIdentifier{pkgName=n,pkgVersion=v}
{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.PackageDescription
-- Copyright   :  Isaac Jones 2003-2005
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- Package description and parsing.

{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.PackageDescription (
        -- * Package descriptions
        PackageDescription(..),
        emptyPackageDescription,
        readPackageDescription,
        parseDescription,
        StanzaField(..),
        LineNo,
        basicStanzaFields,
        writePackageDescription,
        showPackageDescription,
        sanityCheckPackage, errorOut,
        setupMessage,
        Library(..),
        withLib,
        hasLibs,
        libModules,
        Executable(..),
        withExe,
        exeModules,
        -- * Build information
        BuildInfo(..),
        emptyBuildInfo,
        -- ** Supplementary build information
        HookedBuildInfo,
        emptyHookedBuildInfo,
        readHookedBuildInfo,
        parseHookedBuildInfo,
        writeHookedBuildInfo,
        showHookedBuildInfo,        
        updatePackageDescription,
        -- * Utilities
        ParseResult(..),
        PError, PWarning, showError,
        hcOptions,
        autogenModuleName,
        haddockName,




  ) where

import Control.Monad(liftM, foldM, when)
import Data.Char
import Data.Maybe(fromMaybe, isNothing, catMaybes)
import Data.List (nub,lookup)
import Text.PrettyPrint.HughesPJ
import System.Directory(doesFileExist)
import System.Environment(getProgName)
import System.IO(hPutStrLn, stderr)
import System.Exit

import Distribution.ParseUtils
import Distribution.Package(PackageIdentifier(..),showPackageId,
                            parsePackageName)
import Distribution.Version(Version(..), VersionRange(..), withinRange,
                            showVersion, parseVersion, showVersionRange, parseVersionRange)
import Distribution.License(License(..))
import Distribution.Version(Dependency(..))
import Distribution.Compiler(CompilerFlavor(..))
import Distribution.Simple.Utils(currentDir, die, dieWithLocation, warn)
import Language.Haskell.Extension(Extension(..))

import Distribution.Compat.ReadP as ReadP hiding (get)
import Distribution.Compat.FilePath(joinFileExt)






-- |Fix. Figure out a way to get this from .cabal file
cabalVersion :: Version
cabalVersion = Version [1,1,4] []

-- | This data type is the internal representation of the file @pkg.cabal@.
-- It contains two kinds of information about the package: information
-- which is needed for all packages, such as the package name and version, and 
-- information which is needed for the simple build system only, such as 
-- the compiler options and library name.
-- 
data PackageDescription
    =  PackageDescription {
        -- the following are required by all packages:
        package        :: PackageIdentifier,
        license        :: License,
        licenseFile    :: FilePath,
        copyright      :: String,
        maintainer     :: String,
        author         :: String,
        stability      :: String,
        testedWith     :: [(CompilerFlavor,VersionRange)],
        homepage       :: String,
        pkgUrl         :: String,
        synopsis       :: String, -- ^A one-line summary of this package
        description    :: String, -- ^A more verbose description of this package
        category       :: String,
        buildDepends   :: [Dependency],
        descCabalVersion :: VersionRange, -- ^If this package depends on a specific version of Cabal, give that here.
        -- components
        library        :: Maybe Library,
        executables    :: [Executable],
        dataFiles      :: [FilePath],
        extraSrcFiles  :: [FilePath],
        extraTmpFiles  :: [FilePath]
    }
    deriving (Show, Read, Eq)

data Library = Library {
        exposedModules    :: [String],
        libBuildInfo      :: BuildInfo
    }
    deriving (Show, Eq, Read)

emptyLibrary :: Library
emptyLibrary = Library [] emptyBuildInfo

emptyPackageDescription :: PackageDescription
emptyPackageDescription
    =  PackageDescription {package      = PackageIdentifier "" (Version [] []),
                      license      = AllRightsReserved,
                      licenseFile  = "",
                      descCabalVersion = AnyVersion,
                      copyright    = "",
                      maintainer   = "",
                      author       = "",
                      stability    = "",
                      testedWith   = [],
                      buildDepends = [],
                      homepage     = "",
                      pkgUrl       = "",
                      synopsis     = "",
                      description  = "",
                      category     = "",
                      library      = Nothing,
                      executables  = [],
                      dataFiles    = [],
                      extraSrcFiles = [],
                      extraTmpFiles = []
                     }

-- |Get all the module names from the libraries in this package
libModules :: PackageDescription -> [String]
libModules PackageDescription{library=lib}
    = maybe [] exposedModules lib
       ++ maybe [] (otherModules . libBuildInfo) lib

-- |Get all the module names from the exes in this package
exeModules :: PackageDescription -> [String]
exeModules PackageDescription{executables=execs}
    = concatMap (otherModules . buildInfo) execs

-- |does this package have any libraries?
hasLibs :: PackageDescription -> Bool
hasLibs p = maybe False (buildable . libBuildInfo) (library p)

-- |'Maybe' version of 'hasLibs'
maybeHasLibs :: PackageDescription -> Maybe Library
maybeHasLibs p =
   library p >>= (\lib -> toMaybe (buildable (libBuildInfo lib)) lib)

-- Consider refactoring into executable and library versions.
data BuildInfo = BuildInfo {
        buildable         :: Bool,      -- ^ component is buildable here
        ccOptions         :: [String],  -- ^ options for C compiler
        ldOptions         :: [String],  -- ^ options for linker
        frameworks        :: [String], -- ^support frameworks for Mac OS X
        cSources          :: [FilePath],
        hsSourceDirs      :: [FilePath], -- ^ where to look for the haskell module hierarchy
        otherModules      :: [String], -- ^ non-exposed or non-main modules
        extensions        :: [Extension],
        extraLibs         :: [String], -- ^ what libraries to link with when compiling a program that uses your package
        extraLibDirs      :: [String],
        includeDirs       :: [FilePath], -- ^directories to find .h files
        includes          :: [FilePath], -- ^ The .h files to be found in includeDirs
	installIncludes   :: [FilePath], -- ^ .h files to install with the package
        options           :: [(CompilerFlavor,[String])],
        ghcProfOptions       :: [String]
    }
    deriving (Show,Read,Eq)

emptyBuildInfo :: BuildInfo
emptyBuildInfo = BuildInfo {
                      buildable         = True,
                      ccOptions         = [],
                      ldOptions         = [],
                      frameworks        = [],
                      cSources          = [],
                      hsSourceDirs      = [currentDir],
                      otherModules      = [],
                      extensions        = [],
                      extraLibs         = [],
                      extraLibDirs      = [],
                      includeDirs       = [],
                      includes          = [],
                      installIncludes   = [],
                      options           = [],
                      ghcProfOptions       = []
                     }

data Executable = Executable {
        exeName    :: String,
        modulePath :: FilePath,
        buildInfo  :: BuildInfo
    }
    deriving (Show, Read, Eq)

emptyExecutable :: Executable
emptyExecutable = Executable {
                      exeName = "",
                      modulePath = "",
                      buildInfo = emptyBuildInfo
                     }

-- | Perform the action on each buildable 'Executable' in the package
-- description.
withExe :: PackageDescription -> (Executable -> IO a) -> IO ()
withExe pkg_descr f =
  sequence_ [f exe | exe <- executables pkg_descr, buildable (buildInfo exe)]

type HookedBuildInfo = (Maybe BuildInfo, [(String, BuildInfo)])

emptyHookedBuildInfo :: HookedBuildInfo
emptyHookedBuildInfo = (Nothing, [])

-- ------------------------------------------------------------
-- * Utils
-- ------------------------------------------------------------

-- |If the package description has a library section, call the given
--  function with the library build info as argument.
withLib :: PackageDescription -> a -> (Library -> IO a) -> IO a
withLib pkg_descr a f =
   maybe (return a) f (maybeHasLibs pkg_descr)

setupMessage :: String -> PackageDescription -> IO ()
setupMessage msg pkg_descr = 
   putStrLn (msg ++ ' ':showPackageId (package pkg_descr) ++ "...")

-- |Update the given package description with the output from the
-- pre-hooks.

updatePackageDescription :: HookedBuildInfo -> PackageDescription -> PackageDescription
updatePackageDescription (mb_lib_bi, exe_bi) p
    = p{ executables = updateExecutables exe_bi    (executables p)
       , library     = updateLibrary     mb_lib_bi (library     p)
       }
    where
      updateLibrary :: Maybe BuildInfo -> Maybe Library -> Maybe Library
      updateLibrary (Just bi) (Just lib) = Just (lib{libBuildInfo = unionBuildInfo bi (libBuildInfo lib)})
      updateLibrary Nothing   mb_lib     = mb_lib

       --the lib only exists in the buildinfo file.  FIX: Is this
       --wrong?  If there aren't any exposedModules, then the library
       --won't build anyway.  add to sanity checker?
      updateLibrary (Just bi) Nothing     = Just emptyLibrary{libBuildInfo=bi}

      updateExecutables :: [(String, BuildInfo)] -- ^[(exeName, new buildinfo)]
                        -> [Executable]          -- ^list of executables to update
                        -> [Executable]          -- ^list with exeNames updated
      updateExecutables exe_bi' executables' = foldr updateExecutable executables' exe_bi'
      
      updateExecutable :: (String, BuildInfo) -- ^(exeName, new buildinfo)
                       -> [Executable]        -- ^list of executables to update
                       -> [Executable]        -- ^libst with exeName updated
      updateExecutable _                 []         = []
      updateExecutable exe_bi'@(name,bi) (exe:exes)
        | exeName exe == name = exe{buildInfo = unionBuildInfo bi (buildInfo exe)} : exes
        | otherwise           = exe : updateExecutable exe_bi' exes

unionBuildInfo :: BuildInfo -> BuildInfo -> BuildInfo
unionBuildInfo b1 b2
    = b1{buildable         = buildable b1 && buildable b2,
         ccOptions         = combine ccOptions,
         ldOptions         = combine ldOptions,
         frameworks        = combine frameworks,
         cSources          = combine cSources,
         hsSourceDirs      = combine hsSourceDirs,
         otherModules      = combine otherModules,
         extensions        = combine extensions,
         extraLibs         = combine extraLibs,
         extraLibDirs      = combine extraLibDirs,
         includeDirs       = combine includeDirs,
         includes          = combine includes,
         installIncludes   = combine installIncludes,
         options           = combine options
        }
      where 
      combine :: (Eq a) => (BuildInfo -> [a]) -> [a]
      combine f = nub $ f b1 ++ f b2

-- |Select options for a particular Haskell compiler.
hcOptions :: CompilerFlavor -> [(CompilerFlavor, [String])] -> [String]
hcOptions hc hc_opts = [opt | (hc',opts) <- hc_opts, hc' == hc, opt <- opts]

-- |The name of the auto-generated module associated with a package
autogenModuleName :: PackageDescription -> String
autogenModuleName pkg_descr =
    "Paths_" ++ map fixchar (pkgName (package pkg_descr))
  where fixchar '-' = '_'
        fixchar c   = c

haddockName :: PackageDescription -> FilePath
haddockName pkg_descr =
   joinFileExt (pkgName (package pkg_descr)) "haddock"

-- ------------------------------------------------------------
-- * Parsing & Pretty printing
-- ------------------------------------------------------------

-- the strings for the required fields are necessary here, and so we
-- don't repeat ourselves, I name them:

reqNameName       = "name"
reqNameVersion    = "version"
reqNameCopyright  = "copyright"
reqNameMaintainer = "maintainer"
reqNameSynopsis   = "synopsis"

basicStanzaFields :: [StanzaField PackageDescription]
basicStanzaFields =
 [ simpleField reqNameName
                           text                   parsePackageName
                           (pkgName . package)    (\name pkg -> pkg{package=(package pkg){pkgName=name}})
 , simpleField reqNameVersion
                           (text . showVersion)   parseVersion
                           (pkgVersion . package) (\ver pkg -> pkg{package=(package pkg){pkgVersion=ver}})
 , simpleField "cabal-version"
                           (text . showVersionRange) parseVersionRange
                           descCabalVersion       (\v pkg -> pkg{descCabalVersion=v})
 , simpleField "license"
                           (text . show)          parseLicenseQ
                           license                (\l pkg -> pkg{license=l})
 , simpleField "license-file"
                           showFilePath           parseFilePathQ
                           licenseFile            (\l pkg -> pkg{licenseFile=l})
 , simpleField reqNameCopyright
                           showFreeText           (munch (const True))
                           copyright              (\val pkg -> pkg{copyright=val})
 , simpleField reqNameMaintainer
                           showFreeText           (munch (const True))
                           maintainer             (\val pkg -> pkg{maintainer=val})
 , commaListField  "build-depends"
                           showDependency         parseDependency
                           buildDepends           (\xs    pkg -> pkg{buildDepends=xs})
 , simpleField "stability"
                           showFreeText           (munch (const True))
                           stability              (\val pkg -> pkg{stability=val})
 , simpleField "homepage"
                           showFreeText           (munch (const True))
                           homepage               (\val pkg -> pkg{homepage=val})
 , simpleField "package-url"
                           showFreeText           (munch (const True))
                           pkgUrl                 (\val pkg -> pkg{pkgUrl=val})
 , simpleField reqNameSynopsis
                           showFreeText           (munch (const True))
                           synopsis               (\val pkg -> pkg{synopsis=val})
 , simpleField "description"
                           showFreeText           (munch (const True))
                           description            (\val pkg -> pkg{description=val})
 , simpleField "category"
                           showFreeText           (munch (const True))
                           category               (\val pkg -> pkg{category=val})
 , simpleField "author"
                           showFreeText           (munch (const True))
                           author                 (\val pkg -> pkg{author=val})
 , listField "tested-with"
                           showTestedWith         parseTestedWithQ
                           testedWith             (\val pkg -> pkg{testedWith=val})
 , listField "data-files"  showFilePath           parseFilePathQ
                           dataFiles              (\val pkg -> pkg{dataFiles=val})
 , listField "extra-source-files" showFilePath    parseFilePathQ
                           extraSrcFiles          (\val pkg -> pkg{extraSrcFiles=val})
 , listField "extra-tmp-files" showFilePath       parseFilePathQ
                           extraTmpFiles          (\val pkg -> pkg{extraTmpFiles=val})
 ]

executableStanzaFields :: [StanzaField Executable]
executableStanzaFields =
 [ simpleField "executable"
                           showFreeText       (munch (const True))
                           exeName            (\xs    exe -> exe{exeName=xs})
 , simpleField "main-is"
                           showFilePath       parseFilePathQ
                           modulePath         (\xs    exe -> exe{modulePath=xs})
 ]

binfoFields :: [StanzaField BuildInfo]
binfoFields =
 [ simpleField "buildable"
                           (text . show)      parseReadS
                           buildable          (\val binfo -> binfo{buildable=val})
 , listField "cc-options"
                           showToken          parseTokenQ
                           ccOptions          (\val binfo -> binfo{ccOptions=val})
 , listField "ld-options"
                           showToken          parseTokenQ
                           ldOptions          (\val binfo -> binfo{ldOptions=val})
 , listField "frameworks"
                           showToken          parseTokenQ
                           frameworks         (\val binfo -> binfo{frameworks=val})
 , listField   "c-sources"
                           showFilePath       parseFilePathQ
                           cSources           (\paths binfo -> binfo{cSources=paths})
 , listField   "extensions"
                           (text . show)      parseExtensionQ
                           extensions         (\exts  binfo -> binfo{extensions=exts})
 , listField   "extra-libraries"
                           showToken          parseTokenQ
                           extraLibs          (\xs    binfo -> binfo{extraLibs=xs})
 , listField   "extra-lib-dirs"
                           showFilePath       parseFilePathQ
                           extraLibDirs       (\xs    binfo -> binfo{extraLibDirs=xs})
 , listField   "includes"
                           showFilePath       parseFilePathQ
                           includes           (\paths binfo -> binfo{includes=paths})
 , listField   "install-includes"
                           showFilePath       parseFilePathQ
                           includes           (\paths binfo -> binfo{installIncludes=paths})
 , listField   "include-dirs"
                           showFilePath       parseFilePathQ
                           includeDirs        (\paths binfo -> binfo{includeDirs=paths})
 , listField   "hs-source-dirs"
                           showFilePath       parseFilePathQ
                           hsSourceDirs       (\paths binfo -> binfo{hsSourceDirs=paths})
 , listField   "other-modules"         
                           text               parseModuleNameQ
                           otherModules       (\val binfo -> binfo{otherModules=val})
 , listField   "ghc-prof-options"         
                           text               parseTokenQ
                           ghcProfOptions        (\val binfo -> binfo{ghcProfOptions=val})
 , optsField   "ghc-options"  GHC
                           options            (\path  binfo -> binfo{options=path})
 , optsField   "hugs-options" Hugs
                           options            (\path  binfo -> binfo{options=path})
 , optsField   "nhc-options"  NHC
                           options            (\path  binfo -> binfo{options=path})
 , optsField   "jhc-options"  JHC
                           options            (\path  binfo -> binfo{options=path})
 ]


-- --------------------------------------------
-- ** Parsing

-- | Given a parser and a filename, return the parse of the file,
-- after checking if the file exists.
readAndParseFile ::  (String -> ParseResult a) -> FilePath -> IO a
readAndParseFile parser fpath = do 
  exists <- doesFileExist fpath
  when (not exists) (die $ "Error Parsing: file \"" ++ fpath ++ "\" doesn't exist. Cannot continue.")
  str <- readFile fpath
  case parser str of
    ParseFailed e -> do
        let (lineNo, message) = locatedErrorMsg e
        dieWithLocation fpath lineNo message
    ParseOk ws x -> do
        mapM_ warn ws
        return x

-- |Parse the given package file.
readPackageDescription :: FilePath -> IO PackageDescription
readPackageDescription = readAndParseFile parseDescription 

readHookedBuildInfo :: FilePath -> IO HookedBuildInfo
readHookedBuildInfo = readAndParseFile parseHookedBuildInfo

parseDescription :: String -> ParseResult PackageDescription
parseDescription inp = do (st:sts) <- splitStanzas inp
                          pkg <- foldM (parseBasicStanza basicStanzaFields) emptyPackageDescription st
                          exes <- mapM parseExecutableStanza sts
                          return pkg{executables=exes}
  where -- The basic stanza, with library building info
        parseBasicStanza ((StanzaField name _ set):fields) pkg (lineNo, f, val)
          | name == f = set lineNo val pkg
          | otherwise = parseBasicStanza fields pkg (lineNo, f, val)
          {-     
     , listField   "exposed-modules"
                           text               parseModuleNameQ
                           (\p -> maybe [] exposedModules (library p))
                           (\xs    pkg -> let lib = fromMaybe emptyLibrary (library pkg) in
                                              pkg{library = Just lib{exposedModules=xs}})
-}
        parseBasicStanza [] pkg (lineNo, f, val)
          | "exposed-modules" == f = do
               mods <- runP lineNo f (parseOptCommaList parseModuleNameQ) val
               return pkg{library=Just lib{exposedModules=mods}}
          | otherwise = do
               bi <- parseBInfoField binfoFields (libBuildInfo lib) (lineNo, f, val)
               return pkg{library=Just lib{libBuildInfo=bi}}
          where
            lib = fromMaybe emptyLibrary (library pkg)

        parseExecutableStanza st@((lineNo, "executable",eName):_) =
          case lookupField "main-is" st of
            Just (_,_) -> foldM (parseExecutableField executableStanzaFields) emptyExecutable st
            Nothing    -> syntaxError lineNo $ "No 'Main-Is' field found for " ++ eName ++ " stanza"
        parseExecutableStanza ((lineNo, f,_):_) = 
          syntaxError lineNo $ "'Executable' stanza starting with field '" ++ f ++ "'"
        parseExecutableStanza _ = error "This shouldn't happen!"

        parseExecutableField ((StanzaField name _ set):fields) exe (lineNo, f, val)
          | name == f = set lineNo val exe
          | otherwise = parseExecutableField fields exe (lineNo, f, val)
        parseExecutableField [] exe (lineNo, f, val) = do
          binfo <- parseBInfoField binfoFields (buildInfo exe) (lineNo, f, val)
          return exe{buildInfo=binfo}

        -- ...
        lookupField :: String -> Stanza -> Maybe (LineNo,String)
        lookupField x sts = lookup x (map (\(n,f,v) -> (f,(n,v))) sts)


parseHookedBuildInfo :: String -> ParseResult HookedBuildInfo
parseHookedBuildInfo inp = do
  stanzas@(mLibStr:exes) <- splitStanzas inp
  mLib <- parseLib mLibStr
  biExes <- mapM parseExe (maybe stanzas (const exes) mLib)
  return (mLib, biExes)
  where
    parseLib :: Stanza -> ParseResult (Maybe BuildInfo)
    parseLib (bi@((_, inFieldName, _):_))
        | map toLower inFieldName /= "executable" = liftM Just (parseBI bi)
    parseLib _ = return Nothing
    parseExe :: Stanza -> ParseResult (String, BuildInfo)
    parseExe ((lineNo, inFieldName, mName):bi)
        | map toLower inFieldName == "executable"
            = do bis <- parseBI bi
                 return (mName, bis)
        | otherwise = syntaxError lineNo "expecting 'executable' at top of stanza"
    parseExe [] = syntaxError 0 "error in parsing buildinfo file. Expected executable stanza"
    parseBI :: Stanza -> ParseResult BuildInfo
    parseBI st = foldM (parseBInfoField binfoFields) emptyBuildInfo st

parseBInfoField :: [StanzaField a] -> a -> (LineNo, String, String) -> ParseResult a
parseBInfoField ((StanzaField name _ set):fields) binfo (lineNo, f, val)
          | name == f = set lineNo val binfo
          | otherwise = parseBInfoField fields binfo (lineNo, f, val)
-- ignore "x-" extension fields without a warning
parseBInfoField [] binfo (lineNo, 'x':'-':f, _) = return binfo
parseBInfoField [] binfo (lineNo, f, _) = do
          warning $ "Unknown field '" ++ f ++ "'"
          return binfo

-- --------------------------------------------
-- ** Pretty printing

writePackageDescription :: FilePath -> PackageDescription -> IO ()
writePackageDescription fpath pkg = writeFile fpath (showPackageDescription pkg)

showPackageDescription :: PackageDescription -> String
showPackageDescription pkg = render $
  ppFields pkg basicStanzaFields $$
  (case library pkg of
     Nothing  -> empty
     Just lib -> 
        text "exposed-modules" <> colon <+> fsep (punctuate comma (map text (exposedModules lib))) $$
        ppFields (libBuildInfo lib) binfoFields) $$
  vcat (map ppExecutable (executables pkg))
  where
    ppExecutable exe =
      space $$
      ppFields exe executableStanzaFields $$
      ppFields (buildInfo exe) binfoFields

    ppFields _ [] = empty
    ppFields pkg' ((StanzaField name get _):flds) =
           ppField name (get pkg') $$ ppFields pkg' flds

ppField name field = text name <> colon <+> field

writeHookedBuildInfo :: FilePath -> HookedBuildInfo -> IO ()
writeHookedBuildInfo fpath pbi = writeFile fpath (showHookedBuildInfo pbi)

showHookedBuildInfo :: HookedBuildInfo -> String
showHookedBuildInfo (mb_lib_bi, ex_bi) = render $
  (case mb_lib_bi of
     Nothing -> empty
     Just bi -> ppFields bi binfoFields) $$
  vcat (map ppExeBuildInfo ex_bi)
  where
    ppExeBuildInfo (name, bi) =
      space $$
      text "executable:" <+> text name $$
      ppFields bi binfoFields

    ppFields _  [] = empty
    ppFields bi ((StanzaField name get _):flds) =
           ppField name (get bi) $$ ppFields bi flds


-- ------------------------------------------------------------
-- * Sanity Checking
-- ------------------------------------------------------------

-- |Sanity check this description file.

-- FIX: add a sanity check for missing haskell files? That's why its
-- in the IO monad.

sanityCheckPackage :: PackageDescription -> IO ([String] -- Warnings
                                               ,[String])-- Errors
sanityCheckPackage pkg_descr
    = let libSane   = sanityCheckLib (library pkg_descr)
          nothingToDo = checkSanity
                        (null (executables pkg_descr) && isNothing (library pkg_descr))
                        "No executables and no library found. Nothing to do."
          noModules = checkSanity (hasMods pkg_descr)
                      "No exposed modules or executables in this package."
          allRights = checkSanity (license pkg_descr == AllRightsReserved)
                      "Package is copyright All Rights Reserved"
          noLicenseFile = checkSanity (null $ licenseFile pkg_descr)
                          "No license-file field."
          goodCabal = let v = (descCabalVersion pkg_descr)
                          in checkSanity (not $ cabalVersion  `withinRange` v)
                                 ("This package requires Cabal verion: " ++ (showVersionRange v) ++ ".")

         in return $ (catMaybes [nothingToDo, noModules,
                                 allRights, noLicenseFile]
                     ,catMaybes $ libSane:goodCabal:(checkMissingFields pkg_descr))

-- |Output warnings and errors. Exit if any errors.
errorOut :: [String]  -- ^Warnings
         -> [String]  -- ^errors
         -> IO ()
errorOut warnings errors = do
  mapM warn warnings
  when (not (null errors)) $ do
    pname <- getProgName
    mapM (hPutStrLn stderr . ((pname ++ ": Error: ") ++)) errors
    exitWith (ExitFailure 1)

toMaybe :: Bool -> a -> Maybe a
toMaybe b x = if b then Just x else Nothing

checkMissingFields :: PackageDescription -> [Maybe String]
checkMissingFields pkg_descr = 
    [missingField (pkgName . package)    reqNameName
    ,missingField (versionBranch .pkgVersion .package) reqNameVersion
    ]
    where missingField :: (PackageDescription -> [a]) -- Field accessor
                       -> String -- Name of field
                       -> Maybe String -- error message
          missingField f n
              = toMaybe (null (f pkg_descr)) ("Missing field: " ++ n)

sanityCheckLib :: Maybe Library -> Maybe String
sanityCheckLib ml =
   ml >>= (\l ->
      toMaybe (null $ exposedModules l)
              ("Non-empty library, but empty exposed modules list. " ++
               "Cabal may not build this library correctly"))

checkSanity :: Bool -> String -> Maybe String
checkSanity = toMaybe

hasMods :: PackageDescription -> Bool
hasMods pkg_descr =
   null (executables pkg_descr) &&
      maybe True (null . exposedModules) (library pkg_descr)


-- ------------------------------------------------------------
-- * Testing
-- ------------------------------------------------------------




























































































































































































-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.ParseUtils
-- Copyright   :  (c) The University of Glasgow 2004
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  alpha
-- Portability :  portable
--
-- Utilities for parsing PackageDescription and InstalledPackageInfo.


{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of the University nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

-- This module is meant to be local-only to Distribution...

-- #hide
module Distribution.ParseUtils (
        LineNo, PError(..), PWarning,
        locatedErrorMsg, showError, syntaxError, warning,
	runP, ParseResult(..),
	StanzaField(..), splitStanzas, Stanza, singleStanza,
	parseFilePathQ, parseTokenQ,
	parseModuleNameQ, parseDependency, parseOptVersion,
	parsePackageNameQ, parseVersionRangeQ,
	parseTestedWithQ, parseLicenseQ, parseExtensionQ, parseCommaList, parseOptCommaList,
	showFilePath, showToken, showTestedWith, showDependency, showFreeText,
	simpleField, listField, commaListField, optsField, 
	parseReadS, parseQuoted,
  ) where

import Text.PrettyPrint.HughesPJ
import Distribution.Compiler (CompilerFlavor)
import Distribution.License
import Distribution.Version
import Distribution.Package	( parsePackageName )
import Distribution.Compat.ReadP as ReadP hiding (get)
import Distribution.Compat.FilePath (platformPath)
import Control.Monad (liftM)
import Data.Char
import Language.Haskell.Extension (Extension)

-- -----------------------------------------------------------------------------

type LineNo = Int

data PError = AmbigousParse String LineNo
            | NoParse String LineNo
            | FromString String (Maybe LineNo)
        deriving Show

type PWarning = String

data ParseResult a = ParseFailed PError | ParseOk [PWarning] a
        deriving Show

instance Monad ParseResult where
	return x = ParseOk [] x
	ParseFailed err >>= _ = ParseFailed err
	ParseOk ws x >>= f = case f x of
	                       ParseFailed err -> ParseFailed err
			       ParseOk ws' x' -> ParseOk (ws'++ws) x'
	fail s = ParseFailed (FromString s Nothing)

runP :: LineNo -> String -> ReadP a a -> String -> ParseResult a
runP lineNo field p s =
  case [ x | (x,"") <- results ] of
    [a] -> ParseOk [] a
    []  -> case [ x | (x,ys) <- results, all isSpace ys ] of
             [a] -> ParseOk [] a
             []  -> ParseFailed (NoParse field lineNo)
             _   -> ParseFailed (AmbigousParse field lineNo)
    _   -> ParseFailed (AmbigousParse field lineNo)
  where results = readP_to_S p s

-- TODO: deprecated
showError :: PError -> String
showError e =
  case locatedErrorMsg e of
    (Just n,  s) -> "Line "++show n++": " ++ s
    (Nothing, s) -> s

locatedErrorMsg :: PError -> (Maybe LineNo, String)
locatedErrorMsg (AmbigousParse f n) = (Just n, "Ambigous parse in field '"++f++"'")
locatedErrorMsg (NoParse f n)       = (Just n, "Parse of field '"++f++"' failed: ")
locatedErrorMsg (FromString s n)    = (n, s)

syntaxError :: LineNo -> String -> ParseResult a
syntaxError n s = ParseFailed $ FromString s (Just n)

warning :: String -> ParseResult ()
warning s = ParseOk [s] ()

data StanzaField a 
  = StanzaField 
      { fieldName     :: String
      , fieldGet      :: a -> Doc
      , fieldSet      :: LineNo -> String -> a -> ParseResult a
      }

simpleField :: String -> (a -> Doc) -> (ReadP a a) -> (b -> a) -> (a -> b -> b) -> StanzaField b
simpleField name showF readF get set = StanzaField name
   (\st -> showF (get st))
   (\lineNo val st -> do
       x <- runP lineNo name readF val
       return (set x st))

commaListField :: String -> (a -> Doc) -> (ReadP [a] a) -> (b -> [a]) -> ([a] -> b -> b) -> StanzaField b
commaListField name showF readF get set = StanzaField name
   (\st -> fsep (punctuate comma (map showF (get st))))
   (\lineNo val st -> do
       xs <- runP lineNo name (parseCommaList readF) val
       return (set xs st))

listField :: String -> (a -> Doc) -> (ReadP [a] a) -> (b -> [a]) -> ([a] -> b -> b) -> StanzaField b
listField name showF readF get set = StanzaField name
   (\st -> fsep (map showF (get st)))
   (\lineNo val st -> do
       xs <- runP lineNo name (parseOptCommaList readF) val
       return (set xs st))

optsField :: String -> CompilerFlavor -> (b -> [(CompilerFlavor,[String])]) -> ([(CompilerFlavor,[String])] -> b -> b) -> StanzaField b
optsField name flavor get set = StanzaField name
   (\st -> case lookup flavor (get st) of
        Just args -> hsep (map text args)
        Nothing   -> empty)
   (\_ val st -> 
       let
         old_val  = get st
         old_args = case lookup flavor old_val of
                       Just args -> args
                       Nothing   -> []
         val'     = filter (\(f,_) -> f/=flavor) old_val
       in return (set ((flavor,words val++old_args) : val') st))

type Stanza = [(LineNo,String,String)]

-- |Split a string into blank line-separated stanzas of
-- "Field: value" groups
splitStanzas :: String -> ParseResult [Stanza]
splitStanzas = mapM mkStanza . map merge . groupStanzas . filter validLine . zip [1..] . lines
  where validLine (_,s) = case dropWhile isSpace s of
                            '-':'-':_ -> False      -- Comment
                            _         -> True
        groupStanzas :: [(Int,String)] -> [[(Int,String)]]
        groupStanzas [] = []
        groupStanzas xs = let (ys,zs) = break allSpaces xs
                           in ys : groupStanzas (dropWhile allSpaces zs)

allSpaces :: (a, String) -> Bool
allSpaces (_,xs) = all isSpace xs

-- |Split a file into "Field: value" groups, but blank lines have no
-- significance, unlike 'splitStanzas'.  A field value may span over blank
-- lines.
singleStanza :: String -> ParseResult Stanza
singleStanza = mkStanza . merge . filter validLine . zip [1..] . lines
  where validLine (_,s) = case dropWhile isSpace s of
                            '-':'-':_ -> False      -- Comment
                            []        -> False      -- blank line
                            _         -> True

merge :: [(a, [Char])] -> [(a, [Char])]
merge ((n,x):(_,c:s):ys) 
  | c == ' ' || c == '\t' = case dropWhile isSpace s of
                               ('.':s') -> merge ((n,x++"\n"++s'):ys)
                               s'       -> merge ((n,x++"\n"++s'):ys)
merge ((n,x):ys) = (n,x) : merge ys
merge []         = []

mkStanza :: [(Int,String)] -> ParseResult Stanza
mkStanza []          = return []
mkStanza ((n,xs):ys) =
  case break (==':') xs of
    (fld', ':':val) -> do
       let fld'' = map toLower fld'
       fld <- case () of
                _ | fld'' == "hs-source-dir"
                           -> do warning "The field \"hs-source-dir\" is deprecated, please use hs-source-dirs."
                                 return "hs-source-dirs"
                  | fld'' == "other-files"
                           -> do warning "The field \"other-files\" is deprecated, please use extra-source-files."
                                 return "extra-source-files"
                  | otherwise -> return fld''
       ss <- mkStanza ys
       checkDuplField fld ss
       return ((n, fld, dropWhile isSpace val):ss)
    (_, _)       -> syntaxError n "Invalid syntax (no colon after field name)"
  where
    checkDuplField _ [] = return ()
    checkDuplField fld ((n',fld',_):xs')
      | fld' == fld = syntaxError (max n n') $ "The field "++fld++" was already defined on line " ++ show (min n n')
      | otherwise   = checkDuplField fld xs'

-- |parse a module name
parseModuleNameQ :: ReadP r String
parseModuleNameQ = parseQuoted modu <++ modu
 where modu = do 
	  c <- satisfy isUpper
	  cs <- munch (\x -> isAlphaNum x || x `elem` "_'.")
	  return (c:cs)

parseFilePathQ :: ReadP r FilePath
parseFilePathQ = liftM platformPath parseTokenQ

parseReadS :: Read a => ReadP r a
parseReadS = readS_to_P reads

parseDependency :: ReadP r Dependency
parseDependency = do name <- parsePackageNameQ
                     skipSpaces
                     ver <- parseVersionRangeQ <++ return AnyVersion
                     skipSpaces
                     return $ Dependency name ver

parsePackageNameQ :: ReadP r String
parsePackageNameQ = parseQuoted parsePackageName <++ parsePackageName 

parseVersionRangeQ :: ReadP r VersionRange
parseVersionRangeQ = parseQuoted parseVersionRange <++ parseVersionRange

parseOptVersion :: ReadP r Version
parseOptVersion = parseQuoted ver <++ ver
  where ver = parseVersion <++ return noVersion
	noVersion = Version{ versionBranch=[], versionTags=[] }

parseTestedWithQ :: ReadP r (CompilerFlavor,VersionRange)
parseTestedWithQ = parseQuoted tw <++ tw
  where tw = do compiler <- parseReadS
		skipSpaces
		version <- parseVersionRange <++ return AnyVersion
		skipSpaces
		return (compiler,version)

parseLicenseQ :: ReadP r License
parseLicenseQ = parseQuoted parseReadS <++ parseReadS

-- urgh, we can't define optQuotes :: ReadP r a -> ReadP r a
-- because the "compat" version of ReadP isn't quite powerful enough.  In
-- particular, the type of <++ is ReadP r r -> ReadP r a -> ReadP r a
-- Hence the trick above to make 'lic' polymorphic.

parseExtensionQ :: ReadP r Extension
parseExtensionQ = parseQuoted parseReadS <++ parseReadS

parseTokenQ :: ReadP r String
parseTokenQ = parseReadS <++ munch1 (\x -> not (isSpace x) && x /= ',')

parseCommaList :: ReadP r a -- ^The parser for the stuff between commas
               -> ReadP r [a]
parseCommaList p = sepBy p separator
    where separator = skipSpaces >> ReadP.char ',' >> skipSpaces

parseOptCommaList :: ReadP r a -- ^The parser for the stuff between commas
               -> ReadP r [a]
parseOptCommaList p = sepBy p separator
    where separator = skipSpaces >> optional (ReadP.char ',') >> skipSpaces

parseQuoted :: ReadP r a -> ReadP r a
parseQuoted p = between (ReadP.char '"') (ReadP.char '"') p

-- --------------------------------------------
-- ** Pretty printing

showFilePath :: FilePath -> Doc
showFilePath = showToken

showToken :: String -> Doc
showToken str
 | not (any dodgy str) &&
   not (null str)       = text str
 | otherwise            = text (show str)
  where dodgy c = isSpace c || c == ','

showTestedWith :: (CompilerFlavor,VersionRange) -> Doc
showTestedWith (compiler,version) = text (show compiler ++ " " ++ showVersionRange version)

showDependency :: Dependency -> Doc
showDependency (Dependency name ver) = text name <+> text (showVersionRange ver)

-- | Pretty-print free-format text, ensuring that it is vertically aligned,
-- and with blank lines replaced by dots for correct re-parsing.
showFreeText :: String -> Doc
showFreeText s = vcat [text (if null l then "." else l) | l <- lines s]
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.PreProcess
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
{- Copyright (c) 2003-2005, Isaac Jones, Malcolm Wallace
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.PreProcess (preprocessSources, knownSuffixHandlers,
                                ppSuffixes, PPSuffixHandler, PreProcessor,
                                removePreprocessed, removePreprocessedPackage,
                                ppCpp, ppCpp', ppGreenCard, ppC2hs, ppHsc2hs,
				ppHappy, ppAlex, ppUnlit
                               )
    where

import Distribution.PreProcess.Unlit(unlit)
import Distribution.PackageDescription (setupMessage, PackageDescription(..),
                                        BuildInfo(..), Executable(..), withExe,
					Library(..), withLib, libModules)
import Distribution.Compiler (CompilerFlavor(..), Compiler(..))
import Distribution.Simple.LocalBuildInfo (LocalBuildInfo(..))
import Distribution.Simple.Utils (rawSystemVerbose,
                                  moduleToFilePath, die, dieWithLocation)
import Distribution.Version (Version(..))
import Control.Monad (unless)
import Data.Maybe (fromMaybe)
import Data.List (nub)
import System.Exit (ExitCode(..))
import System.Directory (removeFile, getModificationTime)
import System.Info (os, arch)
import Distribution.Compat.FilePath
	(splitFileExt, joinFileName, joinFileExt)

-- |The interface to a preprocessor, which may be implemented using an
-- external program, but need not be.  The arguments are the name of
-- the input file, the name of the output file and a verbosity level.
-- Here is a simple example that merely prepends a comment to the given
-- source file:
--
-- > ppTestHandler :: PreProcessor
-- > ppTestHandler inFile outFile verbose
-- >     = do when (verbose > 0) $
-- >            putStrLn (inFile++" has been preprocessed to "++outFile)
-- >          stuff <- readFile inFile
-- >          writeFile outFile ("-- preprocessed as a test\n\n" ++ stuff)
-- >          return ExitSuccess
--
type PreProcessor = FilePath  -- Location of the source file in need of preprocessing
                  -> FilePath -- Output filename
                  -> Int      -- verbose
                  -> IO ExitCode


-- |A preprocessor for turning non-Haskell files with the given extension
-- into plain Haskell source files.
type PPSuffixHandler
    = (String, BuildInfo -> LocalBuildInfo -> PreProcessor)

-- |Apply preprocessors to the sources from 'hsSourceDirs', to obtain
-- a Haskell source file for each module.
preprocessSources :: PackageDescription 
		  -> LocalBuildInfo 
		  -> Int                -- ^ verbose
                  -> [PPSuffixHandler]  -- ^ preprocessors to try
		  -> IO ()

preprocessSources pkg_descr lbi verbose handlers = do
    withLib pkg_descr () $ \ lib -> do
        setupMessage "Preprocessing library" pkg_descr
        let bi = libBuildInfo lib
	let biHandlers = localHandlers bi
	sequence_ [do retVal <- preprocessModule (hsSourceDirs bi) modu
                                                 verbose builtinSuffixes biHandlers
                      unless (retVal == ExitSuccess)
                             (die $ "got error code while preprocessing: " ++ modu)
                   | modu <- libModules pkg_descr]
    unless (null (executables pkg_descr)) $
        setupMessage "Preprocessing executables for" pkg_descr
    withExe pkg_descr $ \ theExe -> do
        let bi = buildInfo theExe
	let biHandlers = localHandlers bi
	sequence_ [do retVal <- preprocessModule (nub $ (hsSourceDirs bi)
                                     ++(maybe [] (hsSourceDirs . libBuildInfo) (library pkg_descr)))
                                     modu verbose builtinSuffixes biHandlers
                      unless (retVal == ExitSuccess)
                             (die $ "got error code while preprocessing: " ++ modu)
                   | modu <- otherModules bi]
  where hc = compilerFlavor (compiler lbi)
	builtinSuffixes
	  | hc == NHC = ["hs", "lhs", "gc"]
	  | otherwise = ["hs", "lhs"]
	localHandlers bi = [(ext, h bi lbi) | (ext, h) <- handlers]

-- |Find the first extension of the file that exists, and preprocess it
-- if required.
preprocessModule
    :: [FilePath]			-- ^source directories
    -> String				-- ^module name
    -> Int				-- ^verbose
    -> [String]				-- ^builtin suffixes
    -> [(String, PreProcessor)]		-- ^possible preprocessors
    -> IO ExitCode
preprocessModule searchLoc modu verbose builtinSuffixes handlers = do
    bsrcFiles <- moduleToFilePath searchLoc modu builtinSuffixes
    psrcFiles <- moduleToFilePath searchLoc modu (map fst handlers)
    case psrcFiles of
	[] -> case bsrcFiles of
	          [] -> die ("can't find source for " ++ modu ++ " in " ++ show searchLoc)
	          _  -> return ExitSuccess
	(psrcFile:_) -> do
	    let (srcStem, ext) = splitFileExt psrcFile
	        pp = fromMaybe (error "Internal error in preProcess module: Just expected")
	                       (lookup ext handlers)
	    recomp <- case bsrcFiles of
	                  [] -> return True
	                  (bsrcFile:_) -> do
	                      btime <- getModificationTime bsrcFile
	                      ptime <- getModificationTime psrcFile
	                      return (btime < ptime)
	    if recomp
	      then pp psrcFile (srcStem `joinFileExt` "hs") verbose
	      else return ExitSuccess

removePreprocessedPackage :: PackageDescription
                          -> FilePath -- ^root of source tree (where to look for hsSources)
                          -> [String] -- ^suffixes
                          -> IO ()
removePreprocessedPackage  pkg_descr r suff
    = do withLib pkg_descr () (\lib -> do
                     let bi = libBuildInfo lib
                     removePreprocessed (map (joinFileName r) (hsSourceDirs bi)) (libModules pkg_descr) suff)
         withExe pkg_descr (\theExe -> do
                     let bi = buildInfo theExe
                     removePreprocessed (map (joinFileName r) (hsSourceDirs bi)) (otherModules bi) suff)

-- |Remove the preprocessed .hs files. (do we need to get some .lhs files too?)
removePreprocessed :: [FilePath] -- ^search Location
                   -> [String] -- ^Modules
                   -> [String] -- ^suffixes
                   -> IO ()
removePreprocessed searchLocs mods suffixesIn
    = mapM_ removePreprocessedModule mods
  where removePreprocessedModule m = do
	    -- collect related files
	    fs <- moduleToFilePath searchLocs m otherSuffixes
	    -- does M.hs also exist?
	    hs <- moduleToFilePath searchLocs m ["hs"]
	    unless (null fs) (mapM_ removeFile hs)
	otherSuffixes = filter (/= "hs") suffixesIn

-- ------------------------------------------------------------
-- * known preprocessors
-- ------------------------------------------------------------

ppGreenCard :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppGreenCard = ppGreenCard' []

ppGreenCard' :: [String] -> BuildInfo -> LocalBuildInfo -> PreProcessor
ppGreenCard' inputArgs bi lbi
    = maybe (ppNone "greencard") pp (withGreencard lbi)
    where pp greencard inFile outFile verbose
              = rawSystemVerbose verbose greencard (["-tffi", "-o" ++ outFile, inFile] ++ inputArgs)

-- This one is useful for preprocessors that can't handle literate source.
-- We also need a way to chain preprocessors.
ppUnlit :: PreProcessor
ppUnlit inFile outFile verbose = do
    contents <- readFile inFile
    writeFile outFile (unlit inFile contents)
    return ExitSuccess

ppCpp :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppCpp = ppCpp' []

ppCpp' :: [String] -> BuildInfo -> LocalBuildInfo -> PreProcessor
ppCpp' inputArgs bi lbi =
  case withCpphs lbi of
     Just path                          -> use_cpphs path
     Nothing | compilerFlavor hc == GHC -> use_ghc
     _otherwise                         -> ppNone "cpphs (or GHC)"
  where 
	hc = compiler lbi

	use_cpphs cpphs inFile outFile verbose
	  = rawSystemVerbose verbose cpphs cpphsArgs
	  where cpphsArgs = ("-O"++outFile) : inFile : "--noline" : "--strip"
				 : extraArgs

        extraArgs = sysDefines ++ cppOptions bi lbi ++ inputArgs

        sysDefines =
                ["-D" ++ os ++ "_" ++ loc ++ "_OS" | loc <- locations] ++
                ["-D" ++ arch ++ "_" ++ loc ++ "_ARCH" | loc <- locations]
        locations = ["BUILD", "HOST"]

	use_ghc inFile outFile verbose
	  = rawSystemVerbose verbose (compilerPath hc) 
		(["-E", "-cpp", "-optP-P", "-o", outFile, inFile] ++ extraArgs)

ppHsc2hs :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppHsc2hs bi lbi
    = maybe (ppNone "hsc2hs") pp (withHsc2hs lbi)
  where pp n = standardPP n (hcDefines (compiler lbi)
                         ++ ["-I" ++ dir | dir <- includeDirs bi]
                         ++ [opt | opt@('-':c:_) <- ccOptions bi, c == 'D' || c == 'I']
                         ++ ["--cflag=" ++ opt | opt@('-':'U':_) <- ccOptions bi]
                         ++ ["--lflag=-L" ++ dir | dir <- extraLibDirs bi]
                         ++ ["--lflag=-l" ++ lib | lib <- extraLibs bi])

ppC2hs :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppC2hs bi lbi
    = maybe (ppNone "c2hs") pp (withC2hs lbi)
  where pp n = standardPP n (concat [["-C", opt] | opt <- cppOptions bi lbi])

cppOptions :: BuildInfo -> LocalBuildInfo -> [String]
cppOptions bi lbi
    = hcDefines (compiler lbi) ++
            ["-I" ++ dir | dir <- includeDirs bi] ++
            [opt | opt@('-':c:_) <- ccOptions bi, c `elem` "DIU"]

hcDefines :: Compiler -> [String]
hcDefines Compiler { compilerFlavor=GHC, compilerVersion=version }
  = ["-D__GLASGOW_HASKELL__=" ++ versionInt version]
hcDefines Compiler { compilerFlavor=JHC, compilerVersion=version }
  = ["-D__JHC__=" ++ versionInt version]
hcDefines Compiler { compilerFlavor=NHC, compilerVersion=version }
  = ["-D__NHC__=" ++ versionInt version]
hcDefines Compiler { compilerFlavor=Hugs }
  = ["-D__HUGS__"]
hcDefines _ = []

versionInt :: Version -> String
versionInt (Version { versionBranch = [] }) = "1"
versionInt (Version { versionBranch = [n] }) = show n
versionInt (Version { versionBranch = n1:n2:_ })
  = show n1 ++ take 2 ('0' : show n2)

ppHappy :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppHappy _ lbi
    = maybe (ppNone "happy") pp (withHappy lbi)
  where pp n = standardPP n (hcFlags hc)
        hc = compilerFlavor (compiler lbi)
	hcFlags GHC = ["-agc"]
	hcFlags _ = []

ppAlex :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppAlex _ lbi
    = maybe (ppNone "alex") pp (withAlex lbi)
  where pp n = standardPP n (hcFlags hc)
        hc = compilerFlavor (compiler lbi)
	hcFlags GHC = ["-g"]
	hcFlags _ = []

standardPP :: String -> [String] -> PreProcessor
standardPP eName args inFile outFile verbose
    = rawSystemVerbose verbose eName (args ++ ["-o", outFile, inFile])

ppNone :: String -> PreProcessor
ppNone name inFile _ _ =
    dieWithLocation inFile Nothing $ "no " ++ name ++ " preprocessor available"

-- |Convenience function; get the suffixes of these preprocessors.
ppSuffixes :: [ PPSuffixHandler ] -> [String]
ppSuffixes = map fst

-- |Standard preprocessors: GreenCard, c2hs, hsc2hs, happy, alex and cpphs.
knownSuffixHandlers :: [ PPSuffixHandler ]
knownSuffixHandlers =
  [ ("gc",     ppGreenCard)
  , ("chs",    ppC2hs)
  , ("hsc",    ppHsc2hs)
  , ("x",      ppAlex)
  , ("y",      ppHappy)
  , ("ly",     ppHappy)
  , ("cpphs",  ppCpp)
  ]
module Distribution.Program( Program(..)
                           , ProgramLocation(..)
                           , ProgramConfiguration(..)
                           , withProgramFlag
                           , programOptsFlag
                           , programOptsField
                           , defaultProgramConfiguration
                           , updateProgram
                           , userSpecifyPath
                           , userSpecifyArgs
                           , lookupProgram
                           , lookupPrograms
                           , rawSystemProgram
                           , rawSystemProgramConf
                           , simpleProgram
                             -- Programs
                           , ghcProgram
                           , ghcPkgProgram
                           , nhcProgram
                           , jhcProgram
                           , hugsProgram
                           , ranlibProgram
                           , arProgram
                           , alexProgram
                           , hsc2hsProgram
                           , c2hsProgram
                           , cpphsProgram
                           , haddockProgram
                           , greencardProgram
                           , ldProgram
                           , cppProgram
                           , pfesetupProgram
                           ) where

import qualified Distribution.Compat.Map as Map
import Control.Monad(when)
import Data.Maybe(catMaybes)
import System.Exit (ExitCode)
import Distribution.Compat.Directory(findExecutable)
import Distribution.Simple.Utils (die, rawSystemVerbose, maybeExit)

-- |Represents a program which cabal may call.
data Program
    = Program { -- |The simple name of the program, eg ghc
               programName :: String
                -- |The name of this program's binary, eg ghc-6.4
              ,programBinName :: String
                -- |Default command-line args for this program
              ,programArgs :: [String]
                -- |Location of the program.  eg. \/usr\/bin\/ghc-6.4
              ,programLocation :: ProgramLocation
              } deriving (Read, Show)

-- |Similar to Maybe, but tells us whether it's specifed by user or
-- not.  This includes not just the path, but the program as well.
data ProgramLocation = EmptyLocation
                     | UserSpecified FilePath
                     | FoundOnSystem FilePath
      deriving (Read, Show)

data ProgramConfiguration = ProgramConfiguration (Map.Map String Program)

-- Read & Show instances are based on listToFM

instance Show ProgramConfiguration where
  show (ProgramConfiguration s) = show $ Map.toAscList s

instance Read ProgramConfiguration where
  readsPrec p s = [(ProgramConfiguration $ Map.fromList $ s', r)
                       | (s', r) <- readsPrec p s ]

-- |The default list of programs and their arguments.  These programs
-- are typically used internally to Cabal.

defaultProgramConfiguration :: ProgramConfiguration
defaultProgramConfiguration = progListToFM 
                              [ haddockProgram
                              , pfesetupProgram
                              , ranlibProgram
                              , simpleProgram "runghc"
                              , simpleProgram "runhugs"
                              , arProgram]
-- haddock is currently the only one that really works.
{-                              [ ghcProgram
                              , ghcPkgProgram
                              , nhcProgram
                              , hugsProgram
                              , alexProgram
                              , hsc2hsProgram
                              , c2hsProgram
                              , cpphsProgram
                              , haddockProgram
                              , greencardProgram
                              , ldProgram
                              , cppProgram
                              , pfesetupProgram
                              , ranlib, ar
                              ]-}

-- |The flag for giving a path to this program.  eg --with-alex=\/usr\/bin\/alex
withProgramFlag :: Program -> String
withProgramFlag Program{programName=n} = "with-" ++ n

-- |The flag for giving args for this program.
--  eg --haddock-options=-s http:\/\/foo
programOptsFlag :: Program -> String
programOptsFlag Program{programName=n} = n ++ "-options"

-- |The foo.cabal field for  giving args for this program.
--  eg haddock-options: -s http:\/\/foo
programOptsField :: Program -> String
programOptsField = programOptsFlag

-- ------------------------------------------------------------
-- * cabal programs
-- ------------------------------------------------------------

ghcProgram :: Program
ghcProgram = simpleProgram "ghc"

ghcPkgProgram :: Program
ghcPkgProgram = simpleProgram "ghc-pkg"

nhcProgram :: Program
nhcProgram = simpleProgram "nhc"

jhcProgram :: Program
jhcProgram = simpleProgram "jhc"

hugsProgram :: Program
hugsProgram = simpleProgram "hugs"

alexProgram :: Program
alexProgram = simpleProgram "alex"

ranlibProgram :: Program
ranlibProgram = simpleProgram "ranlib"

arProgram :: Program
arProgram = simpleProgram "ar"

hsc2hsProgram :: Program
hsc2hsProgram = simpleProgram "hsc2hs"

c2hsProgram :: Program
c2hsProgram = simpleProgram "c2hs"

cpphsProgram :: Program
cpphsProgram = simpleProgram "cpphs"

haddockProgram :: Program
haddockProgram = simpleProgram "haddock"

greencardProgram :: Program
greencardProgram = simpleProgram "greencard"

ldProgram :: Program
ldProgram = simpleProgram "ld"

cppProgram :: Program
cppProgram = simpleProgram "cpp"

pfesetupProgram :: Program
pfesetupProgram = simpleProgram "pfesetup"

-- ------------------------------------------------------------
-- * helpers
-- ------------------------------------------------------------

-- |Looks up a program in the given configuration.  If there's no
-- location information in the configuration, then we use IO to look
-- on the system in PATH for the program.  If the program is not in
-- the configuration at all, we return Nothing.  FIX: should we build
-- a simpleProgram in that case? Do we want a way to specify NOT to
-- find it on the system (populate programLocation).

lookupProgram :: String -- simple name of program
              -> ProgramConfiguration
              -> IO (Maybe Program) -- the full program
lookupProgram name conf = 
  case lookupProgram' name conf of
    Nothing   -> return Nothing
    Just p@Program{ programLocation= configLoc
                  , programBinName = binName}
        -> do newLoc <- case configLoc of
                         EmptyLocation
                             -> do maybeLoc <- findExecutable binName
                                   return $ maybe EmptyLocation FoundOnSystem maybeLoc
                         a   -> return a
              return $ Just p{programLocation=newLoc}

lookupPrograms :: ProgramConfiguration -> IO [(String, Maybe Program)]
lookupPrograms conf@(ProgramConfiguration fm) = do
  let l = Map.elems fm
  mapM (\p -> do fp <- lookupProgram (programName p) conf
                 return (programName p, fp)
       ) l

-- |User-specify this path.  Basically override any path information
-- for this program in the configuration. If it's not a known
-- program, add it.
userSpecifyPath :: String   -- ^Program name
                -> FilePath -- ^user-specified path to filename
                -> ProgramConfiguration
                -> ProgramConfiguration
userSpecifyPath name path conf'@(ProgramConfiguration conf)
    = case Map.lookup name conf of
       Just p  -> updateProgram (Just p{programLocation=UserSpecified path}) conf'
       Nothing -> updateProgram (Just $ Program name name [] (UserSpecified path))
                                conf'

-- |User-specify the arguments for this program.  Basically override
-- any args information for this program in the configuration. If it's
-- not a known program, add it.
userSpecifyArgs :: String -- ^Program name
                -> String -- ^user-specified args
                -> ProgramConfiguration
                -> ProgramConfiguration
userSpecifyArgs name args conf'@(ProgramConfiguration conf)
    = case Map.lookup name conf of
       Just p  -> updateProgram (Just p{programArgs=(words args)}) conf'
       Nothing -> updateProgram (Just $ Program name name (words args) EmptyLocation) conf'

-- |Update this program's entry in the configuration.  No changes if
-- you pass in Nothing.
updateProgram :: Maybe Program -> ProgramConfiguration -> ProgramConfiguration
updateProgram (Just p@Program{programName=n}) (ProgramConfiguration conf)
    = ProgramConfiguration $ Map.insert n p conf
updateProgram Nothing conf = conf

-- |Runs the given program.
rawSystemProgram :: Int      -- ^Verbosity
                 -> Program  -- ^The program to run
                 -> [String] -- ^Any /extra/ arguments to add
                 -> IO ()
rawSystemProgram verbose (Program { programLocation=(UserSpecified p)
                                  , programArgs=args
                                  }) extraArgs
    = maybeExit $ rawSystemVerbose verbose p (extraArgs ++ args)

rawSystemProgram verbose (Program { programLocation=(FoundOnSystem p)
                                  , programArgs=args
                                  }) extraArgs
    = maybeExit $ rawSystemVerbose verbose p (args ++ extraArgs)

rawSystemProgram _ (Program { programLocation=EmptyLocation
                            , programName=n}) _
    = die ("Error: Could not find location for program: " ++ n)

rawSystemProgramConf :: Int -- ^verbosity
                     -> String -- ^The name of the program to run
                     -> ProgramConfiguration -- ^look up the program here
                     -> [String] -- ^Any /extra/ arguments to add
                     -> IO ()
rawSystemProgramConf verbose progName programConf extraArgs 
    = do prog <- do mProg <- lookupProgram progName programConf
                    case mProg of
                        Nothing -> (die (progName ++ " command not found"))
                        Just h  -> return h
         rawSystemProgram verbose prog extraArgs


-- ------------------------------------------------------------
-- * Internal helpers
-- ------------------------------------------------------------

-- Export?
lookupProgram' :: String -> ProgramConfiguration -> Maybe Program
lookupProgram' s (ProgramConfiguration conf) = Map.lookup s conf

progListToFM :: [Program] -> ProgramConfiguration
progListToFM progs = foldl
                     (\ (ProgramConfiguration conf')
                      p@(Program {programName=n})
                          -> ProgramConfiguration (Map.insert n p conf'))
                     (ProgramConfiguration Map.empty)
                     progs

simpleProgram :: String -> Program
simpleProgram s = Program s s [] EmptyLocation
{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Setup
-- Copyright   :  Isaac Jones 2003-2004
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- Explanation: Data types and parser for the standard command-line
-- setup.  Will also return commands it doesn't know about.

{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Setup (--parseArgs,
                           module Distribution.Compiler,
                           Action(..),
                           ConfigFlags(..), emptyConfigFlags, configureArgs,
                           CopyFlags(..), CopyDest(..), 
			   InstallFlags(..), emptyInstallFlags,
                           HaddockFlags(..), emptyHaddockFlags,
                           BuildFlags(..), CleanFlags(..), PFEFlags(..),
                           RegisterFlags(..), emptyRegisterFlags,
			   SDistFlags(..),
                           MaybeUserFlag(..), userOverride,
			   --optionHelpString,



                           parseGlobalArgs, defaultCompilerFlavor,
                           parseConfigureArgs, parseBuildArgs, parseCleanArgs,
                           parseHaddockArgs, parseProgramaticaArgs, parseTestArgs,
                           parseInstallArgs, parseSDistArgs, parseRegisterArgs,
                           parseUnregisterArgs, parseCopyArgs,
                           reqPathArg, reqDirArg
                           ) where


-- Misc:




import Distribution.Compiler (CompilerFlavor(..), Compiler(..))
import Distribution.Simple.Utils (die)
import Distribution.Program(ProgramConfiguration(..),
                            userSpecifyPath, userSpecifyArgs)
import Data.List(find)
import Distribution.Compat.Map (keys)
import Distribution.GetOpt
import Distribution.Compat.FilePath (platformPath)
import System.Exit
import System.Environment

-- type CommandLineOpts = (Action,
--                         [String]) -- The un-parsed remainder

data Action = ConfigCmd ConfigFlags   -- config
            | BuildCmd                -- build
            | CleanCmd                -- clean
            | CopyCmd CopyDest        -- copy (--destdir flag)
            | HaddockCmd              -- haddock
            | ProgramaticaCmd         -- pfesetup
            | InstallCmd              -- install (install-prefix)
            | SDistCmd                -- sdist
            | TestCmd                 -- test
            | RegisterCmd    	      -- register
            | UnregisterCmd           -- unregister
	    | HelpCmd		      -- help
--            | NoCmd -- error case, help case.
--             | TestCmd 1.0?
--             | BDist -- 1.0
--            | CleanCmd                 -- clean
--            | NoCmd -- error case?

-- ------------------------------------------------------------
-- * Flag-related types
-- ------------------------------------------------------------

-- | Flags to @configure@ command
data ConfigFlags = ConfigFlags {
        configPrograms :: ProgramConfiguration, -- ^All programs that cabal may run
        configHcFlavor :: Maybe CompilerFlavor,
        configHcPath   :: Maybe FilePath, -- ^given compiler location
        configHcPkg    :: Maybe FilePath, -- ^given hc-pkg location
        configHappy    :: Maybe FilePath, -- ^Happy path
        configAlex     :: Maybe FilePath, -- ^Alex path
        configHsc2hs   :: Maybe FilePath, -- ^Hsc2hs path
        configC2hs     :: Maybe FilePath, -- ^C2hs path
        configCpphs    :: Maybe FilePath, -- ^Cpphs path
        configGreencard:: Maybe FilePath, -- ^GreenCard path
        configVanillaLib  :: Bool,        -- ^Enable vanilla library
        configProfLib  :: Bool,           -- ^Enable profiling in the library
        configProfExe  :: Bool,           -- ^Enable profiling in the executables.
        configPrefix   :: Maybe FilePath,
		-- ^installation prefix
	configBinDir   :: Maybe FilePath, 
		-- ^installation dir for binaries,
	configLibDir   :: Maybe FilePath, 
		-- ^installation dir for object code libraries, 
	configLibSubDir :: Maybe FilePath,
		-- ^subdirectory of libdir in which libs are installed
	configLibExecDir :: Maybe FilePath,
		-- ^installation dir for program executables,
	configDataDir  :: Maybe FilePath,
		-- ^installation dir for read-only arch-independent data,
	configDataSubDir :: Maybe FilePath,
		-- ^subdirectory of datadir in which data files are installed

        configVerbose  :: Int,            -- ^verbosity level
	configUser     :: Bool,		  -- ^--user flag?
	configGHCiLib  :: Bool,           -- ^Enable compiling library for GHCi
	configSplitObjs :: Bool		  -- ^Enable -split-objs with GHC
    }

emptyConfigFlags :: ProgramConfiguration -> ConfigFlags
emptyConfigFlags progConf = ConfigFlags {
        configPrograms = progConf,
        configHcFlavor = defaultCompilerFlavor,
        configHcPath   = Nothing,
        configHcPkg    = Nothing,
--        configHaddock  = EmptyLocation,
        configHappy    = Nothing,
        configAlex     = Nothing,
        configHsc2hs   = Nothing,
        configC2hs     = Nothing,
        configVanillaLib  = True,
        configProfLib  = False,
        configProfExe  = False,
        configCpphs    = Nothing,
        configGreencard= Nothing,
        configPrefix   = Nothing,
	configBinDir   = Nothing,
	configLibDir   = Nothing,
	configLibSubDir = Nothing,
	configLibExecDir = Nothing,
	configDataDir  = Nothing,
	configDataSubDir = Nothing,
        configVerbose  = 0,
	configUser     = False,
	configGHCiLib  = True,
	configSplitObjs = False -- takes longer, so turn off by default
    }

-- | Flags to @copy@: (destdir, copy-prefix (backwards compat), verbose)
data CopyFlags = CopyFlags {copyDest      :: CopyDest
                           ,copyVerbose :: Int}

data CopyDest
  = NoCopyDest
  | CopyTo FilePath
  | CopyPrefix FilePath		-- DEPRECATED
  deriving (Eq, Show)

data MaybeUserFlag  = MaybeUserNone   -- ^no --user OR --global flag.
                    | MaybeUserUser   -- ^--user flag
                    | MaybeUserGlobal -- ^--global flag

-- |A 'MaybeUserFlag' overrides the default --user setting
userOverride :: MaybeUserFlag -> Bool -> Bool
MaybeUserUser   `userOverride` _ = True
MaybeUserGlobal `userOverride` _ = False
_               `userOverride` r = r

-- | Flags to @install@: (user package, verbose)
data InstallFlags = InstallFlags {installUserFlags::MaybeUserFlag
                                 ,installVerbose :: Int}

emptyInstallFlags :: InstallFlags
emptyInstallFlags = InstallFlags{ installUserFlags=MaybeUserNone,
				  installVerbose=0 }

-- | Flags to @sdist@: (snapshot, verbose)
data SDistFlags = SDistFlags {sDistSnapshot::Bool
                             ,sDistVerbose:: Int}

-- | Flags to @register@ and @unregister@: (user package, gen-script, 
-- in-place, verbose)
data RegisterFlags = RegisterFlags {regUser::MaybeUserFlag
                                   ,regGenScript::Bool
				   ,regInPlace::Bool
				   ,regWithHcPkg::Maybe FilePath
                                   ,regVerbose::Int}


emptyRegisterFlags :: RegisterFlags
emptyRegisterFlags = RegisterFlags { regUser=MaybeUserNone,
				     regGenScript=False,
				     regInPlace=False,
				     regWithHcPkg=Nothing,
				     regVerbose=0 }

data HaddockFlags = HaddockFlags {haddockHoogle :: Bool
                                 ,haddockVerbose :: Int}

emptyHaddockFlags :: HaddockFlags
emptyHaddockFlags = HaddockFlags {haddockHoogle = False, haddockVerbose = 0}

-- Following only have verbose flags, but for consistency and
-- extensibility we make them into a type.
data BuildFlags   = BuildFlags   {buildVerbose   :: Int}
data CleanFlags   = CleanFlags   {cleanVerbose   :: Int}
data PFEFlags     = PFEFlags     {pfeVerbose     :: Int}

-- |Most of these flags are for Configure, but InstPrefix is for Copy.
data Flag a = GhcFlag | NhcFlag | HugsFlag | JhcFlag
          | WithCompiler FilePath | WithHcPkg FilePath
          | WithHappy FilePath | WithAlex FilePath
          | WithHsc2hs FilePath | WithC2hs FilePath | WithCpphs FilePath
          | WithGreencard FilePath
          | WithVanillaLib | WithoutVanillaLib
          | WithProfLib | WithoutProfLib
          | WithProfExe | WithoutProfExe
	  | WithGHCiLib | WithoutGHCiLib
	  | WithSplitObjs | WithoutSplitObjs

	  | Prefix FilePath
	  | BinDir FilePath
	  | LibDir FilePath
	  | LibSubDir FilePath
	  | LibExecDir FilePath
	  | DataDir FilePath
	  | DataSubDir FilePath

          | ProgramArgs String String   -- program name, arguments
          | WithProgram String FilePath -- program name, location

          -- For install, register, and unregister:
          | UserFlag | GlobalFlag
          -- for register & unregister
          | GenScriptFlag
	  | InPlaceFlag
          -- For copy:
          | InstPrefix FilePath
	  | DestDir FilePath
          -- For sdist:
          | Snapshot
          -- For haddock:
          | HaddockHoogle
          -- For everyone:
          | HelpFlag
          | Verbose Int
--          | Version?
          | Lift a
            deriving (Show, Eq)


-- ------------------------------------------------------------
-- * Mostly parsing functions
-- ------------------------------------------------------------

defaultCompilerFlavor :: Maybe CompilerFlavor
defaultCompilerFlavor =







   Just Hugs




-- | Arguments to pass to a @configure@ script, e.g. generated by
-- @autoconf@.
configureArgs :: ConfigFlags -> [String]
configureArgs flags
  = hc_flag ++
        optFlag "with-hc-pkg" configHcPkg ++
        optFlag "prefix" configPrefix ++
        optFlag "bindir" configBinDir ++
        optFlag "libdir" configLibDir ++
        optFlag "libexecdir" configLibExecDir ++
        optFlag "datadir" configDataDir
  where
        hc_flag = case (configHcFlavor flags, configHcPath flags) of
                        (_, Just hc_path)  -> ["--with-hc=" ++ hc_path]
                        (Just hc, Nothing) -> ["--with-hc=" ++ showHC hc]
                        (Nothing,Nothing)  -> []
        optFlag name config_field = case config_field flags of
                        Just p -> ["--" ++ name ++ "=" ++ p]
                        Nothing -> []

        showHC GHC = "ghc"
        showHC NHC = "nhc98"
        showHC JHC = "jhc"
        showHC Hugs = "hugs"
        showHC c    = "unknown compiler: " ++ (show c)


cmd_help :: OptDescr (Flag a)
cmd_help = Option "h?" ["help"] (NoArg HelpFlag) "Show this help text"

cmd_verbose :: OptDescr (Flag a)
cmd_verbose = Option "v" ["verbose"] (OptArg verboseFlag "n") "Control verbosity (n is 0--5, normal verbosity level is 1, -v alone is equivalent to -v3)"
  where
    verboseFlag mb_s = Verbose (maybe 3 read mb_s)

cmd_with_hc_pkg :: OptDescr (Flag a)
cmd_with_hc_pkg = Option "" ["with-hc-pkg"] (reqPathArg WithHcPkg)
               "give the path to the package tool"

-- Do we have any other interesting global flags?
globalOptions :: [OptDescr (Flag a)]
globalOptions = [
  cmd_help
  ]

liftCustomOpts :: [OptDescr a] -> [OptDescr (Flag a)]
liftCustomOpts flags = [ Option shopt lopt (f adesc) help
                       | Option shopt lopt adesc help <- flags ]
  where f (NoArg x)    = NoArg (Lift x)
        f (ReqArg g s) = ReqArg (Lift . g) s
        f (OptArg g s) = OptArg (Lift . g) s

data Cmd a = Cmd {
        cmdName         :: String,
        cmdHelp         :: String, -- Short description
        cmdDescription  :: String, -- Long description
        cmdOptions      :: [OptDescr (Flag a)],
        cmdAction       :: Action
        }

commandList :: ProgramConfiguration -> [Cmd a]
commandList progConf = [(configureCmd progConf), buildCmd, cleanCmd, installCmd,
                        copyCmd, sdistCmd, testCmd, haddockCmd, programaticaCmd,
                        registerCmd, unregisterCmd]

lookupCommand :: String -> [Cmd a] -> Maybe (Cmd a)
lookupCommand name = find ((==name) . cmdName)

printGlobalHelp :: ProgramConfiguration -> IO ()
printGlobalHelp progConf = 
                  do pname <- getProgName
                     let syntax_line = "Usage: " ++ pname ++ " [GLOBAL FLAGS]\n  or:  " ++ pname ++ " COMMAND [FLAGS]\n\nGlobal flags:"
                     putStrLn (usageInfo syntax_line globalOptions)
                     putStrLn "Commands:"
                     let maxlen = maximum [ length (cmdName cmd) | cmd <- (commandList progConf) ]
                     sequence_ [ do putStr "  "
                                    putStr (align maxlen (cmdName cmd))
                                    putStr "    "
                                    putStrLn (cmdHelp cmd)
                               | cmd <- (commandList progConf) ]
                     putStrLn $ "\nFor more information about a command, try '" ++ pname ++ " COMMAND --help'."
  where align n str = str ++ replicate (n - length str) ' '

printCmdHelp :: Cmd a -> [OptDescr a] -> IO ()
printCmdHelp cmd opts = do pname <- getProgName
                           let syntax_line = "Usage: " ++ pname ++ " " ++ cmdName cmd ++ " [FLAGS]\n\nFlags for " ++ cmdName cmd ++ ":"
                           putStrLn (usageInfo syntax_line (cmdOptions cmd ++ liftCustomOpts opts))
                           putStr (cmdDescription cmd)

getCmdOpt :: Cmd a -> [OptDescr a] -> [String] -> ([Flag a], [String], [String])
getCmdOpt cmd opts s = let (a,_,c,d) = getOpt' Permute (cmdOptions cmd ++ liftCustomOpts opts) s
                         in (a,c,d)

-- We don't want to use elem, because that imposes Eq a
hasHelpFlag :: [Flag a] -> Bool
hasHelpFlag flags = not . null $ [ () | HelpFlag <- flags ]

parseGlobalArgs :: ProgramConfiguration -> [String] -> IO (Action,[String])
parseGlobalArgs progConf args =
  case getOpt' RequireOrder globalOptions args of
    (flags, _, _, []) | hasHelpFlag flags -> do
      (printGlobalHelp progConf)
      exitWith ExitSuccess
    (_, cname:cargs, extra_args, []) -> do
      case lookupCommand cname (commandList progConf) of
        Just cmd -> return (cmdAction cmd, extra_args ++ cargs)
        Nothing  -> die $ "Unrecognised command: " ++ cname ++ " (try --help)"
    (_, [], _, [])  -> die $ "No command given (try --help)"
    (_, _, _, errs) -> putErrors errs

configureCmd :: ProgramConfiguration -> Cmd a
configureCmd progConf = Cmd {
        cmdName        = "configure",
        cmdHelp        = "Prepare to build the package.",
        cmdDescription = "",  -- This can be a multi-line description
        cmdOptions     = [cmd_help, cmd_verbose,
           Option "g" ["ghc"] (NoArg GhcFlag) "compile with GHC",
           Option "n" ["nhc"] (NoArg NhcFlag) "compile with NHC",
           Option "" ["jhc"]  (NoArg JhcFlag) "compile with JHC",
           Option "" ["hugs"] (NoArg HugsFlag) "compile with hugs",
           Option "w" ["with-compiler"] (reqPathArg WithCompiler)
               "give the path to a particular compiler",
	   cmd_with_hc_pkg,
           Option "" ["prefix"] (reqDirArg Prefix)
               "bake this prefix in preparation of installation",
	   Option "" ["bindir"] (reqDirArg BinDir)
		"installation directory for executables",
	   Option "" ["libdir"] (reqDirArg LibDir)
		"installation directory for libraries",
	   Option "" ["libsubdir"] (reqDirArg LibSubDir)
		"subdirectory of libdir in which libs are installed",
	   Option "" ["libexecdir"] (reqDirArg LibExecDir)
		"installation directory for program executables",
	   Option "" ["datadir"] (reqDirArg DataDir)
		"installation directory for read-only data",
	   Option "" ["datasubdir"] (reqDirArg DataSubDir)
		"subdirectory of datadir in which data files are installed",
           Option "" ["with-happy"] (reqPathArg WithHappy)
               "give the path to happy",
           Option "" ["with-alex"] (reqPathArg WithAlex)
               "give the path to alex",
           Option "" ["with-hsc2hs"] (reqPathArg WithHsc2hs)
               "give the path to hsc2hs",
           Option "" ["with-c2hs"] (reqPathArg WithC2hs)
               "give the path to c2hs",
           Option "" ["with-cpphs"] (reqPathArg WithCpphs)
               "give the path to cpphs",
           Option "" ["with-greencard"] (reqPathArg WithGreencard)
               "give the path to greencard",
           Option "" ["enable-library-vanilla"] (NoArg WithVanillaLib)
               "Enable vanilla libraries",
           Option "" ["disable-library-vanilla"] (NoArg WithoutVanillaLib)
               "Disable vanilla libraries",
           Option "p" ["enable-library-profiling"] (NoArg WithProfLib)
               "Enable library profiling",
           Option "" ["disable-library-profiling"] (NoArg WithoutProfLib)
               "Disable library profiling",
           Option "" ["enable-executable-profiling"] (NoArg WithProfExe)
               "Enable executable profiling",
           Option "" ["disable-executable-profiling"] (NoArg WithoutProfExe)
               "Disable executable profiling",
	   Option "" ["enable-library-for-ghci"] (NoArg WithGHCiLib)
               "compile library for use with GHCi",
	   Option "" ["disable-library-for-ghci"] (NoArg WithoutGHCiLib)
               "do not compile libraries for GHCi",
	   Option "" ["enable-split-objs"] (NoArg WithSplitObjs)
	       "split library into smaller objects to reduce binary sizes (GHC 6.6+)",
	   Option "" ["disable-split-objs"] (NoArg WithoutSplitObjs)
	       "split library into smaller objects to reduce binary sizes (GHC 6.6+)",
           Option "" ["user"] (NoArg UserFlag)
               "allow dependencies to be satisfied from the user package database. also implies install --user",
           Option "" ["global"] (NoArg GlobalFlag)
               "(default) dependencies must be satisfied from the global package database"
           ]
{- 
   FIX: Instead of using ++ here, we might add extra arguments.  That
   way, we can condense the help out put to something like
   --with-{haddock,happy,alex,etc}

   FIX: shouldn't use default. Look in hooks?.
-}
         ++ (withProgramOptions progConf)
         ++ (programArgsOptions progConf),
        cmdAction      = ConfigCmd (emptyConfigFlags progConf)
        }

programArgsOptions :: ProgramConfiguration -> [OptDescr (Flag a)]
programArgsOptions (ProgramConfiguration conf) = map f (keys conf)
    where f name = Option "" [name ++ "-args"] (reqPathArg (ProgramArgs name))
                   ("give the args to " ++ name)

withProgramOptions :: ProgramConfiguration -> [OptDescr (Flag a)]
withProgramOptions (ProgramConfiguration conf) = map f (keys conf)
    where f name = Option "" ["with-" ++ name] (reqPathArg (WithProgram name))
                   ("give the path to " ++ name)

reqPathArg :: (FilePath -> a) -> ArgDescr a
reqPathArg constr = ReqArg (constr . platformPath) "PATH"

reqDirArg :: (FilePath -> a) -> ArgDescr a
reqDirArg constr = ReqArg (constr . platformPath) "DIR"

parseConfigureArgs :: ProgramConfiguration -> ConfigFlags -> [String] -> [OptDescr a] ->
                      IO (ConfigFlags, [a], [String])
parseConfigureArgs progConf = parseArgs (configureCmd progConf) updateCfg
  where updateCfg t GhcFlag              = t { configHcFlavor = Just GHC }
        updateCfg t NhcFlag              = t { configHcFlavor = Just NHC }
        updateCfg t JhcFlag              = t { configHcFlavor = Just JHC }
        updateCfg t HugsFlag             = t { configHcFlavor = Just Hugs }
        updateCfg t (WithCompiler path)  = t { configHcPath   = Just path }
        updateCfg t (WithHcPkg path)     = t { configHcPkg    = Just path }
        updateCfg t (WithHappy path)     = t { configHappy    = Just path }
        updateCfg t (WithAlex path)      = t { configAlex     = Just path }
        updateCfg t (WithHsc2hs path)    = t { configHsc2hs   = Just path }
        updateCfg t (WithC2hs path)      = t { configC2hs     = Just path }
        updateCfg t (WithCpphs path)     = t { configCpphs    = Just path }
        updateCfg t (WithGreencard path) = t { configGreencard= Just path }
        updateCfg t (ProgramArgs name args) = t { configPrograms = (userSpecifyArgs
                                                                 name
                                                                 args (configPrograms t))}
        updateCfg t (WithProgram name path) = t { configPrograms = (userSpecifyPath
                                                                 name
                                                                 path (configPrograms t))}
        updateCfg t WithVanillaLib       = t { configVanillaLib  = True }
        updateCfg t WithoutVanillaLib    = t { configVanillaLib  = False, configGHCiLib = False }
        updateCfg t WithProfLib          = t { configProfLib  = True }
        updateCfg t WithoutProfLib       = t { configProfLib  = False }
        updateCfg t WithProfExe          = t { configProfExe  = True }
        updateCfg t WithoutProfExe       = t { configProfExe  = False }
	updateCfg t WithGHCiLib          = t { configGHCiLib  = True }
	updateCfg t WithoutGHCiLib       = t { configGHCiLib  = False }
        updateCfg t (Prefix path)        = t { configPrefix   = Just path }
        updateCfg t (BinDir path)        = t { configBinDir   = Just path }
        updateCfg t (LibDir path)        = t { configLibDir   = Just path }
        updateCfg t (LibSubDir path)     = t { configLibSubDir= Just path }
        updateCfg t (LibExecDir path)    = t { configLibExecDir = Just path }
        updateCfg t (DataDir path)       = t { configDataDir  = Just path }
        updateCfg t (DataSubDir path)    = t { configDataSubDir = Just path }
        updateCfg t (Verbose n)          = t { configVerbose  = n }
        updateCfg t UserFlag             = t { configUser     = True }
        updateCfg t GlobalFlag           = t { configUser     = False }
	updateCfg t WithSplitObjs	 = t { configSplitObjs = True }
	updateCfg t WithoutSplitObjs	 = t { configSplitObjs = False }
        updateCfg t (Lift _)             = t
        updateCfg t _                    = error $ "Unexpected flag!"

buildCmd :: Cmd a
buildCmd = Cmd {
        cmdName        = "build",
        cmdHelp        = "Make this package ready for installation.",
        cmdDescription = "",  -- This can be a multi-line description
        cmdOptions     = [cmd_help, cmd_verbose],
        cmdAction      = BuildCmd
        }

parseBuildArgs :: [String] -> [OptDescr a] -> IO (BuildFlags, [a], [String])
parseBuildArgs = parseNoArgs buildCmd BuildFlags

haddockCmd :: Cmd a
haddockCmd = Cmd {
        cmdName        = "haddock",
        cmdHelp        = "Generate Haddock HTML code from Exposed-Modules.",
        cmdDescription = "Requires cpphs and haddock.",
        cmdOptions     = [cmd_help, cmd_verbose,
                          Option "" ["hoogle"] (NoArg HaddockHoogle) "Generate a hoogle database"],
        cmdAction      = HaddockCmd
        }

parseHaddockArgs :: HaddockFlags -> [String] -> [OptDescr a] -> IO (HaddockFlags, [a], [String])
parseHaddockArgs  = parseArgs haddockCmd updateCfg
  where updateCfg (HaddockFlags hoogle verbose) fl = case fl of
            HaddockHoogle -> HaddockFlags True verbose
            Verbose n     -> HaddockFlags hoogle n
            _             -> error "Unexpected flag!"

programaticaCmd :: Cmd a
programaticaCmd = Cmd {
        cmdName        = "pfe",
        cmdHelp        = "Generate Programatica Project.",
        cmdDescription = "",
        cmdOptions     = [cmd_help, cmd_verbose],
        cmdAction      = ProgramaticaCmd
        }

parseProgramaticaArgs :: [String] -> [OptDescr a] -> IO (PFEFlags, [a], [String])
parseProgramaticaArgs  = parseNoArgs programaticaCmd PFEFlags

cleanCmd :: Cmd a
cleanCmd = Cmd {
        cmdName        = "clean",
        cmdHelp        = "Clean up after a build.",
        cmdDescription = "Removes .hi, .o, preprocessed sources, etc.\n", -- Multi-line!
        cmdOptions     = [cmd_help, cmd_verbose],
        cmdAction      = CleanCmd
        }

parseCleanArgs :: [String] -> [OptDescr a] -> IO (CleanFlags, [a], [String])
parseCleanArgs = parseNoArgs cleanCmd CleanFlags

installCmd :: Cmd a
installCmd = Cmd {
        cmdName        = "install",
        cmdHelp        = "Copy the files into the install locations. Run register.",
        cmdDescription = "Unlike the copy command, install calls the register command.\nIf you want to install into a location that is not what was\nspecified in the configure step, use the copy command.\n",
        cmdOptions     = [cmd_help, cmd_verbose,
           Option "" ["install-prefix"] (reqDirArg InstPrefix)
               "[DEPRECATED, use copy]",
           Option "" ["user"] (NoArg UserFlag)
               "upon registration, register this package in the user's local package database",
           Option "" ["global"] (NoArg GlobalFlag)
               "(default; override with configure) upon registration, register this package in the system-wide package database"
           ],
        cmdAction      = InstallCmd
        }

copyCmd :: Cmd a
copyCmd = Cmd {
        cmdName        = "copy",
        cmdHelp        = "Copy the files into the install locations.",
        cmdDescription = "Does not call register, and allows a prefix at install time\nWithout the --destdir flag, configure determines location.\n",
        cmdOptions     = [cmd_help, cmd_verbose,
           Option "" ["destdir"] (reqDirArg DestDir)
               "directory to copy files to, prepended to installation directories",
           Option "" ["copy-prefix"] (reqDirArg InstPrefix)
               "[DEPRECATED, directory to copy files to instead of prefix]"
           ],
        cmdAction      = CopyCmd NoCopyDest
        }

parseCopyArgs :: CopyFlags -> [String] -> [OptDescr a] ->
                    IO (CopyFlags, [a], [String])
parseCopyArgs = parseArgs copyCmd updateCfg
  where updateCfg (CopyFlags copydest verbose) fl = case fl of
            InstPrefix path -> (CopyFlags (CopyPrefix path) verbose)
	    DestDir path    -> (CopyFlags (CopyTo path) verbose)
            Verbose n       -> (CopyFlags copydest n)
            _               -> error $ "Unexpected flag!"


parseInstallArgs :: InstallFlags -> [String] -> [OptDescr a] ->
                    IO (InstallFlags, [a], [String])
parseInstallArgs = parseArgs installCmd updateCfg
  where updateCfg (InstallFlags uFlag verbose) fl = case fl of
            InstPrefix _ -> error "--install-prefix is obsolete. Use copy command instead."
            UserFlag     -> (InstallFlags MaybeUserUser  verbose)
            GlobalFlag   -> (InstallFlags MaybeUserGlobal verbose)
            Verbose n    -> (InstallFlags uFlag n)
            _            -> error $ "Unexpected flag!"

sdistCmd :: Cmd a
sdistCmd = Cmd {
        cmdName        = "sdist",
        cmdHelp        = "Generate a source distribution file (.tar.gz or .zip).",
        cmdDescription = "",  -- This can be a multi-line description
        cmdOptions     = [cmd_help,cmd_verbose,
           Option "" ["snapshot"] (NoArg Snapshot)
               "Produce a snapshot source distribution"
           ],
        cmdAction      = SDistCmd
        }

parseSDistArgs :: [String] -> [OptDescr a] -> IO (SDistFlags, [a], [String])
parseSDistArgs = parseArgs sdistCmd updateCfg (SDistFlags False 0)
  where updateCfg (SDistFlags snapshot verbose) fl = case fl of
            Snapshot        -> (SDistFlags True verbose)
            Verbose n       -> (SDistFlags snapshot n)
            _               -> error $ "Unexpected flag!"

testCmd :: Cmd a
testCmd = Cmd {
        cmdName        = "test",
        cmdHelp        = "Run the test suite, if any (configure with UserHooks).",
        cmdDescription = "",  -- This can be a multi-line description
        cmdOptions     = [cmd_help,cmd_verbose],
        cmdAction      = TestCmd
        }

parseTestArgs :: [String] -> [OptDescr a] -> IO (Int, [a], [String])
parseTestArgs = parseNoArgs testCmd id

registerCmd :: Cmd a
registerCmd = Cmd {
        cmdName        = "register",
        cmdHelp        = "Register this package with the compiler.",
        cmdDescription = "",  -- This can be a multi-line description
        cmdOptions     = [cmd_help, cmd_verbose,
           Option "" ["user"] (NoArg UserFlag)
               "upon registration, register this package in the user's local package database",
           Option "" ["global"] (NoArg GlobalFlag)
               "(default) upon registration, register this package in the system-wide package database",
           Option "" ["inplace"] (NoArg InPlaceFlag)
               "register the package in the build location, so it can be used without being installed",
           Option "" ["gen-script"] (NoArg GenScriptFlag)
               "Instead of performing the register command, generate a script to register later",
	   cmd_with_hc_pkg
           ],
        cmdAction      = RegisterCmd
        }

parseRegisterArgs :: RegisterFlags -> [String] -> [OptDescr a] ->
                     IO (RegisterFlags, [a], [String])
parseRegisterArgs = parseArgs registerCmd updateCfg
  where updateCfg reg fl = case fl of
            UserFlag        -> reg { regUser=MaybeUserUser }
            GlobalFlag      -> reg { regUser=MaybeUserGlobal }
            Verbose n       -> reg { regVerbose=n }
            GenScriptFlag   -> reg { regGenScript=True }
	    InPlaceFlag     -> reg { regInPlace=True }
	    WithHcPkg f	    -> reg { regWithHcPkg=Just f }
            _               -> error $ "Unexpected flag!"

unregisterCmd :: Cmd a
unregisterCmd = Cmd {
        cmdName        = "unregister",
        cmdHelp        = "Unregister this package with the compiler.",
        cmdDescription = "",  -- This can be a multi-line description
        cmdOptions     = [cmd_help, cmd_verbose,
           Option "" ["user"] (NoArg UserFlag)
               "unregister this package in the user's local package database",
           Option "" ["global"] (NoArg GlobalFlag)
               "(default) unregister this package in the system-wide package database",
           Option "" ["gen-script"] (NoArg GenScriptFlag)
               "Instead of performing the unregister command, generate a script to unregister later"

           ],
        cmdAction      = UnregisterCmd
        }

parseUnregisterArgs :: RegisterFlags -> [String] -> [OptDescr a] ->
                       IO (RegisterFlags, [a], [String])
parseUnregisterArgs = parseRegisterArgs

-- |Helper function for commands with no arguments except for verbose
-- and help.

parseNoArgs :: (Cmd a)
            -> (Int -> b) -- Constructor to make this type.
            -> [String] -> [OptDescr a]-> IO (b, [a], [String])
parseNoArgs cmd c = parseArgs cmd updateCfg (c 0)
  where
    updateCfg _ (Verbose n) = c n
    updateCfg _ _           = error "Unexpected flag!"

-- |Helper function for commands with more options.

parseArgs :: Cmd a -> (cfg -> Flag a -> cfg) -> cfg ->
        [String] -> [OptDescr a] -> IO (cfg, [a], [String])
parseArgs cmd updateCfg cfg args customOpts =
  case getCmdOpt cmd customOpts args of
    (flags, _, []) | hasHelpFlag flags -> do
      printCmdHelp cmd customOpts
      exitWith ExitSuccess
    (flags, args', []) ->
      let flags' = filter (not.isLift) flags in
      return (foldl updateCfg cfg flags', unliftFlags flags, args')
    (_, _, errs) -> putErrors errs
  where
    isLift (Lift _) = True
    isLift _        = False
    unliftFlags :: [Flag a] -> [a]
    unliftFlags flags = [ fl | Lift fl <- flags ]

putErrors :: [String] -> IO a
putErrors errs = die $ "Errors:" ++ concat ['\n':err | err <- errs]












































{- Testing ideas:
   * IO to look for hugs and hugs-pkg (which hugs, etc)
   * quickCheck to test permutations of arguments
   * what other options can we over-ride with a command-line flag?
-}

{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Simple
-- Copyright   :  Isaac Jones 2003-2005
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- Explanation: Simple build system; basically the interface for
-- Distribution.Simple.\* modules.  When given the parsed command-line
-- args and package information, is able to perform basic commands
-- like configure, build, install, register, etc.
--
-- This module isn't called \"Simple\" because it's simple.  Far from
-- it.  It's called \"Simple\" because it does complicated things to
-- simple software.

{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Simple (
	module Distribution.Package,
	module Distribution.Version,
	module Distribution.License,
	module Distribution.Compiler,
	module Language.Haskell.Extension,
        -- * Simple interface
	defaultMain, defaultMainNoRead, defaultMainArgs,
        -- * Customization
        UserHooks(..), Args,
        defaultMainWithHooks, defaultUserHooks, emptyUserHooks,
        defaultHookedPackageDesc



  ) where

-- local
import Distribution.Compiler
import Distribution.Package --must not specify imports, since we're exporting moule.
import Distribution.PackageDescription
import Distribution.Program(lookupProgram, Program(..), ProgramConfiguration(..),
                            haddockProgram, rawSystemProgram, defaultProgramConfiguration,
                            pfesetupProgram, updateProgram,  rawSystemProgramConf)
import Distribution.PreProcess (knownSuffixHandlers, ppSuffixes, ppCpp',
                                ppUnlit, removePreprocessedPackage,
                                preprocessSources, PPSuffixHandler)
import Distribution.Setup

import Distribution.Simple.Build	( build )
import Distribution.Simple.SrcDist	( sdist )
import Distribution.Simple.Register	( register, unregister,
                                          writeInstalledConfig, installedPkgConfigFile,
                                          regScriptLocation, unregScriptLocation
                                        )

import Distribution.Simple.Configure(getPersistBuildConfig, maybeGetPersistBuildConfig,
                                     findProgram, configure, writePersistBuildConfig,
                                     localBuildInfoFile)

import Distribution.Simple.LocalBuildInfo (LocalBuildInfo(..))
import Distribution.Simple.Install(install)
import Distribution.Simple.Utils (die, currentDir, rawSystemVerbose,
                                  defaultPackageDesc, defaultHookedPackageDesc,
                                  moduleToFilePath, findFile,
                                  distPref, srcPref, haddockPref)




import Language.Haskell.Extension
-- Base
import System.Environment(getArgs)
import System.Exit(ExitCode(..), exitWith)
import System.Directory(removeFile, doesFileExist, doesDirectoryExist)

import Distribution.License
import Control.Monad(when, unless)
import Data.List	( intersperse, unionBy )
import Data.Maybe       ( isJust, fromJust )
import System.IO.Error (try)
import Distribution.GetOpt

import Distribution.Compat.Directory(createDirectoryIfMissing,removeDirectoryRecursive, copyFile)
import Distribution.Compat.FilePath(joinFileName, joinPaths, joinFileExt,
                                    splitFileName, splitFileExt, changeFileExt)





import Distribution.Version


type Args = [String]

-- | WARNING: The hooks interface is under rather constant flux as we
-- try to understand users needs.  Setup files that depend on this
-- interface may break in future releases.  Hooks allow authors to add
-- specific functionality before and after a command is run, and also
-- to specify additional preprocessors.
data UserHooks = UserHooks
    {
     runTests :: Args -> Bool -> PackageDescription -> LocalBuildInfo -> IO ExitCode, -- ^Used for @.\/setup test@
     readDesc :: IO (Maybe PackageDescription), -- ^Read the description file
     hookedPreProcessors :: [ PPSuffixHandler ],
        -- ^Custom preprocessors in addition to and overriding 'knownSuffixHandlers'.
     hookedPrograms :: [Program],
        -- ^These programs are detected at configure time.  Arguments for them are added to the configure command.

      -- |Hook to run before configure command
     preConf  :: Args -> ConfigFlags -> IO HookedBuildInfo,
     -- |Over-ride this hook to get different behavior during configure.
     confHook :: PackageDescription -> ConfigFlags -> IO LocalBuildInfo,
      -- |Hook to run after configure command
     postConf :: Args -> ConfigFlags -> PackageDescription -> LocalBuildInfo -> IO ExitCode,

      -- |Hook to run before build command.  Second arg indicates verbosity level.
     preBuild  :: Args -> BuildFlags -> IO HookedBuildInfo,

     -- |Over-ride this hook to get different behavior during build.
     buildHook :: PackageDescription -> LocalBuildInfo -> Maybe UserHooks -> BuildFlags -> IO (),
      -- |Hook to run after build command.  Second arg indicates verbosity level.
     postBuild :: Args -> BuildFlags -> PackageDescription -> LocalBuildInfo -> IO ExitCode,

      -- |Hook to run before clean command.  Second arg indicates verbosity level.
     preClean  :: Args -> CleanFlags -> IO HookedBuildInfo,
     -- |Over-ride this hook to get different behavior during clean.
     cleanHook :: PackageDescription -> Maybe LocalBuildInfo -> Maybe UserHooks -> CleanFlags -> IO (),
      -- |Hook to run after clean command.  Second arg indicates verbosity level.
     postClean :: Args -> CleanFlags -> PackageDescription -> Maybe LocalBuildInfo -> IO ExitCode,

      -- |Hook to run before copy command
     preCopy  :: Args -> CopyFlags -> IO HookedBuildInfo,
     -- |Over-ride this hook to get different behavior during copy.
     copyHook :: PackageDescription -> LocalBuildInfo -> Maybe UserHooks -> CopyFlags -> IO (),
      -- |Hook to run after copy command
     postCopy :: Args -> CopyFlags -> PackageDescription -> LocalBuildInfo -> IO ExitCode,

      -- |Hook to run before install command
     preInst  :: Args -> InstallFlags -> IO HookedBuildInfo,

     -- |Over-ride this hook to get different behavior during install.
     instHook :: PackageDescription -> LocalBuildInfo -> Maybe UserHooks -> InstallFlags -> IO (),
      -- |Hook to run after install command.  postInst should be run
      -- on the target, not on the build machine.
     postInst :: Args -> InstallFlags -> PackageDescription -> LocalBuildInfo -> IO ExitCode,

      -- |Hook to run before sdist command.  Second arg indicates verbosity level.
     preSDist  :: Args -> SDistFlags -> IO HookedBuildInfo,
     -- |Over-ride this hook to get different behavior during sdist.
     sDistHook :: PackageDescription -> Maybe LocalBuildInfo -> Maybe UserHooks -> SDistFlags -> IO (),
      -- |Hook to run after sdist command.  Second arg indicates verbosity level.
     postSDist :: Args -> SDistFlags -> PackageDescription -> Maybe LocalBuildInfo -> IO ExitCode,

      -- |Hook to run before register command
     preReg  :: Args -> RegisterFlags -> IO HookedBuildInfo,
     -- |Over-ride this hook to get different behavior during pfe.
     regHook :: PackageDescription -> LocalBuildInfo -> Maybe UserHooks -> RegisterFlags -> IO (),
      -- |Hook to run after register command
     postReg :: Args -> RegisterFlags -> PackageDescription -> LocalBuildInfo -> IO ExitCode,

      -- |Hook to run before unregister command
     preUnreg  :: Args -> RegisterFlags -> IO HookedBuildInfo,
      -- |Over-ride this hook to get different behavior during pfe.
     unregHook :: PackageDescription -> LocalBuildInfo -> Maybe UserHooks -> RegisterFlags -> IO (),
      -- |Hook to run after unregister command
     postUnreg :: Args -> RegisterFlags -> PackageDescription -> LocalBuildInfo -> IO ExitCode,

      -- |Hook to run before haddock command.  Second arg indicates verbosity level.
     preHaddock  :: Args -> HaddockFlags -> IO HookedBuildInfo,
      -- |Hook to run after haddock command.  Second arg indicates verbosity level.
     -- |Over-ride this hook to get different behavior during haddock.
     haddockHook :: PackageDescription -> LocalBuildInfo -> Maybe UserHooks -> HaddockFlags -> IO (),
     postHaddock :: Args -> HaddockFlags -> PackageDescription -> LocalBuildInfo -> IO ExitCode,

      -- |Hook to run before pfe command.  Second arg indicates verbosity level.
     prePFE  :: Args -> PFEFlags -> IO HookedBuildInfo,
     -- |Over-ride this hook to get different behavior during pfe.
     pfeHook :: PackageDescription -> LocalBuildInfo -> Maybe UserHooks -> PFEFlags -> IO (),
      -- |Hook to run after  pfe command.  Second arg indicates verbosity level.
     postPFE :: Args -> PFEFlags -> PackageDescription -> LocalBuildInfo -> IO ExitCode

    }

-- |A simple implementation of @main@ for a Cabal setup script.
-- It reads the package description file using IO, and performs the
-- action specified on the command line.
defaultMain :: IO ()
defaultMain = getArgs >>=defaultMainArgs

defaultMainArgs :: [String] -> IO ()
defaultMainArgs args = do
                 (action, args) <- parseGlobalArgs (allPrograms Nothing) args
                 pkg_descr_file <- defaultPackageDesc
                 pkg_descr <- readPackageDescription pkg_descr_file
                 defaultMainWorker pkg_descr action args Nothing
                 return ()

-- | A customizable version of 'defaultMain'.
defaultMainWithHooks :: UserHooks -> IO ()
defaultMainWithHooks hooks
    = do args <- getArgs
         (action, args) <- parseGlobalArgs (allPrograms (Just hooks)) args
         maybeDesc <- readDesc hooks
         pkg_descr <- maybe (defaultPackageDesc >>= readPackageDescription)
                            return maybeDesc
         defaultMainWorker pkg_descr action args (Just hooks)
         return ()

-- |Like 'defaultMain', but accepts the package description as input
-- rather than using IO to read it.
defaultMainNoRead :: PackageDescription -> IO ()
defaultMainNoRead pkg_descr
    = do args <- getArgs
         (action, args) <- parseGlobalArgs (allPrograms Nothing) args
         defaultMainWorker pkg_descr action args Nothing
         return ()

-- |Combine the programs in the given hooks with the programs built
-- into cabal.
allPrograms :: Maybe UserHooks
            -> ProgramConfiguration -- combine defaults w/ user programs
allPrograms Nothing = defaultProgramConfiguration
allPrograms (Just h) = foldl (\pConf p -> updateProgram (Just p) pConf)
                        defaultProgramConfiguration
                        (hookedPrograms h)

-- |Combine the preprocessors in the given hooks with the
-- preprocessors built into cabal.
allSuffixHandlers :: Maybe UserHooks
                  -> [PPSuffixHandler]
allSuffixHandlers hooks
    = maybe knownSuffixHandlers
      (\h -> overridesPP (hookedPreProcessors h) knownSuffixHandlers)
      hooks
    where
      overridesPP :: [PPSuffixHandler] -> [PPSuffixHandler] -> [PPSuffixHandler]
      overridesPP = unionBy (\x y -> fst x == fst y)

-- |Helper function for /defaultMain/ and /defaultMainNoRead/
defaultMainWorker :: PackageDescription
                  -> Action
                  -> [String] -- ^args1
                  -> Maybe UserHooks
                  -> IO ExitCode
defaultMainWorker pkg_descr_in action args hooks
    = do case action of
            ConfigCmd flags -> do
                (flags, optFns, args) <-
			parseConfigureArgs (allPrograms hooks) flags args [buildDirOpt]
                pkg_descr <- hookOrInArgs preConf args flags
                (warns, ers) <- sanityCheckPackage pkg_descr
                errorOut warns ers

                let c = maybe (confHook defaultUserHooks) confHook hooks
		localbuildinfo <- c pkg_descr flags
		writePersistBuildConfig (foldr id localbuildinfo optFns)
                postHook postConf args flags pkg_descr localbuildinfo

            BuildCmd -> do
                (flags, _, args) <- parseBuildArgs args []
                pkg_descr <- hookOrInArgs preBuild args flags
		localbuildinfo <- getPersistBuildConfig

                cmdHook buildHook pkg_descr localbuildinfo flags
                postHook postBuild args flags pkg_descr localbuildinfo

            HaddockCmd -> do
                (verbose, _, args) <- parseHaddockArgs emptyHaddockFlags args []
                pkg_descr <- hookOrInArgs preHaddock args verbose
		localbuildinfo <- getPersistBuildConfig

                cmdHook haddockHook pkg_descr localbuildinfo verbose
                postHook postHaddock args verbose pkg_descr localbuildinfo

            ProgramaticaCmd -> do
                (verbose, _, args) <- parseProgramaticaArgs args []
                pkg_descr <- hookOrInArgs prePFE args verbose
                localbuildinfo <- getPersistBuildConfig

                cmdHook pfeHook pkg_descr localbuildinfo verbose
                postHook postPFE args verbose pkg_descr localbuildinfo

            CleanCmd -> do
                (verbose,_, args) <- parseCleanArgs args []
                pkg_descr <- hookOrInArgs preClean args verbose
		maybeLocalbuildinfo <- maybeGetPersistBuildConfig

                cmdHook cleanHook pkg_descr maybeLocalbuildinfo verbose
                postHook postClean args verbose pkg_descr maybeLocalbuildinfo

            CopyCmd mprefix -> do
                (flags, _, args) <- parseCopyArgs (CopyFlags mprefix 0) args []
                pkg_descr <- hookOrInArgs preCopy args flags
		localbuildinfo <- getPersistBuildConfig

                cmdHook copyHook pkg_descr localbuildinfo flags
                postHook postCopy args flags pkg_descr localbuildinfo

            InstallCmd -> do
                (flags, _, args) <- parseInstallArgs emptyInstallFlags args []
                pkg_descr <- hookOrInArgs preInst args flags
		localbuildinfo <- getPersistBuildConfig

                cmdHook instHook pkg_descr localbuildinfo flags
                postHook postInst args flags pkg_descr localbuildinfo

            SDistCmd -> do
                (flags,_, args) <- parseSDistArgs args []
                pkg_descr <- hookOrInArgs preSDist args flags
                maybeLocalbuildinfo <- maybeGetPersistBuildConfig

                cmdHook sDistHook pkg_descr maybeLocalbuildinfo flags
                postHook postSDist args flags pkg_descr maybeLocalbuildinfo

            TestCmd -> do
                (verbose,_, args) <- parseTestArgs args []
                case hooks of
                 Nothing -> return ExitSuccess
                 Just h  -> do localbuildinfo <- getPersistBuildConfig
                               out <- (runTests h) args False pkg_descr_in localbuildinfo
                               when (isFailure out) (exitWith out)
                               return out

            RegisterCmd  -> do
                (flags, _, args) <- parseRegisterArgs emptyRegisterFlags args []
                pkg_descr <- hookOrInArgs preReg args flags
		localbuildinfo <- getPersistBuildConfig

                cmdHook regHook pkg_descr localbuildinfo flags 
                postHook postReg args flags pkg_descr localbuildinfo

            UnregisterCmd -> do
                (flags,_, args) <- parseUnregisterArgs emptyRegisterFlags args []
                pkg_descr <- hookOrInArgs preUnreg args flags
		localbuildinfo <- getPersistBuildConfig

                cmdHook unregHook pkg_descr localbuildinfo flags
                postHook postUnreg args flags pkg_descr localbuildinfo

            HelpCmd -> return ExitSuccess -- this is handled elsewhere
        where
        hookOrInArgs :: (UserHooks -> ([String] -> b -> IO HookedBuildInfo))
                     -> [String]
                     -> b
                     -> IO PackageDescription
        hookOrInArgs f a i
                 = case hooks of
                    Nothing -> no_extra_flags a >> return pkg_descr_in
                    Just h -> do pbi <- f h a i
                                 return (updatePackageDescription pbi pkg_descr_in)
        cmdHook f desc lbi = (maybe (f defaultUserHooks) f hooks) desc lbi hooks
        postHook f args flags pkg_descr localbuildinfo
                 = case hooks of
                    Nothing -> return ExitSuccess
                    Just h  -> f h args flags pkg_descr localbuildinfo

        isFailure :: ExitCode -> Bool
        isFailure (ExitFailure _) = True
        isFailure _               = False

-- (filter (\x -> notElem x overriders) overridden) ++ overriders


getModulePaths :: BuildInfo -> [String] -> IO [FilePath]
getModulePaths bi =
   fmap concat .
      mapM (flip (moduleToFilePath (hsSourceDirs bi)) ["hs", "lhs"])

haddock :: PackageDescription -> LocalBuildInfo -> Maybe UserHooks -> HaddockFlags -> IO ()
haddock pkg_descr lbi hooks (HaddockFlags hoogle verbose) = do
    let pps = allSuffixHandlers hooks
    confHaddock <- do let programConf = withPrograms lbi
                      let haddockName = programName haddockProgram
                      mHaddock <- lookupProgram haddockName programConf
                      maybe (die "haddock command not found") return mHaddock

    let tmpDir = joinPaths (buildDir lbi) "tmp"
    createDirectoryIfMissing True tmpDir
    createDirectoryIfMissing True haddockPref
    preprocessSources pkg_descr lbi verbose pps

    setupMessage "Running Haddock for" pkg_descr

    let replaceLitExts = map (joinFileName tmpDir . flip changeFileExt "hs")
    let mockAll bi = mapM_ (mockPP ["-D__HADDOCK__"] pkg_descr bi lbi tmpDir verbose)
    let showPkg     = showPackageId (package pkg_descr)
    let showDepPkgs = map showPackageId (packageDeps lbi)
    let outputFlag  = if hoogle then "--hoogle" else "--html"

    withLib pkg_descr () $ \lib -> do
        let bi = libBuildInfo lib
        inFiles <- getModulePaths bi (exposedModules lib ++ otherModules bi)
        mockAll bi inFiles
        let prologName = showPkg ++ "-haddock-prolog.txt"
        writeFile prologName (description pkg_descr ++ "\n")
        let outFiles = replaceLitExts inFiles
        let haddockFile = joinFileName haddockPref (haddockName pkg_descr)
        -- FIX: replace w/ rawSystemProgramConf?
        rawSystemProgram verbose confHaddock
                ([outputFlag,
                  "--odir=" ++ haddockPref,
                  "--title=" ++ showPkg ++ ": " ++ synopsis pkg_descr,
                  "--package=" ++ showPkg,
                  "--dump-interface=" ++ haddockFile,
                  "--prologue=" ++ prologName]
                 ++ map ("--use-package=" ++) showDepPkgs
                 ++ programArgs confHaddock
                 ++ (if verbose > 4 then ["--verbose"] else [])
                 ++ outFiles
                 ++ map ("--hide=" ++) (otherModules bi)
                )
        removeFile prologName
    withExe pkg_descr $ \exe -> do
        let bi = buildInfo exe
            exeTargetDir = haddockPref `joinFileName` exeName exe
        createDirectoryIfMissing True exeTargetDir
        inFiles' <- getModulePaths bi (otherModules bi)
        srcMainPath <- findFile (hsSourceDirs bi) (modulePath exe)
        let inFiles = srcMainPath : inFiles'
        mockAll bi inFiles
        let outFiles = replaceLitExts inFiles
        rawSystemProgram verbose confHaddock
                ([outputFlag,
                  "--odir=" ++ exeTargetDir,
                  "--title=" ++ exeName exe]
                 ++ map ("--use-package=" ++) (showPkg:showDepPkgs)
                 ++ programArgs confHaddock
                 ++ (if verbose > 4 then ["--verbose"] else [])
                 ++ outFiles
                )

    removeDirectoryRecursive tmpDir
  where
        mockPP inputArgs pkg_descr bi lbi pref verbose file
            = do let (filePref, fileName) = splitFileName file
                 let targetDir = joinPaths pref filePref
                 let targetFile = joinFileName targetDir fileName
                 let (targetFileNoext, targetFileExt) = splitFileExt targetFile
                 createDirectoryIfMissing True targetDir
                 if (needsCpp pkg_descr)
                    then ppCpp' inputArgs bi lbi file targetFile verbose
                    else copyFile file targetFile >> return ExitSuccess
                 when (targetFileExt == "lhs") $ do
                       ppUnlit targetFile (joinFileExt targetFileNoext "hs") verbose
                       return ()
        needsCpp :: PackageDescription -> Bool
        needsCpp p =
           hasLibs p &&
           any (== CPP) (extensions $ libBuildInfo $ fromJust $ library p)

pfe :: PackageDescription -> LocalBuildInfo -> Maybe UserHooks -> PFEFlags -> IO ()
pfe pkg_descr _lbi hooks (PFEFlags verbose) = do
    let pps = allSuffixHandlers hooks
    unless (hasLibs pkg_descr) $
        die "no libraries found in this project"
    withLib pkg_descr () $ \lib -> do
        lbi <- getPersistBuildConfig
        let bi = libBuildInfo lib
        let mods = exposedModules lib ++ otherModules (libBuildInfo lib)
        preprocessSources pkg_descr lbi verbose pps
        inFiles <- getModulePaths bi mods
        rawSystemProgramConf verbose (programName pfesetupProgram) (withPrograms lbi)
                ("noplogic":"cpp": (if verbose > 4 then ["-v"] else [])
                ++ inFiles)
        return ()

clean :: PackageDescription -> Maybe LocalBuildInfo -> Maybe UserHooks -> CleanFlags -> IO ()
clean pkg_descr maybeLbi hooks (CleanFlags verbose) = do
    let pps = allSuffixHandlers hooks
    putStrLn "cleaning..."
    try $ removeDirectoryRecursive (joinPaths distPref "doc")
    try $ removeFile installedPkgConfigFile
    try $ removeFile localBuildInfoFile
    try $ removeFile regScriptLocation
    try $ removeFile unregScriptLocation
    removePreprocessedPackage pkg_descr currentDir (ppSuffixes pps)
    mapM_ removeFileOrDirectory (extraTmpFiles pkg_descr)

    when (isJust maybeLbi) $ do
        let lbi = fromJust maybeLbi
        try $ removeDirectoryRecursive (buildDir lbi)
        case compilerFlavor (compiler lbi) of
          GHC -> cleanGHCExtras lbi
          JHC -> cleanJHCExtras lbi
          _   -> return ()
  where
        cleanGHCExtras lbi = do
            -- remove source stubs for library
            withLib pkg_descr () $ \ Library{libBuildInfo=bi} ->
                removeGHCModuleStubs bi (libModules pkg_descr)
            -- remove source stubs for executables
            withExe pkg_descr $ \ Executable{modulePath=exeSrcName
                                            ,buildInfo=bi} -> do
                removeGHCModuleStubs bi (exeModules pkg_descr)
                let (startN, _) = splitFileExt exeSrcName
                try $ removeFile (startN ++ "_stub.h")
                try $ removeFile (startN ++ "_stub.c")
        removeGHCModuleStubs :: BuildInfo -> [String] -> IO ()
        removeGHCModuleStubs (BuildInfo{hsSourceDirs=dirs}) mods = do
            s <- mapM (\x -> moduleToFilePath dirs (x ++"_stub") ["h", "c"]) mods
            mapM_ removeFile (concat s)
        -- JHC FIXME remove exe-sources
        cleanJHCExtras lbi = do
            try $ removeFile (buildDir lbi `joinFileName` "jhc-pkg.conf")
            removePreprocessedPackage pkg_descr currentDir ["ho"]
        removeFileOrDirectory :: FilePath -> IO ()
        removeFileOrDirectory fname = do
            isDir <- doesDirectoryExist fname
            isFile <- doesFileExist fname
            if isDir then removeDirectoryRecursive fname
              else if isFile then removeFile fname
              else return ()

no_extra_flags :: [String] -> IO ()
no_extra_flags [] = return ()
no_extra_flags extra_flags  = 
  die ("Unrecognised flags: " ++ concat (intersperse "," extra_flags))

buildDirOpt :: OptDescr (LocalBuildInfo -> LocalBuildInfo)
buildDirOpt = Option "b" ["scratchdir"] (reqDirArg setBuildDir)
		"directory to receive the built package [dist/build]"
  where setBuildDir dir lbi = lbi { buildDir = dir }

-- |Empty 'UserHooks' which do nothing.
emptyUserHooks :: UserHooks
emptyUserHooks
    = UserHooks
      {
       runTests  = res,
       readDesc  = return Nothing,
       hookedPreProcessors = [],
       hookedPrograms      = [],
       preConf   = rn,
       confHook  = (\_ _ -> return (error "No local build info generated during configure. Over-ride empty configure hook.")),
       postConf  = res,
       preBuild  = rn,
       buildHook = ru,
       postBuild = res,
       preClean  = rn,
       cleanHook = ru,
       postClean = res,
       preCopy   = rn,
       copyHook  = ru,
       postCopy  = res,
       preInst   = rn,
       instHook  = ru,
       postInst  = res,
       preSDist  = rn,
       sDistHook = ru,
       postSDist = res,
       preReg    = rn,
       regHook   = ru,
       postReg   = res,
       preUnreg  = rn,
       unregHook = ru,
       postUnreg = res,
       prePFE    = rn,
       pfeHook   = ru,
       postPFE   = res,
       preHaddock  = rn,
       haddockHook = ru,
       postHaddock = res
      }
    where rn  _ _    = return emptyHookedBuildInfo
          res _ _ _ _  = return ExitSuccess
          ru _ _ _ _ = return ()

-- |Basic default 'UserHooks':
--
-- * on non-Windows systems, 'postConf' runs @.\/configure@, if present.
--
-- * the pre-hooks 'preBuild', 'preClean', 'preCopy', 'preInst',
--   'preReg' and 'preUnreg' read additional build information from
--   /package/@.buildinfo@, if present.
--
-- Thus @configure@ can use local system information to generate
-- /package/@.buildinfo@ and possibly other files.

-- FIXME: do something sensible for windows, or do nothing in postConf.

defaultUserHooks :: UserHooks
defaultUserHooks
    = emptyUserHooks
      {
       postConf  = defaultPostConf,
       confHook  = configure,
       preBuild  = readHook buildVerbose,
       buildHook = defaultBuildHook,
       preClean  = readHook cleanVerbose,
       preCopy   = readHook copyVerbose,
       copyHook  = \desc lbi _ f -> install desc lbi f, -- has correct 'copy' behavior with params
       preInst   = readHook installVerbose,
       instHook  = defaultInstallHook,
       sDistHook = \p _ h f -> sdist p f srcPref distPref (allSuffixHandlers h),
       pfeHook   = pfe,
       cleanHook = clean,
       haddockHook = haddock,
       preReg    = readHook regVerbose,
       regHook   = defaultRegHook,
       unregHook = \p l _ f -> unregister p l f,
       preUnreg  = readHook regVerbose
      }
    where defaultPostConf :: Args -> ConfigFlags -> PackageDescription -> LocalBuildInfo -> IO ExitCode
          defaultPostConf args flags pkg_descr lbi
              = do let verbose = configVerbose flags
                       args' = configureArgs flags ++ args
                   confExists <- doesFileExist "configure"
                   if confExists then





                       -- FIXME: should we really be discarding the exit code?
                       rawSystemVerbose verbose "./configure" args'

                     else do
                       no_extra_flags args
                       return ExitSuccess

          readHook :: (a -> Int) -> Args -> a -> IO HookedBuildInfo
          readHook verbose a flags = do
              no_extra_flags a
              maybe_infoFile <- defaultHookedPackageDesc
              case maybe_infoFile of
                  Nothing       -> return emptyHookedBuildInfo
                  Just infoFile -> do
                      when (verbose flags > 0) $
                          putStrLn $ "Reading parameters from " ++ infoFile
                      readHookedBuildInfo infoFile

defaultInstallHook :: PackageDescription -> LocalBuildInfo
	-> Maybe UserHooks ->InstallFlags -> IO ()
defaultInstallHook pkg_descr localbuildinfo _ (InstallFlags uInstFlag verbose) = do
  install pkg_descr localbuildinfo (CopyFlags NoCopyDest verbose)
  when (hasLibs pkg_descr) $
      register pkg_descr localbuildinfo 
           emptyRegisterFlags{ regUser=uInstFlag, regVerbose=verbose }

defaultBuildHook :: PackageDescription -> LocalBuildInfo
	-> Maybe UserHooks -> BuildFlags -> IO ()
defaultBuildHook pkg_descr localbuildinfo hooks flags = do
  build pkg_descr localbuildinfo flags (allSuffixHandlers hooks)
  when (hasLibs pkg_descr) $
      writeInstalledConfig pkg_descr localbuildinfo False

defaultRegHook :: PackageDescription -> LocalBuildInfo
	-> Maybe UserHooks -> RegisterFlags -> IO ()
defaultRegHook pkg_descr localbuildinfo _ flags =
    if hasLibs pkg_descr
    then register pkg_descr localbuildinfo flags
    else die "Package contains no library to register"

-- ------------------------------------------------------------
-- * Testing
-- ------------------------------------------------------------




{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Version
-- Copyright   :  Isaac Jones, Simon Marlow 2003-2004
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- Versions for packages, based on the 'Version' datatype.

{- Copyright (c) 2003-2004, Isaac Jones
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Version (
  -- * Package versions
  Version(..),
  showVersion,
  parseVersion,

  -- * Version ranges
  VersionRange(..), 
  orLaterVersion, orEarlierVersion,
  betweenVersionsInclusive,
  withinRange,
  showVersionRange,
  parseVersionRange,

  -- * Dependencies
  Dependency(..),




 ) where


import Data.Version	( Version(..), showVersion, parseVersion )


import Control.Monad    ( liftM )

import Distribution.Compat.ReadP





-- -----------------------------------------------------------------------------
-- The Version type



















































































































-- -----------------------------------------------------------------------------
-- Version ranges

-- Todo: maybe move this to Distribution.Package.Version?
-- (package-specific versioning scheme).

data VersionRange
  = AnyVersion
  | ThisVersion		   Version -- = version
  | LaterVersion	   Version -- > version  (NB. not >=)
  | EarlierVersion	   Version -- < version
	-- ToDo: are these too general?
  | UnionVersionRanges      VersionRange VersionRange
  | IntersectVersionRanges  VersionRange VersionRange
  deriving (Show,Read,Eq)

orLaterVersion :: Version -> VersionRange
orLaterVersion   v = UnionVersionRanges (ThisVersion v) (LaterVersion v)

orEarlierVersion :: Version -> VersionRange
orEarlierVersion v = UnionVersionRanges (ThisVersion v) (EarlierVersion v)


betweenVersionsInclusive :: Version -> Version -> VersionRange
betweenVersionsInclusive v1 v2 =
  IntersectVersionRanges (orLaterVersion v1) (orEarlierVersion v2)

laterVersion :: Version -> Version -> Bool
v1 `laterVersion`   v2 = versionBranch v1 > versionBranch v2

earlierVersion :: Version -> Version -> Bool
v1 `earlierVersion` v2 = versionBranch v1 < versionBranch v2

-- |Does this version fall within the given range?
withinRange :: Version -> VersionRange -> Bool
withinRange _  AnyVersion                = True
withinRange v1 (ThisVersion v2) 	 = v1 == v2
withinRange v1 (LaterVersion v2)         = v1 `laterVersion` v2
withinRange v1 (EarlierVersion v2)       = v1 `earlierVersion` v2
withinRange v1 (UnionVersionRanges v2 v3) 
   = v1 `withinRange` v2 || v1 `withinRange` v3
withinRange v1 (IntersectVersionRanges v2 v3) 
   = v1 `withinRange` v2 && v1 `withinRange` v3

showVersionRange :: VersionRange -> String
showVersionRange AnyVersion = "-any"
showVersionRange (ThisVersion v) = '=' : '=' : showVersion v
showVersionRange (LaterVersion v) = '>' : showVersion v
showVersionRange (EarlierVersion v) = '<' : showVersion v
showVersionRange (UnionVersionRanges (ThisVersion v1) (LaterVersion v2))
  | v1 == v2 = '>' : '=' : showVersion v1
showVersionRange (UnionVersionRanges (LaterVersion v2) (ThisVersion v1))
  | v1 == v2 = '>' : '=' : showVersion v1
showVersionRange (UnionVersionRanges (ThisVersion v1) (EarlierVersion v2))
  | v1 == v2 = '<' : '=' : showVersion v1
showVersionRange (UnionVersionRanges (EarlierVersion v2) (ThisVersion v1))
  | v1 == v2 = '<' : '=' : showVersion v1
showVersionRange (UnionVersionRanges r1 r2) 
  = showVersionRange r1 ++ "||" ++ showVersionRange r2
showVersionRange (IntersectVersionRanges r1 r2) 
  = showVersionRange r1 ++ "&&" ++ showVersionRange r2

-- ------------------------------------------------------------
-- * Package dependencies
-- ------------------------------------------------------------

data Dependency = Dependency String VersionRange
                  deriving (Read, Show, Eq)

-- ------------------------------------------------------------
-- * Parsing
-- ------------------------------------------------------------

--  -----------------------------------------------------------
parseVersionRange :: ReadP r VersionRange
parseVersionRange = do
  f1 <- factor
  skipSpaces
  (do
     string "||"
     skipSpaces
     f2 <- factor
     return (UnionVersionRanges f1 f2)
   +++
   do    
     string "&&"
     skipSpaces
     f2 <- factor
     return (IntersectVersionRanges f1 f2)
   +++
   return f1)
  where 
        factor   = choice ((string "-any" >> return AnyVersion) :
                                    map parseRangeOp rangeOps)
        parseRangeOp (s,f) = string s >> skipSpaces >> liftM f parseVersion
        rangeOps = [ ("<",  EarlierVersion),
                     ("<=", orEarlierVersion),
                     (">",  LaterVersion),
                     (">=", orLaterVersion),
                     ("==", ThisVersion) ]









































































{-# OPTIONS_GHC -cpp #-}
-- #hide
module Distribution.Compat.Directory (
        module System.Directory,

 	findExecutable, copyFile, getHomeDirectory, createDirectoryIfMissing,
        removeDirectoryRecursive,

        getDirectoryContentsWithoutSpecial
  ) where











import System.Directory















































































































getDirectoryContentsWithoutSpecial :: FilePath -> IO [FilePath]
getDirectoryContentsWithoutSpecial =
   fmap (filter (not . flip elem [".", ".."])) . getDirectoryContents
{-# OPTIONS_GHC -cpp #-}
-- #hide
module Distribution.Compat.Exception (bracket,finally) where





import Control.Exception (bracket,finally)






{-# OPTIONS_GHC -cpp #-}
-- #hide
module Distribution.Compat.FilePath
         ( -- * File path
           FilePath
         , splitFileName
         , splitFileExt
         , splitFilePath
         , baseName
         , dirName
         , joinFileName
         , joinFileExt
         , joinPaths
         , changeFileExt
         , isRootedPath
         , isAbsolutePath
         , dropAbsolutePrefix
         , breakFilePath
         , dropPrefix

         , pathParents
         , commonParent

         -- * Search path
         , parseSearchPath
         , mkSearchPath

         -- * Separators
         , isPathSeparator
         , pathSeparator
         , searchPathSeparator
         , platformPath

         -- * Filename extensions
         , exeExtension
         , objExtension
         , dllExtension
         ) where









import Data.List(intersperse)

--------------------------------------------------------------
-- * FilePath
--------------------------------------------------------------

-- | Split the path into directory and file name
--
-- Examples:
--
-- \[Posix\]
--
-- > splitFileName "/"            == ("/",    ".")
-- > splitFileName "/foo/bar.ext" == ("/foo", "bar.ext")
-- > splitFileName "bar.ext"      == (".",    "bar.ext")
-- > splitFileName "/foo/."       == ("/foo", ".")
-- > splitFileName "/foo/.."      == ("/foo", "..")
--
-- \[Windows\]
--
-- > splitFileName "\\"               == ("\\",      "")
-- > splitFileName "c:\\foo\\bar.ext" == ("c:\\foo", "bar.ext")
-- > splitFileName "bar.ext"          == (".",       "bar.ext")
-- > splitFileName "c:\\foo\\."       == ("c:\\foo", ".")
-- > splitFileName "c:\\foo\\.."      == ("c:\\foo", "..")
--
-- The first case in the Windows examples returns an empty file name.
-- This is a special case because the \"\\\\\" path doesn\'t refer to
-- an object (file or directory) which resides within a directory.
splitFileName :: FilePath -> (String, String)














splitFileName p = (reverse path1, reverse fname1)
  where
    (fname,path) = break isPathSeparator (reverse p)
    path1 = case path of
      "" -> "."
      _  -> case dropWhile isPathSeparator path of
        "" -> [pathSeparator]
        p  -> p
    fname1 = case fname of
      "" -> "."
      _  -> fname


-- | Split the path into file name and extension. If the file doesn\'t have extension,
-- the function will return empty string. The extension doesn\'t include a leading period.
--
-- Examples:
--
-- > splitFileExt "foo.ext" == ("foo", "ext")
-- > splitFileExt "foo"     == ("foo", "")
-- > splitFileExt "."       == (".",   "")
-- > splitFileExt ".."      == ("..",  "")
-- > splitFileExt "foo.bar."== ("foo.bar.", "")
-- > splitFileExt "foo.tar.gz" == ("foo.tar","gz")

splitFileExt :: FilePath -> (String, String)
splitFileExt p =
  case break (== '.') fname of
        (suf@(_:_),_:pre) -> (reverse (pre++path), reverse suf)
        _                 -> (p, [])
  where
    (fname,path) = break isPathSeparator (reverse p)

-- | Split the path into directory, file name and extension.
-- The function is an optimized version of the following equation:
--
-- > splitFilePath path = (dir,name,ext)
-- >   where
-- >     (dir,basename) = splitFileName path
-- >     (name,ext)     = splitFileExt  basename
splitFilePath :: FilePath -> (String, String, String)
splitFilePath path = case break (== '.') (reverse basename) of
    (name_r, "")      -> (dir, reverse name_r, "")
    (ext_r, _:name_r) -> (dir, reverse name_r, reverse ext_r)
  where
    (dir, basename) = splitFileName path

baseName :: FilePath -> FilePath
baseName = snd . splitFileName
dirName :: FilePath -> FilePath
dirName  = fst . splitFileName


-- | The 'joinFileName' function is the opposite of 'splitFileName'.
-- It joins directory and file names to form a complete file path.
--
-- The general rule is:
--
-- > dir `joinFileName` basename == path
-- >   where
-- >     (dir,basename) = splitFileName path
--
-- There might be an exceptions to the rule but in any case the
-- reconstructed path will refer to the same object (file or directory).
-- An example exception is that on Windows some slashes might be converted
-- to backslashes.
joinFileName :: String -> String -> FilePath
joinFileName ""  fname = fname
joinFileName "." fname = fname
joinFileName dir ""    = dir
joinFileName dir fname
  | isPathSeparator (last dir) = dir++fname
  | otherwise                  = dir++pathSeparator:fname

-- | The 'joinFileExt' function is the opposite of 'splitFileExt'.
-- It joins a file name and an extension to form a complete file path.
--
-- The general rule is:
--
-- > filename `joinFileExt` ext == path
-- >   where
-- >     (filename,ext) = splitFileExt path
joinFileExt :: String -> String -> FilePath
joinFileExt path ""  = path
joinFileExt path ext = path ++ '.':ext

-- | Given a directory path \"dir\" and a file\/directory path \"rel\",
-- returns a merged path \"full\" with the property that
-- (cd dir; do_something_with rel) is equivalent to
-- (do_something_with full). If the \"rel\" path is an absolute path
-- then the returned path is equal to \"rel\"
joinPaths :: FilePath -> FilePath -> FilePath
joinPaths path1 path2
  | isRootedPath path2 = path2
  | otherwise          =






        path1 `joinFileName` path2


-- | Changes the extension of a file path.
changeFileExt :: FilePath           -- ^ The path information to modify.
          -> String                 -- ^ The new extension (without a leading period).
                                    -- Specify an empty string to remove an existing
                                    -- extension from path.
          -> FilePath               -- ^ A string containing the modified path information.
changeFileExt path ext = joinFileExt name ext
  where
    (name,_) = splitFileExt path

-- | On Unix and Macintosh the 'isRootedPath' function is a synonym to 'isAbsolutePath'.
-- The difference is important only on Windows. The rooted path must start from the root
-- directory but may not include the drive letter while the absolute path always includes
-- the drive letter and the full file path.
isRootedPath :: FilePath -> Bool
isRootedPath (c:_) | isPathSeparator c = True



isRootedPath _ = False

-- | Returns 'True' if this path\'s meaning is independent of any OS
-- \"working directory\", or 'False' if it isn\'t.
isAbsolutePath :: FilePath -> Bool



isAbsolutePath (c:_)       | isPathSeparator c = True

isAbsolutePath _ = False

-- | If the function is applied to an absolute path then it returns a local path droping
-- the absolute prefix in the path. Under Windows the prefix is \"\\\", \"c:\" or \"c:\\\". Under
-- Unix the prefix is always \"\/\".
dropAbsolutePrefix :: FilePath -> FilePath
dropAbsolutePrefix (c:cs) | isPathSeparator c = cs




dropAbsolutePrefix cs = cs

-- | Split the path into a list of strings constituting the filepath
--
-- >  breakFilePath "/usr/bin/ls" == ["/","usr","bin","ls"]
breakFilePath :: FilePath -> [String]
breakFilePath = worker []
    where worker ac path
              | less == path = less:ac
              | otherwise = worker (current:ac) less
              where (less,current) = splitFileName path

-- | Drops a specified prefix from a filepath.
--
-- >  dropPrefix "." "Src/Test.hs" == "Src/Test.hs"
-- >  dropPrefix "Src" "Src/Test.hs" == "Test.hs"
dropPrefix :: FilePath -> FilePath -> FilePath
dropPrefix prefix path
    = worker (breakFilePath prefix) (breakFilePath path)
    where worker (x:xs) (y:ys)
              | x == y = worker xs ys
          worker _ ys = foldr1 joinPaths ys
-- | Gets this path and all its parents.
-- The function is useful in case if you want to create
-- some file but you aren\'t sure whether all directories
-- in the path exist or if you want to search upward for some file.
--
-- Some examples:
--
-- \[Posix\]
--
-- >  pathParents "/"          == ["/"]
-- >  pathParents "/dir1"      == ["/", "/dir1"]
-- >  pathParents "/dir1/dir2" == ["/", "/dir1", "/dir1/dir2"]
-- >  pathParents "dir1"       == [".", "dir1"]
-- >  pathParents "dir1/dir2"  == [".", "dir1", "dir1/dir2"]
--
-- \[Windows\]
--
-- >  pathParents "c:"             == ["c:."]
-- >  pathParents "c:\\"           == ["c:\\"]
-- >  pathParents "c:\\dir1"       == ["c:\\", "c:\\dir1"]
-- >  pathParents "c:\\dir1\\dir2" == ["c:\\", "c:\\dir1", "c:\\dir1\\dir2"]
-- >  pathParents "c:dir1"         == ["c:.","c:dir1"]
-- >  pathParents "dir1\\dir2"     == [".", "dir1", "dir1\\dir2"]
--
-- Note that if the file is relative then the current directory (\".\")
-- will be explicitly listed.
pathParents :: FilePath -> [FilePath]
pathParents p =
    root'' : map ((++) root') (dropEmptyPath $ inits path')
    where





       (root,path) = ("",p)

       (root',root'',path') = case path of
         (c:path) | isPathSeparator c -> (root++[pathSeparator],root++[pathSeparator],path)
         _                            -> (root                 ,root++"."            ,path)

       dropEmptyPath ("":paths) = paths
       dropEmptyPath paths      = paths

       inits :: String -> [String]
       inits [] =  [""]
       inits cs =
         case pre of
           "."  -> inits suf
           ".." -> map (joinFileName pre) (dropEmptyPath $ inits suf)
           _    -> "" : map (joinFileName pre) (inits suf)
         where
           (pre,suf) = case break isPathSeparator cs of
              (pre,"")    -> (pre, "")
              (pre,_:suf) -> (pre,suf)

-- | Given a list of file paths, returns the longest common parent.
commonParent :: [FilePath] -> Maybe FilePath
commonParent []           = Nothing
commonParent paths@(p:ps) =
  case common Nothing "" p ps of












    Nothing | all (not . isAbsolutePath) paths -> Just "."

    mb_path   -> mb_path
  where
    common i acc []     ps = checkSep   i acc         ps
    common i acc (c:cs) ps
      | isPathSeparator c  = removeSep  i acc   cs [] ps
      | otherwise          = removeChar i acc c cs [] ps

    checkSep i acc []      = Just (reverse acc)
    checkSep i acc ([]:ps) = Just (reverse acc)
    checkSep i acc ((c1:p):ps)
      | isPathSeparator c1 = checkSep i acc ps
    checkSep i acc ps      = i

    removeSep i acc cs pacc []          =
      common (Just (reverse (pathSeparator:acc))) (pathSeparator:acc) cs pacc
    removeSep i acc cs pacc ([]    :ps) = Just (reverse acc)
    removeSep i acc cs pacc ((c1:p):ps)
      | isPathSeparator c1              = removeSep i acc cs (p:pacc) ps
    removeSep i acc cs pacc ps          = i

    removeChar i acc c cs pacc []          = common i (c:acc) cs pacc
    removeChar i acc c cs pacc ([]    :ps) = i
    removeChar i acc c cs pacc ((c1:p):ps)
      | c == c1                            = removeChar i acc c cs (p:pacc) ps
    removeChar i acc c cs pacc ps          = i

--------------------------------------------------------------
-- * Search path
--------------------------------------------------------------

-- | The function splits the given string to substrings
-- using the 'searchPathSeparator'.
parseSearchPath :: String -> [FilePath]
parseSearchPath path = split path
  where
    split :: String -> [String]
    split s =
      case rest' of
        []     -> [chunk]
        _:rest -> chunk : split rest
      where
        chunk =
          case chunk' of



            _                                 -> chunk'

        (chunk', rest') = break (==searchPathSeparator) s

-- | The function concatenates the given paths to form a
-- single string where the paths are separated with 'searchPathSeparator'.
mkSearchPath :: [FilePath] -> String
mkSearchPath paths = concat (intersperse [searchPathSeparator] paths)


--------------------------------------------------------------
-- * Separators
--------------------------------------------------------------

-- | Checks whether the character is a valid path separator for the host
-- platform. The valid character is a 'pathSeparator' but since the Windows
-- operating system also accepts a slash (\"\/\") since DOS 2, the function
-- checks for it on this platform, too.
isPathSeparator :: Char -> Bool
isPathSeparator ch =



  ch == '/'


-- | Provides a platform-specific character used to separate directory levels in
-- a path string that reflects a hierarchical file system organization. The
-- separator is a slash (@\"\/\"@) on Unix and Macintosh, and a backslash
-- (@\"\\\"@) on the Windows operating system.
pathSeparator :: Char



pathSeparator = '/'


-- | A platform-specific character used to separate search path strings in
-- environment variables. The separator is a colon (\":\") on Unix and Macintosh,
-- and a semicolon (\";\") on the Windows operating system.
searchPathSeparator :: Char



searchPathSeparator = ':'


-- |Convert Unix-style path separators to the path separators for this platform.
platformPath :: FilePath -> FilePath





platformPath = id


-- ToDo: This should be determined via autoconf (AC_EXEEXT)
-- | Extension for executable files
-- (typically @\"\"@ on Unix and @\"exe\"@ on Windows or OS\/2)
exeExtension :: String



exeExtension = ""


-- ToDo: This should be determined via autoconf (AC_OBJEXT)
-- | Extension for object files. For GHC and NHC the extension is @\"o\"@.
-- Hugs uses either @\"o\"@ or @\"obj\"@ depending on the used C compiler.
objExtension :: String
objExtension = "o"

-- | Extension for dynamically linked (or shared) libraries
-- (typically @\"so\"@ on Unix and @\"dll\"@ on Windows)
dllExtension :: String



dllExtension = "so"

{-# OPTIONS_GHC -cpp #-}
-- #hide
module Distribution.Compat.Map (
   Map,
   member, lookup, findWithDefault,
   empty,
   insert, insertWith,
   union, unionWith, unions,
   elems, keys,
   fromList, fromListWith,
   toAscList
) where

import Prelude hiding ( lookup )


import Data.Map


















































{-# OPTIONS_GHC -cpp #-}
-- #hide
module Distribution.Compat.RawSystem (rawSystem) where






import System.Cmd (rawSystem)







{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Compat.ReadP
-- Copyright   :  (c) The University of Glasgow 2002
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- This is a library of parser combinators, originally written by Koen Claessen.
-- It parses all alternatives in parallel, so it never keeps hold of 
-- the beginning of the input string, a common source of space leaks with
-- other parsers.  The '(+++)' choice combinator is genuinely commutative;
-- it makes no difference which branch is \"shorter\".
--
-- See also Koen's paper /Parallel Parsing Processes/
-- (<http://www.cs.chalmers.se/~koen/publications.html>).
--
-- This version of ReadP has been locally hacked to make it H98, by
-- Martin Sj&#xF6;gren <mailto:msjogren@gmail.com>
--
-----------------------------------------------------------------------------

module Distribution.Compat.ReadP
  ( 
  -- * The 'ReadP' type
  ReadP,      -- :: * -> *; instance Functor, Monad, MonadPlus
  
  -- * Primitive operations
  get,        -- :: ReadP Char
  look,       -- :: ReadP String
  (+++),      -- :: ReadP a -> ReadP a -> ReadP a
  (<++),      -- :: ReadP a -> ReadP a -> ReadP a
  gather,     -- :: ReadP a -> ReadP (String, a)
  
  -- * Other operations
  pfail,      -- :: ReadP a
  satisfy,    -- :: (Char -> Bool) -> ReadP Char
  char,       -- :: Char -> ReadP Char
  string,     -- :: String -> ReadP String
  munch,      -- :: (Char -> Bool) -> ReadP String
  munch1,     -- :: (Char -> Bool) -> ReadP String
  skipSpaces, -- :: ReadP ()
  choice,     -- :: [ReadP a] -> ReadP a
  count,      -- :: Int -> ReadP a -> ReadP [a]
  between,    -- :: ReadP open -> ReadP close -> ReadP a -> ReadP a
  option,     -- :: a -> ReadP a -> ReadP a
  optional,   -- :: ReadP a -> ReadP ()
  many,       -- :: ReadP a -> ReadP [a]
  many1,      -- :: ReadP a -> ReadP [a]
  skipMany,   -- :: ReadP a -> ReadP ()
  skipMany1,  -- :: ReadP a -> ReadP ()
  sepBy,      -- :: ReadP a -> ReadP sep -> ReadP [a]
  sepBy1,     -- :: ReadP a -> ReadP sep -> ReadP [a]
  endBy,      -- :: ReadP a -> ReadP sep -> ReadP [a]
  endBy1,     -- :: ReadP a -> ReadP sep -> ReadP [a]
  chainr,     -- :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
  chainl,     -- :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
  chainl1,    -- :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
  chainr1,    -- :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
  manyTill,   -- :: ReadP a -> ReadP end -> ReadP [a]
  
  -- * Running a parser
  ReadS,      -- :: *; = String -> [(a,String)]
  readP_to_S, -- :: ReadP a -> ReadS a
  readS_to_P  -- :: ReadS a -> ReadP a
  




  )
 where



import Text.ParserCombinators.ReadP hiding (ReadP)
import qualified Text.ParserCombinators.ReadP as ReadP

type ReadP r a = ReadP.ReadP a

















































































































































































































































































































































































































-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.PreProcess.Unlit
-- Copyright   :  ...
-- 
-- Maintainer  :  Malcolm Wallace <Malcolm.Wallace@cs.york.ac.uk>
-- Stability   :  Stable
-- Portability :  portable
--
-- Remove the \"literal\" markups from a Haskell source file, including
-- \"@>@\", \"@\\begin{code}@\", \"@\\end{code}@\", and \"@#@\"
--
-- Part of the following code is from
-- /Report on the Programming Language Haskell/,
--   version 1.2, appendix C.

module Distribution.PreProcess.Unlit(unlit,plain) where

import Data.Char

-- exports:

unlit :: String -> String -> String
unlit file lhs = (unlines . map unclassify . adjacent file (0::Int) Blank
                 . classify 0) (tolines lhs)

plain :: String -> String -> String	-- no unliteration
plain _ hs = hs
----

data Classified = Program String | Blank | Comment
		| Include Int String | Pre String

classify :: Int -> [String] -> [Classified]
classify _ []                = []
classify _ (('\\':x):xs) | x == "begin{code}" = Blank : allProg xs
   where allProg [] = []	-- Should give an error message, but I have no
				-- good position information.
         allProg (('\\':x'):xs') |  x' == "end{code}" = Blank : classify 0 xs'
	 allProg (x':xs') = Program x':allProg xs'
classify 0 (('>':x):xs)  = let (sp,code) = span isSpace x in
                           Program code : classify (length sp + 1) xs
classify n (('>':x):xs)  = Program (drop (n-1) x) : classify n xs
classify _ (('#':x):xs)  =
     (case words x of
        (line:file:_) | all isDigit line -> Include (read line) file
        _                                -> Pre x
     ) : classify 0 xs
classify _ (x:xs) | all isSpace x = Blank:classify 0 xs
classify _ (_:xs)                 = Comment:classify 0 xs

unclassify :: Classified -> String
unclassify (Program s) = s
unclassify (Pre s)     = '#':s
unclassify (Include i f) = '#':' ':show i ++ ' ':f
unclassify Blank       = ""
unclassify Comment     = ""

adjacent :: String -> Int -> Classified -> [Classified] -> [Classified]
adjacent file 0 _             (x              :xs) = x: adjacent file 1 x xs
					-- force evaluation of line number
adjacent file n   (Program _) (Comment      :_) =
				error (message file n "program" "comment")
adjacent _    _ y@(Program _) (x@(Include i f):xs) = x: adjacent f    i     y xs
adjacent file n y@(Program _) (x@(Pre _)      :xs) = x: adjacent file (n+1) y xs
adjacent file n    Comment    ((Program _)  :_) =
				error (message file n "comment" "program")
adjacent _    _ y@Comment     (x@(Include i f):xs) = x: adjacent f    i     y xs
adjacent file n y@Comment     (x@(Pre _)      :xs) = x: adjacent file (n+1) y xs
adjacent _    _ y@Blank       (x@(Include i f):xs) = x: adjacent f    i     y xs
adjacent file n y@Blank       (x@(Pre _)      :xs) = x: adjacent file (n+1) y xs
adjacent file n _             (x              :xs) = x: adjacent file (n+1) x xs
adjacent _    _ _             []                    = []

message :: (Show a) => String -> a -> String -> String -> String
message "\"\"" n p c = "Line "++show n++": "++p++ " line before "++c++" line.\n"
message []     n p c = "Line "++show n++": "++p++ " line before "++c++" line.\n"
message file   n p c = "In file " ++ file ++ " at line "
                              ++show n++": "++p++ " line before "++c++" line.\n"


-- Re-implementation of 'lines', for better efficiency (but decreased
-- laziness).  Also, importantly, accepts non-standard DOS and Mac line
-- ending characters.
tolines :: String -> [String]
tolines s' = lines' s' id
  where
  lines' []             acc = [acc []]
  lines' ('\^M':'\n':s) acc = acc [] : lines' s id      -- DOS
  lines' ('\^M':s)      acc = acc [] : lines' s id      -- MacOS
  lines' ('\n':s)       acc = acc [] : lines' s id      -- Unix
  lines' (c:s)          acc = lines' s (acc . (c:))



{-
-- A very naive version of unliteration....
module Unlit(unlit) where
-- This version does not handle \begin{code} & \end{code}, and it is
-- careless with indentation.
unlit = map unlitline

unlitline ('>' : s) = s
unlitline _ = ""
-}

{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Simple.Build
-- Copyright   :  Isaac Jones 2003-2005
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--

{- Copyright (c) 2003-2005, Isaac Jones
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Simple.Build (
	build



  ) where

import Distribution.Compiler	( Compiler(..), CompilerFlavor(..) )
import Distribution.PackageDescription 
				( PackageDescription(..), BuildInfo(..),
				  setupMessage, Executable(..), Library(..), 
                                  autogenModuleName )
import Distribution.Package 	( PackageIdentifier(..), showPackageId )
import Distribution.Setup	 (CopyDest(..), BuildFlags(..) )
import Distribution.PreProcess  ( preprocessSources, PPSuffixHandler )
import Distribution.Simple.LocalBuildInfo
				( LocalBuildInfo(..), mkBinDir, mkBinDirRel,
				  mkLibDir, mkLibDirRel, mkDataDir,mkDataDirRel,
				  mkLibexecDir, mkLibexecDirRel )
import Distribution.Simple.Configure
				( localBuildInfoFile )
import Distribution.Simple.Utils( die )

import Distribution.Compat.Directory
				( createDirectoryIfMissing )
import Distribution.Compat.FilePath
				( joinFileName, pathSeparator )

import Data.Maybe		( maybeToList, fromJust )
import Control.Monad 		( unless )
import System.Directory		( getModificationTime, doesFileExist)

import qualified Distribution.Simple.GHC  as GHC
import qualified Distribution.Simple.JHC  as JHC
-- import qualified Distribution.Simple.NHC  as NHC
import qualified Distribution.Simple.Hugs as Hugs









-- -----------------------------------------------------------------------------
-- Build the library

build :: PackageDescription
         -> LocalBuildInfo
         -> BuildFlags
         -> [ PPSuffixHandler ]
         -> IO ()
build pkg_descr lbi (BuildFlags verbose) suffixes = do
  -- check that there's something to build
  let buildInfos =
          map libBuildInfo (maybeToList (library pkg_descr)) ++
          map buildInfo (executables pkg_descr)
  unless (any buildable buildInfos) $ do
    let name = showPackageId (package pkg_descr)
    die ("Package " ++ name ++ " can't be built on this system.")

  createDirectoryIfMissing True (buildDir lbi)

  -- construct and write the Paths_<pkg>.hs file
  createDirectoryIfMissing True (autogenModulesDir lbi)
  buildPathsModule pkg_descr lbi

  preprocessSources pkg_descr lbi verbose suffixes
  setupMessage "Building" pkg_descr
  case compilerFlavor (compiler lbi) of
   GHC  -> GHC.build  pkg_descr lbi verbose
   JHC  -> JHC.build  pkg_descr lbi verbose
   Hugs -> Hugs.build pkg_descr lbi verbose
   _    -> die ("Building is not supported with this compiler.")

-- ------------------------------------------------------------
-- * Building Paths_<pkg>.hs
-- ------------------------------------------------------------

-- The directory in which we put auto-generated modules
autogenModulesDir :: LocalBuildInfo -> String
autogenModulesDir lbi = buildDir lbi `joinFileName` "autogen"

buildPathsModule :: PackageDescription -> LocalBuildInfo -> IO ()
buildPathsModule pkg_descr lbi =
   let pragmas
	| absolute = ""
	| otherwise =
	  "{-# OPTIONS_GHC -fffi #-}\n"++
	  "{-# LANGUAGE ForeignFunctionInterface #-}\n"

       foreign_imports
	| absolute = ""
	| otherwise =
	  "import Foreign\n"++
	  "import Foreign.C\n"++
	  "import Data.Maybe\n"

       header =
	pragmas++
	"module " ++ paths_modulename ++ " (\n"++
	"\tversion,\n"++
	"\tgetBinDir, getLibDir, getDataDir, getLibexecDir,\n"++
	"\tgetDataFileName\n"++
	"\t) where\n"++
	"\n"++
	foreign_imports++
	"import Data.Version"++
	"\n"++
	"\nversion = " ++ show (pkgVersion (package pkg_descr))++
	"\n"

       body
	| absolute =
	  "\nbindir     = " ++ show flat_bindir ++
	  "\nlibdir     = " ++ show flat_libdir ++
	  "\ndatadir    = " ++ show flat_datadir ++
	  "\nlibexecdir = " ++ show flat_libexecdir ++
	  "\n"++
	  "\ngetBinDir, getLibDir, getDataDir, getLibexecDir :: IO FilePath\n"++
	  "getBinDir = return bindir\n"++
	  "getLibDir = return libdir\n"++
	  "getDataDir = return datadir\n"++
	  "getLibexecDir = return libexecdir\n" ++
	  "\n"++
	  "getDataFileName :: FilePath -> IO FilePath\n"++
	  "getDataFileName name = return (datadir ++ "++path_sep++" ++ name)\n"
	| otherwise =
	  "\nprefix        = " ++ show (prefix lbi) ++
	  "\nbindirrel     = " ++ show (fromJust flat_bindirrel) ++
	  "\n"++
	  "\ngetBinDir :: IO FilePath\n"++
	  "getBinDir = getPrefixDirRel bindirrel\n\n"++
	  "getLibDir :: IO FilePath\n"++
	  "getLibDir = "++mkGetDir flat_libdir flat_libdirrel++"\n\n"++
	  "getDataDir :: IO FilePath\n"++
	  "getDataDir =  "++mkGetDir flat_datadir flat_datadirrel++"\n\n"++
	  "getLibexecDir :: IO FilePath\n"++
	  "getLibexecDir = "++mkGetDir flat_libexecdir flat_libexecdirrel++"\n\n"++
	  "getDataFileName :: FilePath -> IO FilePath\n"++
	  "getDataFileName name = do\n"++
	  "  dir <- getDataDir\n"++
	  "  return (dir `joinFileName` name)\n"++
	  "\n"++
	  get_prefix_stuff
   in do btime <- getModificationTime localBuildInfoFile
   	 exists <- doesFileExist paths_filepath
   	 ptime <- if exists
   	            then getModificationTime paths_filepath
   	            else return btime
	 if btime >= ptime
	   then writeFile paths_filepath (header++body)
	   else return ()
 where
	flat_bindir        = mkBinDir pkg_descr lbi NoCopyDest
	flat_bindirrel     = mkBinDirRel pkg_descr lbi NoCopyDest
	flat_libdir        = mkLibDir pkg_descr lbi NoCopyDest
	flat_libdirrel     = mkLibDirRel pkg_descr lbi NoCopyDest
	flat_datadir       = mkDataDir pkg_descr lbi NoCopyDest
	flat_datadirrel    = mkDataDirRel pkg_descr lbi NoCopyDest
	flat_libexecdir    = mkLibexecDir pkg_descr lbi NoCopyDest
	flat_libexecdirrel = mkLibexecDirRel pkg_descr lbi NoCopyDest
	
	mkGetDir dir (Just dirrel) = "getPrefixDirRel " ++ show dirrel
	mkGetDir dir Nothing       = "return " ++ show dir




	absolute = True


  	paths_modulename = autogenModuleName pkg_descr
	paths_filename = paths_modulename ++ ".hs"
	paths_filepath = autogenModulesDir lbi `joinFileName` paths_filename

	path_sep = show [pathSeparator]

get_prefix_stuff :: String
get_prefix_stuff =
  "getPrefixDirRel :: FilePath -> IO FilePath\n"++
  "getPrefixDirRel dirRel = do \n"++
  "  let len = (2048::Int) -- plenty, PATH_MAX is 512 under Win32.\n"++
  "  buf <- mallocArray len\n"++
  "  ret <- getModuleFileName nullPtr buf len\n"++
  "  if ret == 0 \n"++
  "     then do free buf;\n"++
  "             return (prefix `joinFileName` dirRel)\n"++
  "     else do exePath <- peekCString buf\n"++
  "             free buf\n"++
  "             let (bindir,_) = splitFileName exePath\n"++
  "             return (prefixFromBinDir bindir bindirrel `joinFileName` dirRel)\n"++
  "  where\n"++
  "    prefixFromBinDir bindir path\n"++
  "      | path' == \".\" = bindir'\n"++
  "      | otherwise    = prefixFromBinDir bindir' path'\n"++
  "      where\n"++
  "        (bindir',_) = splitFileName bindir\n"++
  "        (path',  _) = splitFileName path\n"++
  "\n"++
  "foreign import stdcall unsafe \"windows.h GetModuleFileNameA\"\n"++
  "  getModuleFileName :: Ptr () -> CString -> Int -> IO Int32\n"++
  "\n"++
  "joinFileName :: String -> String -> FilePath\n"++
  "joinFileName \"\"  fname = fname\n"++
  "joinFileName \".\" fname = fname\n"++
  "joinFileName dir \"\"    = dir\n"++
  "joinFileName dir fname\n"++
  "  | isPathSeparator (last dir) = dir++fname\n"++
  "  | otherwise                  = dir++pathSeparator:fname\n"++
  "\n"++
  "splitFileName p = (reverse (path2++drive), reverse fname)\n"++
  "  where\n"++
  "    (path,drive) = case p of\n"++
  "       (c:':':p) -> (reverse p,[':',c])\n"++
  "       _         -> (reverse p,\"\")\n"++
  "    (fname,path1) = break isPathSeparator path\n"++
  "    path2 = case path1 of\n"++
  "      []                           -> \".\"\n"++
  "      [_]                          -> path1   -- don't remove the trailing slash if \n"++
  "                                              -- there is only one character\n"++
  "      (c:path) | isPathSeparator c -> path\n"++
  "      _                            -> path1\n"++
  "\n"++
  "pathSeparator :: Char\n"++
  "pathSeparator = '\\\\'\n"++
  "\n"++
  "isPathSeparator :: Char -> Bool\n"++
  "isPathSeparator ch =\n"++
  "  ch == '/' || ch == '\\\\'\n"

-- ------------------------------------------------------------
-- * Testing
-- ------------------------------------------------------------





{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Simple.Configure
-- Copyright   :  Isaac Jones 2003-2005
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- Explanation: Perform the \"@.\/setup configure@\" action.
-- Outputs the @.setup-config@ file.

{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Simple.Configure (writePersistBuildConfig,
                                      getPersistBuildConfig,
                                      maybeGetPersistBuildConfig,
 			  	      configure,
                                      localBuildInfoFile,
                                      findProgram,
                                      getInstalledPackages,
				      configDependency,
                                      configCompiler, configCompilerAux,



                                     )
    where









import Distribution.Simple.LocalBuildInfo
import Distribution.Simple.Register (removeInstalledConfig)
import Distribution.Setup(ConfigFlags(..), CopyDest(..))
import Distribution.Compiler(CompilerFlavor(..), Compiler(..),
			     compilerBinaryName, extensionsToFlags)
import Distribution.Package (PackageIdentifier(..), showPackageId, 
			     parsePackageId)
import Distribution.PackageDescription(
 	PackageDescription(..), Library(..),
	BuildInfo(..), Executable(..), setupMessage )
import Distribution.Simple.Utils (die, warn, withTempFile,maybeExit)
import Distribution.Version (Version(..), Dependency(..), VersionRange(ThisVersion),
			     parseVersion, showVersion, withinRange,
			     showVersionRange)

import Data.List (intersperse, nub, maximumBy, isPrefixOf)
import Data.Char (isSpace)
import Data.Maybe(fromMaybe)
import System.Directory
import Distribution.Compat.FilePath (splitFileName, joinFileName,
                                  joinFileExt, exeExtension)
import Distribution.Program(Program(..), ProgramLocation(..),
                            lookupPrograms, updateProgram)
import System.Cmd		( system )
import System.Exit		( ExitCode(..) )
import Control.Monad		( when, unless )
import Distribution.Compat.ReadP
import Distribution.Compat.Directory (findExecutable)
import Data.Char (isDigit)
import Prelude hiding (catch)









tryGetPersistBuildConfig :: IO (Either String LocalBuildInfo)
tryGetPersistBuildConfig = do
  e <- doesFileExist localBuildInfoFile
  let dieMsg = "error reading " ++ localBuildInfoFile ++ "; run \"setup configure\" command?\n"
  if (not e) then return $ Left dieMsg else do 
    str <- readFile localBuildInfoFile
    case reads str of
      [(bi,_)] -> return $ Right bi
      _        -> return $ Left  dieMsg

getPersistBuildConfig :: IO LocalBuildInfo
getPersistBuildConfig = do
  lbi <- tryGetPersistBuildConfig
  either die return lbi

maybeGetPersistBuildConfig :: IO (Maybe LocalBuildInfo)
maybeGetPersistBuildConfig = do
  lbi <- tryGetPersistBuildConfig
  return $ either (const Nothing) Just lbi

writePersistBuildConfig :: LocalBuildInfo -> IO ()
writePersistBuildConfig lbi = do
  writeFile localBuildInfoFile (show lbi)

localBuildInfoFile :: FilePath
localBuildInfoFile = "./.setup-config"

-- -----------------------------------------------------------------------------
-- * Configuration
-- -----------------------------------------------------------------------------

configure :: PackageDescription -> ConfigFlags -> IO LocalBuildInfo
configure pkg_descr cfg
  = do
	setupMessage "Configuring" pkg_descr
	removeInstalledConfig
        let lib = library pkg_descr
	-- detect compiler
	comp@(Compiler f' ver p' pkg) <- configCompilerAux cfg

	-- installation directories
	defPrefix <- default_prefix
	defDataDir <- default_datadir pkg_descr
        let 
		pref = fromMaybe defPrefix (configPrefix cfg)
		my_bindir = fromMaybe default_bindir 
				  (configBinDir cfg)
		my_libdir = fromMaybe (default_libdir comp)
				  (configLibDir cfg)
		my_libsubdir = fromMaybe (default_libsubdir comp)
				  (configLibSubDir cfg)
		my_libexecdir = fromMaybe default_libexecdir
				  (configLibExecDir cfg)
		my_datadir = fromMaybe defDataDir
				  (configDataDir cfg)
		my_datasubdir = fromMaybe default_datasubdir
				  (configDataSubDir cfg)

        -- check extensions
        let extlist = nub $ maybe [] (extensions . libBuildInfo) lib ++
                      concat [ extensions exeBi | Executable _ _ exeBi <- executables pkg_descr ]
        let exts = fst $ extensionsToFlags f' extlist
        unless (null exts) $ warn $ -- Just warn, FIXME: Should this be an error?
            show f' ++ " does not support the following extensions:\n " ++
            concat (intersperse ", " (map show exts))

        foundPrograms <- lookupPrograms (configPrograms cfg)

        happy     <- findProgram "happy"     (configHappy cfg)
        alex      <- findProgram "alex"      (configAlex cfg)
        hsc2hs    <- findProgram "hsc2hs"    (configHsc2hs cfg)
        c2hs      <- findProgram "c2hs"      (configC2hs cfg)
        cpphs     <- findProgram "cpphs"     (configCpphs cfg)
        greencard <- findProgram "greencard" (configGreencard cfg)

        let newConfig = foldr (\(_, p) c -> updateProgram p c) (configPrograms cfg) foundPrograms

        -- FIXME: currently only GHC has hc-pkg
        dep_pkgs <- case f' of
                      GHC | ver >= Version [6,3] [] -> do
                        ipkgs <-  getInstalledPackagesAux comp cfg
	                mapM (configDependency ipkgs) (buildDepends pkg_descr)
                      JHC                           -> do
                        ipkgs <-  getInstalledPackagesJHC comp cfg
	                mapM (configDependency ipkgs) (buildDepends pkg_descr)
                      _                             -> do
                        return $ map setDepByVersion (buildDepends pkg_descr)

	split_objs <- 
	   if not (configSplitObjs cfg)
		then return False
		else case f' of
			    GHC | ver >= Version [6,5] [] -> return True
	    		    _ -> do warn ("this compiler does not support " ++
					    "--enable-split-objs; ignoring")
				    return False

	let lbi = LocalBuildInfo{prefix=pref, compiler=comp,
			      buildDir="dist" `joinFileName` "build",
			      bindir=my_bindir,
			      libdir=my_libdir,
			      libsubdir=my_libsubdir,
			      libexecdir=my_libexecdir,
			      datadir=my_datadir,
			      datasubdir=my_datasubdir,
                              packageDeps=dep_pkgs,
                              withPrograms=newConfig,
                              withHappy=happy, withAlex=alex,
                              withHsc2hs=hsc2hs, withC2hs=c2hs,
                              withCpphs=cpphs,
                              withGreencard=greencard,
                              withVanillaLib=configVanillaLib cfg,
                              withProfLib=configProfLib cfg,
                              withProfExe=configProfExe cfg,
			      withGHCiLib=configGHCiLib cfg,
			      splitObjs=split_objs,
                              userConf=configUser cfg
                             }

        -- FIXME: maybe this should only be printed when verbose?
        message $ "Using install prefix: " ++ pref

        messageDir pkg_descr lbi "Binaries" mkBinDir mkBinDirRel
        messageDir pkg_descr lbi "Libraries" mkLibDir mkLibDirRel
        messageDir pkg_descr lbi "Private binaries" mkLibexecDir mkLibexecDirRel
        messageDir pkg_descr lbi "Data files" mkDataDir mkDataDirRel
        
        message $ "Using compiler: " ++ p'
        message $ "Compiler flavor: " ++ (show f')
        message $ "Compiler version: " ++ showVersion ver
        message $ "Using package tool: " ++ pkg

        mapM (\(s,p) -> reportProgram' s p) foundPrograms

        reportProgram "happy"     happy
        reportProgram "alex"      alex
        reportProgram "hsc2hs"    hsc2hs
        reportProgram "c2hs"      c2hs
        reportProgram "cpphs"     cpphs
        reportProgram "greencard" greencard

	return lbi

messageDir :: PackageDescription -> LocalBuildInfo -> String
	-> (PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath)
	-> (PackageDescription -> LocalBuildInfo -> CopyDest -> Maybe FilePath)
	-> IO ()
messageDir pkg_descr lbi name mkDir mkDirRel = 
  message (name ++ " installed in: " ++ mkDir pkg_descr lbi NoCopyDest ++ rel_note)
  where







    rel_note      = ""


-- |Converts build dependencies to a versioned dependency.  only sets
-- version information for exact versioned dependencies.
setDepByVersion :: Dependency -> PackageIdentifier

-- if they specify the exact version, use that:
setDepByVersion (Dependency s (ThisVersion v)) = PackageIdentifier s v

-- otherwise, just set it to empty
setDepByVersion (Dependency s _) = PackageIdentifier s (Version [] [])


-- |Return the explicit path if given, otherwise look for the program
-- name in the path.
findProgram
    :: String              -- ^ program name
    -> Maybe FilePath      -- ^ optional explicit path
    -> IO (Maybe FilePath)
findProgram name Nothing = findExecutable name
findProgram _ p = return p

reportProgram :: String -> Maybe FilePath -> IO ()
reportProgram name Nothing = message ("No " ++ name ++ " found")
reportProgram name (Just p) = message ("Using " ++ name ++ ": " ++ p)

reportProgram' :: String -> Maybe Program -> IO ()
reportProgram' _ (Just Program{ programName=name
                              , programLocation=EmptyLocation})
                  = message ("No " ++ name ++ " found")
reportProgram' _ (Just Program{ programName=name
                              , programLocation=FoundOnSystem p})
                  = message ("Using " ++ name ++ " found on system at: " ++ p)
reportProgram' _ (Just Program{ programName=name
                              , programLocation=UserSpecified p})
                  = message ("Using " ++ name ++ " given by user at: " ++ p)
reportProgram' name Nothing = message ("No " ++ name ++ " found")


-- | Test for a package dependency and record the version we have installed.
configDependency :: [PackageIdentifier] -> Dependency -> IO PackageIdentifier
configDependency ps (Dependency pkgname vrange) = do
  let
	ok p = pkgName p == pkgname && pkgVersion p `withinRange` vrange
  --
  case filter ok ps of
    [] -> die ("cannot satisfy dependency " ++ 
			pkgname ++ showVersionRange vrange)
    qs -> let 
	    pkg = maximumBy versions qs
	    versions a b = pkgVersion a `compare` pkgVersion b
	  in do message ("Dependency " ++ pkgname ++ showVersionRange vrange ++
			 ": using " ++ showPackageId pkg)
		return pkg

getInstalledPackagesJHC :: Compiler -> ConfigFlags -> IO [PackageIdentifier]
getInstalledPackagesJHC comp cfg = do
   let verbose = configVerbose cfg
   when (verbose > 0) $ message "Reading installed packages..."
   let cmd_line  = "\"" ++ compilerPkgTool comp ++ "\" --list-libraries"
   str <- systemCaptureStdout verbose cmd_line
   case pCheck (readP_to_S (many (skipSpaces >> parsePackageId)) str) of
     [ps] -> return ps
     _    -> die "cannot parse package list"

getInstalledPackagesAux :: Compiler -> ConfigFlags -> IO [PackageIdentifier]
getInstalledPackagesAux comp cfg = getInstalledPackages comp (configUser cfg) (configVerbose cfg)

getInstalledPackages :: Compiler -> Bool -> Int -> IO [PackageIdentifier]
getInstalledPackages comp user verbose = do
   when (verbose > 0) $ message "Reading installed packages..."
   let user_flag = if user then "--user" else "--global"
       cmd_line  = "\"" ++ compilerPkgTool comp ++ "\" " ++ user_flag ++ " list"
   str <- systemCaptureStdout verbose cmd_line
   let keep_line s = ':' `notElem` s && not ("Creating" `isPrefixOf` s)
       str1 = unlines (filter keep_line (lines str))
       str2 = filter (`notElem` ",()") str1
       --
   case pCheck (readP_to_S (many (skipSpaces >> parsePackageId)) str2) of
     [ps] -> return ps
     _    -> die "cannot parse package list"

systemCaptureStdout :: Int -> String -> IO String
systemCaptureStdout verbose cmd = do
   withTempFile "." "" $ \tmp -> do
      let cmd_line  = cmd ++ " >" ++ tmp
      when (verbose > 0) $ putStrLn cmd_line
      res <- system cmd_line
      case res of
        ExitFailure _ -> die ("executing external program failed: "++cmd_line)
        ExitSuccess   -> do str <- readFile tmp
                            let ev [] = ' '; ev xs = last xs
                            ev str `seq` return str

-- -----------------------------------------------------------------------------
-- Determining the compiler details

configCompilerAux :: ConfigFlags -> IO Compiler
configCompilerAux cfg = configCompiler (configHcFlavor cfg)
                                       (configHcPath cfg)
                                       (configHcPkg cfg)
                                       (configVerbose cfg)

configCompiler :: Maybe CompilerFlavor -> Maybe FilePath -> Maybe FilePath -> Int -> IO Compiler
configCompiler hcFlavor hcPath hcPkg verbose
  = do let flavor = case hcFlavor of
                      Just f  -> f
                      Nothing -> error "Unknown compiler"
       comp <- 
	 case hcPath of
	   Just path -> return path
	   Nothing   -> findCompiler verbose flavor

       ver <- configCompilerVersion flavor comp verbose

       pkgtool <-
	 case hcPkg of
	   Just path -> return path
	   Nothing   -> guessPkgToolFromHCPath verbose flavor comp

       return (Compiler{compilerFlavor=flavor,
			compilerVersion=ver,
			compilerPath=comp,
			compilerPkgTool=pkgtool})

findCompiler :: Int -> CompilerFlavor -> IO FilePath
findCompiler verbose flavor = do
  let prog = compilerBinaryName flavor
  when (verbose > 0) $ message $ "searching for " ++ prog ++ " in path."
  res <- findExecutable prog
  case res of
   Nothing   -> die ("Cannot find compiler for " ++ prog)
   Just path -> do when (verbose > 0) $ message ("found " ++ prog ++ " at "++ path)
		   return path
   -- ToDo: check that compiler works?

compilerPkgToolName :: CompilerFlavor -> String
compilerPkgToolName GHC  = "ghc-pkg"
compilerPkgToolName NHC  = "hmake" -- FIX: nhc98-pkg Does not yet exist
compilerPkgToolName Hugs = "hugs"
compilerPkgToolName JHC  = "jhc"
compilerPkgToolName cmp  = error $ "Unsupported compiler: " ++ (show cmp)

configCompilerVersion :: CompilerFlavor -> FilePath -> Int -> IO Version
configCompilerVersion GHC compilerP verbose = do
  str <- systemGetStdout verbose ("\"" ++ compilerP ++ "\" --version")
  case pCheck (readP_to_S parseVersion (dropWhile (not.isDigit) str)) of
    [v] -> return v
    _   -> die ("cannot determine version of " ++ compilerP ++ ":\n  "++ str)
configCompilerVersion JHC compilerP verbose = do
  str <- systemGetStdout verbose ("\"" ++ compilerP ++ "\" --version")
  case words str of
    (_:ver:_) -> case pCheck $ readP_to_S parseVersion ver of
                   [v] -> return v
                   _   -> fail ("parsing version: "++ver++" failed.")
    _        -> fail ("reading version string: "++show str++" failed.")
configCompilerVersion _ _ _ = return Version{ versionBranch=[],versionTags=[] }

systemGetStdout :: Int -> String -> IO String
systemGetStdout verbose cmd = do
  withTempFile "." "" $ \tmp -> do
    let cmd_line = cmd ++ " >" ++ tmp
    when (verbose > 0) $ putStrLn cmd_line
    maybeExit $ system cmd_line
    str <- readFile tmp
    let eval [] = ' '; eval xs = last xs
    eval str `seq` return str

pCheck :: [(a, [Char])] -> [a]
pCheck rs = [ r | (r,s) <- rs, all isSpace s ]

guessPkgToolFromHCPath :: Int -> CompilerFlavor -> FilePath -> IO FilePath
guessPkgToolFromHCPath verbose flavor path
  = do let pkgToolName     = compilerPkgToolName flavor
           (dir,_)         = splitFileName path
           pkgtool         = dir `joinFileName` pkgToolName `joinFileExt` exeExtension
       when (verbose > 0) $ message $ "looking for package tool: " ++ pkgToolName ++ " near compiler in " ++ path
       exists <- doesFileExist pkgtool
       when (not exists) $
	  die ("Cannot find package tool: " ++ pkgtool)
       when (verbose > 0) $ message $ "found package tool in " ++ pkgtool
       return pkgtool

message :: String -> IO ()
message s = putStrLn $ "configure: " ++ s

-- -----------------------------------------------------------------------------
-- Tests





















{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Simple.GHC
-- Copyright   :  Isaac Jones 2003-2006
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--

{- Copyright (c) 2003-2005, Isaac Jones
All rights reserved.

Redistribution and use in source and binary forms, with or without
modiication, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Simple.GHC (
	build, installLib, installExe
 ) where

import Distribution.PackageDescription
				( PackageDescription(..), BuildInfo(..),
				  withLib, setupMessage,
				  Executable(..), withExe, Library(..),
				  libModules, hcOptions )
import Distribution.Simple.LocalBuildInfo
				( LocalBuildInfo(..), autogenModulesDir,
				  mkLibDir, mkIncludeDir )
import Distribution.Simple.Utils( rawSystemExit, rawSystemPath,
				  rawSystemVerbose, maybeExit, xargs,
				  die, dirOf, moduleToFilePath,
				  smartCopySources, findFile, copyFileVerbose,
                                  mkLibName, mkProfLibName, dotToSep )
import Distribution.Package  	( PackageIdentifier(..), showPackageId )
import Distribution.Program	( rawSystemProgram, ranlibProgram,
				  Program(..), ProgramConfiguration(..),
				  ProgramLocation(..),
				  lookupProgram, arProgram )
import Distribution.Compiler 	( Compiler(..), CompilerFlavor(..),
				  extensionsToGHCFlag )
import Distribution.Version	( Version(..) )
import Distribution.Compat.FilePath
				( joinFileName, exeExtension, joinFileExt,
				  splitFilePath, objExtension, joinPaths,
                                  isAbsolutePath, splitFileExt )
import Distribution.Compat.Directory 
				( createDirectoryIfMissing )
import qualified Distribution.Simple.GHCPackageConfig as GHC
				( localPackageConfig,
				  canReadLocalPackageConfig )
import Language.Haskell.Extension (Extension(..))

import Control.Monad		( unless, when )
import Data.List		( isSuffixOf, nub )
import System.Directory		( removeFile, renameFile,
				  getDirectoryContents, doesFileExist )
import System.Exit              (ExitCode(..))






import Control.Exception (try)




-- -----------------------------------------------------------------------------
-- Building

-- |Building for GHC.  If .ghc-packages exists and is readable, add
-- it to the command-line.
build :: PackageDescription -> LocalBuildInfo -> Int -> IO ()
build pkg_descr lbi verbose = do
  let pref = buildDir lbi
  let ghcPath = compilerPath (compiler lbi)
      ifVanillaLib forceVanilla = when (forceVanilla || withVanillaLib lbi)
      ifProfLib = when (withProfLib lbi)
      ifGHCiLib = when (withGHCiLib lbi)

  -- GHC versions prior to 6.4 didn't have the user package database,
  -- so we fake it.  TODO: This can go away in due course.
  pkg_conf <- if versionBranch (compilerVersion (compiler lbi)) >= [6,4]
		then return []
		else do  pkgConf <- GHC.localPackageConfig
			 pkgConfReadable <- GHC.canReadLocalPackageConfig
			 if pkgConfReadable 
				then return ["-package-conf", pkgConf]
				else return []
	       
  -- Build lib
  withLib pkg_descr () $ \lib -> do
      when (verbose > 3) (putStrLn "Building library...")
      let libBi = libBuildInfo lib
          libTargetDir = pref
	  forceVanillaLib = TemplateHaskell `elem` extensions libBi
	  -- TH always needs vanilla libs, even when building for profiling

      createDirectoryIfMissing True libTargetDir
      -- put hi-boot files into place for mutually recurive modules
      smartCopySources verbose (hsSourceDirs libBi)
                       libTargetDir (libModules pkg_descr) ["hi-boot"] False False
      let ghcArgs = 
                 pkg_conf
              ++ ["-package-name", showPackageId (package pkg_descr) ]
	      ++ (if splitObjs lbi then ["-split-objs"] else [])
              ++ constructGHCCmdLine lbi libBi libTargetDir verbose
              ++ (libModules pkg_descr)
          ghcArgsProf = ghcArgs
              ++ ["-prof",
                  "-hisuf", "p_hi",
                  "-osuf", "p_o"
                 ]
              ++ ghcProfOptions libBi
      unless (null (libModules pkg_descr)) $
        do ifVanillaLib forceVanillaLib (rawSystemExit verbose ghcPath ghcArgs)
           ifProfLib (rawSystemExit verbose ghcPath ghcArgsProf)

      -- build any C sources
      unless (null (cSources libBi)) $ do
         when (verbose > 3) (putStrLn "Building C Sources...")
         -- FIX: similar 'versionBranch' logic duplicated below. refactor for code sharing
         sequence_ [do let ghc_vers = compilerVersion (compiler lbi)
			   odir | versionBranch ghc_vers >= [6,4,1] = pref
				| otherwise = pref `joinFileName` dirOf c
				-- ghc 6.4.1 fixed a bug in -odir handling
				-- for C compilations.
                       createDirectoryIfMissing True odir
		       let cArgs = ["-I" ++ dir | dir <- includeDirs libBi]
			       ++ ["-optc" ++ opt | opt <- ccOptions libBi]
			       ++ ["-odir", odir, "-hidir", pref, "-c"]
			       ++ (if verbose > 4 then ["-v"] else [])
                       rawSystemExit verbose ghcPath (cArgs ++ [c])
                                   | c <- cSources libBi]

      -- link:
      when (verbose > 3) (putStrLn "cabal-linking...")
      let cObjs = [ path `joinFileName` file `joinFileExt` objExtension
                  | (path, file, _) <- (map splitFilePath (cSources libBi)) ]
          libName  = mkLibName pref (showPackageId (package pkg_descr))
          profLibName  = mkProfLibName pref (showPackageId (package pkg_descr))
	  ghciLibName = mkGHCiLibName pref (showPackageId (package pkg_descr))

      stubObjs <- sequence [moduleToFilePath [libTargetDir] (x ++"_stub") [objExtension]
                           |  x <- libModules pkg_descr ]  >>= return . concat
      stubProfObjs <- sequence [moduleToFilePath [libTargetDir] (x ++"_stub") ["p_" ++ objExtension]
                           |  x <- libModules pkg_descr ]  >>= return . concat

      hObjs     <- getHaskellObjects pkg_descr libBi lbi
			pref objExtension
      hProfObjs <- 
	if (withProfLib lbi)
		then getHaskellObjects pkg_descr libBi lbi
			pref ("p_" ++ objExtension)
		else return []

      unless (null hObjs && null cObjs && null stubObjs) $ do
        try (removeFile libName) -- first remove library if it exists
        try (removeFile profLibName) -- first remove library if it exists
	try (removeFile ghciLibName) -- first remove library if it exists
        let arArgs = ["q"++ (if verbose > 4 then "v" else "")]
                ++ [libName]
            arObjArgs =
		   hObjs
                ++ map (pref `joinFileName`) cObjs
                ++ stubObjs
            arProfArgs = ["q"++ (if verbose > 4 then "v" else "")]
                ++ [profLibName]
            arProfObjArgs =
		   hProfObjs
                ++ map (pref `joinFileName`) cObjs
                ++ stubProfObjs
	    ldArgs = ["-r"]
                ++ ["-x"] -- FIXME: only some systems's ld support the "-x" flag
	        ++ ["-o", ghciLibName `joinFileExt` "tmp"]
            ldObjArgs =
		   hObjs
                ++ map (pref `joinFileName`) cObjs
		++ stubObjs








            ld = "ld"
            rawSystemLd = rawSystemPath
             --TODO: discover this at configure time on unix
            maxCommandLineSize = 30 * 1024

            runLd ld args = do
              exists <- doesFileExist ghciLibName
              status <- rawSystemLd verbose ld
                          (args ++ if exists then [ghciLibName] else [])
              when (status == ExitSuccess)
                   (renameFile (ghciLibName `joinFileExt` "tmp") ghciLibName)
              return status

        ifVanillaLib False $ maybeExit $ xargs maxCommandLineSize
          (rawSystemPath verbose) "ar" arArgs arObjArgs

        ifProfLib $ maybeExit $ xargs maxCommandLineSize
          (rawSystemPath verbose) "ar" arProfArgs arProfObjArgs

        ifGHCiLib $ maybeExit $ xargs maxCommandLineSize
          runLd ld ldArgs ldObjArgs

  -- build any executables
  withExe pkg_descr $ \ (Executable exeName' modPath exeBi) -> do
                 when (verbose > 3)
                      (putStrLn $ "Building executable: " ++ exeName' ++ "...")

                 -- exeNameReal, the name that GHC really uses (with .exe on Windows)
                 let exeNameReal = exeName' `joinFileExt`
                                   (if null $ snd $ splitFileExt exeName' then exeExtension else "")

		 let targetDir = pref `joinFileName` exeName'
                 let exeDir = joinPaths targetDir (exeName' ++ "-tmp")
                 createDirectoryIfMissing True targetDir
                 createDirectoryIfMissing True exeDir
                 -- put hi-boot files into place for mutually recursive modules
                 -- FIX: what about exeName.hi-boot?
                 smartCopySources verbose (hsSourceDirs exeBi)
                                  exeDir (otherModules exeBi) ["hi-boot"] False False

                 -- build executables
                 unless (null (cSources exeBi)) $ do
                  when (verbose > 3) (putStrLn "Building C Sources.")
                  sequence_ [do let cSrcODir |versionBranch (compilerVersion (compiler lbi))
                                                    >= [6,4,1] = exeDir
                                             | otherwise 
                                                 = exeDir `joinFileName` (dirOf c)
                                createDirectoryIfMissing True cSrcODir
		                let cArgs = ["-I" ++ dir | dir <- includeDirs exeBi]
			                    ++ ["-optc" ++ opt | opt <- ccOptions exeBi]
			                    ++ ["-odir", cSrcODir, "-hidir", pref, "-c"]
			                    ++ (if verbose > 4 then ["-v"] else [])
                                rawSystemExit verbose ghcPath (cArgs ++ [c])
                                    | c <- cSources exeBi]
                 srcMainFile <- findFile (hsSourceDirs exeBi) modPath

                 let cObjs = [ path `joinFileName` file `joinFileExt` objExtension
                                   | (path, file, _) <- (map splitFilePath (cSources exeBi)) ]
                 let binArgs linkExe profExe =
                            pkg_conf
                         ++ ["-I"++pref]
			 ++ (if linkExe
			        then ["-o", targetDir `joinFileName` exeNameReal]
                                else ["-c"])
                         ++ constructGHCCmdLine lbi exeBi exeDir verbose
                         ++ [exeDir `joinFileName` x | x <- cObjs]
                         ++ [srcMainFile]
			 ++ ldOptions exeBi
			 ++ ["-l"++lib | lib <- extraLibs exeBi]
			 ++ ["-L"++libDir | libDir <- extraLibDirs exeBi]
                         ++ if profExe
                               then "-prof":ghcProfOptions exeBi
                               else []

		 -- For building exe's for profiling that use TH we actually
		 -- have to build twice, once without profiling and the again
		 -- with profiling. This is because the code that TH needs to
		 -- run at compile time needs to be the vanilla ABI so it can
		 -- be loaded up and run by the compiler.
		 when (withProfExe lbi && TemplateHaskell `elem` extensions exeBi)
		    (rawSystemExit verbose ghcPath (binArgs False False))

		 rawSystemExit verbose ghcPath (binArgs True (withProfExe lbi))


-- when using -split-objs, we need to search for object files in the
-- Module_split directory for each module.
getHaskellObjects :: PackageDescription -> BuildInfo -> LocalBuildInfo
 	-> FilePath -> String -> IO [FilePath]
getHaskellObjects pkg_descr libBi lbi pref obj_ext
  | splitObjs lbi = do
	let dirs = [ pref `joinFileName` (dotToSep x ++ "_split") 
		   | x <- libModules pkg_descr ]
	objss <- mapM getDirectoryContents dirs
	let objs = [ dir `joinFileName` obj
		   | (objs,dir) <- zip objss dirs, obj <- objs,
		     obj_ext `isSuffixOf` obj ]
	return objs
  | otherwise  = 
	return [ pref `joinFileName` (dotToSep x) `joinFileExt` obj_ext
               | x <- libModules pkg_descr ]


constructGHCCmdLine
	:: LocalBuildInfo
        -> BuildInfo
	-> FilePath
	-> Int				-- verbosity level
        -> [String]
constructGHCCmdLine lbi bi odir verbose = 
        ["--make"]
     ++ (if verbose > 4 then ["-v"] else [])
	    -- Unsupported extensions have already been checked by configure
     ++ (if compilerVersion (compiler lbi) > Version [6,4] []
            then ["-hide-all-packages"]
            else [])
     ++ ["-i"]
     ++ ["-i" ++ autogenModulesDir lbi]
     ++ ["-i" ++ l | l <- nub (hsSourceDirs bi)]
     ++ ["-I" ++ dir | dir <- includeDirs bi]
     ++ ["-optc" ++ opt | opt <- ccOptions bi]
     ++ [ "-#include \"" ++ inc ++ "\"" | inc <- includes bi ++ installIncludes bi ]
     ++ [ "-odir",  odir, "-hidir", odir ]
     ++ (concat [ ["-package", showPackageId pkg] | pkg <- packageDeps lbi ])
     ++ hcOptions GHC (options bi)
     ++ snd (extensionsToGHCFlag (extensions bi))

mkGHCiLibName :: FilePath -- ^file Prefix
              -> String   -- ^library name.
              -> String
mkGHCiLibName pref lib = pref `joinFileName` ("HS" ++ lib ++ ".o")

-- -----------------------------------------------------------------------------
-- Installing

-- |Install executables for GHC.
installExe :: Int      -- ^verbose
              -> FilePath -- ^install location
              -> FilePath -- ^Build location
              -> PackageDescription -> IO ()
installExe verbose pref buildPref pkg_descr
    = do createDirectoryIfMissing True pref
         withExe pkg_descr $ \ (Executable e _ b) -> do
             let exeName = e `joinFileExt` exeExtension
             copyFileVerbose verbose (buildPref `joinFileName` e `joinFileName` exeName) (pref `joinFileName` exeName)

-- |Install for ghc, .hi, .a and, if --with-ghci given, .o
installLib    :: Int      -- ^verbose
              -> ProgramConfiguration
              -> Bool     -- ^has vanilla library
              -> Bool     -- ^has profiling library
	      -> Bool     -- ^has GHCi libs
              -> FilePath -- ^install location
              -> FilePath -- ^Build location
              -> PackageDescription -> IO ()
installLib verbose programConf hasVanilla hasProf hasGHCi pref buildPref
              pd@PackageDescription{library=Just l,
                                    package=p}
    = do ifVanilla $ smartCopySources verbose [buildPref] pref (libModules pd) ["hi"] True False
         ifProf $ smartCopySources verbose [buildPref] pref (libModules pd) ["p_hi"] True False
         let libTargetLoc = mkLibName pref (showPackageId p)
             profLibTargetLoc = mkProfLibName pref (showPackageId p)
	     libGHCiTargetLoc = mkGHCiLibName pref (showPackageId p)
         ifVanilla $ copyFileVerbose verbose (mkLibName buildPref (showPackageId p)) libTargetLoc
         ifProf $ copyFileVerbose verbose (mkProfLibName buildPref (showPackageId p)) profLibTargetLoc
	 ifGHCi $ copyFileVerbose verbose (mkGHCiLibName buildPref (showPackageId p)) libGHCiTargetLoc

	 installIncludeFiles verbose pd pref

         -- use ranlib or ar -s to build an index. this is necessary
         -- on some systems like MacOS X.  If we can't find those,
         -- don't worry too much about it.
         let progName = programName $ ranlibProgram
         mProg <- lookupProgram progName programConf
         case foundProg mProg of
           Just rl  -> do ifVanilla $ rawSystemProgram verbose rl [libTargetLoc]
                          ifProf $ rawSystemProgram verbose rl [profLibTargetLoc]

           Nothing -> do let progName = programName $ arProgram
                         mProg <- lookupProgram progName programConf
                         case mProg of
                          Just ar  -> do ifVanilla $ rawSystemProgram verbose ar ["-s", libTargetLoc]
                                         ifProf $ rawSystemProgram verbose ar ["-s", profLibTargetLoc]
                          Nothing -> setupMessage  "Warning: Unable to generate index for library (missing ranlib and ar)" pd
         return ()
    where ifVanilla action = when hasVanilla (action >> return ())
          ifProf action = when hasProf (action >> return ())
	  ifGHCi action = when hasGHCi (action >> return ())
installLib _ _ _ _ _ _ _ PackageDescription{library=Nothing}
    = die $ "Internal Error. installLibGHC called with no library."

-- | Install the files listed in install-includes
installIncludeFiles :: Int -> PackageDescription -> FilePath -> IO ()
installIncludeFiles verbose pkg_descr@PackageDescription{library=Just l} libdir
 = do
   createDirectoryIfMissing True incdir
   incs <- mapM (findInc relincdirs) (installIncludes lbi)
   sequence_ [ copyFileVerbose verbose path (incdir `joinFileName` f)
	     | (f,path) <- incs ]
  where
   relincdirs = filter (not.isAbsolutePath) (includeDirs lbi)
   lbi = libBuildInfo l
   incdir = mkIncludeDir libdir

   findInc [] f = die ("can't find include file " ++ f)
   findInc (d:ds) f = do
     let path = (d `joinFileName` f)
     b <- doesFileExist path
     if b then return (f,path) else findInc ds f

-- Also checks whether the program was actually found.
foundProg :: Maybe Program -> Maybe Program
foundProg Nothing = Nothing
foundProg (Just Program{programLocation=EmptyLocation}) = Nothing
foundProg x = x
{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.GHCPackageConfig
-- Copyright   :  (c) The University of Glasgow 2004
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  alpha
-- Portability :  portable
--
-- Explanation: Performs registration for GHC.  Specific to
-- ghc-pkg. Creates a GHC package config file.

module Distribution.Simple.GHCPackageConfig (
	GHCPackageConfig(..),
	mkGHCPackageConfig,
	defaultGHCPackageConfig,
	showGHCPackageConfig,

        localPackageConfig, maybeCreateLocalPackageConfig,
        canWriteLocalPackageConfig, canReadLocalPackageConfig
  ) where

import Distribution.PackageDescription (PackageDescription(..), BuildInfo(..), Library(..))
import Distribution.Package (PackageIdentifier(..), showPackageId)
import Distribution.Simple.LocalBuildInfo (LocalBuildInfo(..),mkLibDir)
import Distribution.Setup (CopyDest(..))


import Control.Exception (try)



import Control.Monad(unless)
import Text.PrettyPrint.HughesPJ
import System.Directory (doesFileExist, getPermissions, Permissions (..))
import Distribution.Compat.FilePath (joinFileName)
import Distribution.Compat.Directory (getHomeDirectory)

-- |Where ghc keeps the --user files.
-- |return the file, whether it exists, and whether it's readable

localPackageConfig :: IO FilePath
localPackageConfig = do u <- getHomeDirectory
                        return $ (u `joinFileName` ".ghc-packages")

-- |If the package file doesn't exist, we should try to create it.  If
-- it already exists, do nothing and return true.  This does not take
-- into account whether it is readable or writeable.
maybeCreateLocalPackageConfig :: IO Bool  -- ^success?
maybeCreateLocalPackageConfig
    = do f <- localPackageConfig
         exists <- doesFileExist f
         unless exists $ (try (writeFile f "[]\n") >> return ())
         doesFileExist f


-- |Helper function for canReadPackageConfig and canWritePackageConfig
checkPermission :: (Permissions -> Bool) -> IO Bool
checkPermission perm
    = do f <- localPackageConfig
         exists <- doesFileExist f
         if exists
            then getPermissions f >>= (return . perm)
            else return False

-- |Check for read permission on the localPackageConfig
canReadLocalPackageConfig :: IO Bool
canReadLocalPackageConfig = checkPermission readable

-- |Check for write permission on the localPackageConfig
canWriteLocalPackageConfig :: IO Bool
canWriteLocalPackageConfig = checkPermission writable

-- -----------------------------------------------------------------------------
-- GHC 6.2 PackageConfig type

-- Until GHC supports the InstalledPackageInfo type above, we use its
-- existing PackagConfig type.

mkGHCPackageConfig :: PackageDescription -> LocalBuildInfo -> GHCPackageConfig
mkGHCPackageConfig pkg_descr lbi
  = defaultGHCPackageConfig {
	name	        = pkg_name,
	auto	        = True,
	import_dirs     = [mkLibDir pkg_descr lbi NoCopyDest],
	library_dirs    = (mkLibDir pkg_descr lbi NoCopyDest: 
			   maybe [] (extraLibDirs . libBuildInfo) (library pkg_descr)),
	hs_libraries    = ["HS"++(showPackageId (package pkg_descr))],
	extra_libraries = maybe [] (extraLibs . libBuildInfo)  (library pkg_descr),
	include_dirs    = maybe [] (includeDirs . libBuildInfo) (library pkg_descr),
	c_includes      = maybe [] (includes . libBuildInfo) (library pkg_descr),
	package_deps    = map pkgName (packageDeps lbi)
    }
 where
   pkg_name = pkgName (package pkg_descr)

data GHCPackageConfig
   = GHCPackage {
	name            :: String,
	auto		:: Bool,
	import_dirs     :: [String],
	source_dirs     :: [String],
	library_dirs    :: [String],
	hs_libraries    :: [String],
	extra_libraries :: [String],
	include_dirs    :: [String],
	c_includes      :: [String],
	package_deps    :: [String],
	extra_ghc_opts  :: [String],
	extra_cc_opts   :: [String],
	extra_ld_opts   :: [String],
	framework_dirs  :: [String], -- ignored everywhere but on Darwin/MacOS X
	extra_frameworks:: [String]  -- ignored everywhere but on Darwin/MacOS X
     }

defaultGHCPackageConfig :: GHCPackageConfig
defaultGHCPackageConfig
   = GHCPackage {
	name = error "defaultPackage",
	auto = False,
	import_dirs     = [],
	source_dirs     = [],
	library_dirs    = [],
	hs_libraries    = [],
	extra_libraries = [],
	include_dirs    = [],
	c_includes      = [],
	package_deps    = [],
	extra_ghc_opts  = [],
	extra_cc_opts   = [],
	extra_ld_opts   = [],
	framework_dirs  = [],
	extra_frameworks= []
    }

-- ---------------------------------------------------------------------------
-- Pretty printing package info

showGHCPackageConfig :: GHCPackageConfig -> String
showGHCPackageConfig pkg = render $
   text "Package" $$ nest 3 (braces (
      sep (punctuate comma [
         text "name = " <> text (show (name pkg)),
	 text "auto = " <> text (show (auto pkg)),
         dumpField "import_dirs"     (import_dirs     pkg),
         dumpField "source_dirs"     (source_dirs     pkg),
         dumpField "library_dirs"    (library_dirs    pkg),
         dumpField "hs_libraries"    (hs_libraries    pkg),
         dumpField "extra_libraries" (extra_libraries pkg),
         dumpField "include_dirs"    (include_dirs    pkg),
         dumpField "c_includes"      (c_includes      pkg),
         dumpField "package_deps"    (package_deps    pkg),
         dumpField "extra_ghc_opts"  (extra_ghc_opts  pkg),
         dumpField "extra_cc_opts"   (extra_cc_opts   pkg),
         dumpField "extra_ld_opts"   (extra_ld_opts   pkg),
         dumpField "framework_dirs"  (framework_dirs   pkg),
         dumpField "extra_frameworks"(extra_frameworks pkg)
      ])))

dumpField :: String -> [String] -> Doc
dumpField name' val = hang (text name' <+> equals) 2  (dumpFieldContents val)

dumpFieldContents :: [String] -> Doc
dumpFieldContents val = brackets (sep (punctuate comma (map (text . show) val)))
{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Simple.Hugs
-- Copyright   :  Isaac Jones 2003-2006
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--

{- Copyright (c) 2003-2005, Isaac Jones
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Simple.Hugs (
	build, install,
	hugsPackageDir
 ) where

import Distribution.PackageDescription
				( PackageDescription(..), BuildInfo(..),
				  withLib,
				  Executable(..), withExe, Library(..),
				  libModules, hcOptions, autogenModuleName )
import Distribution.Compiler 	( Compiler(..), CompilerFlavor(..) )
import Distribution.Package  	( PackageIdentifier(..) )
import Distribution.Setup 	( CopyDest(..) )
import Distribution.PreProcess 	( ppCpp )
import Distribution.PreProcess.Unlit
				( unlit )
import Distribution.Simple.LocalBuildInfo
				( LocalBuildInfo(..), 
				  mkLibDir, autogenModulesDir )
import Distribution.Simple.Utils( rawSystemExit, die,
				  dirOf, dotToSep, moduleToFilePath,
				  smartCopySources, findFile )
import Language.Haskell.Extension
				( Extension(..) )
import Distribution.Compat.Directory
				( copyFile,createDirectoryIfMissing,
				  removeDirectoryRecursive )
import Distribution.Compat.FilePath
				( joinFileName, splitFileExt, joinFileExt,
                                  dllExtension, searchPathSeparator,
                                  platformPath )


import Data.Char		( isSpace )
import Data.Maybe		( mapMaybe )
import Control.Monad		( unless, when, filterM )

import Control.Exception	( try )



import Data.List		( nub, sort, isSuffixOf )
import System.Directory		( Permissions(..), getPermissions,
				  setPermissions )

-- -----------------------------------------------------------------------------

-- |Building a package for Hugs.
build :: PackageDescription -> LocalBuildInfo -> Int -> IO ()
build pkg_descr lbi verbose = do
    let pref = buildDir lbi
    withLib pkg_descr () $ \ l -> do
	copyFile (autogenModulesDir lbi `joinFileName` paths_modulename)
		(pref `joinFileName` paths_modulename)
	compileBuildInfo pref [] (libModules pkg_descr) (libBuildInfo l)
    withExe pkg_descr $ compileExecutable (pref `joinFileName` "programs")
  where
	paths_modulename = autogenModuleName pkg_descr ++ ".hs"

	compileExecutable :: FilePath -> Executable -> IO ()
	compileExecutable destDir (exe@Executable {modulePath=mainPath, buildInfo=bi}) = do
            let exeMods = otherModules bi
	    srcMainFile <- findFile (hsSourceDirs bi) mainPath
	    let exeDir = destDir `joinFileName` exeName exe
	    let destMainFile = exeDir `joinFileName` hugsMainFilename exe
	    copyModule (CPP `elem` extensions bi) bi srcMainFile destMainFile
	    let destPathsFile = exeDir `joinFileName` paths_modulename
	    copyFile (autogenModulesDir lbi `joinFileName` paths_modulename)
		     destPathsFile
	    compileBuildInfo exeDir (maybe [] (hsSourceDirs . libBuildInfo) (library pkg_descr)) exeMods bi
	    compileFiles bi exeDir [destMainFile, destPathsFile]
	
	compileBuildInfo :: FilePath
                         -> [FilePath] -- ^library source dirs, if building exes
                         -> [String] -- ^Modules
                         -> BuildInfo -> IO ()
	compileBuildInfo destDir mLibSrcDirs mods bi = do
	    -- Pass 1: copy or cpp files from src directory to build directory
	    let useCpp = CPP `elem` extensions bi
	    let srcDirs = nub $ hsSourceDirs bi ++ mLibSrcDirs
            when (verbose > 3) (putStrLn $ "Source directories: " ++ show srcDirs)
            flip mapM_ mods $ \ m -> do
                fs <- moduleToFilePath srcDirs m suffixes
                if null fs then
                    die ("can't find source for module " ++ m)
                  else do
                    let srcFile = head fs
                    let (_, ext) = splitFileExt srcFile
                    copyModule useCpp bi srcFile
                        (destDir `joinFileName` dotToSep m `joinFileExt` ext)
	    -- Pass 2: compile foreign stubs in build directory
	    stubsFileLists <- sequence [moduleToFilePath [destDir] modu suffixes |
			modu <- mods]
            compileFiles bi destDir (concat stubsFileLists)

	suffixes = ["hs", "lhs"]

	-- Copy or cpp a file from the source directory to the build directory.
	copyModule :: Bool -> BuildInfo -> FilePath -> FilePath -> IO ()
	copyModule cppAll bi srcFile destFile = do
	    createDirectoryIfMissing True (dirOf destFile)
	    (exts, opts, _) <- getOptionsFromSource srcFile
	    let ghcOpts = hcOptions GHC opts
	    if cppAll || CPP `elem` exts || "-cpp" `elem` ghcOpts then do
	    	ppCpp bi lbi srcFile destFile verbose
	    	return ()
	      else
	    	copyFile srcFile destFile

        compileFiles :: BuildInfo -> FilePath -> [FilePath] -> IO ()
        compileFiles bi modDir fileList = do
	    ffiFileList <- filterM testFFI fileList
            unless (null ffiFileList) $ do
                when (verbose > 2) (putStrLn "Compiling FFI stubs")
	        mapM_ (compileFFI bi modDir) ffiFileList

        -- Only compile FFI stubs for a file if it contains some FFI stuff
        testFFI :: FilePath -> IO Bool
        testFFI file = do
            inp <- readHaskellFile file
            return ("foreign" `elem` symbols (stripComments False inp))

        compileFFI :: BuildInfo -> FilePath -> FilePath -> IO ()
        compileFFI bi modDir file = do
            (_, opts, file_incs) <- getOptionsFromSource file
            let ghcOpts = hcOptions GHC opts
            let pkg_incs = ["\"" ++ inc ++ "\"" 
			   | inc <- includes bi ++ installIncludes bi]
            let incs = nub (sort (file_incs ++ includeOpts ghcOpts ++ pkg_incs))
            let pathFlag = "-P" ++ modDir ++ [searchPathSeparator]
            let hugsArgs = "-98" : pathFlag : map ("-i" ++) incs
            cfiles <- getCFiles file
            let cArgs =
                    ["-I" ++ dir | dir <- includeDirs bi] ++
                    ccOptions bi ++
                    cfiles ++
                    ["-L" ++ dir | dir <- extraLibDirs bi] ++
                    ldOptions bi ++
                    ["-l" ++ lib | lib <- extraLibs bi] ++
                    concat [["-framework", f] | f <- frameworks bi]
            rawSystemExit verbose ffihugs (hugsArgs ++ file : cArgs)

	ffihugs = compilerPath (compiler lbi)

	includeOpts :: [String] -> [String]
	includeOpts [] = []
	includeOpts ("-#include" : arg : opts) = arg : includeOpts opts
	includeOpts (_ : opts) = includeOpts opts

	-- get C file names from CFILES pragmas throughout the source file
	getCFiles :: FilePath -> IO [String]
	getCFiles file = do
	    inp <- readHaskellFile file
	    return [platformPath cfile |
		"{-#" : "CFILES" : rest <-
			map words $ lines $ stripComments True inp,
		last rest == "#-}",
		cfile <- init rest]

	-- List of terminal symbols in a source file.
	symbols :: String -> [String]
	symbols cs = case lex cs of
	    (sym, cs'):_ | not (null sym) -> sym : symbols cs'
	    _ -> []

	-- Get the non-literate source of a Haskell module.
	readHaskellFile :: FilePath -> IO String
	readHaskellFile file = do
	    text <- readFile file
	    return $ if ".lhs" `isSuffixOf` file then unlit file text else text

-- ------------------------------------------------------------
-- * options in source files
-- ------------------------------------------------------------

-- |Read the initial part of a source file, before any Haskell code,
-- and return the contents of any LANGUAGE, OPTIONS and INCLUDE pragmas.
getOptionsFromSource
    :: FilePath
    -> IO ([Extension],                 -- LANGUAGE pragma, if any
           [(CompilerFlavor,[String])], -- OPTIONS_FOO pragmas
           [String]                     -- INCLUDE pragmas
          )
getOptionsFromSource file = do
    text <- readFile file
    return $ foldr appendOptions ([],[],[]) $ map getOptions $
	takeWhileJust $ map getPragma $
	filter textLine $ map (dropWhile isSpace) $ lines $
	stripComments True $
	if ".lhs" `isSuffixOf` file then unlit file text else text
  where textLine [] = False
	textLine ('#':_) = False
	textLine _ = True

	getPragma :: String -> Maybe [String]
	getPragma line = case words line of
	    ("{-#" : rest) | last rest == "#-}" -> Just (init rest)
	    _ -> Nothing

	getOptions ("OPTIONS":opts) = ([], [(GHC, opts)], [])
	getOptions ("OPTIONS_GHC":opts) = ([], [(GHC, opts)], [])
	getOptions ("OPTIONS_NHC98":opts) = ([], [(NHC, opts)], [])
	getOptions ("OPTIONS_HUGS":opts) = ([], [(Hugs, opts)], [])
	getOptions ("LANGUAGE":ws) = (mapMaybe readExtension ws, [], [])
	  where	readExtension :: String -> Maybe Extension
		readExtension w = case reads w of
		    [(ext, "")] -> Just ext
		    [(ext, ",")] -> Just ext
		    _ -> Nothing
	getOptions ("INCLUDE":ws) = ([], [], ws)
	getOptions _ = ([], [], [])

	appendOptions (exts, opts, incs) (exts', opts', incs')
          = (exts++exts', opts++opts', incs++incs')

-- takeWhileJust f = map fromJust . takeWhile isJust
takeWhileJust :: [Maybe a] -> [a]
takeWhileJust (Just x:xs) = x : takeWhileJust xs
takeWhileJust _ = []

-- |Strip comments from Haskell source.
stripComments
    :: Bool	-- ^ preserve pragmas?
    -> String	-- ^ input source text
    -> String
stripComments keepPragmas = stripCommentsLevel 0
  where stripCommentsLevel :: Int -> String -> String
	stripCommentsLevel 0 ('"':cs) = '"':copyString cs
	stripCommentsLevel 0 ('-':'-':cs) =	-- FIX: symbols like -->
	    stripCommentsLevel 0 (dropWhile (/= '\n') cs)
	stripCommentsLevel 0 ('{':'-':'#':cs)
	  | keepPragmas = '{' : '-' : '#' : copyPragma cs
	stripCommentsLevel n ('{':'-':cs) = stripCommentsLevel (n+1) cs
	stripCommentsLevel 0 (c:cs) = c : stripCommentsLevel 0 cs
	stripCommentsLevel n ('-':'}':cs) = stripCommentsLevel (n-1) cs
	stripCommentsLevel n (c:cs) = stripCommentsLevel n cs
	stripCommentsLevel _ [] = []

	copyString ('\\':c:cs) = '\\' : c : copyString cs
	copyString ('"':cs) = '"' : stripCommentsLevel 0 cs
	copyString (c:cs) = c : copyString cs
	copyString [] = []

	copyPragma ('#':'-':'}':cs) = '#' : '-' : '}' : stripCommentsLevel 0 cs
	copyPragma (c:cs) = c : copyPragma cs
	copyPragma [] = []

-- -----------------------------------------------------------------------------
-- Install for Hugs
-- For install, copy-prefix = prefix, but for copy they're different.
-- The library goes in <copy-prefix>/lib/hugs/packages/<pkgname>
-- (i.e. <prefix>/lib/hugs/packages/<pkgname> on the target system).
-- Each executable goes in <copy-prefix>/lib/hugs/programs/<exename>
-- (i.e. <prefix>/lib/hugs/programs/<exename> on the target system)
-- with a script <copy-prefix>/bin/<exename> pointing at
-- <prefix>/lib/hugs/programs/<exename>
install
    :: Int      -- ^verbose
    -> FilePath -- ^Library install location
    -> FilePath -- ^Program install location
    -> FilePath -- ^Executable install location
    -> FilePath -- ^Program location on target system
    -> FilePath -- ^Build location
    -> PackageDescription
    -> IO ()
install verbose libDir installProgDir binDir targetProgDir buildPref pkg_descr = do
    withLib pkg_descr () $ \ libInfo -> do
        try $ removeDirectoryRecursive libDir
        smartCopySources verbose [buildPref] libDir (libModules pkg_descr) hugsInstallSuffixes True False
    let buildProgDir = buildPref `joinFileName` "programs"
    when (any (buildable . buildInfo) (executables pkg_descr)) $
        createDirectoryIfMissing True binDir
    withExe pkg_descr $ \ exe -> do
        let buildDir = buildProgDir `joinFileName` exeName exe
        let installDir = installProgDir `joinFileName` exeName exe
        let targetDir = targetProgDir `joinFileName` exeName exe
        try $ removeDirectoryRecursive installDir
        smartCopySources verbose [buildDir] installDir
            ("Main" : autogenModuleName pkg_descr : otherModules (buildInfo exe)) hugsInstallSuffixes True False
        let targetName = "\"" ++ (targetDir `joinFileName` hugsMainFilename exe) ++ "\""
        -- FIX (HUGS): use extensions, and options from file too?
        -- see http://hackage.haskell.org/trac/hackage/ticket/43
        let hugsOptions = hcOptions Hugs (options (buildInfo exe))






        let exeFile = binDir `joinFileName` exeName exe
        let script = unlines [
                "#! /bin/sh",
                unwords ("runhugs" : hugsOptions ++ [targetName, "\"$@\""])]

        writeFile exeFile script
        perms <- getPermissions exeFile
        setPermissions exeFile perms { executable = True, readable = True }

hugsInstallSuffixes :: [String]
hugsInstallSuffixes = ["hs", "lhs", dllExtension]

-- |Hugs library directory for a package
hugsPackageDir :: PackageDescription -> LocalBuildInfo -> FilePath
hugsPackageDir pkg_descr lbi =
    mkLibDir pkg_descr lbi NoCopyDest
	`joinFileName` "packages" `joinFileName` pkgName (package pkg_descr)

-- |Filename used by Hugs for the main module of an executable.
-- This is a simple filename, so that Hugs will look for any auxiliary
-- modules it uses relative to the directory it's in.
hugsMainFilename :: Executable -> FilePath
hugsMainFilename exe = "Main" `joinFileExt` ext
  where (_, ext) = splitFileExt (modulePath exe)
{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Simple.Install
-- Copyright   :  Isaac Jones 2003-2004
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- Explanation: Perform the \"@.\/setup install@\" action.  Move files into
-- place based on the prefix argument.

{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Simple.Install (
	install,



  ) where









import Distribution.PackageDescription (
	PackageDescription(..),
	setupMessage, hasLibs, withLib, withExe )
import Distribution.Simple.LocalBuildInfo (
        LocalBuildInfo(..), mkLibDir, mkBinDir, mkDataDir, mkProgDir, mkHaddockDir)
import Distribution.Simple.Utils(copyFileVerbose, die, haddockPref,  copyDirectoryRecursiveVerbose)
import Distribution.Compiler (CompilerFlavor(..), Compiler(..))
import Distribution.Setup (CopyFlags(..), CopyDest(..))

import Distribution.Compat.Directory(createDirectoryIfMissing)
import Distribution.Compat.FilePath(splitFileName,joinFileName)

import qualified Distribution.Simple.GHC  as GHC
import qualified Distribution.Simple.JHC  as JHC
-- import qualified Distribution.Simple.NHC  as NHC
import qualified Distribution.Simple.Hugs as Hugs

import Control.Monad(when)
import Distribution.Compat.Directory(createDirectoryIfMissing, doesDirectoryExist)
import Distribution.Compat.FilePath(splitFileName,joinFileName)





-- |FIX: nhc isn't implemented yet.
install :: PackageDescription
        -> LocalBuildInfo
        -> CopyFlags
        -> IO ()
install pkg_descr lbi (CopyFlags copydest verbose) = do
  let dataFilesExist = not (null (dataFiles pkg_descr))
  docExists <- doesDirectoryExist haddockPref
  when (verbose >= 4)
       (putStrLn ("directory " ++ haddockPref ++
                  " does exist: " ++ show docExists))
  when (dataFilesExist || docExists) $ do
    let dataPref = mkDataDir pkg_descr lbi copydest
    createDirectoryIfMissing True dataPref
    flip mapM_ (dataFiles pkg_descr) $ \ file -> do
      let (dir, _) = splitFileName file
      createDirectoryIfMissing True (dataPref `joinFileName` dir)
      copyFileVerbose verbose file (dataPref `joinFileName` file)
    when docExists $ do
      let targetDir = mkHaddockDir pkg_descr lbi copydest
      createDirectoryIfMissing True targetDir
      copyDirectoryRecursiveVerbose verbose haddockPref targetDir
      -- setPermissionsRecursive [Read] targetDir
  let buildPref = buildDir lbi
  let libPref = mkLibDir pkg_descr lbi copydest
  let binPref = mkBinDir pkg_descr lbi copydest
  setupMessage ("Installing: " ++ libPref ++ " & " ++ binPref) pkg_descr
  case compilerFlavor (compiler lbi) of
     GHC  -> do when (hasLibs pkg_descr)
                     (GHC.installLib verbose (withPrograms lbi)
                       (withVanillaLib lbi) (withProfLib lbi)
                       (withGHCiLib lbi) libPref buildPref pkg_descr)
                GHC.installExe verbose binPref buildPref pkg_descr
     JHC  -> do withLib pkg_descr () $ JHC.installLib verbose libPref buildPref pkg_descr
                withExe pkg_descr $ JHC.installExe verbose binPref buildPref pkg_descr
     Hugs -> do
       let progPref = mkProgDir pkg_descr lbi copydest
       let targetProgPref = mkProgDir pkg_descr lbi NoCopyDest
       Hugs.install verbose libPref progPref binPref targetProgPref buildPref pkg_descr
     _    -> die ("only installing with GHC, JHC or Hugs is implemented")
  return ()
  -- register step should be performed by caller.

-- ------------------------------------------------------------
-- * Testing
-- ------------------------------------------------------------




-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Simple.JHC
-- Copyright   :  Isaac Jones 2003-2006
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--

{- Copyright (c) 2003-2005, Isaac Jones
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Simple.JHC (
	build, installLib, installExe
 ) where

import Distribution.PackageDescription
				( PackageDescription(..), BuildInfo(..),
				  withLib,
				  Executable(..), withExe, Library(..),
				  libModules, hcOptions )
import Distribution.Simple.LocalBuildInfo
				( LocalBuildInfo(..), 
				  autogenModulesDir )
import Distribution.Compiler 	( Compiler(..), CompilerFlavor(..),
				  extensionsToJHCFlag )
import Distribution.Package  	( showPackageId )
import Distribution.Simple.Utils( rawSystemExit, copyFileVerbose )
import Distribution.Compat.FilePath
				( joinFileName, exeExtension )
import Distribution.Compat.Directory
				( createDirectoryIfMissing )

import Control.Monad		( when )
import Data.List		( nub, intersperse )


-- -----------------------------------------------------------------------------
-- Building

-- | Building a package for JHC.
-- Currently C source files are not supported.
build :: PackageDescription -> LocalBuildInfo -> Int -> IO ()
build pkg_descr lbi verbose = do
  let jhcPath = compilerPath (compiler lbi)
  withLib pkg_descr () $ \lib -> do
      when (verbose > 3) (putStrLn "Building library...")
      let libBi = libBuildInfo lib
      let args  = constructJHCCmdLine lbi libBi (buildDir lbi) verbose
      rawSystemExit verbose jhcPath (["-c"] ++ args ++ libModules pkg_descr)
      let pkgid = showPackageId (package pkg_descr)
          pfile = buildDir lbi `joinFileName` "jhc-pkg.conf"
          hlfile= buildDir lbi `joinFileName` (pkgid ++ ".hl")
      writeFile pfile $ jhcPkgConf pkg_descr
      rawSystemExit verbose jhcPath ["--build-hl="++pfile, "-o", hlfile]
  withExe pkg_descr $ \exe -> do
      when (verbose > 3) (putStrLn ("Building executable "++exeName exe))
      let exeBi = buildInfo exe
      let out   = buildDir lbi `joinFileName` exeName exe
      let args  = constructJHCCmdLine lbi exeBi (buildDir lbi) verbose
      rawSystemExit verbose jhcPath (["-o",out] ++ args ++ [modulePath exe])

constructJHCCmdLine :: LocalBuildInfo -> BuildInfo -> FilePath -> Int -> [String]
constructJHCCmdLine lbi bi odir verbose =
        (if verbose > 4 then ["-v"] else [])
     ++ snd (extensionsToJHCFlag (extensions bi))
     ++ hcOptions JHC (options bi)
     ++ ["--noauto","-i-"]
     ++ ["-i", autogenModulesDir lbi]
     ++ concat [["-i", l] | l <- nub (hsSourceDirs bi)]
     ++ ["-optc" ++ opt | opt <- ccOptions bi]
     ++ (concat [ ["-p", showPackageId pkg] | pkg <- packageDeps lbi ])

jhcPkgConf :: PackageDescription -> String
jhcPkgConf pd =
  let sline name sel = name ++ ": "++sel pd
      Just lib = library pd
      comma f l = concat $ intersperse "," $ map f l
  in unlines [sline "name" (showPackageId . package)
             ,"exposed-modules: " ++ (comma id (exposedModules lib))
             ,"hidden-modules: " ++ (comma id (otherModules $ libBuildInfo lib))
             ]
                         
installLib :: Int -> FilePath -> FilePath -> PackageDescription -> Library -> IO ()
installLib verb dest build pkg_descr _ = do
    let p = showPackageId (package pkg_descr)++".hl"
    createDirectoryIfMissing True dest
    copyFileVerbose verb (joinFileName build p) (joinFileName dest p)

installExe :: Int -> FilePath -> FilePath -> PackageDescription -> Executable -> IO ()
installExe verb dest build pkg_descr exe = do
    let out   = exeName exe `joinFileName` exeExtension
    createDirectoryIfMissing True dest
    copyFileVerbose verb (joinFileName build out) (joinFileName dest out)
{-# OPTIONS_GHC -cpp -fffi #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Simple.LocalBuildInfo
-- Copyright   :  Isaac Jones 2003-2004
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- Definition of the LocalBuildInfo data type.

{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Simple.LocalBuildInfo ( 
	LocalBuildInfo(..),
	default_prefix,
	default_bindir,
	default_libdir,
	default_libsubdir,
	default_libexecdir,
	default_datadir,
	default_datasubdir,
	mkLibDir, mkLibDirRel, mkBinDir, mkBinDirRel, mkLibexecDir, mkLibexecDirRel, mkDataDir, mkDataDirRel, mkHaddockDir, mkProgDir,
	absolutePath, prefixRelPath,
	substDir,
	distPref, srcPref, autogenModulesDir, mkIncludeDir
  ) where


import Distribution.Program (ProgramConfiguration)
import Distribution.PackageDescription (PackageDescription(..))
import Distribution.Package (PackageIdentifier(..), showPackageId)
import Distribution.Compiler (Compiler(..), CompilerFlavor(..), showCompilerId)
import Distribution.Setup (CopyDest(..))
import Distribution.Compat.FilePath







-- |Data cached after configuration step.
data LocalBuildInfo = LocalBuildInfo {
  	prefix	      :: FilePath,
		-- ^ The installation directory (eg. @/usr/local@, or
		-- @C:/Program Files/foo-1.2@ on Windows.
	bindir        :: FilePath,
		-- ^ The bin directory
	libdir        :: FilePath,
		-- ^ The lib directory
	libsubdir     :: FilePath,
		-- ^ Subdirectory of libdir into which libraries are installed
	libexecdir    :: FilePath,
		-- ^ The lib directory
	datadir       :: FilePath,
		-- ^ The data directory
	datasubdir    :: FilePath,
		-- ^ Subdirectory of datadir into which data files are installed
	compiler      :: Compiler,
		-- ^ The compiler we're building with
	buildDir      :: FilePath,
		-- ^ Where to put the result of building.
	packageDeps   :: [PackageIdentifier],
		-- ^ Which packages we depend on, /exactly/.
		-- The 'Distribution.PackageDescription.PackageDescription'
		-- specifies a set of build dependencies
		-- that must be satisfied in terms of version ranges.  This
		-- field fixes those dependencies to the specific versions
		-- available on this machine for this compiler.
        withPrograms  :: ProgramConfiguration, -- location and args for all programs
        userConf      :: Bool,           -- ^Was this package configured with --user?
        withHappy     :: Maybe FilePath, -- ^Might be the location of the Happy executable.
        withAlex      :: Maybe FilePath, -- ^Might be the location of the Alex executable.
        withHsc2hs    :: Maybe FilePath, -- ^Might be the location of the Hsc2hs executable.
        withC2hs      :: Maybe FilePath, -- ^Might be the location of the C2hs executable.
        withCpphs     :: Maybe FilePath, -- ^Might be the location of the Cpphs executable.
        withGreencard :: Maybe FilePath, -- ^Might be the location of the GreenCard executable.
        withVanillaLib:: Bool,  -- ^Whether to build normal libs.
        withProfLib   :: Bool,  -- ^Whether to build profiling versions of libs.
        withProfExe   :: Bool,  -- ^Whether to build executables for profiling.
        withGHCiLib   :: Bool,  -- ^Whether to build libs suitable for use with GHCi.
	splitObjs     :: Bool	-- ^Use -split-objs with GHC, if available
  } deriving (Read, Show)

-- ------------------------------------------------------------
-- * Some Paths
-- ------------------------------------------------------------

distPref :: FilePath
distPref = "dist"

srcPref :: FilePath
srcPref = distPref `joinFileName` "src"

-- |The directory in which we put auto-generated modules
autogenModulesDir :: LocalBuildInfo -> String
autogenModulesDir lbi = buildDir lbi `joinFileName` "autogen"

-- |The place where install-includes are installed, relative to libdir
mkIncludeDir :: FilePath -> FilePath
mkIncludeDir = (`joinFileName` "include")

-- -----------------------------------------------------------------------------
-- Default directories

{-
The defaults are as follows:

Windows:
	prefix	   = C:\Program Files
	bindir     = $prefix\$pkgid
	libdir     = $prefix\Haskell
	libsubdir  = $pkgid\$compiler
	datadir    = $prefix			(for an executable)
	           = $prefix\Common Files	(for a library)
	datasubdir = $pkgid
	libexecdir = $prefix\$pkgid

Unix:
	prefix	   = /usr/local
	bindir	   = $prefix/bin
	libdir	   = $prefix/lib/$pkgid/$compiler
	libsubdir  = $pkgid/$compiler
	datadir	   = $prefix/share/$pkgid
	datasubdir = $pkgid
	libexecdir = $prefix/libexec
-}

default_prefix :: IO String







default_prefix = return "/usr/local"


































default_bindir :: FilePath
default_bindir = "$prefix" `joinFileName`



	"bin"


default_libdir :: Compiler -> FilePath
default_libdir hc = "$prefix" `joinFileName`



                 "lib"


default_libsubdir :: Compiler -> FilePath
default_libsubdir hc =
  case compilerFlavor hc of
	Hugs -> "hugs" `joinFileName` "packages" `joinFileName` "$pkg"
        JHC  -> "$compiler"
	_    -> "$pkgid" `joinFileName` "$compiler"

default_libexecdir :: FilePath
default_libexecdir = "$prefix" `joinFileName`



	"libexec"


default_datadir :: PackageDescription -> IO FilePath
default_datadir pkg_descr




	= return  ("$prefix" `joinFileName` "share")


default_datasubdir :: FilePath
default_datasubdir = "$pkgid"

mkBinDir :: PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath
mkBinDir pkg_descr lbi copydest = 
  absolutePath  pkg_descr lbi copydest (bindir lbi)

mkBinDirRel :: PackageDescription -> LocalBuildInfo -> CopyDest -> Maybe FilePath
mkBinDirRel pkg_descr lbi copydest = 
  prefixRelPath pkg_descr lbi copydest (bindir lbi)

mkLibDir :: PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath
mkLibDir pkg_descr lbi copydest = 
  absolutePath  pkg_descr lbi copydest (libdir lbi `joinFileName` libsubdir lbi)

mkLibDirRel :: PackageDescription -> LocalBuildInfo -> CopyDest -> Maybe FilePath
mkLibDirRel pkg_descr lbi copydest = 
  prefixRelPath pkg_descr lbi copydest (libdir lbi `joinFileName` libsubdir lbi)

mkLibexecDir :: PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath
mkLibexecDir pkg_descr lbi copydest = 
  absolutePath  pkg_descr lbi copydest (libexecdir lbi)

mkLibexecDirRel :: PackageDescription -> LocalBuildInfo -> CopyDest -> Maybe FilePath
mkLibexecDirRel pkg_descr lbi copydest = 
  prefixRelPath pkg_descr lbi copydest (libexecdir lbi)

mkDataDir :: PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath
mkDataDir pkg_descr lbi copydest = 
  absolutePath  pkg_descr lbi copydest (datadir lbi `joinFileName` datasubdir lbi)

mkDataDirRel :: PackageDescription -> LocalBuildInfo -> CopyDest -> Maybe FilePath
mkDataDirRel pkg_descr lbi copydest = 
  prefixRelPath pkg_descr lbi copydest (datadir lbi `joinFileName` datasubdir lbi)

mkHaddockDir :: PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath
mkHaddockDir pkg_descr lbi copydest =
  foldl1 joinPaths [mkDataDir pkg_descr lbi copydest, "doc", "html"]



-- | Directory for program modules (Hugs only).
mkProgDir :: PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath
mkProgDir pkg_descr lbi copydest = 
  absolutePath pkg_descr lbi copydest (libdir lbi) `joinFileName`
  "hugs" `joinFileName` "programs"

prefixRelPath :: PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath
  -> Maybe FilePath
prefixRelPath pkg_descr lbi0 copydest ('$':'p':'r':'e':'f':'i':'x':s) = Just $
  case s of
    (c:s) | isPathSeparator c -> substDir pkg_descr lbi s
    s                         -> substDir pkg_descr lbi s
  where
    lbi = case copydest of 
            CopyPrefix d -> lbi0{prefix=d}
            _otherwise   -> lbi0
prefixRelPath pkg_descr lbi copydest s = Nothing

absolutePath :: PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath
	-> FilePath
absolutePath pkg_descr lbi copydest s =
  case copydest of
    NoCopyDest   -> substDir pkg_descr lbi s
    CopyPrefix d -> substDir pkg_descr lbi{prefix=d} s
    CopyTo     p -> p `joinFileName` (dropAbsolutePrefix (substDir pkg_descr lbi s))

substDir :: PackageDescription -> LocalBuildInfo -> String -> String
substDir pkg_descr lbi s = loop s
 where
  loop "" = ""
  loop ('$':'p':'r':'e':'f':'i':'x':s) 
	= prefix lbi ++ loop s
  loop ('$':'c':'o':'m':'p':'i':'l':'e':'r':s) 
	= showCompilerId (compiler lbi) ++ loop s
  loop ('$':'p':'k':'g':'i':'d':s) 
	= showPackageId (package pkg_descr) ++ loop s
  loop ('$':'p':'k':'g':s) 
	= pkgName (package pkg_descr) ++ loop s
  loop ('$':'v':'e':'r':'s':'i':'o':'n':s) 
	= show (pkgVersion (package pkg_descr)) ++ loop s
  loop ('$':'$':s) = '$' : loop s
  loop (c:s) = c : loop s
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Simple.NHC
-- Copyright   :  Isaac Jones 2003-2006
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--

{- Copyright (c) 2003-2005, Isaac Jones
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Simple.NHC (
	build{-, install -}
 ) where

import Distribution.PackageDescription
				( PackageDescription(..), BuildInfo(..),
				  Library(..), libModules, hcOptions)
import Distribution.Simple.LocalBuildInfo
				( LocalBuildInfo(..) )
import Distribution.Simple.Utils( rawSystemExit )
import Distribution.Compiler 	( Compiler(..), CompilerFlavor(..),
				  extensionsToNHCFlag )

-- |FIX: For now, the target must contain a main module.  Not used
-- ATM. Re-add later.
build :: PackageDescription -> LocalBuildInfo -> Int -> IO ()
build pkg_descr lbi verbose = do
  -- Unsupported extensions have already been checked by configure
  let flags = snd $ extensionsToNHCFlag (maybe [] (extensions . libBuildInfo) (library pkg_descr))
  rawSystemExit verbose (compilerPath (compiler lbi))
                (["-nhc98"]
                ++ flags
                ++ maybe [] (hcOptions NHC . options . libBuildInfo) (library pkg_descr)
                ++ (libModules pkg_descr))

{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Simple.Register
-- Copyright   :  Isaac Jones 2003-2004
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- Explanation: Perform the \"@.\/setup register@\" action.
-- Uses a drop-file for HC-PKG.  See also "Distribution.InstalledPackageInfo".

{- Copyright (c) 2003-2004, Isaac Jones
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Simple.Register (
	register,
	unregister,
        writeInstalledConfig,
	removeInstalledConfig,
        installedPkgConfigFile,
        regScriptLocation,
        unregScriptLocation,



  ) where









import Distribution.Simple.LocalBuildInfo (LocalBuildInfo(..), mkLibDir, mkHaddockDir,
					   mkIncludeDir)
import Distribution.Compiler (CompilerFlavor(..), Compiler(..))
import Distribution.Setup (RegisterFlags(..), CopyDest(..), userOverride)
import Distribution.PackageDescription (setupMessage, PackageDescription(..),
					BuildInfo(..), Library(..), haddockName)
import Distribution.Package (PackageIdentifier(..), showPackageId)
import Distribution.Version (Version(..))
import Distribution.InstalledPackageInfo
	(InstalledPackageInfo, showInstalledPackageInfo, 
	 emptyInstalledPackageInfo)
import qualified Distribution.InstalledPackageInfo as IPI
import Distribution.Simple.Utils (rawSystemExit, copyFileVerbose, die)
import Distribution.Simple.Hugs (hugsPackageDir)
import Distribution.Simple.GHCPackageConfig (mkGHCPackageConfig, showGHCPackageConfig)
import qualified Distribution.Simple.GHCPackageConfig
    as GHC (localPackageConfig, canWriteLocalPackageConfig, maybeCreateLocalPackageConfig)
import Distribution.Compat.Directory
       (createDirectoryIfMissing,removeDirectoryRecursive,
        setPermissions, getPermissions, Permissions(executable)
       )

import Distribution.Compat.FilePath (joinFileName, joinPaths, splitFileName,
				     isAbsolutePath)

import System.Directory(doesFileExist, removeFile, getCurrentDirectory)
import System.IO.Error (try)

import Control.Monad (when, unless)
import Data.Maybe (isNothing, fromJust)
import Data.List (partition)





regScriptLocation :: FilePath



regScriptLocation = "register.sh"


unregScriptLocation :: FilePath



unregScriptLocation = "unregister.sh"


-- -----------------------------------------------------------------------------
-- Registration

register :: PackageDescription -> LocalBuildInfo
         -> RegisterFlags -- ^Install in the user's database?; verbose
         -> IO ()
register pkg_descr lbi regFlags
  | isNothing (library pkg_descr) = do
    setupMessage "No package to register" pkg_descr
    return ()
  | otherwise = do
    let ghc_63_plus = compilerVersion (compiler lbi) >= Version [6,3] []
        genScript = regGenScript regFlags
        verbose = regVerbose regFlags
        user = regUser regFlags `userOverride` userConf lbi
	inplace = regInPlace regFlags
    setupMessage (if genScript
                     then ("Writing registration script: " ++ regScriptLocation)
                     else "Registering")
                 pkg_descr
    case compilerFlavor (compiler lbi) of
      GHC -> do 
	config_flags <-
	   if user
		then if ghc_63_plus
			then return ["--user"]
			else do 
			  GHC.maybeCreateLocalPackageConfig
		          localConf <- GHC.localPackageConfig
			  pkgConfWriteable <- GHC.canWriteLocalPackageConfig
		          when (not pkgConfWriteable && not genScript)
                                   $ userPkgConfErr localConf
			  return ["--config-file=" ++ localConf]
		else return []

	let instConf = if inplace then inplacePkgConfigFile 
				  else installedPkgConfigFile

        instConfExists <- doesFileExist instConf
        when (not instConfExists && not genScript) $ do
          when (verbose > 0) $
            putStrLn ("create " ++ instConf)
          writeInstalledConfig pkg_descr lbi inplace

	let register_flags
		| ghc_63_plus = "update":

		                 if genScript
                                    then []
                                    else 

                                      [instConf]
		| otherwise   = "--update-package":

				 if genScript
                                    then []
                                    else

                                      ["--input-file="++instConf]
        
	let allFlags = register_flags
                       ++ config_flags
                       ++ if ghc_63_plus && genScript then ["-"] else []
        let pkgTool = case regWithHcPkg regFlags of
			 Just f  -> f
			 Nothing -> compilerPkgTool (compiler lbi)

        if genScript
         then do cfg <- showInstalledConfig pkg_descr lbi inplace
	         rawSystemPipe regScriptLocation verbose cfg
                           pkgTool allFlags
         else rawSystemExit verbose pkgTool allFlags

      Hugs -> do
	when inplace $ die "--inplace is not supported with Hugs"
	createDirectoryIfMissing True (hugsPackageDir pkg_descr lbi)
	copyFileVerbose verbose installedPkgConfigFile
	    (hugsPackageDir pkg_descr lbi `joinFileName` "package.conf")
      JHC -> when (verbose > 0) $ putStrLn "registering for JHC (nothing to do)"
      _   -> die ("only registering with GHC is implemented")

userPkgConfErr :: String -> IO a
userPkgConfErr local_conf = 
  die ("--user flag passed, but cannot write to local package config: "
    	++ local_conf )

-- -----------------------------------------------------------------------------
-- The installed package config

-- |Register doesn't drop the register info file, it must be done in a
-- separate step.
writeInstalledConfig :: PackageDescription -> LocalBuildInfo -> Bool -> IO ()
writeInstalledConfig pkg_descr lbi inplace = do
  pkg_config <- showInstalledConfig pkg_descr lbi inplace
  writeFile (if inplace then inplacePkgConfigFile else installedPkgConfigFile)
	    (pkg_config ++ "\n")

-- |Create a string suitable for writing out to the package config file
showInstalledConfig :: PackageDescription -> LocalBuildInfo -> Bool
  -> IO String
showInstalledConfig pkg_descr lbi inplace
  | (case compilerFlavor hc of GHC -> True; _ -> False) &&
    compilerVersion hc < Version [6,3] [] 
    = if inplace then
	  error "--inplace not supported for GHC < 6.3"
      else
	  return (showGHCPackageConfig (mkGHCPackageConfig pkg_descr lbi))
  | otherwise 
    = do cfg <- mkInstalledPackageInfo pkg_descr lbi inplace
         return (showInstalledPackageInfo cfg)
  where
  	hc = compiler lbi

removeInstalledConfig :: IO ()
removeInstalledConfig = do
  try (removeFile installedPkgConfigFile) >> return ()
  try (removeFile inplacePkgConfigFile) >> return ()

installedPkgConfigFile :: String
installedPkgConfigFile = ".installed-pkg-config"

inplacePkgConfigFile :: String
inplacePkgConfigFile = ".inplace-pkg-config"

-- -----------------------------------------------------------------------------
-- Making the InstalledPackageInfo

mkInstalledPackageInfo
	:: PackageDescription
	-> LocalBuildInfo
	-> Bool
	-> IO InstalledPackageInfo
mkInstalledPackageInfo pkg_descr lbi inplace = do 
  pwd <- getCurrentDirectory
  let 
	lib = fromJust (library pkg_descr) -- checked for Nothing earlier
        bi = libBuildInfo lib
	build_dir = pwd `joinFileName` buildDir lbi
	libdir = mkLibDir pkg_descr lbi NoCopyDest
	incdir = mkIncludeDir libdir
	(absinc,relinc) = partition isAbsolutePath (includeDirs bi)
        haddockDir = mkHaddockDir pkg_descr lbi NoCopyDest
        haddockFile = joinPaths haddockDir (haddockName pkg_descr)
    in
    return emptyInstalledPackageInfo{
        IPI.package           = package pkg_descr,
        IPI.license           = license pkg_descr,
        IPI.copyright         = copyright pkg_descr,
        IPI.maintainer        = maintainer pkg_descr,
	IPI.author	      = author pkg_descr,
        IPI.stability         = stability pkg_descr,
	IPI.homepage	      = homepage pkg_descr,
	IPI.pkgUrl	      = pkgUrl pkg_descr,
	IPI.description	      = description pkg_descr,
	IPI.category	      = category pkg_descr,
        IPI.exposed           = True,
	IPI.exposedModules    = exposedModules lib,
	IPI.hiddenModules     = otherModules bi,
        IPI.importDirs        = [if inplace then build_dir else libdir],
        IPI.libraryDirs       = (if inplace then build_dir else libdir)
				: extraLibDirs bi,
        IPI.hsLibraries       = ["HS" ++ showPackageId (package pkg_descr)],
        IPI.extraLibraries    = extraLibs bi,
        IPI.includeDirs       = absinc 
				 ++ if inplace 
					then map (pwd `joinFileName`) relinc
					else [incdir],
        IPI.includes	      = includes bi ++ map (snd.splitFileName)
						   (installIncludes bi),
        IPI.depends           = packageDeps lbi,
        IPI.hugsOptions       = concat [opts | (Hugs,opts) <- options bi],
        IPI.ccOptions         = ccOptions bi,
        IPI.ldOptions         = ldOptions bi,
        IPI.frameworkDirs     = [],
        IPI.frameworks        = frameworks bi,
	IPI.haddockInterfaces = [haddockFile],
	IPI.haddockHTMLs      = [haddockDir]
        }

-- -----------------------------------------------------------------------------
-- Unregistration

unregister :: PackageDescription -> LocalBuildInfo -> RegisterFlags -> IO ()
unregister pkg_descr lbi regFlags = do
  setupMessage "Unregistering" pkg_descr
  let ghc_63_plus = compilerVersion (compiler lbi) >= Version [6,3] []
      genScript = regGenScript regFlags
      verbose = regVerbose regFlags
      user = regUser regFlags `userOverride` userConf lbi
  case compilerFlavor (compiler lbi) of
    GHC -> do
	config_flags <-
	   if user
		then if ghc_63_plus
			then return ["--user"]
			else do
                          instConfExists <- doesFileExist installedPkgConfigFile
		          localConf <- GHC.localPackageConfig
		          unless instConfExists (userPkgConfErr localConf)
			  return ["--config-file=" ++ localConf]
		else return []
        let removeCmd = if ghc_63_plus
                        then ["unregister",showPackageId (package pkg_descr)]
                        else ["--remove-package="++(pkgName $ package pkg_descr)]
        let pkgTool = case regWithHcPkg regFlags of
			 Just f  -> f
			 Nothing -> compilerPkgTool (compiler lbi)
	rawSystemEmit unregScriptLocation genScript verbose pkgTool
	    (removeCmd++config_flags)
    Hugs -> do
        try $ removeDirectoryRecursive (hugsPackageDir pkg_descr lbi)
	return ()
    _ ->
	die ("only unregistering with GHC and Hugs is implemented")

-- |Like rawSystemExit, but optionally emits to a script instead of
-- exiting. FIX: chmod +x?
rawSystemEmit :: FilePath -- ^Script name
              -> Bool     -- ^if true, emit, if false, run
              -> Int      -- ^Verbosity
              -> FilePath -- ^Program to run
              -> [String] -- ^Args
              -> IO ()
rawSystemEmit _ False verbosity path args
    = rawSystemExit verbosity path args
rawSystemEmit scriptName True verbosity path args = do



  writeFile scriptName ("#!/bin/sh\n\n"
                        ++ (path ++ concatMap (' ':) args)
                        ++ "\n")
  p <- getPermissions scriptName
  setPermissions scriptName p{executable=True}


-- |Like rawSystemEmit, except it has string for pipeFrom. FIX: chmod +x
rawSystemPipe :: FilePath -- ^Script location
              -> Int      -- ^Verbosity
              -> String   -- ^where to pipe from
              -> FilePath -- ^Program to run
              -> [String] -- ^Args
              -> IO ()
rawSystemPipe scriptName verbose pipeFrom path args = do



  writeFile scriptName ("#!/bin/sh\n\n"
                        ++ "echo '" ++ pipeFrom
                        ++ "' | " 
                        ++ (path ++ concatMap (' ':) args)
                        ++ "\n")
  p <- getPermissions scriptName
  setPermissions scriptName p{executable=True}


-- ------------------------------------------------------------
-- * Testing
-- ------------------------------------------------------------





{-# OPTIONS_GHC -cpp #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Simple.SrcDist
-- Copyright   :  Simon Marlow 2004
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--

{- Copyright (c) 2003-2004, Simon Marlow
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

-- NOTE: FIX: we don't have a great way of testing this module, since
-- we can't easily look inside a tarball once its created.

module Distribution.Simple.SrcDist (
	sdist



  )  where

import Distribution.PackageDescription
	(PackageDescription(..), BuildInfo(..), Executable(..), Library(..),
         setupMessage, libModules)
import Distribution.Package (showPackageId, PackageIdentifier(pkgVersion))
import Distribution.Version (Version(versionBranch))
import Distribution.Simple.Utils
        (smartCopySources, die, findPackageDesc, findFile, copyFileVerbose)
import Distribution.Setup (SDistFlags(..))
import Distribution.PreProcess (PPSuffixHandler, ppSuffixes, removePreprocessed)

import Control.Monad(when)
import Data.Char (isSpace, toLower)
import Data.List (isPrefixOf)
import System.Cmd (system)
import System.Time (getClockTime, toCalendarTime, CalendarTime(..))
import Distribution.Compat.Directory (doesFileExist, doesDirectoryExist,
         getCurrentDirectory, createDirectoryIfMissing, removeDirectoryRecursive)
import Distribution.Compat.FilePath (joinFileName, splitFileName)





-- |Create a source distribution. FIX: Calls tar directly (won't work
-- on windows).
sdist :: PackageDescription
      -> SDistFlags -- verbose & snapshot
      -> FilePath -- ^build prefix (temp dir)
      -> FilePath -- ^TargetPrefix
      -> [PPSuffixHandler]  -- ^ extra preprocessors (includes suffixes)
      -> IO ()
sdist pkg_descr_orig (SDistFlags snapshot verbose) tmpDir targetPref pps = do
  time <- getClockTime
  ct <- toCalendarTime time
  let date = ctYear ct*10000 + (fromEnum (ctMonth ct) + 1)*100 + ctDay ct
  let pkg_descr
        | snapshot  = updatePackage (updatePkgVersion
                        (updateVersionBranch (++ [date]))) pkg_descr_orig
        | otherwise = pkg_descr_orig
  setupMessage "Building source dist for" pkg_descr
  ex <- doesDirectoryExist tmpDir
  when ex (die $ "Source distribution already in place. please move: " ++ tmpDir)
  let targetDir = tmpDir `joinFileName` (nameVersion pkg_descr)
  createDirectoryIfMissing True targetDir
  -- maybe move the library files into place
  maybe (return ()) (\l -> prepareDir verbose targetDir pps (libModules pkg_descr) (libBuildInfo l))
                    (library pkg_descr)
  -- move the executables into place
  flip mapM_ (executables pkg_descr) $ \ (Executable _ mainPath exeBi) -> do
    prepareDir verbose targetDir pps [] exeBi
    srcMainFile <- findFile (hsSourceDirs exeBi) mainPath
    copyFileTo verbose targetDir srcMainFile
  flip mapM_ (dataFiles pkg_descr) $ \ file -> do
    let (dir, _) = splitFileName file
    createDirectoryIfMissing True (targetDir `joinFileName` dir)
    copyFileVerbose verbose file (targetDir `joinFileName` file)
  when (not (null (licenseFile pkg_descr))) $
    copyFileTo verbose targetDir (licenseFile pkg_descr)
  flip mapM_ (extraSrcFiles pkg_descr) $ \ fpath -> do
    copyFileTo verbose targetDir fpath
  -- setup isn't listed in the description file.
  hsExists <- doesFileExist "Setup.hs"
  lhsExists <- doesFileExist "Setup.lhs"
  if hsExists then copyFileTo verbose targetDir "Setup.hs"
    else if lhsExists then copyFileTo verbose targetDir "Setup.lhs"
    else writeFile (targetDir `joinFileName` "Setup.hs") $ unlines [
                "import Distribution.Simple",
                "main = defaultMainWithHooks defaultUserHooks"]
  -- the description file itself
  descFile <- getCurrentDirectory >>= findPackageDesc
  let targetDescFile = targetDir `joinFileName` descFile
  -- We could just writePackageDescription targetDescFile pkg_descr,
  -- but that would lose comments and formatting.
  if snapshot then do
      contents <- readFile descFile
      writeFile targetDescFile $
          unlines $ map (appendVersion date) $ lines $ contents
    else copyFileVerbose verbose descFile targetDescFile

  let tarBallFilePath = targetPref `joinFileName` tarBallName pkg_descr
  system $ "(cd " ++ tmpDir
           ++ ";tar cf - " ++ (nameVersion pkg_descr) ++ ") | gzip -9 >"
           ++ tarBallFilePath
  removeDirectoryRecursive tmpDir
  putStrLn $ "Source tarball created: " ++ tarBallFilePath

  where
    updatePackage f pd = pd { package = f (package pd) }
    updatePkgVersion f pkg = pkg { pkgVersion = f (pkgVersion pkg) }
    updateVersionBranch f v = v { versionBranch = f (versionBranch v) }

    appendVersion :: Int -> String -> String
    appendVersion n line
      | "version:" `isPrefixOf` map toLower line =
            trimTrailingSpace line ++ "." ++ show n
      | otherwise = line

    trimTrailingSpace :: String -> String
    trimTrailingSpace = reverse . dropWhile isSpace . reverse

-- |Move the sources into place based on buildInfo
prepareDir :: Int       -- ^verbose
           -> FilePath  -- ^TargetPrefix
           -> [PPSuffixHandler]  -- ^ extra preprocessors (includes suffixes)
           -> [String]  -- ^Exposed modules
           -> BuildInfo
           -> IO ()
prepareDir verbose inPref pps mods BuildInfo{hsSourceDirs=srcDirs, otherModules=mods', cSources=cfiles}
    = do let suff = ppSuffixes pps  ++ ["hs", "lhs"]
         smartCopySources verbose srcDirs inPref (mods++mods') suff True True
         removePreprocessed (map (joinFileName inPref) srcDirs) mods suff
         mapM_ (copyFileTo verbose inPref) cfiles

copyFileTo :: Int -> FilePath -> FilePath -> IO ()
copyFileTo verbose dir file = do
  let targetFile = dir `joinFileName` file
  createDirectoryIfMissing True (fst (splitFileName targetFile))
  copyFileVerbose verbose file targetFile

------------------------------------------------------------

-- |The file name of the tarball
tarBallName :: PackageDescription -> FilePath
tarBallName p = (nameVersion p) ++ ".tar.gz"

nameVersion :: PackageDescription -> String
nameVersion = showPackageId . package

-- ------------------------------------------------------------
-- * Testing
-- ------------------------------------------------------------





{-# OPTIONS_GHC -cpp -fffi #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Distribution.Simple.Utils
-- Copyright   :  Isaac Jones, Simon Marlow 2003-2004
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- Explanation: Misc. Utilities, especially file-related utilities.
-- Stuff used by multiple modules that doesn't fit elsewhere.

{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Distribution.Simple.Utils (
	die,
	dieWithLocation,
	warn,
	rawSystemPath,
        rawSystemVerbose,
	rawSystemExit,
        maybeExit,
        xargs,
        matchesDescFile,
	rawSystemPathExit,
        smartCopySources,
        copyFileVerbose,
        copyDirectoryRecursiveVerbose,
        moduleToFilePath,
        mkLibName,
        mkProfLibName,
        currentDir,
	dirOf,
        dotToSep,
	withTempFile,
	findFile,
        defaultPackageDesc,
        findPackageDesc,
	defaultHookedPackageDesc,
	findHookedPackageDesc,
        distPref,
        haddockPref,
        srcPref,



  ) where









import Distribution.Compat.RawSystem (rawSystem)
import Distribution.Compat.Exception (finally)

import Control.Monad(when, filterM, unless)
import Data.List (nub, unfoldr)
import System.Environment (getProgName)
import System.IO (hPutStrLn, stderr, hFlush, stdout)
import System.IO.Error
import System.Exit

import System.Posix.Internals (c_getpid)


import Distribution.Compat.FilePath
	(splitFileName, splitFileExt, joinFileName, joinFileExt, joinPaths,
	pathSeparator,splitFilePath)
import System.Directory (getDirectoryContents, getCurrentDirectory
			, doesDirectoryExist, doesFileExist, removeFile, getPermissions
			, Permissions(executable))

import Distribution.Compat.Directory
           (copyFile, findExecutable, createDirectoryIfMissing,
            getDirectoryContentsWithoutSpecial)





-- ------------------------------------------------------------------------------- Utils for setup

dieWithLocation :: FilePath -> (Maybe Int) -> String -> IO a
dieWithLocation fname Nothing msg = die (fname ++ ": " ++ msg)
dieWithLocation fname (Just n) msg = die (fname ++ ":" ++ show n ++ ": " ++ msg)

die :: String -> IO a
die msg = do
  hFlush stdout
  pname <- getProgName
  hPutStrLn stderr (pname ++ ": " ++ msg)
  exitWith (ExitFailure 1)

warn :: String -> IO ()
warn msg = do
  hFlush stdout
  pname <- getProgName
  hPutStrLn stderr (pname ++ ": Warning: " ++ msg)

-- -----------------------------------------------------------------------------
-- rawSystem variants
rawSystemPath :: Int -> String -> [String] -> IO ExitCode
rawSystemPath verbose prog args = do
  r <- findExecutable prog
  case r of
    Nothing   -> die ("Cannot find: " ++ prog)
    Just path -> rawSystemVerbose verbose path args

rawSystemVerbose :: Int -> FilePath -> [String] -> IO ExitCode
rawSystemVerbose verbose prog args = do
      when (verbose > 0) $
        putStrLn (prog ++ concatMap (' ':) args)
      e <- doesFileExist prog
      if e
         then do perms <- getPermissions prog
                 if (executable perms)
                    then rawSystem prog args
                    else die ("Error: file is not executable: " ++ show prog)
         else die ("Error: file does not exist: " ++ show prog)

maybeExit :: IO ExitCode -> IO ()
maybeExit cmd = do
  res <- cmd
  if res /= ExitSuccess
	then exitWith res  
	else return ()

-- Exit with the same exitcode if the subcommand fails
rawSystemExit :: Int -> FilePath -> [String] -> IO ()
rawSystemExit verbose path args = do
  when (verbose > 0) $
    putStrLn (path ++ concatMap (' ':) args)
  maybeExit $ rawSystem path args

-- Exit with the same exitcode if the subcommand fails
rawSystemPathExit :: Int -> String -> [String] -> IO ()
rawSystemPathExit verbose prog args = do
  maybeExit $ rawSystemPath verbose prog args

-- | Like the unix xargs program. Useful for when we've got very long command
-- lines that might overflow an OS limit on command line length and so you
-- need to invoke a command multiple times to get all the args in.
--
-- Use it with either of the rawSystem variants above. For example:
-- 
-- > xargs (32*1024) (rawSystemPath verbose) prog fixedArgs bigArgs
--
xargs :: Int -> (FilePath -> [String] -> IO ExitCode)
      -> FilePath -> [String] -> [String] -> IO ExitCode
xargs maxSize rawSystem prog fixedArgs bigArgs =
  let fixedArgSize = sum (map length fixedArgs) + length fixedArgs
      chunkSize = maxSize - fixedArgSize
      loop [] = return ExitSuccess
      loop (args:remainingArgs) = do
        status <- rawSystem prog (fixedArgs ++ args)
        case status of
          ExitSuccess -> loop remainingArgs
          _           -> return status
   in loop (chunks chunkSize bigArgs)

  where chunks len = unfoldr $ \s ->
          if null s then Nothing
                    else Just (chunk [] len s)

        chunk acc len []     = (reverse acc,[])
        chunk acc len (s:ss)
          | len' < len = chunk (s:acc) (len-len'-1) ss
          | otherwise  = (reverse acc, s:ss)
          where len' = length s

-- ------------------------------------------------------------
-- * File Utilities
-- ------------------------------------------------------------

-- |Get the file path for this particular module.  In the IO monad
-- because it looks for the actual file.  Might eventually interface
-- with preprocessor libraries in order to correctly locate more
-- filenames.
-- Returns empty list if no such files exist.

moduleToFilePath :: [FilePath] -- ^search locations
                 -> String   -- ^Module Name
                 -> [String] -- ^possible suffixes
                 -> IO [FilePath]

moduleToFilePath pref s possibleSuffixes
    = filterM doesFileExist $
          concatMap (searchModuleToPossiblePaths s possibleSuffixes) pref
    where searchModuleToPossiblePaths :: String -> [String] -> FilePath -> [FilePath]
          searchModuleToPossiblePaths s' suffs searchP
              = moduleToPossiblePaths searchP s' suffs

-- |Like 'moduleToFilePath', but return the location and the rest of
-- the path as separate results.
moduleToFilePath2
    :: [FilePath] -- ^search locations
    -> String   -- ^Module Name
    -> [String] -- ^possible suffixes
    -> IO [(FilePath, FilePath)] -- ^locations and relative names
moduleToFilePath2 locs mname possibleSuffixes
    = filterM exists $
        [(loc, fname `joinFileExt` ext) | loc <- locs, ext <- possibleSuffixes]
  where
    fname = dotToSep mname
    exists (loc, relname) = doesFileExist (loc `joinFileName` relname)

-- |Get the possible file paths based on this module name.
moduleToPossiblePaths :: FilePath -- ^search prefix
                      -> String -- ^module name
                      -> [String] -- ^possible suffixes
                      -> [FilePath]
moduleToPossiblePaths searchPref s possibleSuffixes =
  let fname = searchPref `joinFileName` (dotToSep s)
  in [fname `joinFileExt` ext | ext <- possibleSuffixes]

findFile :: [FilePath]    -- ^search locations
         -> FilePath      -- ^File Name
         -> IO FilePath
findFile prefPathsIn locPath = do
  let prefPaths = nub prefPathsIn -- ignore dups
  paths <- filterM doesFileExist [prefPath `joinFileName` locPath | prefPath <- prefPaths]
  case nub paths of -- also ignore dups, though above nub should fix this.
    [path] -> return path
    []     -> die (locPath ++ " doesn't exist")
    paths  -> die (locPath ++ " is found in multiple places:" ++ unlines (map ((++) "    ") paths))

dotToSep :: String -> String
dotToSep = map dts
  where
    dts '.' = pathSeparator
    dts c   = c

-- |Copy the source files into the right directory.  Looks in the
-- build prefix for files that look like the input modules, based on
-- the input search suffixes.  It copies the files into the target
-- directory.

smartCopySources :: Int      -- ^verbose
            -> [FilePath] -- ^build prefix (location of objects)
            -> FilePath -- ^Target directory
            -> [String] -- ^Modules
            -> [String] -- ^search suffixes
            -> Bool     -- ^Exit if no such modules
            -> Bool     -- ^Preserve directory structure
            -> IO ()
smartCopySources verbose srcDirs targetDir sources searchSuffixes exitIfNone preserveDirs
    = do createDirectoryIfMissing True targetDir
         allLocations <- mapM moduleToFPErr sources
         let copies = [(srcDir `joinFileName` name,
                        if preserveDirs 
                          then targetDir `joinFileName` srcDir `joinFileName` name
                          else targetDir `joinFileName` name) |
                       (srcDir, name) <- concat allLocations]
	 -- Create parent directories for everything:
	 mapM_ (createDirectoryIfMissing True) $ nub $
             [fst (splitFileName targetFile) | (_, targetFile) <- copies]
	 -- Put sources into place:
	 sequence_ [copyFileVerbose verbose srcFile destFile |
                    (srcFile, destFile) <- copies]
    where moduleToFPErr m
              = do p <- moduleToFilePath2 srcDirs m searchSuffixes
                   when (null p && exitIfNone)
                            (die ("Error: Could not find module: " ++ m
                                       ++ " with any suffix: " ++ (show searchSuffixes)))
                   return p

copyFileVerbose :: Int -> FilePath -> FilePath -> IO ()
copyFileVerbose verbose src dest = do
  when (verbose > 0) $
    putStrLn ("copy " ++ src ++ " to " ++ dest)
  copyFile src dest

-- adaptation of removeDirectoryRecursive
copyDirectoryRecursiveVerbose :: Int -> FilePath -> FilePath -> IO ()
copyDirectoryRecursiveVerbose verbose srcDir destDir = do
  when (verbose > 0) $
    putStrLn ("copy directory '" ++ srcDir ++ "' to '" ++ destDir ++ "'.")
  let aux src dest =
         let cp :: FilePath -> IO ()
             cp f = let srcFile  = joinPaths src  f
                        destFile = joinPaths dest f
                    in  do success <- try (copyFileVerbose verbose srcFile destFile)
                           case success of
                              Left e  -> do isDir <- doesDirectoryExist srcFile
                                            -- If f is not a directory, re-throw the error
                                            unless isDir $ ioError e
                                            aux srcFile destFile
                              Right _ -> return ()
         in  do createDirectoryIfMissing False dest
                getDirectoryContentsWithoutSpecial src >>= mapM_ cp
   in aux srcDir destDir




-- | The path name that represents the current directory.
-- In Unix, it's @\".\"@, but this is system-specific.
-- (E.g. AmigaOS uses the empty string @\"\"@ for the current directory.)
currentDir :: FilePath
currentDir = "."

dirOf :: FilePath -> FilePath
dirOf f = (\ (x, _, _) -> x) $ (splitFilePath f)

mkLibName :: FilePath -- ^file Prefix
          -> String   -- ^library name.
          -> String
mkLibName pref lib = pref `joinFileName` ("libHS" ++ lib ++ ".a")

mkProfLibName :: FilePath -- ^file Prefix
              -> String   -- ^library name.
              -> String
mkProfLibName pref lib = mkLibName pref (lib++"_p")

-- ------------------------------------------------------------
-- * Some Paths
-- ------------------------------------------------------------
distPref :: FilePath
distPref = "dist"

srcPref :: FilePath
srcPref = distPref `joinFileName` "src"

haddockPref :: FilePath
haddockPref = foldl1 joinPaths [distPref, "doc", "html"]

-- ------------------------------------------------------------
-- * temporary file names
-- ------------------------------------------------------------

-- use a temporary filename that doesn't already exist.
-- NB. *not* secure (we don't atomically lock the tmp file we get)
withTempFile :: FilePath -> String -> (FilePath -> IO a) -> IO a
withTempFile tmp_dir extn action
  = do x <- getProcessID
       findTempName x
  where 
    findTempName x
      = do let filename = ("tmp" ++ show x) `joinFileExt` extn
	       path = tmp_dir `joinFileName` filename
  	   b  <- doesFileExist path
	   if b then findTempName (x+1)
		else action path `finally` try (removeFile path)





getProcessID :: IO Int
getProcessID = System.Posix.Internals.c_getpid >>= return . fromIntegral





-- ------------------------------------------------------------
-- * Finding the description file
-- ------------------------------------------------------------

oldDescFile :: String
oldDescFile = "Setup.description"

cabalExt :: String
cabalExt = "cabal"

buildInfoExt  :: String
buildInfoExt = "buildinfo"

matchesDescFile :: FilePath -> Bool
matchesDescFile p = (snd $ splitFileExt p) == cabalExt
                    || p == oldDescFile

noDesc :: IO a
noDesc = die $ "No description file found, please create a cabal-formatted description file with the name <pkgname>." ++ cabalExt

multiDesc :: [String] -> IO a
multiDesc l = die $ "Multiple description files found.  Please use only one of : "
                      ++ show (filter (/= oldDescFile) l)

-- |A list of possibly correct description files.  Should be pre-filtered.
descriptionCheck :: [FilePath] -> IO FilePath
descriptionCheck [] = noDesc
descriptionCheck [x]
    | x == oldDescFile
        = do warn $ "The filename \"Setup.description\" is deprecated, please move to <pkgname>." ++ cabalExt
             return x
    | matchesDescFile x = return x
    | otherwise = noDesc
descriptionCheck [x,y]
    | x == oldDescFile
        = do warn $ "The filename \"Setup.description\" is deprecated.  Please move out of the way. Using \""
                  ++ y ++ "\""
             return y
    | y == oldDescFile
        = do warn $ "The filename \"Setup.description\" is deprecated.  Please move out of the way. Using \""
                  ++ x ++ "\""
             return x

    | otherwise = multiDesc [x,y]
descriptionCheck l = multiDesc l

-- |Package description file (/pkgname/@.cabal@)
defaultPackageDesc :: IO FilePath
defaultPackageDesc = getCurrentDirectory >>= findPackageDesc

-- |Find a package description file in the given directory.  Looks for
-- @.cabal@ files.
findPackageDesc :: FilePath    -- ^Where to look
                -> IO FilePath -- <pkgname>.cabal
findPackageDesc p = do ls <- getDirectoryContents p
                       let descs = filter matchesDescFile ls
                       descriptionCheck descs

-- |Optional auxiliary package information file (/pkgname/@.buildinfo@)
defaultHookedPackageDesc :: IO (Maybe FilePath)
defaultHookedPackageDesc = getCurrentDirectory >>= findHookedPackageDesc

-- |Find auxiliary package information in the given directory.
-- Looks for @.buildinfo@ files.
findHookedPackageDesc
    :: FilePath			-- ^Directory to search
    -> IO (Maybe FilePath)	-- ^/dir/@\/@/pkgname/@.buildinfo@, if present
findHookedPackageDesc dir = do
    ns <- getDirectoryContents dir
    case [dir `joinFileName`  n |
		n <- ns, snd (splitFileExt n) == buildInfoExt] of
	[] -> return Nothing
	[f] -> return (Just f)
	_ -> die ("Multiple files with extension " ++ buildInfoExt)

-- ------------------------------------------------------------
-- * Testing
-- ------------------------------------------------------------



















































-----------------------------------------------------------------------------
-- |
-- Module      :  Language.Haskell.Extension
-- Copyright   :  Isaac Jones 2003-2004
-- 
-- Maintainer  :  Isaac Jones <ijones@syntaxpolice.org>
-- Stability   :  alpha
-- Portability :  portable
--
-- Haskell language extensions

{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}

module Language.Haskell.Extension (
	Extension(..),
  ) where

-- ------------------------------------------------------------
-- * Extension
-- ------------------------------------------------------------

-- NB:  if you add a constructor to 'Extension', be sure also to
--      add it to Distribution.Compiler.extensionsTo_X_Flag
--	(where X is each compiler)

-- |This represents language extensions beyond Haskell 98 that are
-- supported by some implementations, usually in some special mode.

data Extension
  = OverlappingInstances
  | UndecidableInstances
  | IncoherentInstances
  | RecursiveDo
  | ParallelListComp
  | MultiParamTypeClasses
  | NoMonomorphismRestriction
  | FunctionalDependencies
  | Rank2Types
  | RankNTypes
  | PolymorphicComponents
  | ExistentialQuantification
  | ScopedTypeVariables
  | ImplicitParams
  | FlexibleContexts
  | FlexibleInstances
  | EmptyDataDecls
  | CPP

  | BangPatterns
  | TypeSynonymInstances
  | TemplateHaskell
  | ForeignFunctionInterface
  | InlinePhase
  | ContextStack
  | Arrows
  | Generics
  | NoImplicitPrelude
  | NamedFieldPuns
  | PatternGuards
  | GeneralizedNewtypeDeriving

  | ExtensibleRecords
  | RestrictedTypeSynonyms
  | HereDocuments
  deriving (Show, Read, Eq)
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Foreign
-- Copyright   :  (c) The FFI task force 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  ffi@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- A collection of data types, classes, and functions for interfacing
-- with another programming language.
--
-----------------------------------------------------------------------------

module Foreign
        ( module Data.Bits
        , module Data.Int
        , module Data.Word
	, module Foreign.Ptr
        , module Foreign.ForeignPtr
        , module Foreign.StablePtr
        , module Foreign.Storable
        , module Foreign.Marshal

        -- | For compatibility with the FFI addendum only.  The recommended
        -- place to get this from is "System.IO.Unsafe".
        , unsafePerformIO
        ) where

import Data.Bits
import Data.Int
import Data.Word
import Foreign.Ptr
import Foreign.ForeignPtr
import Foreign.StablePtr
import Foreign.Storable
import Foreign.Marshal

import System.IO.Unsafe (unsafePerformIO)
This library (libraries/base) is derived from code from several
sources: 

  * Code from the GHC project which is largely (c) The University of
    Glasgow, and distributable under a BSD-style license (see below),

  * Code from the Haskell 98 Report which is (c) Simon Peyton Jones
    and freely redistributable (but see the full license for
    restrictions).

  * Code from the Haskell Foreign Function Interface specification,
    which is (c) Manuel M. T. Chakravarty and freely redistributable
    (but see the full license for restrictions).

The full text of these licenses is reproduced below.  All of the
licenses are BSD-style or compatible.

-----------------------------------------------------------------------------

The Glasgow Haskell Compiler License

Copyright 2004, The University Court of the University of Glasgow. 
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
 
- Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.
 
- Neither name of the University nor the names of its contributors may be
used to endorse or promote products derived from this software without
specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY COURT OF THE UNIVERSITY OF
GLASGOW AND THE CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
UNIVERSITY COURT OF THE UNIVERSITY OF GLASGOW OR THE CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

-----------------------------------------------------------------------------

Code derived from the document "Report on the Programming Language
Haskell 98", is distributed under the following license:

  Copyright (c) 2002 Simon Peyton Jones

  The authors intend this Report to belong to the entire Haskell
  community, and so we grant permission to copy and distribute it for
  any purpose, provided that it is reproduced in its entirety,
  including this Notice.  Modified versions of this Report may also be
  copied and distributed for any purpose, provided that the modified
  version is clearly presented as such, and that it does not claim to
  be a definition of the Haskell 98 Language.

-----------------------------------------------------------------------------

Code derived from the document "The Haskell 98 Foreign Function
Interface, An Addendum to the Haskell 98 Report" is distributed under
the following license:

  Copyright (c) 2002 Manuel M. T. Chakravarty

  The authors intend this Report to belong to the entire Haskell
  community, and so we grant permission to copy and distribute it for
  any purpose, provided that it is reproduced in its entirety,
  including this Notice.  Modified versions of this Report may also be
  copied and distributed for any purpose, provided that the modified
  version is clearly presented as such, and that it does not claim to
  be a definition of the Haskell 98 Foreign Function Interface.

-----------------------------------------------------------------------------
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Numeric
-- Copyright   :  (c) The University of Glasgow 2002
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Odds and ends, mostly functions for reading and showing
-- 'RealFloat'-like kind of values.
--
-----------------------------------------------------------------------------

module Numeric (

	-- * Showing

	showSigned,       -- :: (Real a) => (a -> ShowS) -> Int -> a -> ShowS

        showIntAtBase,    -- :: Integral a => a -> (a -> Char) -> a -> ShowS
	showInt,          -- :: Integral a => a -> ShowS
        showHex,          -- :: Integral a => a -> ShowS
        showOct,          -- :: Integral a => a -> ShowS

	showEFloat,       -- :: (RealFloat a) => Maybe Int -> a -> ShowS
	showFFloat,       -- :: (RealFloat a) => Maybe Int -> a -> ShowS
	showGFloat,       -- :: (RealFloat a) => Maybe Int -> a -> ShowS
	showFloat,        -- :: (RealFloat a) => a -> ShowS

	floatToDigits,    -- :: (RealFloat a) => Integer -> a -> ([Int], Int)

	-- * Reading

	-- | /NB:/ 'readInt' is the \'dual\' of 'showIntAtBase',
	-- and 'readDec' is the \`dual\' of 'showInt'.
	-- The inconsistent naming is a historical accident.

	readSigned,       -- :: (Real a) => ReadS a -> ReadS a

	readInt,          -- :: (Integral a) => a -> (Char -> Bool)
			  --         -> (Char -> Int) -> ReadS a
	readDec,          -- :: (Integral a) => ReadS a
	readOct,          -- :: (Integral a) => ReadS a
	readHex,          -- :: (Integral a) => ReadS a

	readFloat,        -- :: (RealFloat a) => ReadS a
	
	lexDigits,        -- :: ReadS String

	-- * Miscellaneous

        fromRat,          -- :: (RealFloat a) => Rational -> a

	) where












import Data.Char



import Hugs.Prelude
import Hugs.Numeric






















































































































-- ---------------------------------------------------------------------------
-- Integer printing functions

-- | Shows a /non-negative/ 'Integral' number using the base specified by the
-- first argument, and the character representation specified by the second.
showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
showIntAtBase base toChr n r
  | base <= 1 = error ("Numeric.showIntAtBase: applied to unsupported base " ++ show base)
  | n <  0    = error ("Numeric.showIntAtBase: applied to negative number " ++ show n)
  | otherwise = showIt (quotRem n base) r
   where
    showIt (n,d) r = seq c $ -- stricter than necessary
      case n of
        0 -> r'
	_ -> showIt (quotRem n base) r'
     where
      c  = toChr (fromIntegral d) 
      r' = c : r

-- | Show /non-negative/ 'Integral' numbers in base 16.
showHex :: Integral a => a -> ShowS
showHex = showIntAtBase 16 intToDigit

-- | Show /non-negative/ 'Integral' numbers in base 8.
showOct :: Integral a => a -> ShowS
showOct = showIntAtBase 8  intToDigit
module Paths_base (
	version,
	getBinDir, getLibDir, getDataDir, getLibexecDir,
	getDataFileName
	) where

import Data.Version

version = Version {versionBranch = [2,0], versionTags = []}

bindir     = "/usr/local/bin"
libdir     = "/usr/local/lib/hugs/packages/base"
datadir    = "/usr/local/share/base-2.0"
libexecdir = "/usr/local/libexec"

getBinDir, getLibDir, getDataDir, getLibexecDir :: IO FilePath
getBinDir = return bindir
getLibDir = return libdir
getDataDir = return datadir
getLibexecDir = return libexecdir

getDataFileName :: FilePath -> IO FilePath
getDataFileName name = return (datadir ++ "/" ++ name)
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Prelude
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  stable
-- Portability :  portable
--
-- The Prelude: a standard module imported by default into all Haskell
-- modules.  For more documentation, see the Haskell 98 Report
-- <http://www.haskell.org/onlinereport/>.
--
-----------------------------------------------------------------------------

module Prelude (

    -- * Standard types, classes and related functions

    -- ** Basic data types
    Bool(False, True),
    (&&), (||), not, otherwise,

    Maybe(Nothing, Just),
    maybe,

    Either(Left, Right),
    either,

    Ordering(LT, EQ, GT),
    Char, String,

    -- *** Tuples
    fst, snd, curry, uncurry,









    (:),		-- Not legal Haskell 98

    
    -- ** Basic type classes
    Eq((==), (/=)),
    Ord(compare, (<), (<=), (>=), (>), max, min),
    Enum(succ, pred, toEnum, fromEnum, enumFrom, enumFromThen,
         enumFromTo, enumFromThenTo),
    Bounded(minBound, maxBound),

    -- ** Numbers

    -- *** Numeric types
    Int, Integer, Float, Double,
    Rational,

    -- *** Numeric type classes
    Num((+), (-), (*), negate, abs, signum, fromInteger),
    Real(toRational),
    Integral(quot, rem, div, mod, quotRem, divMod, toInteger),
    Fractional((/), recip, fromRational),
    Floating(pi, exp, log, sqrt, (**), logBase, sin, cos, tan,
             asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh),
    RealFrac(properFraction, truncate, round, ceiling, floor),
    RealFloat(floatRadix, floatDigits, floatRange, decodeFloat,
              encodeFloat, exponent, significand, scaleFloat, isNaN,
              isInfinite, isDenormalized, isIEEE, isNegativeZero, atan2),

    -- *** Numeric functions
    subtract, even, odd, gcd, lcm, (^), (^^), 
    fromIntegral, realToFrac,

    -- ** Monads and functors
    Monad((>>=), (>>), return, fail),
    Functor(fmap),
    mapM, mapM_, sequence, sequence_, (=<<),

    -- ** Miscellaneous functions
    id, const, (.), flip, ($), until,
    asTypeOf, error, undefined,
    seq, ($!),

    -- * List operations
    map, (++), filter,
    head, last, tail, init, null, length, (!!), 
    reverse,
    -- ** Reducing lists (folds)
    foldl, foldl1, foldr, foldr1,
    -- *** Special folds
    and, or, any, all,
    sum, product,
    concat, concatMap,
    maximum, minimum,
    -- ** Building lists
    -- *** Scans
    scanl, scanl1, scanr, scanr1,
    -- *** Infinite lists
    iterate, repeat, replicate, cycle,
    -- ** Sublists
    take, drop, splitAt, takeWhile, dropWhile, span, break,
    -- ** Searching lists
    elem, notElem, lookup,
    -- ** Zipping and unzipping lists
    zip, zip3, zipWith, zipWith3, unzip, unzip3,
    -- ** Functions on strings
    lines, words, unlines, unwords,

    -- * Converting to and from @String@
    -- ** Converting to @String@
    ShowS,
    Show(showsPrec, showList, show),
    shows,
    showChar, showString, showParen,
    -- ** Converting from @String@
    ReadS,
    Read(readsPrec, readList),
    reads, readParen, read, lex, 
    
    -- * Basic Input and output
    IO,
    -- ** Simple I\/O operations
    -- All I/O functions defined here are character oriented.  The
    -- treatment of the newline character will vary on different systems.
    -- For example, two characters of input, return and linefeed, may
    -- read as a single newline character.  These functions cannot be
    -- used portably for binary I/O.
    -- *** Output functions
    putChar,
    putStr, putStrLn, print,
    -- *** Input functions
    getChar,
    getLine, getContents, interact,
    -- *** Files
    FilePath,
    readFile, writeFile, appendFile, readIO, readLn,
    -- ** Exception handling in the I\/O monad
    IOError, ioError, userError, catch

  ) where





























import Hugs.Prelude




















-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Applicative
-- Copyright   :  Conor McBride and Ross Paterson 2005
-- License     :  BSD-style (see the LICENSE file in the distribution)
--
-- Maintainer  :  ross@soi.city.ac.uk
-- Stability   :  experimental
-- Portability :  portable
--
-- This module describes a structure intermediate between a functor and
-- a monad: it provides pure expressions and sequencing, but no binding.
-- (Technically, a strong lax monoidal functor.)  For more details, see
-- /Applicative Programming with Effects/,
-- by Conor McBride and Ross Paterson, online at
-- <http://www.soi.city.ac.uk/~ross/papers/Applicative.html>.
--
-- This interface was introduced for parsers by Niklas R&#xF6;jemo, because
-- it admits more sharing than the monadic interface.  The names here are
-- mostly based on recent parsing work by Doaitse Swierstra.
--
-- This class is also useful with instances of the
-- 'Data.Traversable.Traversable' class.

module Control.Applicative (
	-- * Applicative functors
	Applicative(..),
	-- * Alternatives
	Alternative(..),
	-- * Instances
	Const(..), WrappedMonad(..), WrappedArrow(..), ZipList(..),
	-- * Utility functions
	(<$>), (<$), (*>), (<*), (<**>),
	liftA, liftA2, liftA3,
	optional, some, many
	) where





import Control.Arrow
	(Arrow(arr, (>>>), (&&&)), ArrowZero(zeroArrow), ArrowPlus((<+>)))
import Control.Monad (liftM, ap, MonadPlus(..))
import Control.Monad.Instances ()
import Data.Monoid (Monoid(..))

infixl 3 <|>
infixl 4 <$>, <$
infixl 4 <*>, <*, *>, <**>

-- | A functor with application.
--
-- Instances should satisfy the following laws:
--
-- [/identity/]
--	@'pure' 'id' '<*>' v = v@
--
-- [/composition/]
--	@'pure' (.) '<*>' u '<*>' v '<*>' w = u '<*>' (v '<*>' w)@
--
-- [/homomorphism/]
--	@'pure' f '<*>' 'pure' x = 'pure' (f x)@
--
-- [/interchange/]
--	@u '<*>' 'pure' y = 'pure' ('$' y) '<*>' u@
--
-- The 'Functor' instance should satisfy
--
-- @
--	'fmap' f x = 'pure' f '<*>' x
-- @
--
-- If @f@ is also a 'Monad', define @'pure' = 'return'@ and @('<*>') = 'ap'@.

class Functor f => Applicative f where
	-- | Lift a value.
	pure :: a -> f a

        -- | Sequential application.
	(<*>) :: f (a -> b) -> f a -> f b

-- | A monoid on applicative functors.
class Applicative f => Alternative f where
	-- | The identity of '<|>'
	empty :: f a
	-- | An associative binary operation
	(<|>) :: f a -> f a -> f a

-- instances for Prelude types

instance Applicative Maybe where
	pure = return
	(<*>) = ap

instance Alternative Maybe where
	empty = Nothing
	Nothing <|> p = p
	Just x <|> _ = Just x

instance Applicative [] where
	pure = return
	(<*>) = ap

instance Alternative [] where
	empty = []
	(<|>) = (++)

instance Applicative IO where
	pure = return
	(<*>) = ap

instance Applicative ((->) a) where
	pure = const
	(<*>) f g x = f x (g x)

instance Monoid a => Applicative ((,) a) where
	pure x = (mempty, x)
	(u, f) <*> (v, x) = (u `mappend` v, f x)

-- new instances

newtype Const a b = Const { getConst :: a }

instance Functor (Const m) where
	fmap _ (Const v) = Const v

instance Monoid m => Applicative (Const m) where
	pure _ = Const mempty
	Const f <*> Const v = Const (f `mappend` v)

newtype WrappedMonad m a = WrapMonad { unwrapMonad :: m a }

instance Monad m => Functor (WrappedMonad m) where
	fmap f (WrapMonad v) = WrapMonad (liftM f v)

instance Monad m => Applicative (WrappedMonad m) where
	pure = WrapMonad . return
	WrapMonad f <*> WrapMonad v = WrapMonad (f `ap` v)

instance MonadPlus m => Alternative (WrappedMonad m) where
	empty = WrapMonad mzero
	WrapMonad u <|> WrapMonad v = WrapMonad (u `mplus` v)

newtype WrappedArrow a b c = WrapArrow { unwrapArrow :: a b c }

instance Arrow a => Functor (WrappedArrow a b) where
	fmap f (WrapArrow a) = WrapArrow (a >>> arr f)

instance Arrow a => Applicative (WrappedArrow a b) where
	pure x = WrapArrow (arr (const x))
	WrapArrow f <*> WrapArrow v = WrapArrow (f &&& v >>> arr (uncurry id))

instance (ArrowZero a, ArrowPlus a) => Alternative (WrappedArrow a b) where
	empty = WrapArrow zeroArrow
	WrapArrow u <|> WrapArrow v = WrapArrow (u <+> v)

-- | Lists, but with an 'Applicative' functor based on zipping, so that
--
-- @f '<$>' 'ZipList' xs1 '<*>' ... '<*>' 'ZipList' xsn = 'ZipList' (zipWithn f xs1 ... xsn)@
--
newtype ZipList a = ZipList { getZipList :: [a] }

instance Functor ZipList where
	fmap f (ZipList xs) = ZipList (map f xs)

instance Applicative ZipList where
	pure x = ZipList (repeat x)
	ZipList fs <*> ZipList xs = ZipList (zipWith id fs xs)

-- extra functions

-- | A synonym for 'fmap'.
(<$>) :: Functor f => (a -> b) -> f a -> f b
f <$> a = fmap f a

-- | Replace the value.
(<$) :: Functor f => a -> f b -> f a
(<$) = (<$>) . const
 
-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b
(*>) = liftA2 (const id)
 
-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
(<*) = liftA2 const
 
-- | A variant of '<*>' with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
(<**>) = liftA2 (flip ($))

-- | Lift a function to actions.
-- This function may be used as a value for `fmap` in a `Functor` instance.
liftA :: Applicative f => (a -> b) -> f a -> f b
liftA f a = pure f <*> a

-- | Lift a binary function to actions.
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
liftA2 f a b = f <$> a <*> b

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
liftA3 f a b c = f <$> a <*> b <*> c

-- | One or none.
optional :: Alternative f => f a -> f (Maybe a)
optional v = Just <$> v <|> pure Nothing

-- | One or more.
some :: Alternative f => f a -> f [a]
some v = some_v
  where many_v = some_v <|> pure []
	some_v = (:) <$> v <*> many_v

-- | Zero or more.
many :: Alternative f => f a -> f [a]
many v = many_v
  where many_v = some_v <|> pure []
	some_v = (:) <$> v <*> many_v
-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Arrow
-- Copyright   :  (c) Ross Paterson 2002
-- License     :  BSD-style (see the LICENSE file in the distribution)
--
-- Maintainer  :  ross@soi.city.ac.uk
-- Stability   :  experimental
-- Portability :  portable
--
-- Basic arrow definitions, based on
--	/Generalising Monads to Arrows/, by John Hughes,
--	/Science of Computer Programming/ 37, pp67-111, May 2000.
-- plus a couple of definitions ('returnA' and 'loop') from
--	/A New Notation for Arrows/, by Ross Paterson, in /ICFP 2001/,
--	Firenze, Italy, pp229-240.
-- See these papers for the equations these combinators are expected to
-- satisfy.  These papers and more information on arrows can be found at
-- <http://www.haskell.org/arrows/>.

module Control.Arrow (
		-- * Arrows
		Arrow(..), Kleisli(..),
		-- ** Derived combinators
		returnA,
		(^>>), (>>^),
		-- ** Right-to-left variants
		(<<<), (<<^), (^<<),
		-- * Monoid operations
		ArrowZero(..), ArrowPlus(..),
		-- * Conditionals
		ArrowChoice(..),
		-- * Arrow application
		ArrowApply(..), ArrowMonad(..), leftApp,
		-- * Feedback
		ArrowLoop(..)
	) where

import Prelude

import Control.Monad
import Control.Monad.Fix

infixr 5 <+>
infixr 3 ***
infixr 3 &&&
infixr 2 +++
infixr 2 |||
infixr 1 >>>, ^>>, >>^
infixr 1 <<<, ^<<, <<^

-- | The basic arrow class.
--   Any instance must define either 'arr' or 'pure' (which are synonyms),
--   as well as '>>>' and 'first'.  The other combinators have sensible
--   default definitions, which may be overridden for efficiency.

class Arrow a where

	-- | Lift a function to an arrow: you must define either this
	--   or 'pure'.
	arr :: (b -> c) -> a b c
	arr = pure

	-- | A synonym for 'arr': you must define one or other of them.
	pure :: (b -> c) -> a b c
	pure = arr

	-- | Left-to-right composition of arrows.
	(>>>) :: a b c -> a c d -> a b d

	-- | Send the first component of the input through the argument
	--   arrow, and copy the rest unchanged to the output.
	first :: a b c -> a (b,d) (c,d)

	-- | A mirror image of 'first'.
	--
	--   The default definition may be overridden with a more efficient
	--   version if desired.
	second :: a b c -> a (d,b) (d,c)
	second f = arr swap >>> first f >>> arr swap
			where	swap ~(x,y) = (y,x)

	-- | Split the input between the two argument arrows and combine
	--   their output.  Note that this is in general not a functor.
	--
	--   The default definition may be overridden with a more efficient
	--   version if desired.
	(***) :: a b c -> a b' c' -> a (b,b') (c,c')
	f *** g = first f >>> second g

	-- | Fanout: send the input to both argument arrows and combine
	--   their output.
	--
	--   The default definition may be overridden with a more efficient
	--   version if desired.
	(&&&) :: a b c -> a b c' -> a b (c,c')
	f &&& g = arr (\b -> (b,b)) >>> f *** g

{-# RULES
"compose/arr"	forall f g .
		arr f >>> arr g = arr (f >>> g)
"first/arr"	forall f .
		first (arr f) = arr (first f)
"second/arr"	forall f .
		second (arr f) = arr (second f)
"product/arr"	forall f g .
		arr f *** arr g = arr (f *** g)
"fanout/arr"	forall f g .
		arr f &&& arr g = arr (f &&& g)
"compose/first"	forall f g .
		first f >>> first g = first (f >>> g)
"compose/second" forall f g .
		second f >>> second g = second (f >>> g)
 #-}

-- Ordinary functions are arrows.

instance Arrow (->) where
	arr f = f
	f >>> g = g . f
	first f = f *** id
	second f = id *** f
--	(f *** g) ~(x,y) = (f x, g y)
--	sorry, although the above defn is fully H'98, nhc98 can't parse it.
	(***) f g ~(x,y) = (f x, g y)

-- | Kleisli arrows of a monad.

newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }

instance Monad m => Arrow (Kleisli m) where
	arr f = Kleisli (return . f)
	Kleisli f >>> Kleisli g = Kleisli (\b -> f b >>= g)
	first (Kleisli f) = Kleisli (\ ~(b,d) -> f b >>= \c -> return (c,d))
	second (Kleisli f) = Kleisli (\ ~(d,b) -> f b >>= \c -> return (d,c))

-- | The identity arrow, which plays the role of 'return' in arrow notation.

returnA :: Arrow a => a b b
returnA = arr id

-- | Precomposition with a pure function.
(^>>) :: Arrow a => (b -> c) -> a c d -> a b d
f ^>> a = arr f >>> a

-- | Postcomposition with a pure function.
(>>^) :: Arrow a => a b c -> (c -> d) -> a b d
a >>^ f = a >>> arr f

-- | Right-to-left composition, for a better fit with arrow notation.
(<<<) :: Arrow a => a c d -> a b c -> a b d
f <<< g = g >>> f

-- | Precomposition with a pure function (right-to-left variant).
(<<^) :: Arrow a => a c d -> (b -> c) -> a b d
a <<^ f = a <<< arr f

-- | Postcomposition with a pure function (right-to-left variant).
(^<<) :: Arrow a => (c -> d) -> a b c -> a b d
f ^<< a = arr f <<< a

class Arrow a => ArrowZero a where
	zeroArrow :: a b c

instance MonadPlus m => ArrowZero (Kleisli m) where
	zeroArrow = Kleisli (\x -> mzero)

class ArrowZero a => ArrowPlus a where
	(<+>) :: a b c -> a b c -> a b c

instance MonadPlus m => ArrowPlus (Kleisli m) where
	Kleisli f <+> Kleisli g = Kleisli (\x -> f x `mplus` g x)

-- | Choice, for arrows that support it.  This class underlies the
--   @if@ and @case@ constructs in arrow notation.
--   Any instance must define 'left'.  The other combinators have sensible
--   default definitions, which may be overridden for efficiency.

class Arrow a => ArrowChoice a where

	-- | Feed marked inputs through the argument arrow, passing the
	--   rest through unchanged to the output.
	left :: a b c -> a (Either b d) (Either c d)

	-- | A mirror image of 'left'.
	--
	--   The default definition may be overridden with a more efficient
	--   version if desired.
	right :: a b c -> a (Either d b) (Either d c)
	right f = arr mirror >>> left f >>> arr mirror
			where	mirror (Left x) = Right x
				mirror (Right y) = Left y

	-- | Split the input between the two argument arrows, retagging
	--   and merging their outputs.
	--   Note that this is in general not a functor.
	--
	--   The default definition may be overridden with a more efficient
	--   version if desired.
	(+++) :: a b c -> a b' c' -> a (Either b b') (Either c c')
	f +++ g = left f >>> right g

	-- | Fanin: Split the input between the two argument arrows and
	--   merge their outputs.
	--
	--   The default definition may be overridden with a more efficient
	--   version if desired.
	(|||) :: a b d -> a c d -> a (Either b c) d
	f ||| g = f +++ g >>> arr untag
			where	untag (Left x) = x
				untag (Right y) = y

{-# RULES
"left/arr"	forall f .
		left (arr f) = arr (left f)
"right/arr"	forall f .
		right (arr f) = arr (right f)
"sum/arr"	forall f g .
		arr f +++ arr g = arr (f +++ g)
"fanin/arr"	forall f g .
		arr f ||| arr g = arr (f ||| g)
"compose/left"	forall f g .
		left f >>> left g = left (f >>> g)
"compose/right"	forall f g .
		right f >>> right g = right (f >>> g)
 #-}

instance ArrowChoice (->) where
	left f = f +++ id
	right f = id +++ f
	f +++ g = (Left . f) ||| (Right . g)
	(|||) = either

instance Monad m => ArrowChoice (Kleisli m) where
	left f = f +++ arr id
	right f = arr id +++ f
	f +++ g = (f >>> arr Left) ||| (g >>> arr Right)
	Kleisli f ||| Kleisli g = Kleisli (either f g)

-- | Some arrows allow application of arrow inputs to other inputs.

class Arrow a => ArrowApply a where
	app :: a (a b c, b) c

instance ArrowApply (->) where
	app (f,x) = f x

instance Monad m => ArrowApply (Kleisli m) where
	app = Kleisli (\(Kleisli f, x) -> f x)

-- | The 'ArrowApply' class is equivalent to 'Monad': any monad gives rise
--   to a 'Kleisli' arrow, and any instance of 'ArrowApply' defines a monad.

newtype ArrowApply a => ArrowMonad a b = ArrowMonad (a () b)

instance ArrowApply a => Monad (ArrowMonad a) where
	return x = ArrowMonad (arr (\z -> x))
	ArrowMonad m >>= f = ArrowMonad (m >>>
			arr (\x -> let ArrowMonad h = f x in (h, ())) >>>
			app)

-- | Any instance of 'ArrowApply' can be made into an instance of
--   'ArrowChoice' by defining 'left' = 'leftApp'.

leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)
leftApp f = arr ((\b -> (arr (\() -> b) >>> f >>> arr Left, ())) |||
		 (\d -> (arr (\() -> d) >>> arr Right, ()))) >>> app

-- | The 'loop' operator expresses computations in which an output value is
--   fed back as input, even though the computation occurs only once.
--   It underlies the @rec@ value recursion construct in arrow notation.

class Arrow a => ArrowLoop a where
	loop :: a (b,d) (c,d) -> a b c

instance ArrowLoop (->) where
	loop f b = let (c,d) = f (b,d) in c

instance MonadFix m => ArrowLoop (Kleisli m) where
	loop (Kleisli f) = Kleisli (liftM fst . mfix . f')
		where	f' x y = f (x, snd y)
-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Concurrent
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (concurrency)
--
-- A common interface to a collection of useful concurrency
-- abstractions.
--
-----------------------------------------------------------------------------

module Control.Concurrent (
	-- * Concurrent Haskell

	-- $conc_intro

	-- * Basic concurrency operations

        ThreadId,




	forkIO,





	-- * Scheduling

	-- $conc_scheduling	
	yield,         		-- :: IO ()

	-- ** Blocking
	
	-- $blocking








	-- * Communication abstractions

	module Control.Concurrent.MVar,
	module Control.Concurrent.Chan,
	module Control.Concurrent.QSem,
	module Control.Concurrent.QSemN,
	module Control.Concurrent.SampleVar,

	-- * Merging of streams




	-- $merge











	-- * GHC's implementation of concurrency

	-- |This section describes features specific to GHC's
	-- implementation of Concurrent Haskell.
	
	-- ** Haskell threads and Operating System threads

	-- $osthreads

	-- ** Terminating the program

	-- $termination

	-- ** Pre-emption

	-- $preemption
    ) where

import Prelude

import Control.Exception as Exception

















import Hugs.ConcBase


import Control.Concurrent.MVar
import Control.Concurrent.Chan
import Control.Concurrent.QSem
import Control.Concurrent.QSemN
import Control.Concurrent.SampleVar


type ThreadId = ()


{- $conc_intro

The concurrency extension for Haskell is described in the paper
/Concurrent Haskell/
<http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz>.

Concurrency is \"lightweight\", which means that both thread creation
and context switching overheads are extremely low.  Scheduling of
Haskell threads is done internally in the Haskell runtime system, and
doesn't make use of any operating system-supplied thread packages.

However, if you want to interact with a foreign library that expects your
program to use the operating system-supplied thread package, you can do so
by using 'forkOS' instead of 'forkIO'.

Haskell threads can communicate via 'MVar's, a kind of synchronised
mutable variable (see "Control.Concurrent.MVar").  Several common
concurrency abstractions can be built from 'MVar's, and these are
provided by the "Control.Concurrent" library.
In GHC, threads may also communicate via exceptions.
-}

{- $conc_scheduling

    Scheduling may be either pre-emptive or co-operative,
    depending on the implementation of Concurrent Haskell (see below
    for information related to specific compilers).  In a co-operative
    system, context switches only occur when you use one of the
    primitives defined in this module.  This means that programs such
    as:


>   main = forkIO (write 'a') >> write 'b'
>     where write c = putChar c >> write c

    will print either @aaaaaaaaaaaaaa...@ or @bbbbbbbbbbbb...@,
    instead of some random interleaving of @a@s and @b@s.  In
    practice, cooperative multitasking is sufficient for writing
    simple graphical user interfaces.  
-}

{- $blocking
Calling a foreign C procedure (such as @getchar@) that blocks waiting
for input will block /all/ threads, unless the @threadsafe@ attribute
is used on the foreign call (and your compiler \/ operating system
supports it).  GHC's I\/O system uses non-blocking I\/O internally to
implement thread-friendly I\/O, so calling standard Haskell I\/O
functions blocks only the thread making the call.
-}





































































































































































































































-- ---------------------------------------------------------------------------
-- More docs

{- $osthreads

      #osthreads# In GHC, threads created by 'forkIO' are lightweight threads, and
      are managed entirely by the GHC runtime.  Typically Haskell
      threads are an order of magnitude or two more efficient (in
      terms of both time and space) than operating system threads.

      The downside of having lightweight threads is that only one can
      run at a time, so if one thread blocks in a foreign call, for
      example, the other threads cannot continue.  The GHC runtime
      works around this by making use of full OS threads where
      necessary.  When the program is built with the @-threaded@
      option (to link against the multithreaded version of the
      runtime), a thread making a @safe@ foreign call will not block
      the other threads in the system; another OS thread will take
      over running Haskell threads until the original call returns.
      The runtime maintains a pool of these /worker/ threads so that
      multiple Haskell threads can be involved in external calls
      simultaneously.

      The "System.IO" library manages multiplexing in its own way.  On
      Windows systems it uses @safe@ foreign calls to ensure that
      threads doing I\/O operations don't block the whole runtime,
      whereas on Unix systems all the currently blocked I\/O reqwests
      are managed by a single thread (the /IO manager thread/) using
      @select@.

      The runtime will run a Haskell thread using any of the available
      worker OS threads.  If you need control over which particular OS
      thread is used to run a given Haskell thread, perhaps because
      you need to call a foreign library that uses OS-thread-local
      state, then you need "bound threads" (see above).

      If you don't use the @-threaded@ option, then the runtime does
      not make use of multiple OS threads.  Foreign calls will block
      all other running Haskell threads until the call returns.  The
      "System.IO" library still does multiplexing, so there can be multiple
      threads doing I\/O, and this is handled internally by the runtime using
      @select@.
-}

{- $termination

      In a standalone GHC program, only the main thread is
      required to terminate in order for the process to terminate.
      Thus all other forked threads will simply terminate at the same
      time as the main thread (the terminology for this kind of
      behaviour is \"daemonic threads\").

      If you want the program to wait for child threads to
      finish before exiting, you need to program this yourself.  A
      simple mechanism is to have each child thread write to an
      'MVar' when it completes, and have the main
      thread wait on all the 'MVar's before
      exiting:

>   myForkIO :: IO () -> IO (MVar ())
>   myForkIO io = do
>     mvar <- newEmptyMVar
>     forkIO (io `finally` putMVar mvar ())
>     return mvar

      Note that we use 'finally' from the
      "Control.Exception" module to make sure that the
      'MVar' is written to even if the thread dies or
      is killed for some reason.

      A better method is to keep a global list of all child
      threads which we should wait for at the end of the program:

>    children :: MVar [MVar ()]
>    children = unsafePerformIO (newMVar [])
>    
>    waitForChildren :: IO ()
>    waitForChildren = do
>      cs <- takeMVar children
>      case cs of
>        []   -> return ()
>        m:ms -> do
>    	    putMVar children ms
>    	    takeMVar m
>    	    waitForChildren
>    
>    forkChild :: IO () -> IO ()
>    forkChild io = do
>    	 mvar <- newEmptyMVar
>    	 childs <- takeMVar children
>    	 putMVar children (mvar:childs)
>    	 forkIO (io `finally` putMVar mvar ())
>
>     main =
>     	later waitForChildren $
>     	...

      The main thread principle also applies to calls to Haskell from
      outside, using @foreign export@.  When the @foreign export@ed
      function is invoked, it starts a new main thread, and it returns
      when this main thread terminates.  If the call causes new
      threads to be forked, they may remain in the system after the
      @foreign export@ed function has returned.
-}

{- $preemption

      GHC implements pre-emptive multitasking: the execution of
      threads are interleaved in a random fashion.  More specifically,
      a thread may be pre-empted whenever it allocates some memory,
      which unfortunately means that tight loops which do no
      allocation tend to lock out other threads (this only seems to
      happen with pathological benchmark-style code, however).

      The rescheduling timer runs on a 20ms granularity by
      default, but this may be altered using the
      @-i\<n\>@ RTS option.  After a rescheduling
      \"tick\" the running thread is pre-empted as soon as
      possible.

      One final note: the
      @aaaa@ @bbbb@ example may not
      work too well on GHC (see Scheduling, above), due
      to the locking on a 'System.IO.Handle'.  Only one thread
      may hold the lock on a 'System.IO.Handle' at any one
      time, so if a reschedule happens while a thread is holding the
      lock, the other thread won't be able to run.  The upshot is that
      the switch from @aaaa@ to
      @bbbbb@ happens infrequently.  It can be
      improved by lowering the reschedule tick period.  We also have a
      patch that causes a reschedule whenever a thread waiting on a
      lock is woken up, but haven't found it to be useful for anything
      other than this example :-)
-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Exception
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (extended exceptions)
--
-- This module provides support for raising and catching both built-in
-- and user-defined exceptions.
--
-- In addition to exceptions thrown by 'IO' operations, exceptions may
-- be thrown by pure code (imprecise exceptions) or by external events
-- (asynchronous exceptions), but may only be caught in the 'IO' monad.
-- For more details, see:
--
--  * /A semantics for imprecise exceptions/, by Simon Peyton Jones,
--    Alastair Reid, Tony Hoare, Simon Marlow, Fergus Henderson,
--    in /PLDI'99/.
--
--  * /Asynchronous exceptions in Haskell/, by Simon Marlow, Simon Peyton
--    Jones, Andy Moran and John Reppy, in /PLDI'01/.
--
-----------------------------------------------------------------------------

module Control.Exception (

	-- * The Exception type
	Exception(..),		-- instance Eq, Ord, Show, Typeable
	IOException,		-- instance Eq, Ord, Show, Typeable
	ArithException(..),	-- instance Eq, Ord, Show, Typeable
	ArrayException(..),	-- instance Eq, Ord, Show, Typeable
	AsyncException(..),	-- instance Eq, Ord, Show, Typeable

	-- * Throwing exceptions
	throwIO,	-- :: Exception -> IO a
	throw,		-- :: Exception -> a
	ioError,	-- :: IOError -> IO a




	-- * Catching Exceptions

	-- |There are several functions for catching and examining
    	-- exceptions; all of them may only be used from within the
    	-- 'IO' monad.

	-- ** The @catch@ functions
	catch,     -- :: IO a -> (Exception -> IO a) -> IO a
	catchJust, -- :: (Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a

	-- ** The @handle@ functions
	handle,	   -- :: (Exception -> IO a) -> IO a -> IO a
	handleJust,-- :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a

	-- ** The @try@ functions
	try,       -- :: IO a -> IO (Either Exception a)
	tryJust,   -- :: (Exception -> Maybe b) -> a    -> IO (Either b a)

	-- ** The @evaluate@ function
	evaluate,  -- :: a -> IO a

	-- ** The @mapException@ function
	mapException,		-- :: (Exception -> Exception) -> a -> a

	-- ** Exception predicates
	
	-- $preds

	ioErrors,		-- :: Exception -> Maybe IOError
	arithExceptions, 	-- :: Exception -> Maybe ArithException
	errorCalls,		-- :: Exception -> Maybe String
	dynExceptions,		-- :: Exception -> Maybe Dynamic
	assertions,		-- :: Exception -> Maybe String
	asyncExceptions, 	-- :: Exception -> Maybe AsyncException
	userErrors,		-- :: Exception -> Maybe String

	-- * Dynamic exceptions

	-- $dynamic
	throwDyn, 	-- :: Typeable ex => ex -> b



	catchDyn, 	-- :: Typeable ex => IO a -> (ex -> IO a) -> IO a
	
	-- * Asynchronous Exceptions

	-- $async

	-- ** Asynchronous exception control

	-- |The following two functions allow a thread to control delivery of
	-- asynchronous exceptions during a critical region.

        block,          -- :: IO a -> IO a
        unblock,        -- :: IO a -> IO a

	-- *** Applying @block@ to an exception handler

	-- $block_handler

	-- *** Interruptible operations

	-- $interruptible

	-- * Assertions

	assert,		-- :: Bool -> a -> a

	-- * Utilities

	bracket,  	-- :: IO a -> (a -> IO b) -> (a -> IO c) -> IO ()
	bracket_, 	-- :: IO a -> IO b -> IO c -> IO ()
	bracketOnError,

	finally, 	-- :: IO a -> IO b -> IO a
	




  ) where











import Hugs.Exception	as ExceptionBase


import Prelude 		hiding ( catch )
import System.IO.Error	hiding ( catch, try )
import System.IO.Unsafe (unsafePerformIO)
import Data.Dynamic

-----------------------------------------------------------------------------
-- Catching exceptions

-- |This is the simplest of the exception-catching functions.  It
-- takes a single argument, runs it, and if an exception is raised
-- the \"handler\" is executed, with the value of the exception passed as an
-- argument.  Otherwise, the result is returned as normal.  For example:
--
-- >   catch (openFile f ReadMode) 
-- >       (\e -> hPutStr stderr ("Couldn't open "++f++": " ++ show e))
--
-- For catching exceptions in pure (non-'IO') expressions, see the
-- function 'evaluate'.
--
-- Note that due to Haskell\'s unspecified evaluation order, an
-- expression may return one of several possible exceptions: consider
-- the expression @error \"urk\" + 1 \`div\` 0@.  Does
-- 'catch' execute the handler passing
-- @ErrorCall \"urk\"@, or @ArithError DivideByZero@?
--
-- The answer is \"either\": 'catch' makes a
-- non-deterministic choice about which exception to catch.  If you
-- call it again, you might get a different exception back.  This is
-- ok, because 'catch' is an 'IO' computation.
--
-- Note that 'catch' catches all types of exceptions, and is generally
-- used for \"cleaning up\" before passing on the exception using
-- 'throwIO'.  It is not good practice to discard the exception and
-- continue, without first checking the type of the exception (it
-- might be a 'ThreadKilled', for example).  In this case it is usually better
-- to use 'catchJust' and select the kinds of exceptions to catch.
--
-- Also note that the "Prelude" also exports a function called
-- 'Prelude.catch' with a similar type to 'Control.Exception.catch',
-- except that the "Prelude" version only catches the IO and user
-- families of exceptions (as required by Haskell 98).  
--
-- We recommend either hiding the "Prelude" version of 'Prelude.catch'
-- when importing "Control.Exception": 
--
-- > import Prelude hiding (catch)
--
-- or importing "Control.Exception" qualified, to avoid name-clashes:
--
-- > import qualified Control.Exception as C
--
-- and then using @C.catch@
--

catch  	:: IO a 		-- ^ The computation to run
  	-> (Exception -> IO a)	-- ^ Handler to invoke if an exception is raised
  	-> IO a			
catch =  ExceptionBase.catchException

-- | The function 'catchJust' is like 'catch', but it takes an extra
-- argument which is an /exception predicate/, a function which
-- selects which type of exceptions we\'re interested in.  There are
-- some predefined exception predicates for useful subsets of
-- exceptions: 'ioErrors', 'arithExceptions', and so on.  For example,
-- to catch just calls to the 'error' function, we could use
--
-- >   result <- catchJust errorCalls thing_to_try handler
--
-- Any other exceptions which are not matched by the predicate
-- are re-raised, and may be caught by an enclosing
-- 'catch' or 'catchJust'.
catchJust
	:: (Exception -> Maybe b) -- ^ Predicate to select exceptions
	-> IO a		 	  -- ^ Computation to run
	-> (b -> IO a)		  -- ^ Handler
	-> IO a
catchJust p a handler = catch a handler'
  where handler' e = case p e of 
			Nothing -> throw e
			Just b  -> handler b

-- | A version of 'catch' with the arguments swapped around; useful in
-- situations where the code for the handler is shorter.  For example:
--
-- >   do handle (\e -> exitWith (ExitFailure 1)) $
-- >	  ...
handle	   :: (Exception -> IO a) -> IO a -> IO a
handle     =  flip catch

-- | A version of 'catchJust' with the arguments swapped around (see
-- 'handle').
handleJust :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a
handleJust p =  flip (catchJust p)

-----------------------------------------------------------------------------
-- 'mapException'

-- | This function maps one exception into another as proposed in the
-- paper \"A semantics for imprecise exceptions\".

-- Notice that the usage of 'unsafePerformIO' is safe here.

mapException :: (Exception -> Exception) -> a -> a
mapException f v = unsafePerformIO (catch (evaluate v)
                                          (\x -> throw (f x)))

-----------------------------------------------------------------------------
-- 'try' and variations.

-- | Similar to 'catch', but returns an 'Either' result which is
-- @('Right' a)@ if no exception was raised, or @('Left' e)@ if an
-- exception was raised and its value is @e@.
--
-- >  try a = catch (Right `liftM` a) (return . Left)
--
-- Note: as with 'catch', it is only polite to use this variant if you intend
-- to re-throw the exception after performing whatever cleanup is needed.
-- Otherwise, 'tryJust' is generally considered to be better.
--
-- Also note that "System.IO.Error" also exports a function called
-- 'System.IO.Error.try' with a similar type to 'Control.Exception.try',
-- except that it catches only the IO and user families of exceptions
-- (as required by the Haskell 98 @IO@ module).

try :: IO a -> IO (Either Exception a)
try a = catch (a >>= \ v -> return (Right v)) (\e -> return (Left e))

-- | A variant of 'try' that takes an exception predicate to select
-- which exceptions are caught (c.f. 'catchJust').  If the exception
-- does not match the predicate, it is re-thrown.
tryJust :: (Exception -> Maybe b) -> IO a -> IO (Either b a)
tryJust p a = do
  r <- try a
  case r of
	Right v -> return (Right v)
	Left  e -> case p e of
			Nothing -> throw e
			Just b  -> return (Left b)

-----------------------------------------------------------------------------
-- Dynamic exceptions

-- $dynamic
--  #DynamicExceptions# Because the 'Exception' datatype is not extensible, there is an
-- interface for throwing and catching exceptions of type 'Dynamic'
-- (see "Data.Dynamic") which allows exception values of any type in
-- the 'Typeable' class to be thrown and caught.

-- | Raise any value as an exception, provided it is in the
-- 'Typeable' class.
throwDyn :: Typeable exception => exception -> b
throwDyn exception = throw (DynException (toDyn exception))








-- | Catch dynamic exceptions of the required type.  All other
-- exceptions are re-thrown, including dynamic exceptions of the wrong
-- type.
--
-- When using dynamic exceptions it is advisable to define a new
-- datatype to use for your exception type, to avoid possible clashes
-- with dynamic exceptions used in other libraries.
--
catchDyn :: Typeable exception => IO a -> (exception -> IO a) -> IO a
catchDyn m k = catchException m handle
  where handle ex = case ex of
  			   (DynException dyn) ->
		  	  	case fromDynamic dyn of
				    Just exception  -> k exception
				    Nothing -> throw ex
			   _ -> throw ex

-----------------------------------------------------------------------------
-- Exception Predicates

-- $preds
-- These pre-defined predicates may be used as the first argument to
-- 'catchJust', 'tryJust', or 'handleJust' to select certain common
-- classes of exceptions.

ioErrors		:: Exception -> Maybe IOError
arithExceptions 	:: Exception -> Maybe ArithException
errorCalls		:: Exception -> Maybe String
assertions		:: Exception -> Maybe String
dynExceptions		:: Exception -> Maybe Dynamic
asyncExceptions 	:: Exception -> Maybe AsyncException
userErrors		:: Exception -> Maybe String

ioErrors (IOException e) = Just e
ioErrors _ = Nothing

arithExceptions (ArithException e) = Just e
arithExceptions _ = Nothing

errorCalls (ErrorCall e) = Just e
errorCalls _ = Nothing

assertions (AssertionFailed e) = Just e
assertions _ = Nothing

dynExceptions (DynException e) = Just e
dynExceptions _ = Nothing

asyncExceptions (AsyncException e) = Just e
asyncExceptions _ = Nothing

userErrors (IOException e) | isUserError e = Just (ioeGetErrorString e)
userErrors _ = Nothing

-----------------------------------------------------------------------------
-- Some Useful Functions

-- | When you want to acquire a resource, do some work with it, and
-- then release the resource, it is a good idea to use 'bracket',
-- because 'bracket' will install the necessary exception handler to
-- release the resource in the event that an exception is raised
-- during the computation.  If an exception is raised, then 'bracket' will 
-- re-raise the exception (after performing the release).
--
-- A common example is opening a file:
--
-- > bracket
-- >   (openFile "filename" ReadMode)
-- >   (hClose)
-- >   (\handle -> do { ... })
--
-- The arguments to 'bracket' are in this order so that we can partially apply 
-- it, e.g.:
--
-- > withFile name = bracket (openFile name) hClose
--
bracket 
	:: IO a		-- ^ computation to run first (\"acquire resource\")
	-> (a -> IO b)  -- ^ computation to run last (\"release resource\")
	-> (a -> IO c)	-- ^ computation to run in-between
	-> IO c		-- returns the value from the in-between computation
bracket before after thing =
  block (do
    a <- before 
    r <- catch 
	   (unblock (thing a))
	   (\e -> do { after a; throw e })
    after a
    return r
 )
   

-- | A specialised variant of 'bracket' with just a computation to run
-- afterward.
-- 
finally :: IO a		-- ^ computation to run first
	-> IO b		-- ^ computation to run afterward (even if an exception 
			-- was raised)
	-> IO a		-- returns the value from the first computation
a `finally` sequel =
  block (do
    r <- catch 
	     (unblock a)
	     (\e -> do { sequel; throw e })
    sequel
    return r
  )

-- | A variant of 'bracket' where the return value from the first computation
-- is not required.
bracket_ :: IO a -> IO b -> IO c -> IO c
bracket_ before after thing = bracket before (const after) (const thing)

-- | Like bracket, but only performs the final action if there was an 
-- exception raised by the in-between computation.
bracketOnError
	:: IO a		-- ^ computation to run first (\"acquire resource\")
	-> (a -> IO b)  -- ^ computation to run last (\"release resource\")
	-> (a -> IO c)	-- ^ computation to run in-between
	-> IO c		-- returns the value from the in-between computation
bracketOnError before after thing =
  block (do
    a <- before 
    catch 
	(unblock (thing a))
	(\e -> do { after a; throw e })
 )

-- -----------------------------------------------------------------------------
-- Asynchronous exceptions

{- $async

 #AsynchronousExceptions# Asynchronous exceptions are so-called because they arise due to
external influences, and can be raised at any point during execution.
'StackOverflow' and 'HeapOverflow' are two examples of
system-generated asynchronous exceptions.

The primary source of asynchronous exceptions, however, is
'throwTo':

>  throwTo :: ThreadId -> Exception -> IO ()

'throwTo' (also 'throwDynTo' and 'Control.Concurrent.killThread') allows one
running thread to raise an arbitrary exception in another thread.  The
exception is therefore asynchronous with respect to the target thread,
which could be doing anything at the time it receives the exception.
Great care should be taken with asynchronous exceptions; it is all too
easy to introduce race conditions by the over zealous use of
'throwTo'.
-}

{- $block_handler
There\'s an implied 'block' around every exception handler in a call
to one of the 'catch' family of functions.  This is because that is
what you want most of the time - it eliminates a common race condition
in starting an exception handler, because there may be no exception
handler on the stack to handle another exception if one arrives
immediately.  If asynchronous exceptions are blocked on entering the
handler, though, we have time to install a new exception handler
before being interrupted.  If this weren\'t the default, one would have
to write something like

>      block (
>           catch (unblock (...))
>                      (\e -> handler)
>      )

If you need to unblock asynchronous exceptions again in the exception
handler, just use 'unblock' as normal.

Note that 'try' and friends /do not/ have a similar default, because
there is no exception handler in this case.  If you want to use 'try'
in an asynchronous-exception-safe way, you will need to use
'block'.
-}

{- $interruptible

Some operations are /interruptible/, which means that they can receive
asynchronous exceptions even in the scope of a 'block'.  Any function
which may itself block is defined as interruptible; this includes
'Control.Concurrent.MVar.takeMVar'
(but not 'Control.Concurrent.MVar.tryTakeMVar'),
and most operations which perform
some I\/O with the outside world.  The reason for having
interruptible operations is so that we can write things like

>      block (
>         a <- takeMVar m
>         catch (unblock (...))
>               (\e -> ...)
>      )

if the 'Control.Concurrent.MVar.takeMVar' was not interruptible,
then this particular
combination could lead to deadlock, because the thread itself would be
blocked in a state where it can\'t receive any asynchronous exceptions.
With 'Control.Concurrent.MVar.takeMVar' interruptible, however, we can be
safe in the knowledge that the thread can receive exceptions right up
until the point when the 'Control.Concurrent.MVar.takeMVar' succeeds.
Similar arguments apply for other interruptible operations like
'System.IO.openFile'.
-}


assert :: Bool -> a -> a
assert True x = x
assert False _ = throw (AssertionFailed "")




























{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Monad
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- The 'Functor', 'Monad' and 'MonadPlus' classes,
-- with some useful operations on monads.

module Control.Monad
    (
    -- * Functor and monad classes

      Functor(fmap)
    , Monad((>>=), (>>), return, fail)

    , MonadPlus (   -- class context: Monad
	  mzero     -- :: (MonadPlus m) => m a
	, mplus     -- :: (MonadPlus m) => m a -> m a -> m a
	)
    -- * Functions

    -- ** Naming conventions
    -- $naming

    -- ** Basic functions from the "Prelude"

    , mapM          -- :: (Monad m) => (a -> m b) -> [a] -> m [b]
    , mapM_         -- :: (Monad m) => (a -> m b) -> [a] -> m ()
    , forM          -- :: (Monad m) => [a] -> (a -> m b) -> m [b]
    , forM_         -- :: (Monad m) => [a] -> (a -> m b) -> m ()
    , sequence      -- :: (Monad m) => [m a] -> m [a]
    , sequence_     -- :: (Monad m) => [m a] -> m ()
    , (=<<)         -- :: (Monad m) => (a -> m b) -> m a -> m b

    -- ** Generalisations of list functions

    , join          -- :: (Monad m) => m (m a) -> m a
    , msum          -- :: (MonadPlus m) => [m a] -> m a
    , filterM       -- :: (Monad m) => (a -> m Bool) -> [a] -> m [a]
    , mapAndUnzipM  -- :: (Monad m) => (a -> m (b,c)) -> [a] -> m ([b], [c])
    , zipWithM      -- :: (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
    , zipWithM_     -- :: (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()
    , foldM         -- :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a 
    , foldM_        -- :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m ()
    , replicateM    -- :: (Monad m) => Int -> m a -> m [a]
    , replicateM_   -- :: (Monad m) => Int -> m a -> m ()

    -- ** Conditional execution of monadic expressions

    , guard         -- :: (MonadPlus m) => Bool -> m ()
    , when          -- :: (Monad m) => Bool -> m () -> m ()
    , unless        -- :: (Monad m) => Bool -> m () -> m ()

    -- ** Monadic lifting operators

    , liftM         -- :: (Monad m) => (a -> b) -> (m a -> m b)
    , liftM2        -- :: (Monad m) => (a -> b -> c) -> (m a -> m b -> m c)
    , liftM3        -- :: ...
    , liftM4        -- :: ...
    , liftM5        -- :: ...

    , ap            -- :: (Monad m) => m (a -> b) -> m a -> m b

    ) where

import Data.Maybe











































-- -----------------------------------------------------------------------------
-- The MonadPlus class definition

-- | Monads that also support choice and failure.
class Monad m => MonadPlus m where
   -- | the identity of 'mplus'.  It should also satisfy the equations
   --
   -- > mzero >>= f  =  mzero
   -- > v >> mzero   =  mzero
   --
   -- (but the instance for 'System.IO.IO' defined in "Control.Monad.Error"
   -- does not satisfy the second one).
   mzero :: m a	
   -- | an associative operation
   mplus :: m a -> m a -> m a

instance MonadPlus [] where
   mzero = []
   mplus = (++)

instance MonadPlus Maybe where
   mzero = Nothing

   Nothing `mplus` ys  = ys
   xs      `mplus` _ys = xs

-- -----------------------------------------------------------------------------
-- Functions mandated by the Prelude

-- | @'guard' b@ is @'return' ()@ if @b@ is 'True',
-- and 'mzero' if @b@ is 'False'.
guard           :: (MonadPlus m) => Bool -> m ()
guard True      =  return ()
guard False     =  mzero

-- | This generalizes the list-based 'filter' function.

filterM          :: (Monad m) => (a -> m Bool) -> [a] -> m [a]
filterM _ []     =  return []
filterM p (x:xs) =  do
   flg <- p x
   ys  <- filterM p xs
   return (if flg then x:ys else ys)

-- | 'forM' is 'mapM' with its arguments flipped
forM            :: Monad m => [a] -> (a -> m b) -> m [b]
{-# INLINE forM #-}
forM            = flip mapM

-- | 'forM_' is 'mapM_' with its arguments flipped
forM_           :: Monad m => [a] -> (a -> m b) -> m ()
{-# INLINE forM_ #-}
forM_           = flip mapM_

-- | This generalizes the list-based 'concat' function.

msum        :: MonadPlus m => [m a] -> m a
{-# INLINE msum #-}
msum        =  foldr mplus mzero

-- -----------------------------------------------------------------------------
-- Other monad functions

-- | The 'join' function is the conventional monad join operator. It is used to
-- remove one level of monadic structure, projecting its bound argument into the
-- outer level.
join              :: (Monad m) => m (m a) -> m a
join x            =  x >>= id

-- | The 'mapAndUnzipM' function maps its first argument over a list, returning
-- the result as a pair of lists. This function is mainly used with complicated
-- data structures or a state-transforming monad.
mapAndUnzipM      :: (Monad m) => (a -> m (b,c)) -> [a] -> m ([b], [c])
mapAndUnzipM f xs =  sequence (map f xs) >>= return . unzip

-- | The 'zipWithM' function generalizes 'zipWith' to arbitrary monads.
zipWithM          :: (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
zipWithM f xs ys  =  sequence (zipWith f xs ys)

-- | 'zipWithM_' is the extension of 'zipWithM' which ignores the final result.
zipWithM_         :: (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()
zipWithM_ f xs ys =  sequence_ (zipWith f xs ys)

{- | The 'foldM' function is analogous to 'foldl', except that its result is
encapsulated in a monad. Note that 'foldM' works from left-to-right over
the list arguments. This could be an issue where '(>>)' and the `folded
function' are not commutative.


>	foldM f a1 [x1, x2, ..., xm ]

==  

>	do
>	  a2 <- f a1 x1
>	  a3 <- f a2 x2
>	  ...
>	  f am xm

If right-to-left evaluation is required, the input list should be reversed.
-}

foldM             :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
foldM _ a []      =  return a
foldM f a (x:xs)  =  f a x >>= \fax -> foldM f fax xs

-- | Like 'foldM', but discards the result.
foldM_            :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m ()
foldM_ f a xs     = foldM f a xs >> return ()

-- | @'replicateM' n act@ performs the action @n@ times,
-- gathering the results.
replicateM        :: (Monad m) => Int -> m a -> m [a]
replicateM n x    = sequence (replicate n x)

-- | Like 'replicateM', but discards the result.
replicateM_       :: (Monad m) => Int -> m a -> m ()
replicateM_ n x   = sequence_ (replicate n x)

{- | Conditional execution of monadic expressions. For example, 

>	when debug (putStr "Debugging\n")

will output the string @Debugging\\n@ if the Boolean value @debug@ is 'True',
and otherwise do nothing.
-}

when              :: (Monad m) => Bool -> m () -> m ()
when p s          =  if p then s else return ()

-- | The reverse of 'when'.

unless            :: (Monad m) => Bool -> m () -> m ()
unless p s        =  if p then return () else s

-- | Promote a function to a monad.
liftM   :: (Monad m) => (a1 -> r) -> m a1 -> m r
liftM f m1              = do { x1 <- m1; return (f x1) }

-- | Promote a function to a monad, scanning the monadic arguments from
-- left to right.  For example,
--
-- >	liftM2 (+) [0,1] [0,2] = [0,2,1,3]
-- >	liftM2 (+) (Just 1) Nothing = Nothing
--
liftM2  :: (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
liftM2 f m1 m2          = do { x1 <- m1; x2 <- m2; return (f x1 x2) }

-- | Promote a function to a monad, scanning the monadic arguments from
-- left to right (cf. 'liftM2').
liftM3  :: (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
liftM3 f m1 m2 m3       = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }

-- | Promote a function to a monad, scanning the monadic arguments from
-- left to right (cf. 'liftM2').
liftM4  :: (Monad m) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
liftM4 f m1 m2 m3 m4    = do { x1 <- m1; x2 <- m2; x3 <- m3; x4 <- m4; return (f x1 x2 x3 x4) }

-- | Promote a function to a monad, scanning the monadic arguments from
-- left to right (cf. 'liftM2').
liftM5  :: (Monad m) => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
liftM5 f m1 m2 m3 m4 m5 = do { x1 <- m1; x2 <- m2; x3 <- m3; x4 <- m4; x5 <- m5; return (f x1 x2 x3 x4 x5) }

{- | In many situations, the 'liftM' operations can be replaced by uses of
'ap', which promotes function application. 

>	return f `ap` x1 `ap` ... `ap` xn

is equivalent to 

>	liftMn f x1 x2 ... xn

-}

ap                :: (Monad m) => m (a -> b) -> m a -> m b
ap                =  liftM2 id

{- $naming

The functions in this library use the following naming conventions: 

* A postfix \'@M@\' always stands for a function in the Kleisli category:
  The monad type constructor @m@ is added to function results
  (modulo currying) and nowhere else.  So, for example, 

>  filter  ::              (a ->   Bool) -> [a] ->   [a]
>  filterM :: (Monad m) => (a -> m Bool) -> [a] -> m [a]

* A postfix \'@_@\' changes the result type from @(m a)@ to @(m ())@.
  Thus, for example: 

>  sequence  :: Monad m => [m a] -> m [a] 
>  sequence_ :: Monad m => [m a] -> m () 

* A prefix \'@m@\' generalizes an existing function to a monadic form.
  Thus, for example: 

>  sum  :: Num a       => [a]   -> a
>  msum :: MonadPlus m => [m a] -> m a

-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Parallel
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable
--
-- Parallel Constructs
--
-----------------------------------------------------------------------------

module Control.Parallel (
          par, seq -- re-exported



    ) where

import Prelude

































-- Maybe parIO and the like could be added here later.

-- | Indicates that it may be beneficial to evaluate the first
-- argument in parallel with the second.  Returns the value of the
-- second argument.
-- 
-- @a `par` b@ is exactly equivalent semantically to @b@.
--
-- @par@ is generally used when the value of @a@ is likely to be
-- required later, but not immediately.  Also it is a good idea to
-- ensure that @a@ is not a trivial computation, otherwise the cost of
-- spawning it in parallel overshadows the benefits obtained by
-- running it in parallel.
--
-- Note that actual parallelism is only supported by certain
-- implementations (GHC with the @-threaded@ option, and GPH, for
-- now).  On other implementations, @par a b = b@.
--
par :: a -> b -> b



-- For now, Hugs does not support par properly.
par a b = b

-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Concurrent.Chan
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (concurrency)
--
-- Unbounded channels.
--
-----------------------------------------------------------------------------

module Control.Concurrent.Chan
  ( 
	  -- * The 'Chan' type
	Chan,			-- abstract

	  -- * Operations
	newChan,	 	-- :: IO (Chan a)
	writeChan,	 	-- :: Chan a -> a -> IO ()
	readChan,	 	-- :: Chan a -> IO a
	dupChan,	 	-- :: Chan a -> IO (Chan a)
	unGetChan,		-- :: Chan a -> a -> IO ()
	isEmptyChan,		-- :: Chan a -> IO Bool

	  -- * Stream interface
	getChanContents,	-- :: Chan a -> IO [a]
	writeList2Chan,		-- :: Chan a -> [a] -> IO ()
   ) where

import Prelude

import System.IO.Unsafe		( unsafeInterleaveIO )
import Control.Concurrent.MVar
import Data.Typeable

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
























































-- A channel is represented by two @MVar@s keeping track of the two ends
-- of the channel contents,i.e.,  the read- and write ends. Empty @MVar@s
-- are used to handle consumers trying to read from an empty channel.

-- |'Chan' is an abstract type representing an unbounded FIFO channel.
data Chan a
 = Chan (MVar (Stream a))
        (MVar (Stream a))

chanTc = mkTyCon "Chan"; instance Typeable1 Chan where { typeOf1 _ = mkTyConApp chanTc [] }; instance Typeable a => Typeable (Chan a) where { typeOf = typeOfDefault }

type Stream a = MVar (ChItem a)

data ChItem a = ChItem a (Stream a)

-- See the Concurrent Haskell paper for a diagram explaining the
-- how the different channel operations proceed.

-- @newChan@ sets up the read and write end of a channel by initialising
-- these two @MVar@s with an empty @MVar@.

-- |Build and returns a new instance of 'Chan'.
newChan :: IO (Chan a)
newChan = do
   hole  <- newEmptyMVar
   read  <- newMVar hole
   write <- newMVar hole
   return (Chan read write)

-- To put an element on a channel, a new hole at the write end is created.
-- What was previously the empty @MVar@ at the back of the channel is then
-- filled in with a new stream element holding the entered value and the
-- new hole.

-- |Write a value to a 'Chan'.
writeChan :: Chan a -> a -> IO ()
writeChan (Chan _read write) val = do
  new_hole <- newEmptyMVar
  modifyMVar_ write $ \old_hole -> do
    putMVar old_hole (ChItem val new_hole)
    return new_hole

-- |Read the next value from the 'Chan'.
readChan :: Chan a -> IO a
readChan (Chan read _write) = do
  modifyMVar read $ \read_end -> do
    (ChItem val new_read_end) <- readMVar read_end
	-- Use readMVar here, not takeMVar,
	-- else dupChan doesn't work
    return (new_read_end, val)

-- |Duplicate a 'Chan': the duplicate channel begins empty, but data written to
-- either channel from then on will be available from both.  Hence this creates
-- a kind of broadcast channel, where data written by anyone is seen by
-- everyone else.
dupChan :: Chan a -> IO (Chan a)
dupChan (Chan _read write) = do
   hole     <- readMVar write
   new_read <- newMVar hole
   return (Chan new_read write)

-- |Put a data item back onto a channel, where it will be the next item read.
unGetChan :: Chan a -> a -> IO ()
unGetChan (Chan read _write) val = do
   new_read_end <- newEmptyMVar
   modifyMVar_ read $ \read_end -> do
     putMVar new_read_end (ChItem val read_end)
     return new_read_end

-- |Returns 'True' if the supplied 'Chan' is empty.
isEmptyChan :: Chan a -> IO Bool
isEmptyChan (Chan read write) = do
   withMVar read $ \r -> do
     w <- readMVar write
     let eq = r == w
     eq `seq` return eq

-- Operators for interfacing with functional streams.

-- |Return a lazy list representing the contents of the supplied
-- 'Chan', much like 'System.IO.hGetContents'.
getChanContents :: Chan a -> IO [a]
getChanContents ch
  = unsafeInterleaveIO (do
	x  <- readChan ch
    	xs <- getChanContents ch
    	return (x:xs)
    )

-- |Write an entire list of items to a 'Chan'.
writeList2Chan :: Chan a -> [a] -> IO ()
writeList2Chan ch ls = sequence_ (map (writeChan ch) ls)
-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Concurrent.MVar
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (concurrency)
--
-- Synchronising variables
--
-----------------------------------------------------------------------------

module Control.Concurrent.MVar
	( 
	  -- * @MVar@s
	  MVar		-- abstract
	, newEmptyMVar  -- :: IO (MVar a)
	, newMVar 	-- :: a -> IO (MVar a)
	, takeMVar 	-- :: MVar a -> IO a
	, putMVar  	-- :: MVar a -> a -> IO ()
	, readMVar 	-- :: MVar a -> IO a
	, swapMVar 	-- :: MVar a -> a -> IO a
	, tryTakeMVar   -- :: MVar a -> IO (Maybe a)
	, tryPutMVar    -- :: MVar a -> a -> IO Bool
	, isEmptyMVar	-- :: MVar a -> IO Bool
	, withMVar	-- :: MVar a -> (a -> IO b) -> IO b
	, modifyMVar_ 	-- :: MVar a -> (a -> IO a) -> IO ()
	, modifyMVar 	-- :: MVar a -> (a -> IO (a,b)) -> IO b



    ) where


import Hugs.ConcBase ( MVar, newEmptyMVar, newMVar, takeMVar, putMVar,
		  tryTakeMVar, tryPutMVar, isEmptyMVar,
		)








import Prelude
import Control.Exception as Exception

{-|
  This is a combination of 'takeMVar' and 'putMVar'; ie. it takes the value
  from the 'MVar', puts it back, and also returns it.
-}
readMVar :: MVar a -> IO a
readMVar m =
  block $ do
    a <- takeMVar m
    putMVar m a
    return a

-- |Swap the contents of an 'MVar' for a new value.
swapMVar :: MVar a -> a -> IO a
swapMVar mvar new =
  block $ do
    old <- takeMVar mvar
    putMVar mvar new
    return old

{-|
  'withMVar' is a safe wrapper for operating on the contents of an
  'MVar'.  This operation is exception-safe: it will replace the
  original contents of the 'MVar' if an exception is raised (see
  "Control.Exception").
-}
{-# INLINE withMVar #-}
-- inlining has been reported to have dramatic effects; see
-- http://www.haskell.org//pipermail/haskell/2006-May/017907.html
withMVar :: MVar a -> (a -> IO b) -> IO b
withMVar m io = 
  block $ do
    a <- takeMVar m
    b <- Exception.catch (unblock (io a))
      	    (\e -> do putMVar m a; throw e)
    putMVar m a
    return b

{-|
  A safe wrapper for modifying the contents of an 'MVar'.  Like 'withMVar', 
  'modifyMVar' will replace the original contents of the 'MVar' if an
  exception is raised during the operation.
-}
{-# INLINE modifyMVar_ #-}
modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
modifyMVar_ m io = 
  block $ do
    a  <- takeMVar m
    a' <- Exception.catch (unblock (io a))
      	    (\e -> do putMVar m a; throw e)
    putMVar m a'

{-|
  A slight variation on 'modifyMVar_' that allows a value to be
  returned (@b@) in addition to the modified value of the 'MVar'.
-}
{-# INLINE modifyMVar #-}
modifyMVar :: MVar a -> (a -> IO (a,b)) -> IO b
modifyMVar m io = 
  block $ do
    a      <- takeMVar m
    (a',b) <- Exception.catch (unblock (io a))
      	        (\e -> do putMVar m a; throw e)
    putMVar m a'
    return b
-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Concurrent.QSem
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (concurrency)
--
-- Simple quantity semaphores.
--
-----------------------------------------------------------------------------

module Control.Concurrent.QSem
	( -- * Simple Quantity Semaphores
	  QSem,		-- abstract
	  newQSem,	-- :: Int  -> IO QSem
	  waitQSem,	-- :: QSem -> IO ()
	  signalQSem	-- :: QSem -> IO ()
	) where

import Prelude
import Control.Concurrent.MVar
import Data.Typeable

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
























































-- General semaphores are also implemented readily in terms of shared
-- @MVar@s, only have to catch the case when the semaphore is tried
-- waited on when it is empty (==0). Implement this in the same way as
-- shared variables are implemented - maintaining a list of @MVar@s
-- representing threads currently waiting. The counter is a shared
-- variable, ensuring the mutual exclusion on its access.

-- |A 'QSem' is a simple quantity semaphore, in which the available
-- \"quantity\" is always dealt with in units of one.
newtype QSem = QSem (MVar (Int, [MVar ()]))

qSemTc = mkTyCon "QSem"; instance Typeable QSem where { typeOf _ = mkTyConApp qSemTc [] }

-- |Build a new 'QSem'
newQSem :: Int -> IO QSem
newQSem init = do
   sem <- newMVar (init,[])
   return (QSem sem)

-- |Wait for a unit to become available
waitQSem :: QSem -> IO ()
waitQSem (QSem sem) = do
   (avail,blocked) <- takeMVar sem  -- gain ex. access
   if avail > 0 then
     putMVar sem (avail-1,[])
    else do
     block <- newEmptyMVar
      {-
	Stuff the reader at the back of the queue,
	so as to preserve waiting order. A signalling
	process then only have to pick the MVar at the
	front of the blocked list.

	The version of waitQSem given in the paper could
	lead to starvation.
      -}
     putMVar sem (0, blocked++[block])
     takeMVar block

-- |Signal that a unit of the 'QSem' is available
signalQSem :: QSem -> IO ()
signalQSem (QSem sem) = do
   (avail,blocked) <- takeMVar sem
   case blocked of
     [] -> putMVar sem (avail+1,[])

     (block:blocked') -> do
	   putMVar sem (0,blocked')
	   putMVar block ()
-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Concurrent.QSemN
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (concurrency)
--
-- Quantity semaphores in which each thread may wait for an arbitrary
-- \"amount\".
--
-----------------------------------------------------------------------------

module Control.Concurrent.QSemN
	(  -- * General Quantity Semaphores
	  QSemN,	-- abstract
	  newQSemN,	-- :: Int   -> IO QSemN
	  waitQSemN,	-- :: QSemN -> Int -> IO ()
	  signalQSemN	-- :: QSemN -> Int -> IO ()
      ) where

import Prelude

import Control.Concurrent.MVar
import Data.Typeable

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
























































-- |A 'QSemN' is a quantity semaphore, in which the available
-- \"quantity\" may be signalled or waited for in arbitrary amounts.
newtype QSemN = QSemN (MVar (Int,[(Int,MVar ())]))

qSemNTc = mkTyCon "QSemN"; instance Typeable QSemN where { typeOf _ = mkTyConApp qSemNTc [] }

-- |Build a new 'QSemN' with a supplied initial quantity.
newQSemN :: Int -> IO QSemN 
newQSemN init = do
   sem <- newMVar (init,[])
   return (QSemN sem)

-- |Wait for the specified quantity to become available
waitQSemN :: QSemN -> Int -> IO ()
waitQSemN (QSemN sem) sz = do
  (avail,blocked) <- takeMVar sem   -- gain ex. access
  if (avail - sz) >= 0 then
       -- discharging 'sz' still leaves the semaphore
       -- in an 'unblocked' state.
     putMVar sem (avail-sz,blocked)
   else do
     block <- newEmptyMVar
     putMVar sem (avail, blocked++[(sz,block)])
     takeMVar block

-- |Signal that a given quantity is now available from the 'QSemN'.
signalQSemN :: QSemN -> Int  -> IO ()
signalQSemN (QSemN sem) n = do
   (avail,blocked)   <- takeMVar sem
   (avail',blocked') <- free (avail+n) blocked
   putMVar sem (avail',blocked')
 where
   free avail []    = return (avail,[])
   free avail ((req,block):blocked)
     | avail >= req = do
	putMVar block ()
	free (avail-req) blocked
     | otherwise    = do
	(avail',blocked') <- free avail blocked
        return (avail',(req,block):blocked')
-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Concurrent.SampleVar
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (concurrency)
--
-- Sample variables
--
-----------------------------------------------------------------------------

module Control.Concurrent.SampleVar
       (
	 -- * Sample Variables
         SampleVar,         -- :: type _ =
 
	 newEmptySampleVar, -- :: IO (SampleVar a)
         newSampleVar,      -- :: a -> IO (SampleVar a)
	 emptySampleVar,    -- :: SampleVar a -> IO ()
	 readSampleVar,	    -- :: SampleVar a -> IO a
	 writeSampleVar,    -- :: SampleVar a -> a -> IO ()
	 isEmptySampleVar,  -- :: SampleVar a -> IO Bool

       ) where

import Prelude

import Control.Concurrent.MVar

-- |
-- Sample variables are slightly different from a normal 'MVar':
-- 
--  * Reading an empty 'SampleVar' causes the reader to block.
--    (same as 'takeMVar' on empty 'MVar')
-- 
--  * Reading a filled 'SampleVar' empties it and returns value.
--    (same as 'takeMVar')
-- 
--  * Writing to an empty 'SampleVar' fills it with a value, and
--    potentially, wakes up a blocked reader (same as for 'putMVar' on
--    empty 'MVar').
--
--  * Writing to a filled 'SampleVar' overwrites the current value.
--    (different from 'putMVar' on full 'MVar'.)

type SampleVar a
 = MVar (Int,		-- 1  == full
			-- 0  == empty
			-- <0 no of readers blocked
          MVar a)

-- |Build a new, empty, 'SampleVar'
newEmptySampleVar :: IO (SampleVar a)
newEmptySampleVar = do
   v <- newEmptyMVar
   newMVar (0,v)

-- |Build a 'SampleVar' with an initial value.
newSampleVar :: a -> IO (SampleVar a)
newSampleVar a = do
   v <- newEmptyMVar
   putMVar v a
   newMVar (1,v)

-- |If the SampleVar is full, leave it empty.  Otherwise, do nothing.
emptySampleVar :: SampleVar a -> IO ()
emptySampleVar v = do
   (readers, var) <- takeMVar v
   if readers > 0 then do
     takeMVar var
     putMVar v (0,var)
    else
     putMVar v (readers,var)

-- |Wait for a value to become available, then take it and return.
readSampleVar :: SampleVar a -> IO a
readSampleVar svar = do
--
-- filled => make empty and grab sample
-- not filled => try to grab value, empty when read val.
--
   (readers,val) <- takeMVar svar
   putMVar svar (readers-1,val)
   takeMVar val

-- |Write a value into the 'SampleVar', overwriting any previous value that
-- was there.
writeSampleVar :: SampleVar a -> a -> IO ()
writeSampleVar svar v = do
--
-- filled => overwrite
-- not filled => fill, write val
--
   (readers,val) <- takeMVar svar
   case readers of
     1 -> 
       swapMVar val v >> 
       putMVar svar (1,val)
     _ -> 
       putMVar val v >> 
       putMVar svar (min 1 (readers+1), val)

-- | Returns 'True' if the 'SampleVar' is currently empty.
--
-- Note that this function is only useful if you know that no other
-- threads can be modifying the state of the 'SampleVar', because
-- otherwise the state of the 'SampleVar' may have changed by the time
-- you see the result of 'isEmptySampleVar'.
--
isEmptySampleVar :: SampleVar a -> IO Bool
isEmptySampleVar svar = do
   (readers,val) <- readMVar svar
   return (readers == 0)

-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Monad.Fix
-- Copyright   :  (c) Andy Gill 2001,
-- 		  (c) Oregon Graduate Institute of Science and Technology, 2002
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- Monadic fixpoints.
--
-- For a detailed discussion, see Levent Erkok's thesis,
-- /Value Recursion in Monadic Computations/, Oregon Graduate Institute, 2002.
--
-----------------------------------------------------------------------------

module Control.Monad.Fix (
	MonadFix(
	   mfix	-- :: (a -> m a) -> m a
         ),
	fix	-- :: (a -> a) -> a
  ) where

import Prelude
import System.IO
import Control.Monad.Instances ()

-- | @'fix' f@ is the least fixed point of the function @f@,
-- i.e. the least defined @x@ such that @f x = x@.
fix :: (a -> a) -> a
fix f = let x = f x in x

-- | Monads having fixed points with a \'knot-tying\' semantics.
-- Instances of 'MonadFix' should satisfy the following laws:
--
-- [/purity/]
--	@'mfix' ('return' . h)  =  'return' ('fix' h)@
--
-- [/left shrinking/ (or /tightening/)]
--	@'mfix' (\\x -> a >>= \\y -> f x y)  =  a >>= \\y -> 'mfix' (\\x -> f x y)@
--
-- [/sliding/]
--	@'mfix' ('Control.Monad.liftM' h . f)  =  'Control.Monad.liftM' h ('mfix' (f . h))@,
--	for strict @h@.
--
-- [/nesting/]
--	@'mfix' (\\x -> 'mfix' (\\y -> f x y))  =  'mfix' (\\x -> f x x)@
--
-- This class is used in the translation of the recursive @do@ notation
-- supported by GHC and Hugs.
class (Monad m) => MonadFix m where
	-- | The fixed point of a monadic computation.
	-- @'mfix' f@ executes the action @f@ only once, with the eventual
	-- output fed back as the input.  Hence @f@ should not be strict,
	-- for then @'mfix' f@ would diverge.
	mfix :: (a -> m a) -> m a

-- Instances of MonadFix for Prelude monads

-- Maybe:
instance MonadFix Maybe where
    mfix f = let a = f (unJust a) in a
             where unJust (Just x) = x

-- List:
instance MonadFix [] where
    mfix f = case fix (f . head) of
               []    -> []
               (x:_) -> x : mfix (tail . f)

-- IO:
instance MonadFix IO where
    mfix = fixIO 

instance MonadFix ((->) r) where
    mfix f = \ r -> let a = f a r in a
{-# OPTIONS_NHC98 -prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Monad.Instances
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
--
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- 'Functor' and 'Monad' instances for @(->) r@ and
-- 'Functor' instances for @(,) a@ and @'Either' a@.

module Control.Monad.Instances (Functor(..),Monad(..)) where

import Prelude

instance Functor ((->) r) where
	fmap = (.)

instance Monad ((->) r) where
	return = const
	f >>= k = \ r -> k (f r) r

instance Functor ((,) a) where
	fmap f (x,y) = (x, f y)

instance Functor (Either a) where
	fmap _ (Left x) = Left x
	fmap f (Right y) = Right (f y)
-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Monad.ST
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (requires universal quantification for runST)
--
-- This library provides support for /strict/ state threads, as
-- described in the PLDI \'94 paper by John Launchbury and Simon Peyton
-- Jones /Lazy Functional State Threads/.
--
-----------------------------------------------------------------------------

module Control.Monad.ST
  (
	-- * The 'ST' Monad
	ST,		-- abstract, instance of Functor, Monad, Typeable.
	runST,		-- :: (forall s. ST s a) -> a
	fixST,		-- :: (a -> ST s a) -> ST s a

	-- * Converting 'ST' to 'IO'
	RealWorld,		-- abstract
	stToIO,			-- :: ST RealWorld a -> IO a

	-- * Unsafe operations
	unsafeInterleaveST,  	-- :: ST s a -> ST s a
	unsafeIOToST,		-- :: IO a -> ST s a
	unsafeSTToIO		-- :: ST s a -> IO a
      ) where

import Prelude

import Control.Monad.Fix

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

























































import Data.Typeable
import Hugs.ST
import qualified Hugs.LazyST as LazyST

sTTc = mkTyCon "ST"; instance Typeable2 ST where { typeOf2 _ = mkTyConApp sTTc [] }; instance Typeable a => Typeable1 (ST a) where {   typeOf1 = typeOf1Default }; instance (Typeable a, Typeable b) => Typeable (ST a b) where {   typeOf = typeOfDefault }
realWorldTc = mkTyCon "RealWorld"; instance Typeable RealWorld where { typeOf _ = mkTyConApp realWorldTc [] }

fixST :: (a -> ST s a) -> ST s a
fixST f = LazyST.lazyToStrictST (LazyST.fixST (LazyST.strictToLazyST . f))

unsafeInterleaveST :: ST s a -> ST s a
unsafeInterleaveST =
    LazyST.lazyToStrictST . LazyST.unsafeInterleaveST . LazyST.strictToLazyST








instance MonadFix (ST s) where
	mfix = fixST

-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Monad.ST.Lazy
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  non-portable (requires universal quantification for runST)
--
-- This module presents an identical interface to "Control.Monad.ST",
-- except that the monad delays evaluation of state operations until
-- a value depending on them is required.
--
-----------------------------------------------------------------------------

module Control.Monad.ST.Lazy (
	-- * The 'ST' monad
	ST,
	runST,
	fixST,

	-- * Converting between strict and lazy 'ST'
	strictToLazyST, lazyToStrictST,

	-- * Converting 'ST' To 'IO'
	RealWorld,
	stToIO,

	-- * Unsafe operations
	unsafeInterleaveST,
	unsafeIOToST
    ) where

import Prelude

import Control.Monad.Fix

import Control.Monad.ST (RealWorld)
import qualified Control.Monad.ST as ST








import Hugs.LazyST






























































instance MonadFix (ST s) where
	mfix = fixST

-- ---------------------------------------------------------------------------
-- Strict <--> Lazy



























unsafeIOToST :: IO a -> ST s a
unsafeIOToST = strictToLazyST . ST.unsafeIOToST

-- | A monad transformer embedding lazy state transformers in the 'IO'
-- monad.  The 'RealWorld' parameter indicates that the internal state
-- used by the 'ST' computation is a special one supplied by the 'IO'
-- monad, and thus distinct from those used by invocations of 'runST'.
stToIO :: ST RealWorld a -> IO a
stToIO = ST.stToIO . lazyToStrictST
-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Monad.ST.Strict
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  non-portable (requires universal quantification for runST)
--
-- The strict ST monad (re-export of "Control.Monad.ST")
--
-----------------------------------------------------------------------------

module Control.Monad.ST.Strict (
 	module Control.Monad.ST
  ) where

import Prelude
import Control.Monad.ST
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Array 
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Basic non-strict arrays.
--
-- /Note:/ The "Data.Array.IArray" module provides more general interface
-- to immutable arrays: it defines operations with the same names as
-- those defined below, but with more general types, and also defines
-- 'Array' instances of the relevant classes.  To use that more general
-- interface, import "Data.Array.IArray" but not "Data.Array".
-----------------------------------------------------------------------------

module  Data.Array 

    ( 
    -- * Immutable non-strict arrays
    -- $intro
      module Data.Ix		-- export all of Ix 
    , Array 			-- Array type is abstract

    -- * Array construction
    , array	    -- :: (Ix a) => (a,a) -> [(a,b)] -> Array a b
    , listArray     -- :: (Ix a) => (a,a) -> [b] -> Array a b
    , accumArray    -- :: (Ix a) => (b -> c -> b) -> b -> (a,a) -> [(a,c)] -> Array a b
    -- * Accessing arrays
    , (!)           -- :: (Ix a) => Array a b -> a -> b
    , bounds        -- :: (Ix a) => Array a b -> (a,a)
    , indices       -- :: (Ix a) => Array a b -> [a]
    , elems         -- :: (Ix a) => Array a b -> [b]
    , assocs        -- :: (Ix a) => Array a b -> [(a,b)]
    -- * Incremental array updates
    , (//)          -- :: (Ix a) => Array a b -> [(a,b)] -> Array a b
    , accum         -- :: (Ix a) => (b -> c -> b) -> Array a b -> [(a,c)] -> Array a b
    -- * Derived arrays
    , ixmap         -- :: (Ix a, Ix b) => (a,a) -> (a -> b) -> Array b c -> Array a b

    -- Array instances:
    --
    --   Ix a => Functor (Array a)
    --   (Ix a, Eq b)  => Eq   (Array a b)
    --   (Ix a, Ord b) => Ord  (Array a b)
    --   (Ix a, Show a, Show b) => Show (Array a b)
    --   (Ix a, Read a, Read b) => Read (Array a b)
    -- 

    -- Implementation checked wrt. Haskell 98 lib report, 1/99.

    ) where

import Data.Ix









import Hugs.Array






import Data.Typeable

{- $intro
Haskell provides indexable /arrays/, which may be thought of as functions
whose domains are isomorphic to contiguous subsets of the integers.
Functions restricted in this way can be implemented efficiently;
in particular, a programmer may reasonably expect rapid access to
the components.  To ensure the possibility of such an implementation,
arrays are treated as data, not as general functions.

Since most array functions involve the class 'Ix', this module is exported
from "Data.Array" so that modules need not import both "Data.Array" and
"Data.Ix".
-}
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Bits
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
--  This module defines bitwise operations for signed and unsigned
--  integers.  Instances of the class 'Bits' for the 'Int' and
--  'Integer' types are available from this module, and instances for
--  explicitly sized integral types are available from the
--  "Data.Int" and "Data.Word" modules.
--
-----------------------------------------------------------------------------

module Data.Bits ( 
  Bits(
    (.&.), (.|.), xor, -- :: a -> a -> a
    complement,        -- :: a -> a
    shift,             -- :: a -> Int -> a
    rotate,            -- :: a -> Int -> a
    bit,               -- :: Int -> a
    setBit,            -- :: a -> Int -> a
    clearBit,          -- :: a -> Int -> a
    complementBit,     -- :: a -> Int -> a
    testBit,           -- :: a -> Int -> Bool
    bitSize,           -- :: a -> Int
    isSigned,          -- :: a -> Bool
    shiftL, shiftR,    -- :: a -> Int -> a
    rotateL, rotateR   -- :: a -> Int -> a
  )

  -- instance Bits Int
  -- instance Bits Integer
 ) where

-- Defines the @Bits@ class containing bit-based operations.
-- See library document for details on the semantics of the
-- individual operations.


                                                                                                                                                                                                        

                                                                        
                                                                          

                               
                                                                                                            







                                                      












                                                         












                                


                                  


                                 


                               


                                


                                     


                                 


                                         


                                        


                                         


                                              


                                          


                                  


                                                           


                                                         


                                                         


                                                         


                                                         


                                                          


                                                         


                                                           


                                                            


                                                         


                                                                              


                                              


                                                          


                                                          


                                               


                                            


                                                


                                                  


                                                 


                                               


                                                


                                                     


                                                 


                                                         


                                                        


                                                         


                                                              


                                                          


                                                  


                                                      




























































import Hugs.Bits


infixl 8 `shift`, `rotate`, `shiftL`, `shiftR`, `rotateL`, `rotateR`
infixl 7 .&.
infixl 6 `xor`
infixl 5 .|.

{-| 
The 'Bits' class defines bitwise operations over integral types.

* Bits are numbered from 0 with bit 0 being the least
  significant bit.

Minimal complete definition: '.&.', '.|.', 'xor', 'complement',
('shift' or ('shiftL' and 'shiftR')), ('rotate' or ('rotateL' and 'rotateR')),
'bitSize' and 'isSigned'.
-}
class Num a => Bits a where
    -- | Bitwise \"and\"
    (.&.) :: a -> a -> a

    -- | Bitwise \"or\"
    (.|.) :: a -> a -> a

    -- | Bitwise \"xor\"
    xor :: a -> a -> a

    {-| Reverse all the bits in the argument -}
    complement        :: a -> a

    {-| Shift the argument left by the specified number of bits.
	Right shifts (signed) are specified by giving a negative value.

	An instance can define either this unified 'shift' or 'shiftL' and
	'shiftR', depending on which is more convenient for the type in
	question. -}
    shift             :: a -> Int -> a

    x `shift`   i | i<0  = x `shiftR` (-i)
                  | i==0 = x
                  | i>0  = x `shiftL` i

    {-| Rotate the argument left by the specified number of bits.
	Right rotates are specified by giving a negative value.

        For unbounded types like 'Integer', 'rotate' is equivalent to 'shift'.

	An instance can define either this unified 'rotate' or 'rotateL' and
	'rotateR', depending on which is more convenient for the type in
	question. -}
    rotate            :: a -> Int -> a

    x `rotate`  i | i<0  = x `rotateR` (-i)
                  | i==0 = x
                  | i>0  = x `rotateL` i

    {-
    -- Rotation can be implemented in terms of two shifts, but care is
    -- needed for negative values.  This suggested implementation assumes
    -- 2's-complement arithmetic.  It is commented out because it would
    -- require an extra context (Ord a) on the signature of 'rotate'.
    x `rotate`  i | i<0 && isSigned x && x<0
                         = let left = i+bitSize x in
                           ((x `shift` i) .&. complement ((-1) `shift` left))
                           .|. (x `shift` left)
                  | i<0  = (x `shift` i) .|. (x `shift` (i+bitSize x))
                  | i==0 = x
                  | i>0  = (x `shift` i) .|. (x `shift` (i-bitSize x))
    -}

    -- | @bit i@ is a value with the @i@th bit set
    bit               :: Int -> a

    -- | @x \`setBit\` i@ is the same as @x .|. bit i@
    setBit            :: a -> Int -> a

    -- | @x \`clearBit\` i@ is the same as @x .&. complement (bit i)@
    clearBit          :: a -> Int -> a

    -- | @x \`complementBit\` i@ is the same as @x \`xor\` bit i@
    complementBit     :: a -> Int -> a

    -- | Return 'True' if the @n@th bit of the argument is 1
    testBit           :: a -> Int -> Bool

    {-| Return the number of bits in the type of the argument.  The actual
	value of the argument is ignored.  The function 'bitSize' is
	undefined for types that do not have a fixed bitsize, like 'Integer'.
	-}
    bitSize           :: a -> Int

    {-| Return 'True' if the argument is a signed type.  The actual
        value of the argument is ignored -}
    isSigned          :: a -> Bool

    bit i               = 1 `shiftL` i
    x `setBit` i        = x .|. bit i
    x `clearBit` i      = x .&. complement (bit i)
    x `complementBit` i = x `xor` bit i
    x `testBit` i       = (x .&. bit i) /= 0

    {-| Shift the argument left by the specified number of bits
	(which must be non-negative).

	An instance can define either this and 'shiftR' or the unified
	'shift', depending on which is more convenient for the type in
	question. -}
    shiftL            :: a -> Int -> a
    x `shiftL`  i = x `shift`  i

    {-| Shift the argument right (signed) by the specified number of bits
	(which must be non-negative).

	An instance can define either this and 'shiftL' or the unified
	'shift', depending on which is more convenient for the type in
	question. -}
    shiftR            :: a -> Int -> a
    x `shiftR`  i = x `shift`  (-i)

    {-| Rotate the argument left by the specified number of bits
	(which must be non-negative).

	An instance can define either this and 'rotateR' or the unified
	'rotate', depending on which is more convenient for the type in
	question. -}
    rotateL           :: a -> Int -> a
    x `rotateL` i = x `rotate` i

    {-| Rotate the argument right by the specified number of bits
	(which must be non-negative).

	An instance can define either this and 'rotateL' or the unified
	'rotate', depending on which is more convenient for the type in
	question. -}
    rotateR           :: a -> Int -> a
    x `rotateR` i = x `rotate` (-i)

instance Bits Int where



















    (.&.)                  = primAndInt
    (.|.)                  = primOrInt
    xor                    = primXorInt
    complement             = primComplementInt
    shift                  = primShiftInt
    bit                    = primBitInt
    testBit                = primTestInt
    bitSize _              = 4*8










    x `rotate`  i
	| i<0 && x<0       = let left = i+bitSize x in
                             ((x `shift` i) .&. complement ((-1) `shift` left))
                             .|. (x `shift` left)
	| i<0              = (x `shift` i) .|. (x `shift` (i+bitSize x))
	| i==0             = x
	| i>0              = (x `shift` i) .|. (x `shift` (i-bitSize x))



    isSigned _             = True










instance Bits Integer where

























   -- reduce bitwise binary operations to special cases we can handle

   x .&. y   | x<0 && y<0 = complement (complement x `posOr` complement y)
	     | otherwise  = x `posAnd` y
   
   x .|. y   | x<0 || y<0 = complement (complement x `posAnd` complement y)
	     | otherwise  = x `posOr` y
   
   x `xor` y | x<0 && y<0 = complement x `posXOr` complement y
	     | x<0        = complement (complement x `posXOr` y)
	     |        y<0 = complement (x `posXOr` complement y)
	     | otherwise  = x `posXOr` y

   -- assuming infinite 2's-complement arithmetic
   complement a = -1 - a


   shift x i | i >= 0    = x * 2^i
	     | otherwise = x `div` 2^(-i)

   rotate x i = shift x i   -- since an Integer never wraps around

   bitSize _  = error "Data.Bits.bitSize(Integer)"
   isSigned _ = True


-- Crude implementation of bitwise operations on Integers: convert them
-- to finite lists of Ints (least significant first), zip and convert
-- back again.

-- posAnd requires at least one argument non-negative
-- posOr and posXOr require both arguments non-negative

posAnd, posOr, posXOr :: Integer -> Integer -> Integer
posAnd x y   = fromInts $ zipWith (.&.) (toInts x) (toInts y)
posOr x y    = fromInts $ longZipWith (.|.) (toInts x) (toInts y)
posXOr x y   = fromInts $ longZipWith xor (toInts x) (toInts y)

longZipWith :: (a -> a -> a) -> [a] -> [a] -> [a]
longZipWith f xs [] = xs
longZipWith f [] ys = ys
longZipWith f (x:xs) (y:ys) = f x y:longZipWith f xs ys

toInts :: Integer -> [Int]
toInts n
    | n == 0 = []
    | otherwise = mkInt (n `mod` numInts):toInts (n `div` numInts)
  where mkInt n | n > toInteger(maxBound::Int) = fromInteger (n-numInts)
		| otherwise = fromInteger n

fromInts :: [Int] -> Integer
fromInts = foldr catInt 0
    where catInt d n = (if d<0 then n+1 else n)*numInts + toInteger d

numInts = toInteger (maxBound::Int) - toInteger (minBound::Int) + 1

{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Bool
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- The 'Bool' type and related functions.
--
-----------------------------------------------------------------------------

module Data.Bool (
   -- * Booleans
   Bool(..),
   -- ** Operations 
   (&&),	-- :: Bool -> Bool -> Bool
   (||),	-- :: Bool -> Bool -> Bool
   not,		-- :: Bool -> Bool
   otherwise,	-- :: Bool
  ) where















{-# OPTIONS_GHC -cpp -fglasgow-exts -fno-warn-orphans #-}
--
-- Module      : ByteString
-- Copyright   : (c) The University of Glasgow 2001,
--               (c) David Roundy 2003-2005,
--               (c) Simon Marlow 2005
--               (c) Don Stewart 2005-2006
--               (c) Bjorn Bringert 2006
--
-- Array fusion code:
--               (c) 2001,2002 Manuel M T Chakravarty & Gabriele Keller
--               (c) 2006      Manuel M T Chakravarty & Roman Leshchinskiy
--
-- License     : BSD-style
--
-- Maintainer  : dons@cse.unsw.edu.au
-- Stability   : experimental
-- Portability : portable, requires ffi and cpp
-- Tested with : GHC 6.4.1 and Hugs March 2005
-- 

--
-- | A time and space-efficient implementation of byte vectors using
-- packed Word8 arrays, suitable for high performance use, both in terms
-- of large data quantities, or high speed requirements. Byte vectors
-- are encoded as strict 'Word8' arrays of bytes, held in a 'ForeignPtr',
-- and can be passed between C and Haskell with little effort.
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.
--
-- > import qualified Data.ByteString as B
--
-- Original GHC implementation by Bryan O\'Sullivan. Rewritten to use
-- UArray by Simon Marlow. Rewritten to support slices and use
-- ForeignPtr by David Roundy. Polished and extended by Don Stewart.
--

module Data.ByteString (

        -- * The @ByteString@ type
        ByteString,             -- abstract, instances: Eq, Ord, Show, Read, Data, Typeable, Monoid

        -- * Introducing and eliminating 'ByteString's
        empty,                  -- :: ByteString
        singleton,              -- :: Word8   -> ByteString
        pack,                   -- :: [Word8] -> ByteString
        unpack,                 -- :: ByteString -> [Word8]

        -- * Basic interface
        cons,                   -- :: Word8 -> ByteString -> ByteString
        snoc,                   -- :: ByteString -> Word8 -> ByteString
        append,                 -- :: ByteString -> ByteString -> ByteString
        head,                   -- :: ByteString -> Word8
        last,                   -- :: ByteString -> Word8
        tail,                   -- :: ByteString -> ByteString
        init,                   -- :: ByteString -> ByteString
        null,                   -- :: ByteString -> Bool
        length,                 -- :: ByteString -> Int

        -- * Transformating ByteStrings
        map,                    -- :: (Word8 -> Word8) -> ByteString -> ByteString
        reverse,                -- :: ByteString -> ByteString
        intersperse,            -- :: Word8 -> ByteString -> ByteString
        transpose,              -- :: [ByteString] -> [ByteString]

        -- * Reducing 'ByteString's (folds)
        foldl,                  -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldl',                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldl1',                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8

        foldr,                  -- :: (Word8 -> a -> a) -> a -> ByteString -> a
        foldr',                 -- :: (Word8 -> a -> a) -> a -> ByteString -> a
        foldr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldr1',                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8

        -- ** Special folds
        concat,                 -- :: [ByteString] -> ByteString
        concatMap,              -- :: (Word8 -> ByteString) -> ByteString -> ByteString
        any,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
        all,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
        maximum,                -- :: ByteString -> Word8
        minimum,                -- :: ByteString -> Word8

        -- * Building ByteStrings
        -- ** Scans
        scanl,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
        scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString

        -- ** Accumulating maps
        mapAccumL,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumR,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
        mapIndexed,             -- :: (Int -> Word8 -> Word8) -> ByteString -> ByteString

        -- ** Unfolding ByteStrings
        replicate,              -- :: Int -> Word8 -> ByteString
        unfoldr,                -- :: (a -> Maybe (Word8, a)) -> a -> ByteString
        unfoldrN,               -- :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)

        -- * Substrings

        -- ** Breaking strings
        take,                   -- :: Int -> ByteString -> ByteString
        drop,                   -- :: Int -> ByteString -> ByteString
        splitAt,                -- :: Int -> ByteString -> (ByteString, ByteString)
        takeWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
        dropWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
        span,                   -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        spanEnd,                -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        break,                  -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        breakEnd,               -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        group,                  -- :: ByteString -> [ByteString]
        groupBy,                -- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
        inits,                  -- :: ByteString -> [ByteString]
        tails,                  -- :: ByteString -> [ByteString]

        -- ** Breaking into many substrings
        split,                  -- :: Word8 -> ByteString -> [ByteString]
        splitWith,              -- :: (Word8 -> Bool) -> ByteString -> [ByteString]

        -- ** Joining strings
        join,                   -- :: ByteString -> [ByteString] -> ByteString

        -- * Predicates
        isPrefixOf,             -- :: ByteString -> ByteString -> Bool
        isSuffixOf,             -- :: ByteString -> ByteString -> Bool

        -- ** Search for arbitrary substrings
        isSubstringOf,          -- :: ByteString -> ByteString -> Bool
        findSubstring,          -- :: ByteString -> ByteString -> Maybe Int
        findSubstrings,         -- :: ByteString -> ByteString -> [Int]

        -- * Searching ByteStrings

        -- ** Searching by equality
        -- | These functions use memchr(3) to efficiently search the ByteString
        elem,                   -- :: Word8 -> ByteString -> Bool
        notElem,                -- :: Word8 -> ByteString -> Bool

        -- ** Searching with a predicate
        find,                   -- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
        filter,                 -- :: (Word8 -> Bool) -> ByteString -> ByteString
--      partition               -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)

        -- * Indexing ByteStrings
        index,                  -- :: ByteString -> Int -> Word8
        elemIndex,              -- :: Word8 -> ByteString -> Maybe Int
        elemIndices,            -- :: Word8 -> ByteString -> [Int]
        elemIndexEnd,           -- :: Word8 -> ByteString -> Maybe Int
        findIndex,              -- :: (Word8 -> Bool) -> ByteString -> Maybe Int
        findIndices,            -- :: (Word8 -> Bool) -> ByteString -> [Int]
        count,                  -- :: Word8 -> ByteString -> Int

        -- * Zipping and unzipping ByteStrings
        zip,                    -- :: ByteString -> ByteString -> [(Word8,Word8)]
        zipWith,                -- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
        unzip,                  -- :: [(Word8,Word8)] -> (ByteString,ByteString)

        -- * Ordered ByteStrings
        sort,                   -- :: ByteString -> ByteString

        -- * Low level CString conversions

        -- ** Packing CStrings and pointers
        packCString,            -- :: CString -> ByteString
        packCStringLen,         -- :: CString -> ByteString
        packMallocCString,      -- :: CString -> ByteString

        -- ** Using ByteStrings as CStrings
        useAsCString,           -- :: ByteString -> (CString -> IO a) -> IO a
        useAsCStringLen,        -- :: ByteString -> (CStringLen -> IO a) -> IO a

        -- ** Copying ByteStrings
        -- | These functions perform memcpy(3) operations
        copy,                   -- :: ByteString -> ByteString
        copyCString,            -- :: CString -> IO ByteString
        copyCStringLen,         -- :: CStringLen -> IO ByteString

        -- * I\/O with 'ByteString's

        -- ** Standard input and output
        getLine,                -- :: IO ByteString
        getContents,            -- :: IO ByteString
        putStr,                 -- :: ByteString -> IO ()
        putStrLn,               -- :: ByteString -> IO ()
        interact,               -- :: (ByteString -> ByteString) -> IO ()

        -- ** Files
        readFile,               -- :: FilePath -> IO ByteString
        writeFile,              -- :: FilePath -> ByteString -> IO ()
        appendFile,             -- :: FilePath -> ByteString -> IO ()
--      mmapFile,               -- :: FilePath -> IO ByteString

        -- ** I\/O with Handles
        hGetLine,               -- :: Handle -> IO ByteString
        hGetContents,           -- :: Handle -> IO ByteString
        hGet,                   -- :: Handle -> Int -> IO ByteString
        hGetNonBlocking,        -- :: Handle -> Int -> IO ByteString
        hPut,                   -- :: Handle -> ByteString -> IO ()
        hPutStr,                -- :: Handle -> ByteString -> IO ()
        hPutStrLn,              -- :: Handle -> ByteString -> IO ()







  ) where

import qualified Prelude as P
import Prelude hiding           (reverse,head,tail,last,init,null
                                ,length,map,lines,foldl,foldr,unlines
                                ,concat,any,take,drop,splitAt,takeWhile
                                ,dropWhile,span,break,elem,filter,maximum
                                ,minimum,all,concatMap,foldl1,foldr1
                                ,scanl,scanl1,scanr,scanr1
                                ,readFile,writeFile,appendFile,replicate
                                ,getContents,getLine,putStr,putStrLn,interact
                                ,zip,zipWith,unzip,notElem)

import Data.ByteString.Base
import Data.ByteString.Fusion

import qualified Data.List as List

import Data.Word                (Word8)
import Data.Maybe               (listToMaybe)
import Data.Array               (listArray)
import qualified Data.Array as Array ((!))

-- Control.Exception.bracket not available in yhc or nhc
import Control.Exception        (bracket, assert)
import qualified Control.Exception as Exception
import Control.Monad            (when)

import Foreign.C.String         (CString, CStringLen)
import Foreign.C.Types          (CSize)
import Foreign.ForeignPtr
import Foreign.Marshal.Array
import Foreign.Ptr
import Foreign.Storable         (Storable(..))

-- hGetBuf and hPutBuf not available in yhc or nhc
import System.IO                (stdin,stdout,hClose,hFileSize
                                ,hGetBuf,hPutBuf,openBinaryFile
                                ,Handle,IOMode(..))

import Data.Monoid              (Monoid, mempty, mappend, mconcat)


import System.IO.Unsafe
import qualified System.Environment
import qualified System.IO      (hGetLine)

















-- -----------------------------------------------------------------------------
--
-- Useful macros, until we have bang patterns
--







-- -----------------------------------------------------------------------------

instance Eq  ByteString
    where (==)    = eq

instance Ord ByteString
    where compare = compareBytes

instance Monoid ByteString where
    mempty  = empty
    mappend = append
    mconcat = concat

{-
instance Arbitrary PackedString where
    arbitrary = P.pack `fmap` arbitrary
    coarbitrary s = coarbitrary (P.unpack s)
-}

-- | /O(n)/ Equality on the 'ByteString' type.
eq :: ByteString -> ByteString -> Bool
eq a@(PS p s l) b@(PS p' s' l')
    | l /= l'            = False    -- short cut on length
    | p == p' && s == s' = True     -- short cut for the same string
    | otherwise          = compareBytes a b == EQ
{-# INLINE eq #-}

-- | /O(n)/ 'compareBytes' provides an 'Ordering' for 'ByteStrings' supporting slices. 
compareBytes :: ByteString -> ByteString -> Ordering
compareBytes (PS x1 s1 l1) (PS x2 s2 l2)
    | l1 == 0  && l2 == 0               = EQ  -- short cut for empty strings
    | x1 == x2 && s1 == s2 && l1 == l2  = EQ  -- short cut for the same string
    | otherwise                         = inlinePerformIO $
        withForeignPtr x1 $ \p1 ->
        withForeignPtr x2 $ \p2 -> do
            i <- memcmp (p1 `plusPtr` s1) (p2 `plusPtr` s2) (fromIntegral $ min l1 l2)
            return $! case i `compare` 0 of
                        EQ  -> l1 `compare` l2
                        x   -> x
{-# INLINE compareBytes #-}

{-
--
-- About 4x slower over 32M
--
compareBytes :: ByteString -> ByteString -> Ordering
compareBytes (PS fp1 off1 len1) (PS fp2 off2 len2) = inlinePerformIO $
    withForeignPtr fp1 $ \p1 ->
        withForeignPtr fp2 $ \p2 ->
            cmp (p1 `plusPtr` off1)
                (p2 `plusPtr` off2) 0 len1 len2

cmp :: Ptr Word8 -> Ptr Word8 -> Int -> Int -> Int-> IO Ordering
STRICT5(cmp)
cmp p1 p2 n len1 len2
      | n == len1 = if n == len2 then return EQ else return LT
      | n == len2 = return GT
      | otherwise = do
          (a :: Word8) <- peekByteOff p1 n
          (b :: Word8) <- peekByteOff p2 n
          case a `compare` b of
                EQ -> cmp p1 p2 (n+1) len1 len2
                LT -> return LT
                GT -> return GT
{-# INLINE compareBytes #-}
-}

-- -----------------------------------------------------------------------------
-- Introducing and eliminating 'ByteString's

-- | /O(1)/ Convert a 'Word8' into a 'ByteString'
singleton :: Word8 -> ByteString
singleton c = unsafeCreate 1 $ \p -> poke p c
{-# INLINE [1] singleton #-}

--
-- XXX The unsafePerformIO is critical!
--
-- Otherwise:
--
--  singleton 255 `compare` singleton 127
--
-- is compiled to:
--
--  case mallocByteString 2 of 
--      ForeignPtr f internals -> 
--           case writeWord8OffAddr# f 0 255 of _ -> 
--           case writeWord8OffAddr# f 0 127 of _ ->
--           case eqAddr# f f of 
--                  False -> case compare (GHC.Prim.plusAddr# f 0) 
--                                        (GHC.Prim.plusAddr# f 0)
--
--

-- | /O(n)/ Convert a '[Word8]' into a 'ByteString'. 
--
-- For applications with large numbers of string literals, pack can be a
-- bottleneck. In such cases, consider using packAddress (GHC only).
pack :: [Word8] -> ByteString



pack str = unsafeCreate (P.length str) $ \p -> go p str
    where
        go _ []     = return ()
        go p (x:xs) = poke p x >> go (p `plusPtr` 1) xs -- less space than pokeElemOff













-- | /O(n)/ Converts a 'ByteString' to a '[Word8]'.
unpack :: ByteString -> [Word8]



unpack (PS _  _ 0) = []
unpack (PS ps s l) = inlinePerformIO $ withForeignPtr ps $ \p ->
        go (p `plusPtr` s) (l - 1) []
    where
        go a b c | a `seq` b `seq` c `seq` False = undefined
        go p 0 acc = peek p          >>= \e -> return (e : acc)
        go p n acc = peekByteOff p n >>= \e -> go p (n-1) (e : acc)
{-# INLINE unpack #-}





































-- ---------------------------------------------------------------------
-- Basic interface

-- | /O(1)/ Test whether a ByteString is empty.
null :: ByteString -> Bool
null (PS _ _ l) = assert (l >= 0) $ l <= 0
{-# INLINE null #-}

-- ---------------------------------------------------------------------
-- | /O(1)/ 'length' returns the length of a ByteString as an 'Int'.
length :: ByteString -> Int
length (PS _ _ l) = assert (l >= 0) $ l

--
-- length/loop fusion. When taking the length of any fuseable loop,
-- rewrite it as a foldl', and thus avoid allocating the result buffer
-- worth around 10% in speed testing.
--





lengthU :: ByteString -> Int
lengthU = foldl' (const . (+1)) (0::Int)
{-# INLINE lengthU #-}

{-# RULES

-- v2 fusion
"FPS length/loop" forall loop s .
  length  (loopArr (loopWrapper loop s)) =
  lengthU (loopArr (loopWrapper loop s))

  #-}

------------------------------------------------------------------------

-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
-- complexity, as it requires a memcpy.
cons :: Word8 -> ByteString -> ByteString
cons c (PS x s l) = unsafeCreate (l+1) $ \p -> withForeignPtr x $ \f -> do
        poke p c
        memcpy (p `plusPtr` 1) (f `plusPtr` s) (fromIntegral l)
{-# INLINE cons #-}

-- | /O(n)/ Append a byte to the end of a 'ByteString'
snoc :: ByteString -> Word8 -> ByteString
snoc (PS x s l) c = unsafeCreate (l+1) $ \p -> withForeignPtr x $ \f -> do
        memcpy p (f `plusPtr` s) (fromIntegral l)
        poke (p `plusPtr` l) c
{-# INLINE snoc #-}

-- todo fuse

-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
-- An exception will be thrown in the case of an empty ByteString.
head :: ByteString -> Word8
head (PS x s l)
    | l <= 0    = errorEmptyList "head"
    | otherwise = inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p s
{-# INLINE head #-}

-- | /O(1)/ Extract the elements after the head of a ByteString, which must be non-empty.
-- An exception will be thrown in the case of an empty ByteString.
tail :: ByteString -> ByteString
tail (PS p s l)
    | l <= 0    = errorEmptyList "tail"
    | otherwise = PS p (s+1) (l-1)
{-# INLINE tail #-}

-- | /O(1)/ Extract the last element of a ByteString, which must be finite and non-empty.
-- An exception will be thrown in the case of an empty ByteString.
last :: ByteString -> Word8
last ps@(PS x s l)
    | null ps   = errorEmptyList "last"
    | otherwise = inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p (s+l-1)
{-# INLINE last #-}

-- | /O(1)/ Return all the elements of a 'ByteString' except the last one.
-- An exception will be thrown in the case of an empty ByteString.
init :: ByteString -> ByteString
init ps@(PS p s l)
    | null ps   = errorEmptyList "init"
    | otherwise = PS p s (l-1)
{-# INLINE init #-}

-- | /O(n)/ Append two ByteStrings
append :: ByteString -> ByteString -> ByteString
append xs ys | null xs   = ys
             | null ys   = xs
             | otherwise = concat [xs,ys]
{-# INLINE append #-}

-- ---------------------------------------------------------------------
-- Transformations

-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each
-- element of @xs@. This function is subject to array fusion.
map :: (Word8 -> Word8) -> ByteString -> ByteString







map f = loopArr . loopMap f

{-# INLINE map #-}

{-
-- | /O(n)/ Like 'map', but not fuseable. The benefit is that it is
-- slightly faster for one-shot cases.
map' :: (Word8 -> Word8) -> ByteString -> ByteString
map' f (PS fp s len) = inlinePerformIO $ withForeignPtr fp $ \a ->
    create len $ map_ 0 (a `plusPtr` s)
  where
    map_ :: Int -> Ptr Word8 -> Ptr Word8 -> IO ()
    STRICT3(map_)
    map_ n p1 p2
       | n >= len = return ()
       | otherwise = do
            x <- peekByteOff p1 n
            pokeByteOff p2 n (f x)
            map_ (n+1) p1 p2
{-# INLINE map' #-}
-}

-- | /O(n)/ 'reverse' @xs@ efficiently returns the elements of @xs@ in reverse order.
reverse :: ByteString -> ByteString
reverse (PS x s l) = unsafeCreate l $ \p -> withForeignPtr x $ \f ->
        c_reverse p (f `plusPtr` s) (fromIntegral l)

-- todo, fuseable version

-- | /O(n)/ The 'intersperse' function takes a 'Word8' and a
-- 'ByteString' and \`intersperses\' that byte between the elements of
-- the 'ByteString'.  It is analogous to the intersperse function on
-- Lists.
intersperse :: Word8 -> ByteString -> ByteString
intersperse c ps@(PS x s l)
    | length ps < 2  = ps
    | otherwise      = unsafeCreate (2*l-1) $ \p -> withForeignPtr x $ \f ->
        c_intersperse p (f `plusPtr` s) (fromIntegral l) c

{-
intersperse c = pack . List.intersperse c . unpack
-}

-- | The 'transpose' function transposes the rows and columns of its
-- 'ByteString' argument.
transpose :: [ByteString] -> [ByteString]
transpose ps = P.map pack (List.transpose (P.map unpack ps))

-- ---------------------------------------------------------------------
-- Reducing 'ByteString's

-- | 'foldl', applied to a binary operator, a starting value (typically
-- the left-identity of the operator), and a ByteString, reduces the
-- ByteString using the binary operator, from left to right.
-- This function is subject to array fusion.
foldl :: (a -> Word8 -> a) -> a -> ByteString -> a

foldl f z = loopAcc . loopUp (foldEFL f) z



{-# INLINE foldl #-}

{-
--
-- About twice as fast with 6.4.1, but not fuseable
-- A simple fold . map is enough to make it worth while.
--
foldl f v (PS x s l) = inlinePerformIO $ withForeignPtr x $ \ptr ->
        lgo v (ptr `plusPtr` s) (ptr `plusPtr` (s+l))
    where
        STRICT3(lgo)
        lgo z p q | p == q    = return z
                  | otherwise = do c <- peek p
                                   lgo (f z c) (p `plusPtr` 1) q
-}

-- | 'foldl\'' is like 'foldl', but strict in the accumulator.
-- Though actually foldl is also strict in the accumulator.
foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
foldl' = foldl
-- foldl' f z = loopAcc . loopU (foldEFL' f) z
{-# INLINE foldl' #-}

-- | 'foldr', applied to a binary operator, a starting value
-- (typically the right-identity of the operator), and a ByteString,
-- reduces the ByteString using the binary operator, from right to left.
foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
foldr k z = loopAcc . loopDown (foldEFL (flip k)) z
{-# INLINE foldr #-}

-- | 'foldr\'' is like 'foldr', but strict in the accumulator.
foldr' :: (Word8 -> a -> a) -> a -> ByteString -> a
foldr' k v (PS x s l) = inlinePerformIO $ withForeignPtr x $ \ptr ->
        go v (ptr `plusPtr` (s+l-1)) (ptr `plusPtr` (s-1))
    where
        go a b c | a `seq` b `seq` c `seq` False = undefined
        go z p q | p == q    = return z
                 | otherwise = do c  <- peek p
                                  go (c `k` z) (p `plusPtr` (-1)) q -- tail recursive
{-# INLINE [1] foldr' #-}

-- | 'foldl1' is a variant of 'foldl' that has no starting value
-- argument, and thus must be applied to non-empty 'ByteStrings'.
-- This function is subject to array fusion. 
-- An exception will be thrown in the case of an empty ByteString.
foldl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1 f ps
    | null ps   = errorEmptyList "foldl1"
    | otherwise = foldl f (unsafeHead ps) (unsafeTail ps)
{-# INLINE foldl1 #-}

-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
-- An exception will be thrown in the case of an empty ByteString.
foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1' f ps
    | null ps   = errorEmptyList "foldl1'"
    | otherwise = foldl' f (unsafeHead ps) (unsafeTail ps)
{-# INLINE foldl1' #-}

-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
-- and thus must be applied to non-empty 'ByteString's
-- An exception will be thrown in the case of an empty ByteString.
foldr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldr1 f ps
    | null ps        = errorEmptyList "foldr1"
    | otherwise      = foldr f (last ps) (init ps)
{-# INLINE foldr1 #-}

-- | 'foldr1\'' is a variant of 'foldr1', but is strict in the
-- accumulator.
foldr1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldr1' f ps
    | null ps        = errorEmptyList "foldr1"
    | otherwise      = foldr' f (last ps) (init ps)
{-# INLINE [1] foldr1' #-}

-- ---------------------------------------------------------------------
-- Special folds

-- | /O(n)/ Concatenate a list of ByteStrings.
concat :: [ByteString] -> ByteString
concat []     = empty
concat [ps]   = ps
concat xs     = unsafeCreate len $ \ptr -> go xs ptr
  where len = P.sum . P.map length $ xs
        go a b | a `seq` b `seq` False = undefined
        go []            _   = return ()
        go (PS p s l:ps) ptr = do
                withForeignPtr p $ \fp -> memcpy ptr (fp `plusPtr` s) (fromIntegral l)
                go ps (ptr `plusPtr` l)

-- | Map a function over a 'ByteString' and concatenate the results
concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
concatMap f = concat . foldr ((:) . f) []

-- foldr (append . f) empty

-- | /O(n)/ Applied to a predicate and a ByteString, 'any' determines if
-- any element of the 'ByteString' satisfies the predicate.
any :: (Word8 -> Bool) -> ByteString -> Bool
any _ (PS _ _ 0) = False
any f (PS x s l) = inlinePerformIO $ withForeignPtr x $ \ptr ->
        go (ptr `plusPtr` s) (ptr `plusPtr` (s+l))
    where
        go a b | a `seq` b `seq` False = undefined
        go p q | p == q    = return False
               | otherwise = do c <- peek p
                                if f c then return True
                                       else go (p `plusPtr` 1) q

-- todo fuse

-- | /O(n)/ Applied to a predicate and a 'ByteString', 'all' determines
-- if all elements of the 'ByteString' satisfy the predicate.
all :: (Word8 -> Bool) -> ByteString -> Bool
all _ (PS _ _ 0) = True
all f (PS x s l) = inlinePerformIO $ withForeignPtr x $ \ptr ->
        go (ptr `plusPtr` s) (ptr `plusPtr` (s+l))
    where
        go a b | a `seq` b `seq` False = undefined
        go p q | p == q     = return True  -- end of list
               | otherwise  = do c <- peek p
                                 if f c
                                    then go (p `plusPtr` 1) q
                                    else return False

------------------------------------------------------------------------

-- | /O(n)/ 'maximum' returns the maximum value from a 'ByteString'
-- This function will fuse.
-- An exception will be thrown in the case of an empty ByteString.
maximum :: ByteString -> Word8
maximum xs@(PS x s l)
    | null xs   = errorEmptyList "maximum"
    | otherwise = inlinePerformIO $ withForeignPtr x $ \p ->
                      c_maximum (p `plusPtr` s) (fromIntegral l)

-- | /O(n)/ 'minimum' returns the minimum value from a 'ByteString'
-- This function will fuse.
-- An exception will be thrown in the case of an empty ByteString.
minimum :: ByteString -> Word8
minimum xs@(PS x s l)
    | null xs   = errorEmptyList "minimum"
    | otherwise = inlinePerformIO $ withForeignPtr x $ \p ->
                      c_minimum (p `plusPtr` s) (fromIntegral l)

--
-- minimum/maximum/loop fusion. As for length (and other folds), when we
-- see we're applied after a fuseable op, switch from using the C
-- version, to the fuseable version. The result should then avoid
-- allocating a buffer.
--






maximumU :: ByteString -> Word8
maximumU = foldl1' max
{-# INLINE maximumU #-}

minimumU :: ByteString -> Word8
minimumU = foldl1' min
{-# INLINE minimumU #-}

{-# RULES

"FPS minimum/loop" forall loop s .
  minimum  (loopArr (loopWrapper loop s)) =
  minimumU (loopArr (loopWrapper loop s))

"FPS maximum/loop" forall loop s .
  maximum  (loopArr (loopWrapper loop s)) =
  maximumU (loopArr (loopWrapper loop s))

  #-}

------------------------------------------------------------------------

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new list.
mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)

mapAccumL f z = unSP . loopUp (mapAccumEFL f) z



{-# INLINE mapAccumL #-}

-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from right to left, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapAccumR f z = unSP . loopDown (mapAccumEFL f) z
{-# INLINE mapAccumR #-}

-- | /O(n)/ map Word8 functions, provided with the index at each position
mapIndexed :: (Int -> Word8 -> Word8) -> ByteString -> ByteString
mapIndexed f = loopArr . loopUp (mapIndexEFL f) 0
{-# INLINE mapIndexed #-}

-- ---------------------------------------------------------------------
-- Building ByteStrings

-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left. This function will fuse.
--
-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that
--
-- > last (scanl f z xs) == foldl f z xs.
scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString

scanl f z ps = loopArr . loopUp (scanEFL f) z $ (ps `snoc` 0)




    -- n.b. haskell's List scan returns a list one bigger than the
    -- input, so we need to snoc here to get some extra space, however,
    -- it breaks map/up fusion (i.e. scanl . map no longer fuses)
{-# INLINE scanl #-}

-- | 'scanl1' is a variant of 'scanl' that has no starting value argument.
-- This function will fuse.
--
-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
scanl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
scanl1 f ps
    | null ps   = empty
    | otherwise = scanl f (unsafeHead ps) (unsafeTail ps)
{-# INLINE scanl1 #-}

-- | scanr is the right-to-left dual of scanl.
scanr :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
scanr f z ps = loopArr . loopDown (scanEFL (flip f)) z $ (0 `cons` ps) -- extra space
{-# INLINE scanr #-}

-- | 'scanr1' is a variant of 'scanr' that has no starting value argument.
scanr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
scanr1 f ps
    | null ps   = empty
    | otherwise = scanr f (last ps) (init ps) -- todo, unsafe versions
{-# INLINE scanr1 #-}

-- ---------------------------------------------------------------------
-- Unfolds and replicates

-- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@
-- the value of every element. The following holds:
--
-- > replicate w c = unfoldr w (\u -> Just (u,u)) c
--
-- This implemenation uses @memset(3)@
replicate :: Int -> Word8 -> ByteString
replicate w c
    | w <= 0    = empty
    | otherwise = unsafeCreate w $ \ptr ->
                      memset ptr c (fromIntegral w) >> return ()

-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr' 
-- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a 
-- ByteString from a seed value.  The function takes the element and 
-- returns 'Nothing' if it is done producing the ByteString or returns 
-- 'Just' @(a,b)@, in which case, @a@ is the next byte in the string, 
-- and @b@ is the seed value for further production.
--
-- Examples:
--
-- >    unfoldr (\x -> if x <= 5 then Just (x, x + 1) else Nothing) 0
-- > == pack [0, 1, 2, 3, 4, 5]
--
unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
unfoldr f = concat . unfoldChunk 32 64
  where unfoldChunk n n' x =
          case unfoldrN n f x of
            (s, Nothing) -> s : []
            (s, Just x') -> s : unfoldChunk n' (n+n') x'

-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seed
-- value.  However, the length of the result is limited by the first
-- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
-- when the maximum length of the result is known.
--
-- The following equation relates 'unfoldrN' and 'unfoldr':
--
-- > unfoldrN n f s == take n (unfoldr f s)
--
unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
unfoldrN i f x0
    | i < 0     = (empty, Just x0)
    | otherwise = unsafePerformIO $ createAndTrim' i $ \p -> go p x0 0
  where go a b c | a `seq` b `seq` c `seq` False = undefined
        go p x n =
          case f x of
            Nothing      -> return (0, n, Nothing)
            Just (w,x')
             | n == i    -> return (0, n, Just x)
             | otherwise -> do poke p w
                               go (p `plusPtr` 1) x' (n+1)

-- ---------------------------------------------------------------------
-- Substrings

-- | /O(1)/ 'take' @n@, applied to a ByteString @xs@, returns the prefix
-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.
take :: Int -> ByteString -> ByteString
take n ps@(PS x s l)
    | n <= 0    = empty
    | n >= l    = ps
    | otherwise = PS x s n
{-# INLINE take #-}

-- | /O(1)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
-- elements, or @[]@ if @n > 'length' xs@.
drop  :: Int -> ByteString -> ByteString
drop n ps@(PS x s l)
    | n <= 0    = ps
    | n >= l    = empty
    | otherwise = PS x (s+n) (l-n)
{-# INLINE drop #-}

-- | /O(1)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.
splitAt :: Int -> ByteString -> (ByteString, ByteString)
splitAt n ps@(PS x s l)
    | n <= 0    = (empty, ps)
    | n >= l    = (ps, empty)
    | otherwise = (PS x s n, PS x (s+n) (l-n))
{-# INLINE splitAt #-}

-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.
takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
takeWhile f ps = unsafeTake (findIndexOrEnd (not . f) ps) ps
{-# INLINE takeWhile #-}

-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
dropWhile f ps = unsafeDrop (findIndexOrEnd (not . f) ps) ps
{-# INLINE dropWhile #-}

-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
break p ps = case findIndexOrEnd p ps of n -> (unsafeTake n ps, unsafeDrop n ps)
{-# INLINE [1] break #-}

{-# RULES
"FPS specialise break (x==)" forall x.
    break ((==) x) = breakByte x
  #-}








-- | 'breakByte' breaks its ByteString argument at the first occurence
-- of the specified byte. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
-- 
-- > break (=='c') "abcd" == breakByte 'c' "abcd"
--
breakByte :: Word8 -> ByteString -> (ByteString, ByteString)
breakByte c p = case elemIndex c p of
    Nothing -> (p,empty)
    Just n  -> (unsafeTake n p, unsafeDrop n p)
{-# INLINE breakByte #-}

-- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'
-- 
-- breakEnd p == spanEnd (not.p)
breakEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
breakEnd  p ps = splitAt (findFromEndUntil p ps) ps

-- | 'span' @p xs@ breaks the ByteString into two segments. It is
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
span p ps = break (not . p) ps
{-# INLINE [1] span #-}

-- | 'spanByte' breaks its ByteString argument at the first
-- occurence of a byte other than its argument. It is more efficient
-- than 'span (==)'
--
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
--
spanByte :: Word8 -> ByteString -> (ByteString, ByteString)
spanByte c ps@(PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
    go (p `plusPtr` s) 0
  where
    go a b | a `seq` b `seq` False = undefined
    go p i | i >= l    = return (ps, empty)
           | otherwise = do c' <- peekByteOff p i
                            if c /= c'
                                then return (unsafeTake i ps, unsafeDrop i ps)
                                else go p (i+1)
{-# INLINE spanByte #-}

{-# RULES
"FPS specialise span (x==)" forall x.
    span ((==) x) = spanByte x
  #-}








-- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
-- We have
--
-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
--
-- and
--
-- > spanEnd (not . isSpace) ps
-- >    == 
-- > let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x) 
--
spanEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
spanEnd  p ps = splitAt (findFromEndUntil (not.p) ps) ps

-- | /O(n)/ Splits a 'ByteString' into components delimited by
-- separators, where the predicate returns True for a separator element.
-- The resulting components do not contain the separators.  Two adjacent
-- separators result in an empty component in the output.  eg.
--
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
-- > splitWith (=='a') []        == []
--
splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]




























splitWith _ (PS _ _ 0) = []
splitWith p ps = loop p ps
    where
        loop a b | a `seq` b `seq` False = undefined
        loop q qs = if null rest then [chunk]
                                 else chunk : loop q (unsafeTail rest)
            where (chunk,rest) = break q qs


-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.
--
-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split 'a'  "aXaXaXa"    == ["","X","X","X"]
-- > split 'x'  "x"          == ["",""]
-- 
-- and
--
-- > join [c] . split c == id
-- > split == splitWith . (==)
-- 
-- As for all splitting functions in this library, this function does
-- not copy the substrings, it just constructs new 'ByteStrings' that
-- are slices of the original.
--
split :: Word8 -> ByteString -> [ByteString]
split _ (PS _ _ 0) = []
split w (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
    let ptr = p `plusPtr` s

        loop a | a `seq` False = undefined
        loop n =
            let q = inlinePerformIO $ memchr (ptr `plusPtr` n)
                                           w (fromIntegral (l-n))
            in if q == nullPtr
                then [PS x (s+n) (l-n)]
                else let i = q `minusPtr` ptr in PS x (s+n) (i-n) : loop (i+1)

    return (loop 0)
{-# INLINE split #-}

{-
-- slower. but stays inside Haskell.
split _ (PS _  _   0) = []
split (W8# w#) (PS fp off len) = splitWith' off len fp
    where
        splitWith' off' len' fp' = withPtr fp $ \p ->
            splitLoop p 0 off' len' fp'

        splitLoop :: Ptr Word8
                  -> Int -> Int -> Int
                  -> ForeignPtr Word8
                  -> IO [ByteString]

        STRICT5(splitLoop)
        splitLoop p idx' off' len' fp'
            | p `seq` idx' `seq` off' `seq` len' `seq` fp' `seq` False = undefined
            | idx' >= len'  = return [PS fp' off' idx']
            | otherwise = do
                (W8# x#) <- peekElemOff p (off'+idx')
                if word2Int# w# ==# word2Int# x#
                   then return (PS fp' off' idx' :
                              splitWith' (off'+idx'+1) (len'-idx'-1) fp')
                   else splitLoop p (idx'+1) off' len' fp'
-}

{-
-- | Like 'splitWith', except that sequences of adjacent separators are
-- treated as a single separator. eg.
-- 
-- > tokens (=='a') "aabbaca" == ["bb","c"]
--
tokens :: (Word8 -> Bool) -> ByteString -> [ByteString]
tokens f = P.filter (not.null) . splitWith f
{-# INLINE tokens #-}
-}

-- | The 'group' function takes a ByteString and returns a list of
-- ByteStrings such that the concatenation of the result is equal to the
-- argument.  Moreover, each sublist in the result contains only equal
-- elements.  For example,
--
-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--
-- It is a special case of 'groupBy', which allows the programmer to
-- supply their own equality test. It is about 40% faster than 
-- /groupBy (==)/
group :: ByteString -> [ByteString]
group xs
    | null xs   = []
    | otherwise = ys : group zs
    where
        (ys, zs) = spanByte (unsafeHead xs) xs

-- | The 'groupBy' function is the non-overloaded version of 'group'.
groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
groupBy k xs
    | null xs   = []
    | otherwise = unsafeTake n xs : groupBy k (unsafeDrop n xs)
    where
        n = 1 + findIndexOrEnd (not . k (unsafeHead xs)) (unsafeTail xs)

-- | /O(n)/ The 'join' function takes a 'ByteString' and a list of
-- 'ByteString's and concatenates the list after interspersing the first
-- argument between each element of the list.
join :: ByteString -> [ByteString] -> ByteString
join s = concat . (List.intersperse s)
{-# INLINE [1] join #-}

{-# RULES
"FPS specialise join c -> joinByte" forall c s1 s2 .
    join (singleton c) (s1 : s2 : []) = joinWithByte c s1 s2
  #-}

--
-- | /O(n)/ joinWithByte. An efficient way to join to two ByteStrings
-- with a char. Around 4 times faster than the generalised join.
--
joinWithByte :: Word8 -> ByteString -> ByteString -> ByteString
joinWithByte c f@(PS ffp s l) g@(PS fgp t m) = unsafeCreate len $ \ptr ->
    withForeignPtr ffp $ \fp ->
    withForeignPtr fgp $ \gp -> do
        memcpy ptr (fp `plusPtr` s) (fromIntegral l)
        poke (ptr `plusPtr` l) c
        memcpy (ptr `plusPtr` (l + 1)) (gp `plusPtr` t) (fromIntegral m)
    where
      len = length f + length g + 1
{-# INLINE joinWithByte #-}

-- ---------------------------------------------------------------------
-- Indexing ByteStrings

-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.
index :: ByteString -> Int -> Word8
index ps n
    | n < 0          = moduleError "index" ("negative index: " ++ show n)
    | n >= length ps = moduleError "index" ("index too large: " ++ show n
                                         ++ ", length = " ++ show (length ps))
    | otherwise      = ps `unsafeIndex` n
{-# INLINE index #-}

-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element. 
-- This implementation uses memchr(3).
elemIndex :: Word8 -> ByteString -> Maybe Int
elemIndex c (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
    let p' = p `plusPtr` s
    q <- memchr p' c (fromIntegral l)
    return $! if q == nullPtr then Nothing else Just $! q `minusPtr` p'
{-# INLINE elemIndex #-}

-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element. The following
-- holds:
--
-- > elemIndexEnd c xs == 
-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--
elemIndexEnd :: Word8 -> ByteString -> Maybe Int
elemIndexEnd ch (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
    go (p `plusPtr` s) (l-1)
  where
    go a b | a `seq` b `seq` False = undefined
    go p i | i < 0     = return Nothing
           | otherwise = do ch' <- peekByteOff p i
                            if ch == ch'
                                then return $ Just i
                                else go p (i-1)
{-# INLINE elemIndexEnd #-}

-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- the indices of all elements equal to the query element, in ascending order.
-- This implementation uses memchr(3).
elemIndices :: Word8 -> ByteString -> [Int]
elemIndices w (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
    let ptr = p `plusPtr` s

        loop a | a `seq` False = undefined
        loop n = let q = inlinePerformIO $ memchr (ptr `plusPtr` n)
                                                w (fromIntegral (l - n))
                 in if q == nullPtr
                        then []
                        else let i = q `minusPtr` ptr
                             in i : loop (i+1)
    return $! loop 0
{-# INLINE elemIndices #-}

{-
-- much slower
elemIndices :: Word8 -> ByteString -> [Int]
elemIndices c ps = loop 0 ps
   where STRICT2(loop)
         loop _ ps' | null ps'            = []
         loop n ps' | c == unsafeHead ps' = n : loop (n+1) (unsafeTail ps')
                    | otherwise           = loop (n+1) (unsafeTail ps')
-}

-- | count returns the number of times its argument appears in the ByteString
--
-- > count = length . elemIndices
--
-- But more efficiently than using length on the intermediate list.
count :: Word8 -> ByteString -> Int
count w (PS x s m) = inlinePerformIO $ withForeignPtr x $ \p ->
    fmap fromIntegral $ c_count (p `plusPtr` s) (fromIntegral m) w
{-# INLINE count #-}

{-
--
-- around 30% slower
--
count w (PS x s m) = inlinePerformIO $ withForeignPtr x $ \p ->
     go (p `plusPtr` s) (fromIntegral m) 0
    where
        go :: Ptr Word8 -> CSize -> Int -> IO Int
        STRICT3(go)
        go p l i = do
            q <- memchr p w l
            if q == nullPtr
                then return i
                else do let k = fromIntegral $ q `minusPtr` p
                        go (q `plusPtr` 1) (l-k-1) (i+1)
-}

-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- returns the index of the first element in the ByteString
-- satisfying the predicate.
findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int
findIndex k (PS x s l) = inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
  where
    go a b | a `seq` b `seq` False = undefined
    go ptr n | n >= l    = return Nothing
             | otherwise = do w <- peek ptr
                              if k w
                                then return (Just n)
                                else go (ptr `plusPtr` 1) (n+1)
{-# INLINE findIndex #-}

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices :: (Word8 -> Bool) -> ByteString -> [Int]
findIndices p ps = loop 0 ps
   where
     loop a b | a `seq` b `seq` False = undefined
     loop n qs | null qs           = []
               | p (unsafeHead qs) = n : loop (n+1) (unsafeTail qs)
               | otherwise         =     loop (n+1) (unsafeTail qs)

-- ---------------------------------------------------------------------
-- Searching ByteStrings

-- | /O(n)/ 'elem' is the 'ByteString' membership predicate.
elem :: Word8 -> ByteString -> Bool
elem c ps = case elemIndex c ps of Nothing -> False ; _ -> True
{-# INLINE elem #-}

-- | /O(n)/ 'notElem' is the inverse of 'elem'
notElem :: Word8 -> ByteString -> Bool
notElem c ps = not (elem c ps)
{-# INLINE notElem #-}

-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
-- returns a ByteString containing those characters that satisfy the
-- predicate. This function is subject to array fusion.
filter :: (Word8 -> Bool) -> ByteString -> ByteString







filter f = loopArr . loopFilter f

{-# INLINE filter #-}

{-
-- | /O(n)/ 'filter\'' is a non-fuseable version of filter, that may be
-- around 2x faster for some one-shot applications.
filter' :: (Word8 -> Bool) -> ByteString -> ByteString
filter' k ps@(PS x s l)
    | null ps   = ps
    | otherwise = unsafePerformIO $ createAndTrim l $ \p -> withForeignPtr x $ \f -> do
        t <- go (f `plusPtr` s) p (f `plusPtr` (s + l))
        return $! t `minusPtr` p -- actual length
    where
        STRICT3(go)
        go f t end | f == end  = return t
                   | otherwise = do
                        w <- peek f
                        if k w
                            then poke t w >> go (f `plusPtr` 1) (t `plusPtr` 1) end
                            else             go (f `plusPtr` 1) t               end
{-# INLINE filter' #-}
-}

--
-- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
-- case of filtering a single byte. It is more efficient to use
-- /filterByte/ in this case.
--
-- > filterByte == filter . (==)
--
-- filterByte is around 10x faster, and uses much less space, than its
-- filter equivalent
filterByte :: Word8 -> ByteString -> ByteString
filterByte w ps = replicate (count w ps) w
{-# INLINE filterByte #-}

{-# RULES
  "FPS specialise filter (== x)" forall x.
      filter ((==) x) = filterByte x
  #-}








--
-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
-- case of filtering a single byte out of a list. It is more efficient
-- to use /filterNotByte/ in this case.
--
-- > filterNotByte == filter . (/=)
--
-- filterNotByte is around 2x faster than its filter equivalent.
filterNotByte :: Word8 -> ByteString -> ByteString
filterNotByte w = filter (/= w)
{-# INLINE filterNotByte #-}

{-# RULES
"FPS specialise filter (x /=)" forall x.
    filter ((/=) x) = filterNotByte x
  #-}








-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.
--
-- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
--
find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
find f p = case findIndex f p of
                    Just n -> Just (p `unsafeIndex` n)
                    _      -> Nothing
{-# INLINE find #-}

{-
--
-- fuseable, but we don't want to walk the whole array.
-- 
find k = foldl findEFL Nothing
    where findEFL a@(Just _) _ = a
          findEFL _          c | k c       = Just c
                               | otherwise = Nothing
-}

-- ---------------------------------------------------------------------
-- Searching for substrings

-- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True'
-- iff the first is a prefix of the second.
isPrefixOf :: ByteString -> ByteString -> Bool
isPrefixOf (PS x1 s1 l1) (PS x2 s2 l2)
    | l1 == 0   = True
    | l2 < l1   = False
    | otherwise = inlinePerformIO $ withForeignPtr x1 $ \p1 ->
        withForeignPtr x2 $ \p2 -> do
            i <- memcmp (p1 `plusPtr` s1) (p2 `plusPtr` s2) (fromIntegral l1)
            return $! i == 0

-- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'
-- iff the first is a suffix of the second.
-- 
-- The following holds:
--
-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
--
-- However, the real implemenation uses memcmp to compare the end of the
-- string only, with no reverse required..
isSuffixOf :: ByteString -> ByteString -> Bool
isSuffixOf (PS x1 s1 l1) (PS x2 s2 l2)
    | l1 == 0   = True
    | l2 < l1   = False
    | otherwise = inlinePerformIO $ withForeignPtr x1 $ \p1 ->
        withForeignPtr x2 $ \p2 -> do
            i <- memcmp (p1 `plusPtr` s1) (p2 `plusPtr` s2 `plusPtr` (l2 - l1)) (fromIntegral l1)
            return $! i == 0

-- | Check whether one string is a substring of another. @isSubstringOf
-- p s@ is equivalent to @not (null (findSubstrings p s))@.
isSubstringOf :: ByteString -- ^ String to search for.
              -> ByteString -- ^ String to search in.
              -> Bool
isSubstringOf p s = not $ P.null $ findSubstrings p s

-- | Get the first index of a substring in another string,
--   or 'Nothing' if the string is not found.
--   @findSubstring p s@ is equivalent to @listToMaybe (findSubstrings p s)@.
findSubstring :: ByteString -- ^ String to search for.
              -> ByteString -- ^ String to seach in.
              -> Maybe Int
findSubstring = (listToMaybe .) . findSubstrings

-- | Find the indexes of all (possibly overlapping) occurances of a
-- substring in a string.  This function uses the Knuth-Morris-Pratt
-- string matching algorithm.
findSubstrings :: ByteString -- ^ String to search for.
               -> ByteString -- ^ String to seach in.
               -> [Int]

findSubstrings pat@(PS _ _ m) str@(PS _ _ n) = search 0 0
  where
      patc x = pat `unsafeIndex` x
      strc x = str `unsafeIndex` x

      -- maybe we should make kmpNext a UArray before using it in search?
      kmpNext = listArray (0,m) (-1:kmpNextL pat (-1))
      kmpNextL p _ | null p = []
      kmpNextL p j = let j' = next (unsafeHead p) j + 1
                         ps = unsafeTail p
                         x = if not (null ps) && unsafeHead ps == patc j'
                                then kmpNext Array.! j' else j'
                        in x:kmpNextL ps j'
      search i j = match ++ rest -- i: position in string, j: position in pattern
        where match = if j == m then [(i - j)] else []
              rest = if i == n then [] else search (i+1) (next (strc i) j + 1)
      next c j | j >= 0 && (j == m || c /= patc j) = next c (kmpNext Array.! j)
               | otherwise = j

-- ---------------------------------------------------------------------
-- Zipping

-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- corresponding pairs of bytes. If one input ByteString is short,
-- excess elements of the longer ByteString are discarded. This is
-- equivalent to a pair of 'unpack' operations.
zip :: ByteString -> ByteString -> [(Word8,Word8)]
zip ps qs
    | null ps || null qs = []
    | otherwise = (unsafeHead ps, unsafeHead qs) : zip (unsafeTail ps) (unsafeTail qs)

-- | 'zipWith' generalises 'zip' by zipping with the function given as
-- the first argument, instead of a tupling function.  For example,
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of
-- corresponding sums. 
zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
zipWith f ps qs
    | null ps || null qs = []
    | otherwise = f (unsafeHead ps) (unsafeHead qs) : zipWith f (unsafeTail ps) (unsafeTail qs)




--
-- | A specialised version of zipWith for the common case of a
-- simultaneous map over two bytestrings, to build a 3rd. Rewrite rules
-- are used to automatically covert zipWith into zipWith' when a pack is
-- performed on the result of zipWith, but we also export it for
-- convenience.
--
zipWith' :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString -> ByteString
zipWith' f (PS fp s l) (PS fq t m) = inlinePerformIO $
    withForeignPtr fp $ \a ->
    withForeignPtr fq $ \b ->
    create len $ zipWith_ 0 (a `plusPtr` s) (b `plusPtr` t)
  where
    zipWith_ :: Int -> Ptr Word8 -> Ptr Word8 -> Ptr Word8 -> IO ()
    zipWith_ a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
    zipWith_ n p1 p2 r
       | n >= len = return ()
       | otherwise = do
            x <- peekByteOff p1 n
            y <- peekByteOff p2 n
            pokeByteOff r n (f x y)
            zipWith_ (n+1) p1 p2 r

    len = min l m
{-# INLINE zipWith' #-}

{-# RULES

"FPS specialise zipWith" forall (f :: Word8 -> Word8 -> Word8) p q .
    zipWith f p q = unpack (zipWith' f p q)

  #-}

-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
-- ByteStrings. Note that this performs two 'pack' operations.
unzip :: [(Word8,Word8)] -> (ByteString,ByteString)
unzip ls = (pack (P.map fst ls), pack (P.map snd ls))
{-# INLINE unzip #-}

-- ---------------------------------------------------------------------
-- Special lists

-- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.
inits :: ByteString -> [ByteString]
inits (PS x s l) = [PS x s n | n <- [0..l]]

-- | /O(n)/ Return all final segments of the given 'ByteString', longest first.
tails :: ByteString -> [ByteString]
tails p | null p    = [empty]
        | otherwise = p : tails (unsafeTail p)

-- less efficent spacewise: tails (PS x s l) = [PS x (s+n) (l-n) | n <- [0..l]]

-- ---------------------------------------------------------------------
-- ** Ordered 'ByteString's

-- | /O(n)/ Sort a ByteString efficiently, using counting sort.
sort :: ByteString -> ByteString
sort (PS input s l) = unsafeCreate l $ \p -> allocaArray 256 $ \arr -> do

    memset (castPtr arr) 0 (256 * fromIntegral (sizeOf (undefined :: CSize)))
    withForeignPtr input (\x -> countOccurrences arr (x `plusPtr` s) l)

    let go a b | a `seq` b `seq` False = undefined
        go 256 _   = return ()
        go i   ptr = do n <- peekElemOff arr i
                        when (n /= 0) $ memset ptr (fromIntegral i) n >> return ()
                        go (i + 1) (ptr `plusPtr` (fromIntegral n))
    go 0 p

{-
sort :: ByteString -> ByteString
sort (PS x s l) = unsafeCreate l $ \p -> withForeignPtr x $ \f -> do
        memcpy p (f `plusPtr` s) l
        c_qsort p l -- inplace
-}

-- | The 'sortBy' function is the non-overloaded version of 'sort'.
--
-- Try some linear sorts: radix, counting
-- Or mergesort.
--
-- sortBy :: (Word8 -> Word8 -> Ordering) -> ByteString -> ByteString
-- sortBy f ps = undefined

-- ---------------------------------------------------------------------
-- Low level constructors

-- | /O(n)/ Build a @ByteString@ from a @CString@. This value will have /no/
-- finalizer associated to it. The ByteString length is calculated using
-- /strlen(3)/, and thus the complexity is a /O(n)/.
packCString :: CString -> ByteString
packCString cstr = unsafePerformIO $ do
    fp <- newForeignPtr_ (castPtr cstr)
    l <- c_strlen cstr
    return $! PS fp 0 (fromIntegral l)

-- | /O(1)/ Build a @ByteString@ from a @CStringLen@. This value will
-- have /no/ finalizer associated with it. This operation has /O(1)/
-- complexity as we already know the final size, so no /strlen(3)/ is
-- required.
packCStringLen :: CStringLen -> ByteString
packCStringLen (ptr,len) = unsafePerformIO $ do
    fp <- newForeignPtr_ (castPtr ptr)
    return $! PS fp 0 (fromIntegral len)

-- | /O(n)/ Build a @ByteString@ from a malloced @CString@. This value will
-- have a @free(3)@ finalizer associated to it.
packMallocCString :: CString -> ByteString
packMallocCString cstr = unsafePerformIO $ do
    fp <- newForeignFreePtr (castPtr cstr)
    len <- c_strlen cstr
    return $! PS fp 0 (fromIntegral len)

-- | /O(n) construction/ Use a @ByteString@ with a function requiring a
-- null-terminated @CString@.  The @CString@ will be freed
-- automatically. This is a memcpy(3).
useAsCString :: ByteString -> (CString -> IO a) -> IO a
useAsCString (PS ps s l) = bracket alloc (c_free.castPtr)
    where alloc = withForeignPtr ps $ \p -> do
            buf <- c_malloc (fromIntegral l+1)
            memcpy (castPtr buf) (castPtr p `plusPtr` s) (fromIntegral l)
            poke (buf `plusPtr` l) (0::Word8) -- n.b.
            return (castPtr buf)

-- | /O(1) construction/ Use a @ByteString@ with a function requiring a @CStringLen@.
useAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
useAsCStringLen = unsafeUseAsCStringLen

--
-- why were we doing this?
--
-- useAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
-- useAsCStringLen (PS ps s l) = bracket alloc (c_free.castPtr.fst)
--     where
--       alloc = withForeignPtr ps $ \p -> do
--                 buf <- c_malloc (fromIntegral l+1)
--                 memcpy (castPtr buf) (castPtr p `plusPtr` s) (fromIntegral l)
--                 poke (buf `plusPtr` l) (0::Word8) -- n.b.
--                 return $! (castPtr buf, l)
--

-- | /O(n)/ Make a copy of the 'ByteString' with its own storage. 
--   This is mainly useful to allow the rest of the data pointed
--   to by the 'ByteString' to be garbage collected, for example
--   if a large string has been read in, and only a small part of it 
--   is needed in the rest of the program.
copy :: ByteString -> ByteString
copy (PS x s l) = unsafeCreate l $ \p -> withForeignPtr x $ \f ->
    memcpy p (f `plusPtr` s) (fromIntegral l)

-- | /O(n)/ Duplicate a CString as a ByteString. Useful if you know the
-- CString is going to be deallocated from C land.
copyCString :: CString -> IO ByteString
copyCString cstr = do
    len <- c_strlen cstr
    copyCStringLen (cstr, fromIntegral len)

-- | /O(n)/ Same as copyCString, but saves a strlen call when the length is known.
copyCStringLen :: CStringLen -> IO ByteString
copyCStringLen (cstr, len) = create len $ \p ->
    memcpy p (castPtr cstr) (fromIntegral len)

-- ---------------------------------------------------------------------
-- line IO

-- | Read a line from stdin.
getLine :: IO ByteString
getLine = hGetLine stdin

{-
-- | Lazily construct a list of lines of ByteStrings. This will be much
-- better on memory consumption than using 'hGetContents >>= lines'
-- If you're considering this, a better choice might be to use
-- Data.ByteString.Lazy
hGetLines :: Handle -> IO [ByteString]
hGetLines h = go
    where
        go = unsafeInterleaveIO $ do
                e <- hIsEOF h
                if e
                  then return []
                  else do
                x  <- hGetLine h
                xs <- go
                return (x:xs)
-}

-- | Read a line from a handle

hGetLine :: Handle -> IO ByteString

hGetLine h = System.IO.hGetLine h >>= return . pack . P.map c2w




































































-- ---------------------------------------------------------------------
-- Block IO

-- | Outputs a 'ByteString' to the specified 'Handle'.
hPut :: Handle -> ByteString -> IO ()
hPut _ (PS _  _ 0) = return ()
hPut h (PS ps s l) = withForeignPtr ps $ \p-> hPutBuf h (p `plusPtr` s) l

-- | A synonym for @hPut@, for compatibility 
hPutStr :: Handle -> ByteString -> IO ()
hPutStr = hPut

-- | Write a ByteString to a handle, appending a newline byte
hPutStrLn :: Handle -> ByteString -> IO ()
hPutStrLn h ps
    | length ps < 1024 = hPut h (ps `snoc` 0x0a)
    | otherwise        = hPut h ps >> hPut h (singleton (0x0a)) -- don't copy

-- | Write a ByteString to stdout
putStr :: ByteString -> IO ()
putStr = hPut stdout

-- | Write a ByteString to stdout, appending a newline byte
putStrLn :: ByteString -> IO ()
putStrLn = hPutStrLn stdout

-- | Read a 'ByteString' directly from the specified 'Handle'.  This
-- is far more efficient than reading the characters into a 'String'
-- and then using 'pack'.
hGet :: Handle -> Int -> IO ByteString
hGet _ 0 = return empty
hGet h i = createAndTrim i $ \p -> hGetBuf h p i

-- | hGetNonBlocking is identical to 'hGet', except that it will never block
-- waiting for data to become available, instead it returns only whatever data
-- is available.
hGetNonBlocking :: Handle -> Int -> IO ByteString




hGetNonBlocking = hGet


-- | Read entire handle contents into a 'ByteString'.
-- This function reads chunks at a time, doubling the chunksize on each
-- read. The final buffer is then realloced to the appropriate size. For
-- files > half of available memory, this may lead to memory exhaustion.
-- Consider using 'readFile' in this case.
--
-- As with 'hGet', the string representation in the file is assumed to
-- be ISO-8859-1.
--
hGetContents :: Handle -> IO ByteString
hGetContents h = do
    let start_size = 1024
    p <- mallocArray start_size
    i <- hGetBuf h p start_size
    if i < start_size
        then do p' <- reallocArray p i
                fp <- newForeignFreePtr p'
                return $! PS fp 0 i
        else f p start_size
    where
        f p s = do
            let s' = 2 * s
            p' <- reallocArray p s'
            i  <- hGetBuf h (p' `plusPtr` s) s
            if i < s
                then do let i' = s + i
                        p'' <- reallocArray p' i'
                        fp  <- newForeignFreePtr p''
                        return $! PS fp 0 i'
                else f p' s'

-- | getContents. Equivalent to hGetContents stdin
getContents :: IO ByteString
getContents = hGetContents stdin

-- | The interact function takes a function of type @ByteString -> ByteString@
-- as its argument. The entire input from the standard input device is passed
-- to this function as its argument, and the resulting string is output on the
-- standard output device. It's great for writing one line programs!
interact :: (ByteString -> ByteString) -> IO ()
interact transformer = putStr . transformer =<< getContents

-- | Read an entire file strictly into a 'ByteString'.  This is far more
-- efficient than reading the characters into a 'String' and then using
-- 'pack'.  It also may be more efficient than opening the file and
-- reading it using hGet. Files are read using 'binary mode' on Windows,
-- for 'text mode' use the Char8 version of this function.
readFile :: FilePath -> IO ByteString
readFile f = bracket (openBinaryFile f ReadMode) hClose
    (\h -> hFileSize h >>= hGet h . fromIntegral)

-- | Write a 'ByteString' to a file.
writeFile :: FilePath -> ByteString -> IO ()
writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
    (\h -> hPut h txt)

-- | Append a 'ByteString' to a file.
appendFile :: FilePath -> ByteString -> IO ()
appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
    (\h -> hPut h txt)

{-
--
-- Disable until we can move it into a portable .hsc file
--

-- | Like readFile, this reads an entire file directly into a
-- 'ByteString', but it is even more efficient.  It involves directly
-- mapping the file to memory.  This has the advantage that the contents
-- of the file never need to be copied.  Also, under memory pressure the
-- page may simply be discarded, while in the case of readFile it would
-- need to be written to swap.  If you read many small files, mmapFile
-- will be less memory-efficient than readFile, since each mmapFile
-- takes up a separate page of memory.  Also, you can run into bus
-- errors if the file is modified.  As with 'readFile', the string
-- representation in the file is assumed to be ISO-8859-1.
--
-- On systems without mmap, this is the same as a readFile.
--
mmapFile :: FilePath -> IO ByteString
mmapFile f = mmap f >>= \(fp,l) -> return $! PS fp 0 l

mmap :: FilePath -> IO (ForeignPtr Word8, Int)
mmap f = do
    h <- openBinaryFile f ReadMode
    l <- fromIntegral `fmap` hFileSize h
    -- Don't bother mmaping small files because each mmapped file takes up
    -- at least one full VM block.
    if l < mmap_limit
       then do thefp <- mallocByteString l
               withForeignPtr thefp $ \p-> hGetBuf h p l
               hClose h
               return (thefp, l)
       else do
               -- unix only :(
               fd <- fromIntegral `fmap` handleToFd h
               p  <- my_mmap l fd
               fp <- if p == nullPtr
                     then do thefp <- mallocByteString l
                             withForeignPtr thefp $ \p' -> hGetBuf h p' l
                             return thefp
                     else do
                          -- The munmap leads to crashes on OpenBSD.
                          -- maybe there's a use after unmap in there somewhere?
                          -- Bulat suggests adding the hClose to the
                          -- finalizer, excellent idea.
#if !defined(__OpenBSD__)
                             let unmap = c_munmap p l >> return ()
#else


                             fp <- newForeignPtr p unmap
                             return fp
               c_close fd
               hClose h
               return (fp, l)
    where mmap_limit = 16*1024
-}

-- ---------------------------------------------------------------------
-- Internal utilities

-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length
-- of the string if no element is found, rather than Nothing.
findIndexOrEnd :: (Word8 -> Bool) -> ByteString -> Int
findIndexOrEnd k (PS x s l) = inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
  where
    go a b | a `seq` b `seq` False = undefined
    go ptr n | n >= l    = return l
             | otherwise = do w <- peek ptr
                              if k w
                                then return n
                                else go (ptr `plusPtr` 1) (n+1)
{-# INLINE findIndexOrEnd #-}

-- | Perform an operation with a temporary ByteString
withPtr :: ForeignPtr a -> (Ptr a -> IO b) -> b
withPtr fp io = inlinePerformIO (withForeignPtr fp io)
{-# INLINE withPtr #-}

-- Common up near identical calls to `error' to reduce the number
-- constant strings created when compiled:
errorEmptyList :: String -> a
errorEmptyList fun = moduleError fun "empty ByteString"
{-# NOINLINE errorEmptyList #-}

moduleError :: String -> String -> a
moduleError fun msg = error ("Data.ByteString." ++ fun ++ ':':' ':msg)
{-# NOINLINE moduleError #-}

-- Find from the end of the string using predicate
findFromEndUntil :: (Word8 -> Bool) -> ByteString -> Int
findFromEndUntil a b | a `seq` b `seq` False = undefined
findFromEndUntil f ps@(PS x s l) =
    if null ps then 0
    else if f (last ps) then l
         else findFromEndUntil f (PS x s (l-1))

{-# INLINE newForeignFreePtr #-}
newForeignFreePtr :: Ptr Word8 -> IO (ForeignPtr Word8)
newForeignFreePtr p = newForeignPtr c_free_finalizer p
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Char
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  stable
-- Portability :  portable
--
-- The Char type and associated operations.
--
-----------------------------------------------------------------------------

module Data.Char 
    (
      Char

    , String

    -- * Character classification
    -- | Unicode characters are divided into letters, numbers, marks,
    -- punctuation, symbols, separators (including spaces) and others
    -- (including control characters).
    , isControl, isSpace
    , isLower, isUpper, isAlpha, isAlphaNum, isPrint
    , isDigit, isOctDigit, isHexDigit
    , isLetter, isMark, isNumber, isPunctuation, isSymbol, isSeparator

    -- ** Subranges
    , isAscii, isLatin1
    , isAsciiUpper, isAsciiLower

    -- ** Unicode general categories
    , GeneralCategory(..), generalCategory

    -- * Case conversion
    , toUpper, toLower, toTitle  -- :: Char -> Char

    -- * Single digit characters
    , digitToInt        -- :: Char -> Int
    , intToDigit        -- :: Int  -> Char

    -- * Numeric representations
    , ord               -- :: Char -> Int
    , chr               -- :: Int  -> Char

    -- * String representations
    , showLitChar       -- :: Char -> ShowS
    , lexLitChar	-- :: ReadS String
    , readLitChar       -- :: ReadS Char 

     -- Implementation checked wrt. Haskell 98 lib report, 1/99.
    ) where













import Hugs.Prelude (Ix)
import Hugs.Char











-- | Convert a single digit 'Char' to the corresponding 'Int'.  
-- This function fails unless its argument satisfies 'isHexDigit',
-- but recognises both upper and lower-case hexadecimal digits
-- (i.e. @\'0\'@..@\'9\'@, @\'a\'@..@\'f\'@, @\'A\'@..@\'F\'@).
digitToInt :: Char -> Int
digitToInt c
 | isDigit c		=  ord c - ord '0'
 | c >= 'a' && c <= 'f' =  ord c - ord 'a' + 10
 | c >= 'A' && c <= 'F' =  ord c - ord 'A' + 10
 | otherwise	        =  error ("Char.digitToInt: not a digit " ++ show c) -- sigh


isAsciiUpper, isAsciiLower :: Char -> Bool
isAsciiLower c          =  c >= 'a' && c <= 'z'
isAsciiUpper c          =  c >= 'A' && c <= 'Z'


-- | Unicode General Categories (column 2 of the UnicodeData table)
-- in the order they are listed in the Unicode standard.

data GeneralCategory
        = UppercaseLetter       -- ^ Lu: Letter, Uppercase
        | LowercaseLetter       -- ^ Ll: Letter, Lowercase
        | TitlecaseLetter       -- ^ Lt: Letter, Titlecase
        | ModifierLetter        -- ^ Lm: Letter, Modifier
        | OtherLetter           -- ^ Lo: Letter, Other
        | NonSpacingMark        -- ^ Mn: Mark, Non-Spacing
        | SpacingCombiningMark  -- ^ Mc: Mark, Spacing Combining
        | EnclosingMark         -- ^ Me: Mark, Enclosing
        | DecimalNumber         -- ^ Nd: Number, Decimal
        | LetterNumber          -- ^ Nl: Number, Letter
        | OtherNumber           -- ^ No: Number, Other
        | ConnectorPunctuation  -- ^ Pc: Punctuation, Connector
        | DashPunctuation       -- ^ Pd: Punctuation, Dash
        | OpenPunctuation       -- ^ Ps: Punctuation, Open
        | ClosePunctuation      -- ^ Pe: Punctuation, Close
        | InitialQuote          -- ^ Pi: Punctuation, Initial quote
        | FinalQuote            -- ^ Pf: Punctuation, Final quote
        | OtherPunctuation      -- ^ Po: Punctuation, Other
        | MathSymbol            -- ^ Sm: Symbol, Math
        | CurrencySymbol        -- ^ Sc: Symbol, Currency
        | ModifierSymbol        -- ^ Sk: Symbol, Modifier
        | OtherSymbol           -- ^ So: Symbol, Other
        | Space                 -- ^ Zs: Separator, Space
        | LineSeparator         -- ^ Zl: Separator, Line
        | ParagraphSeparator    -- ^ Zp: Separator, Paragraph
        | Control               -- ^ Cc: Other, Control
        | Format                -- ^ Cf: Other, Format
        | Surrogate             -- ^ Cs: Other, Surrogate
        | PrivateUse            -- ^ Co: Other, Private Use
        | NotAssigned           -- ^ Cn: Other, Not Assigned
        deriving (Eq, Ord, Enum, Read, Show, Bounded, Ix)

-- | The Unicode general category of the character.
generalCategory :: Char -> GeneralCategory




generalCategory c = toEnum (primUniGenCat c)


-- derived character classifiers

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
-- title-case letters, plus letters of caseless scripts and modifiers letters).
-- This function is equivalent to 'Data.Char.isAlpha'.
isLetter :: Char -> Bool
isLetter c = case generalCategory c of
        UppercaseLetter         -> True
        LowercaseLetter         -> True
        TitlecaseLetter         -> True
        ModifierLetter          -> True
        OtherLetter             -> True
        _                       -> False

-- | Selects Unicode mark characters, e.g. accents and the like, which
-- combine with preceding letters.
isMark :: Char -> Bool
isMark c = case generalCategory c of
        NonSpacingMark          -> True
        SpacingCombiningMark    -> True
        EnclosingMark           -> True
        _                       -> False

-- | Selects Unicode numeric characters, including digits from various
-- scripts, Roman numerals, etc.
isNumber :: Char -> Bool
isNumber c = case generalCategory c of
        DecimalNumber           -> True
        LetterNumber            -> True
        OtherNumber             -> True
        _                       -> False

-- | Selects Unicode punctuation characters, including various kinds
-- of connectors, brackets and quotes.
isPunctuation :: Char -> Bool
isPunctuation c = case generalCategory c of
        ConnectorPunctuation    -> True
        DashPunctuation         -> True
        OpenPunctuation         -> True
        ClosePunctuation        -> True
        InitialQuote            -> True
        FinalQuote              -> True
        OtherPunctuation        -> True
        _                       -> False

-- | Selects Unicode symbol characters, including mathematical and
-- currency symbols.
isSymbol :: Char -> Bool
isSymbol c = case generalCategory c of
        MathSymbol              -> True
        CurrencySymbol          -> True
        ModifierSymbol          -> True
        OtherSymbol             -> True
        _                       -> False

-- | Selects Unicode space and separator characters.
isSeparator :: Char -> Bool
isSeparator c = case generalCategory c of
        Space                   -> True
        LineSeparator           -> True
        ParagraphSeparator      -> True
        _                       -> False






-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Complex
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Complex numbers.
--
-----------------------------------------------------------------------------

module Data.Complex
	(
	-- * Rectangular form
	  Complex((:+))

	, realPart	-- :: (RealFloat a) => Complex a -> a
	, imagPart      -- :: (RealFloat a) => Complex a -> a
	-- * Polar form
	, mkPolar       -- :: (RealFloat a) => a -> a -> Complex a
	, cis           -- :: (RealFloat a) => a -> Complex a
	, polar         -- :: (RealFloat a) => Complex a -> (a,a)
	, magnitude     -- :: (RealFloat a) => Complex a -> a
	, phase         -- :: (RealFloat a) => Complex a -> a
	-- * Conjugate
	, conjugate     -- :: (RealFloat a) => Complex a -> Complex a

	-- Complex instances:
	--
	--  (RealFloat a) => Eq         (Complex a)
	--  (RealFloat a) => Read       (Complex a)
	--  (RealFloat a) => Show       (Complex a)
	--  (RealFloat a) => Num        (Complex a)
	--  (RealFloat a) => Fractional (Complex a)
	--  (RealFloat a) => Floating   (Complex a)
	-- 
        -- Implementation checked wrt. Haskell 98 lib report, 1/99.

        )  where

import Prelude

import Data.Typeable


import Hugs.Prelude(Num(fromInt), Fractional(fromDouble))


infix  6  :+

-- -----------------------------------------------------------------------------
-- The Complex type

-- | Complex numbers are an algebraic type.
--
-- For a complex number @z@, @'abs' z@ is a number with the magnitude of @z@,
-- but oriented in the positive real direction, whereas @'signum' z@
-- has the phase of @z@, but unit magnitude.
data (RealFloat a) => Complex a
  = !a :+ !a	-- ^ forms a complex number from its real and imaginary
		-- rectangular components.
  deriving (Eq, Read, Show)

-- -----------------------------------------------------------------------------
-- Functions over Complex

-- | Extracts the real part of a complex number.
realPart :: (RealFloat a) => Complex a -> a
realPart (x :+ _) =  x

-- | Extracts the imaginary part of a complex number.
imagPart :: (RealFloat a) => Complex a -> a
imagPart (_ :+ y) =  y

-- | The conjugate of a complex number.
{-# SPECIALISE conjugate :: Complex Double -> Complex Double #-}
conjugate	 :: (RealFloat a) => Complex a -> Complex a
conjugate (x:+y) =  x :+ (-y)

-- | Form a complex number from polar components of magnitude and phase.
{-# SPECIALISE mkPolar :: Double -> Double -> Complex Double #-}
mkPolar		 :: (RealFloat a) => a -> a -> Complex a
mkPolar r theta	 =  r * cos theta :+ r * sin theta

-- | @'cis' t@ is a complex value with magnitude @1@
-- and phase @t@ (modulo @2*'pi'@).
{-# SPECIALISE cis :: Double -> Complex Double #-}
cis		 :: (RealFloat a) => a -> Complex a
cis theta	 =  cos theta :+ sin theta

-- | The function 'polar' takes a complex number and
-- returns a (magnitude, phase) pair in canonical form:
-- the magnitude is nonnegative, and the phase in the range @(-'pi', 'pi']@;
-- if the magnitude is zero, then so is the phase.
{-# SPECIALISE polar :: Complex Double -> (Double,Double) #-}
polar		 :: (RealFloat a) => Complex a -> (a,a)
polar z		 =  (magnitude z, phase z)

-- | The nonnegative magnitude of a complex number.
{-# SPECIALISE magnitude :: Complex Double -> Double #-}
magnitude :: (RealFloat a) => Complex a -> a
magnitude (x:+y) =  scaleFloat k
		     (sqrt ((scaleFloat mk x)^(2::Int) + (scaleFloat mk y)^(2::Int)))
		    where k  = max (exponent x) (exponent y)
		          mk = - k

-- | The phase of a complex number, in the range @(-'pi', 'pi']@.
-- If the magnitude is zero, then so is the phase.
{-# SPECIALISE phase :: Complex Double -> Double #-}
phase :: (RealFloat a) => Complex a -> a
phase (0 :+ 0)   = 0		-- SLPJ July 97 from John Peterson
phase (x:+y)	 = atan2 y x


-- -----------------------------------------------------------------------------
-- Instances of Complex

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      























































complexTc = mkTyCon "Complex"; instance Typeable1 Complex where { typeOf1 _ = mkTyConApp complexTc [] }; instance Typeable a => Typeable (Complex a) where { typeOf = typeOfDefault }

instance  (RealFloat a) => Num (Complex a)  where
    {-# SPECIALISE instance Num (Complex Float) #-}
    {-# SPECIALISE instance Num (Complex Double) #-}
    (x:+y) + (x':+y')	=  (x+x') :+ (y+y')
    (x:+y) - (x':+y')	=  (x-x') :+ (y-y')
    (x:+y) * (x':+y')	=  (x*x'-y*y') :+ (x*y'+y*x')
    negate (x:+y)	=  negate x :+ negate y
    abs z		=  magnitude z :+ 0
    signum 0		=  0
    signum z@(x:+y)	=  x/r :+ y/r  where r = magnitude z
    fromInteger n	=  fromInteger n :+ 0

    fromInt n		=  fromInt n :+ 0


instance  (RealFloat a) => Fractional (Complex a)  where
    {-# SPECIALISE instance Fractional (Complex Float) #-}
    {-# SPECIALISE instance Fractional (Complex Double) #-}
    (x:+y) / (x':+y')	=  (x*x''+y*y'') / d :+ (y*x''-x*y'') / d
			   where x'' = scaleFloat k x'
				 y'' = scaleFloat k y'
				 k   = - max (exponent x') (exponent y')
				 d   = x'*x'' + y'*y''

    fromRational a	=  fromRational a :+ 0

    fromDouble a	=  fromDouble a :+ 0


instance  (RealFloat a) => Floating (Complex a)	where
    {-# SPECIALISE instance Floating (Complex Float) #-}
    {-# SPECIALISE instance Floating (Complex Double) #-}
    pi             =  pi :+ 0
    exp (x:+y)     =  expx * cos y :+ expx * sin y
                      where expx = exp x
    log z          =  log (magnitude z) :+ phase z

    sqrt 0         =  0
    sqrt z@(x:+y)  =  u :+ (if y < 0 then -v else v)
                      where (u,v) = if x < 0 then (v',u') else (u',v')
                            v'    = abs y / (u'*2)
                            u'    = sqrt ((magnitude z + abs x) / 2)

    sin (x:+y)     =  sin x * cosh y :+ cos x * sinh y
    cos (x:+y)     =  cos x * cosh y :+ (- sin x * sinh y)
    tan (x:+y)     =  (sinx*coshy:+cosx*sinhy)/(cosx*coshy:+(-sinx*sinhy))
                      where sinx  = sin x
                            cosx  = cos x
                            sinhy = sinh y
                            coshy = cosh y

    sinh (x:+y)    =  cos y * sinh x :+ sin  y * cosh x
    cosh (x:+y)    =  cos y * cosh x :+ sin y * sinh x
    tanh (x:+y)    =  (cosy*sinhx:+siny*coshx)/(cosy*coshx:+siny*sinhx)
                      where siny  = sin y
                            cosy  = cos y
                            sinhx = sinh x
                            coshx = cosh x

    asin z@(x:+y)  =  y':+(-x')
                      where  (x':+y') = log (((-y):+x) + sqrt (1 - z*z))
    acos z         =  y'':+(-x'')
                      where (x'':+y'') = log (z + ((-y'):+x'))
                            (x':+y')   = sqrt (1 - z*z)
    atan z@(x:+y)  =  y':+(-x')
                      where (x':+y') = log (((1-y):+x) / sqrt (1+z*z))

    asinh z        =  log (z + sqrt (1+z*z))
    acosh z        =  log (z + (z+1) * sqrt ((z-1)/(z+1)))
    atanh z        =  log ((1+z) / sqrt (1-z*z))
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Dynamic
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- The Dynamic interface provides basic support for dynamic types.
-- 
-- Operations for injecting values of arbitrary type into
-- a dynamically typed value, Dynamic, are provided, together
-- with operations for converting dynamic values into a concrete
-- (monomorphic) type.
-- 
-----------------------------------------------------------------------------

module Data.Dynamic
  (

	-- Module Data.Typeable re-exported for convenience
	module Data.Typeable,

	-- * The @Dynamic@ type
	Dynamic,	-- abstract, instance of: Show, Typeable

	-- * Converting to and from @Dynamic@
	toDyn,		-- :: Typeable a => a -> Dynamic
	fromDyn,	-- :: Typeable a => Dynamic -> a -> a
	fromDynamic,	-- :: Typeable a => Dynamic -> Maybe a
	
	-- * Applying functions of dynamic type
	dynApply,
	dynApp,
        dynTypeRep

  ) where


import Data.Typeable
import Data.Maybe









import Hugs.Prelude
import Hugs.IO
import Hugs.IORef
import Hugs.IOExts












                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
























































-------------------------------------------------------------
--
--		The type Dynamic
--
-------------------------------------------------------------

{-|
  A value of type 'Dynamic' is an object encapsulated together with its type.

  A 'Dynamic' may only represent a monomorphic value; an attempt to
  create a value of type 'Dynamic' from a polymorphically-typed
  expression will result in an ambiguity error (see 'toDyn').

  'Show'ing a value of type 'Dynamic' returns a pretty-printed representation
  of the object\'s type; useful for debugging.
-}




dynamicTc = mkTyCon "Dynamic"; instance Typeable Dynamic where { typeOf _ = mkTyConApp dynamicTc [] }

instance Show Dynamic where
   -- the instance just prints the type representation.
   showsPrec _ (Dynamic t _) = 
          showString "<<" . 
	  showsPrec 0 t   . 
	  showString ">>"
















-- | Converts an arbitrary value into an object of type 'Dynamic'.  
--
-- The type of the object must be an instance of 'Typeable', which
-- ensures that only monomorphically-typed objects may be converted to
-- 'Dynamic'.  To convert a polymorphic object into 'Dynamic', give it
-- a monomorphic type signature.  For example:
--
-- >    toDyn (id :: Int -> Int)
--
toDyn :: Typeable a => a -> Dynamic
toDyn v = Dynamic (typeOf v) (unsafeCoerce v)

-- | Converts a 'Dynamic' object back into an ordinary Haskell value of
-- the correct type.  See also 'fromDynamic'.
fromDyn :: Typeable a
 	=> Dynamic 	-- ^ the dynamically-typed object
	-> a		-- ^ a default value 
	-> a		-- ^ returns: the value of the first argument, if
			-- it has the correct type, otherwise the value of
			-- the second argument.
fromDyn (Dynamic t v) def
  | typeOf def == t = unsafeCoerce v
  | otherwise       = def

-- | Converts a 'Dynamic' object back into an ordinary Haskell value of
-- the correct type.  See also 'fromDyn'.
fromDynamic
	:: Typeable a
	=> Dynamic	-- ^ the dynamically-typed object
	-> Maybe a	-- ^ returns: @'Just' a@, if the dynamically-typed
			-- object has the correct type (and @a@ is its value), 
			-- or 'Nothing' otherwise.
fromDynamic (Dynamic t v) =
  case unsafeCoerce v of 
    r | t == typeOf r -> Just r
      | otherwise     -> Nothing

-- (f::(a->b)) `dynApply` (x::a) = (f a)::b
dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
dynApply (Dynamic t1 f) (Dynamic t2 x) =
  case funResultTy t1 t2 of
    Just t3 -> Just (Dynamic t3 ((unsafeCoerce f) x))
    Nothing -> Nothing

dynApp :: Dynamic -> Dynamic -> Dynamic
dynApp f x = case dynApply f x of 
             Just r -> r
             Nothing -> error ("Type error in dynamic application.\n" ++
                               "Can't apply function " ++ show f ++
                               " to argument " ++ show x)

dynTypeRep :: Dynamic -> TypeRep
dynTypeRep (Dynamic tr _) = tr 
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Either
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- The Either type, and associated operations.
--
-----------------------------------------------------------------------------

module Data.Either (
   Either(..),
   either	-- :: (a -> c) -> (b -> c) -> Either a b -> c
 ) where























{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Eq
-- Copyright   :  (c) The University of Glasgow 2005
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  stable
-- Portability :  portable
--
-- Equality
--
-----------------------------------------------------------------------------

module Data.Eq (
   Eq(..),
 ) where




{-# OPTIONS -Wall -Werror -fno-warn-unused-binds #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Fixed
-- Copyright   :  (c) Ashley Yakeley 2005, 2006
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  Ashley Yakeley <ashley@semantic.org>
-- Stability   :  experimental
-- Portability :  portable
--
-- This module defines a "Fixed" type for fixed-precision arithmetic.
-- The parameter to Fixed is any type that's an instance of HasResolution.
-- HasResolution has a single method that gives the resolution of the Fixed type.
-- Parameter types E6 and E12 (for 10^6 and 10^12) are defined, as well as
-- type synonyms for Fixed E6 and Fixed E12.
--
-- This module also contains generalisations of div, mod, and divmod to work
-- with any Real instance.
--
-----------------------------------------------------------------------------

module Data.Fixed
(
	div',mod',divMod',

	Fixed,HasResolution(..),
	showFixed,
	E6,Micro,
	E12,Pico
) where

import Prelude -- necessary to get dependencies right

-- | generalisation of 'div' to any instance of Real
div' :: (Real a,Integral b) => a -> a -> b
div' n d = floor ((toRational n) / (toRational d))

-- | generalisation of 'divMod' to any instance of Real
divMod' :: (Real a,Integral b) => a -> a -> (b,a)
divMod' n d = (f,n - (fromIntegral f) * d) where
	f = div' n d

-- | generalisation of 'mod' to any instance of Real
mod' :: (Real a) => a -> a -> a
mod' n d = n - (fromInteger f) * d where
	f = div' n d

newtype Fixed a = MkFixed Integer deriving (Eq,Ord)

class HasResolution a where
	resolution :: a -> Integer

fixedResolution :: (HasResolution a) => Fixed a -> Integer
fixedResolution fa = resolution (uf fa) where
	uf :: Fixed a -> a
	uf _ = undefined

withType :: (a -> f a) -> f a
withType foo = foo undefined

withResolution :: (HasResolution a) => (Integer -> f a) -> f a
withResolution foo = withType (foo . resolution)

instance Enum (Fixed a) where
	succ (MkFixed a) = MkFixed (succ a)
	pred (MkFixed a) = MkFixed (pred a)
	toEnum = MkFixed . toEnum
	fromEnum (MkFixed a) = fromEnum a
	enumFrom (MkFixed a) = fmap MkFixed (enumFrom a)
	enumFromThen (MkFixed a) (MkFixed b) = fmap MkFixed (enumFromThen a b)
	enumFromTo (MkFixed a) (MkFixed b) = fmap MkFixed (enumFromTo a b)
	enumFromThenTo (MkFixed a) (MkFixed b) (MkFixed c) = fmap MkFixed (enumFromThenTo a b c)

instance (HasResolution a) => Num (Fixed a) where
	(MkFixed a) + (MkFixed b) = MkFixed (a + b)
	(MkFixed a) - (MkFixed b) = MkFixed (a - b)
	fa@(MkFixed a) * (MkFixed b) = MkFixed (div (a * b) (fixedResolution fa))
	negate (MkFixed a) = MkFixed (negate a)
	abs (MkFixed a) = MkFixed (abs a)
	signum (MkFixed a) = fromInteger (signum a)
	fromInteger i = withResolution (\res -> MkFixed (i * res))

instance (HasResolution a) => Real (Fixed a) where
	toRational fa@(MkFixed a) = (toRational a) / (toRational (fixedResolution fa))

instance (HasResolution a) => Fractional (Fixed a) where
	fa@(MkFixed a) / (MkFixed b) = MkFixed (div (a * (fixedResolution fa)) b)
	recip fa@(MkFixed a) = MkFixed (div (res * res) a) where
		res = fixedResolution fa
	fromRational r = withResolution (\res -> MkFixed (floor (r * (toRational res))))

instance (HasResolution a) => RealFrac (Fixed a) where
	properFraction a = (i,a - (fromIntegral i)) where
		i = truncate a
	truncate f = truncate (toRational f)
	round f = round (toRational f)
	ceiling f = ceiling (toRational f)
	floor f = floor (toRational f)

chopZeros :: Integer -> String
chopZeros 0 = ""
chopZeros a | mod a 10 == 0 = chopZeros (div a 10)
chopZeros a = show a

-- only works for positive a
showIntegerZeros :: Bool -> Int -> Integer -> String
showIntegerZeros True _ 0 = ""
showIntegerZeros chopTrailingZeros digits a = replicate (digits - length s) '0' ++ s' where
	s = show a
	s' = if chopTrailingZeros then chopZeros a else s

withDot :: String -> String
withDot "" = ""
withDot s = '.':s

-- | First arg is whether to chop off trailing zeros
showFixed :: (HasResolution a) => Bool -> Fixed a -> String
showFixed chopTrailingZeros fa@(MkFixed a) | a < 0 = "-" ++ (showFixed chopTrailingZeros (asTypeOf (MkFixed (negate a)) fa))
showFixed chopTrailingZeros fa@(MkFixed a) = (show i) ++ (withDot (showIntegerZeros chopTrailingZeros digits fracNum)) where
	res = fixedResolution fa
	(i,d) = divMod a res
	-- enough digits to be unambiguous
	digits = ceiling (logBase 10 (fromInteger res) :: Double)
	maxnum = 10 ^ digits
	fracNum = div (d * maxnum) res

instance (HasResolution a) => Show (Fixed a) where
	show = showFixed False



data E6 = E6

instance HasResolution E6 where
	resolution _ = 1000000

type Micro = Fixed E6


data E12 = E12

instance HasResolution E12 where
	resolution _ = 1000000000000

type Pico = Fixed E12
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Foldable
-- Copyright   :  Ross Paterson 2005
-- License     :  BSD-style (see the LICENSE file in the distribution)
--
-- Maintainer  :  ross@soi.city.ac.uk
-- Stability   :  experimental
-- Portability :  portable
--
-- Class of data structures that can be folded to a summary value.
--
-- Many of these functions generalize "Prelude", "Control.Monad" and
-- "Data.List" functions of the same names from lists to any 'Foldable'
-- functor.  To avoid ambiguity, either import those modules hiding
-- these names or qualify uses of these function names with an alias
-- for this module.

module Data.Foldable (
	-- * Folds
	Foldable(..),
	-- ** Special biased folds
	foldr',
	foldl',
	foldrM,
	foldlM,
	-- ** Folding actions
	-- *** Applicative actions
	traverse_,
	for_,
	sequenceA_,
	asum,
	-- *** Monadic actions
	mapM_,
	forM_,
	sequence_,
	msum,
	-- ** Specialized folds
	toList,
	concat,
	concatMap,
	and,
	or,
	any,
	all,
	sum,
	product,
	maximum,
	maximumBy,
	minimum,
	minimumBy,
	-- ** Searches
	elem,
	notElem,
	find
	) where

import Prelude hiding (foldl, foldr, foldl1, foldr1, mapM_, sequence_,
		elem, notElem, concat, concatMap, and, or, any, all,
		sum, product, maximum, minimum)
import qualified Prelude (foldl, foldr, foldl1, foldr1)
import Control.Applicative
import Control.Monad (MonadPlus(..))
import Data.Maybe (fromMaybe, listToMaybe)
import Data.Monoid
import Data.Array









-- | Data structures that can be folded.
--
-- Minimal complete definition: 'foldMap' or 'foldr'.
--
-- For example, given a data type
--
-- > data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--
-- a suitable instance would be
--
-- > instance Foldable Tree
-- >    foldMap f Empty = mempty
-- >    foldMap f (Leaf x) = f x
-- >    foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--
-- This is suitable even for abstract types, as the monoid is assumed
-- to satisfy the monoid laws.
--
class Foldable t where
	-- | Combine the elements of a structure using a monoid.
	fold :: Monoid m => t m -> m
	fold = foldMap id

	-- | Map each element of the structure to a monoid,
	-- and combine the results.
	foldMap :: Monoid m => (a -> m) -> t a -> m
	foldMap f = foldr (mappend . f) mempty

	-- | Right-associative fold of a structure.
	--
	-- @'foldr' f z = 'Prelude.foldr' f z . 'toList'@
	foldr :: (a -> b -> b) -> b -> t a -> b
	foldr f z t = appEndo (foldMap (Endo . f) t) z

	-- | Left-associative fold of a structure.
	--
	-- @'foldl' f z = 'Prelude.foldl' f z . 'toList'@
	foldl :: (a -> b -> a) -> a -> t b -> a
	foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z

	-- | A variant of 'foldr' that has no base case,
	-- and thus may only be applied to non-empty structures.
	--
	-- @'foldr1' f = 'Prelude.foldr1' f . 'toList'@
	foldr1 :: (a -> a -> a) -> t a -> a
	foldr1 f xs = fromMaybe (error "foldr1: empty structure")
			(foldr mf Nothing xs)
	  where mf x Nothing = Just x
		mf x (Just y) = Just (f x y)

	-- | A variant of 'foldl' that has no base case,
	-- and thus may only be applied to non-empty structures.
	--
	-- @'foldl1' f = 'Prelude.foldl1' f . 'toList'@
	foldl1 :: (a -> a -> a) -> t a -> a
	foldl1 f xs = fromMaybe (error "foldl1: empty structure")
			(foldl mf Nothing xs)
	  where mf Nothing y = Just y
		mf (Just x) y = Just (f x y)

-- instances for Prelude types

instance Foldable Maybe where
	foldr f z Nothing = z
	foldr f z (Just x) = f x z

	foldl f z Nothing = z
	foldl f z (Just x) = f z x

instance Foldable [] where
	foldr = Prelude.foldr
	foldl = Prelude.foldl
	foldr1 = Prelude.foldr1
	foldl1 = Prelude.foldl1

instance Ix i => Foldable (Array i) where
	foldr f z = Prelude.foldr f z . elems

-- | Fold over the elements of a structure,
-- associating to the right, but strictly.
foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldr' f z xs = foldl f' id xs z
  where f' k x z = k $! f x z

-- | Monadic fold over the elements of a structure,
-- associating to the right, i.e. from right to left.
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
foldrM f z xs = foldl f' return xs z
  where f' k x z = f x z >>= k

-- | Fold over the elements of a structure,
-- associating to the left, but strictly.
foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
foldl' f z xs = foldr f' id xs z
  where f' x k z = k $! f z x

-- | Monadic fold over the elements of a structure,
-- associating to the left, i.e. from left to right.
foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
foldlM f z xs = foldr f' return xs z
  where f' x k z = f z x >>= k

-- | Map each element of a structure to an action, evaluate
-- these actions from left to right, and ignore the results.
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
traverse_ f = foldr ((*>) . f) (pure ())

-- | 'for_' is 'traverse_' with its arguments flipped.
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
{-# INLINE for_ #-}
for_ = flip traverse_

-- | Map each element of a structure to an monadic action, evaluate
-- these actions from left to right, and ignore the results.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
mapM_ f = foldr ((>>) . f) (return ())

-- | 'forM_' is 'mapM_' with its arguments flipped.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
{-# INLINE forM_ #-}
forM_ = flip mapM_

-- | Evaluate each action in the structure from left to right,
-- and ignore the results.
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
sequenceA_ = foldr (*>) (pure ())

-- | Evaluate each monadic action in the structure from left to right,
-- and ignore the results.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
sequence_ = foldr (>>) (return ())

-- | The sum of a collection of actions, generalizing 'concat'.
asum :: (Foldable t, Alternative f) => t (f a) -> f a
{-# INLINE asum #-}
asum = foldr (<|>) empty

-- | The sum of a collection of actions, generalizing 'concat'.
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
{-# INLINE msum #-}
msum = foldr mplus mzero

-- These use foldr rather than foldMap to avoid repeated concatenation.

-- | List of elements of a structure.
toList :: Foldable t => t a -> [a]



toList = foldr (:) []


-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]
concat = fold

-- | Map a function over all the elements of a container and concatenate
-- the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
concatMap = foldMap

-- | 'and' returns the conjunction of a container of Bools.  For the
-- result to be 'True', the container must be finite; 'False', however,
-- results from a 'False' value finitely far from the left end.
and :: Foldable t => t Bool -> Bool
and = getAll . foldMap All

-- | 'or' returns the disjunction of a container of Bools.  For the
-- result to be 'False', the container must be finite; 'True', however,
-- results from a 'True' value finitely far from the left end.
or :: Foldable t => t Bool -> Bool
or = getAny . foldMap Any

-- | Determines whether any element of the structure satisfies the predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool
any p = getAny . foldMap (Any . p)

-- | Determines whether all elements of the structure satisfy the predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool
all p = getAll . foldMap (All . p)

-- | The 'sum' function computes the sum of the numbers of a structure.
sum :: (Foldable t, Num a) => t a -> a
sum = getSum . foldMap Sum

-- | The 'product' function computes the product of the numbers of a structure.
product :: (Foldable t, Num a) => t a -> a
product = getProduct . foldMap Product

-- | The largest element of a non-empty structure.
maximum :: (Foldable t, Ord a) => t a -> a
maximum = foldr1 max

-- | The largest element of a non-empty structure with respect to the
-- given comparison function.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
maximumBy cmp = foldr1 max'
  where max' x y = case cmp x y of
			GT -> x
			_  -> y

-- | The least element of a non-empty structure.
minimum :: (Foldable t, Ord a) => t a -> a
minimum = foldr1 min

-- | The least element of a non-empty structure with respect to the
-- given comparison function.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
minimumBy cmp = foldr1 min'
  where min' x y = case cmp x y of
			GT -> y
			_  -> x

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool
elem = any . (==)

-- | 'notElem' is the negation of 'elem'.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
notElem x = not . elem x

-- | The 'find' function takes a predicate and a structure and returns
-- the leftmost element of the structure matching the predicate, or
-- 'Nothing' if there is no such element.
find :: Foldable t => (a -> Bool) -> t a -> Maybe a
find p = listToMaybe . concatMap (\ x -> if p x then [x] else [])
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.FunctorM
-- Copyright   :  (c) The University of Glasgow 2005
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- fmapM generalises fmap, just as mapM generalises map.
--
-- NOTE: This module is DEPRECATED.
-- The classes in "Data.Foldable" and "Data.Traversable" provide a
-- more general interface.
--
-----------------------------------------------------------------------------

module Data.FunctorM
{-# DEPRECATED "Use the more general Data.Foldable and Data.Traversable instead" #-}
  (FunctorM(..)) where

import Prelude
import Data.Array

class FunctorM f where
    fmapM  :: Monad m => (a -> m b) -> f a -> m (f b)
    fmapM_ :: Monad m => (a -> m b) -> f a -> m ()

    fmapM_ f t = fmapM f t >> return ()

instance FunctorM [] where
    fmapM  = mapM
    fmapM_ = mapM_

instance FunctorM Maybe where
    fmapM _ Nothing = return Nothing
    fmapM f (Just x) = f x >>= return . Just 

    fmapM_ _ Nothing = return ()
    fmapM_ f (Just x) = f x >> return ()

instance Ix i => FunctorM (Array i) where
    fmapM f a = do 
	a' <- sequence [ f e >>= return . (,) i | (i,e) <- assocs a]
	return (array (bounds a) a')
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Graph
-- Copyright   :  (c) The University of Glasgow 2002
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (uses Control.Monad.ST)
--
-- A version of the graph algorithms described in:
--
--   /Lazy Depth-First Search and Linear Graph Algorithms in Haskell/,
--   by David King and John Launchbury.
--
-----------------------------------------------------------------------------

module Data.Graph(

	-- * External interface

	-- At present the only one with a "nice" external interface
	stronglyConnComp, stronglyConnCompR, SCC(..), flattenSCC, flattenSCCs,

	-- * Graphs

	Graph, Table, Bounds, Edge, Vertex,

	-- ** Building graphs

	graphFromEdges, graphFromEdges', buildG, transposeG,
	-- reverseE,

	-- ** Graph properties

	vertices, edges,
	outdegree, indegree,

	-- * Algorithms

	dfs, dff,
	topSort,
	components,
	scc,
	bcc,
	-- tree, back, cross, forward,
	reachable, path,

	module Data.Tree

    ) where

-- Extensions
import Control.Monad.ST
import Data.Array.ST (STArray, newArray, readArray, writeArray)
import Data.Tree (Tree(Node), Forest)

-- std interfaces
import Data.Maybe
import Data.Array
import Data.List





-------------------------------------------------------------------------
--									-
--	External interface
--									-
-------------------------------------------------------------------------

-- | Strongly connected component.
data SCC vertex = AcyclicSCC vertex	-- ^ A single vertex that is not
					-- in any cycle.
	        | CyclicSCC  [vertex]	-- ^ A maximal set of mutually
					-- reachable vertices.

-- | The vertices of a list of strongly connected components.
flattenSCCs :: [SCC a] -> [a]
flattenSCCs = concatMap flattenSCC

-- | The vertices of a strongly connected component.
flattenSCC :: SCC vertex -> [vertex]
flattenSCC (AcyclicSCC v) = [v]
flattenSCC (CyclicSCC vs) = vs

-- | The strongly connected components of a directed graph, topologically
-- sorted.
stronglyConnComp
	:: Ord key
	=> [(node, key, [key])]
		-- ^ The graph: a list of nodes uniquely identified by keys,
		-- with a list of keys of nodes this node has edges to.
		-- The out-list may contain keys that don't correspond to
		-- nodes of the graph; such edges are ignored.
	-> [SCC node]

stronglyConnComp edges0
  = map get_node (stronglyConnCompR edges0)
  where
    get_node (AcyclicSCC (n, _, _)) = AcyclicSCC n
    get_node (CyclicSCC triples)     = CyclicSCC [n | (n,_,_) <- triples]

-- | The strongly connected components of a directed graph, topologically
-- sorted.  The function is the same as 'stronglyConnComp', except that
-- all the information about each node retained.
-- This interface is used when you expect to apply 'SCC' to
-- (some of) the result of 'SCC', so you don't want to lose the
-- dependency information.
stronglyConnCompR
	:: Ord key
	=> [(node, key, [key])]
		-- ^ The graph: a list of nodes uniquely identified by keys,
		-- with a list of keys of nodes this node has edges to.
		-- The out-list may contain keys that don't correspond to
		-- nodes of the graph; such edges are ignored.
	-> [SCC (node, key, [key])]	-- ^ Topologically sorted

stronglyConnCompR [] = []  -- added to avoid creating empty array in graphFromEdges -- SOF
stronglyConnCompR edges0
  = map decode forest
  where
    (graph, vertex_fn,_) = graphFromEdges edges0
    forest	       = scc graph
    decode (Node v []) | mentions_itself v = CyclicSCC [vertex_fn v]
		       | otherwise	   = AcyclicSCC (vertex_fn v)
    decode other = CyclicSCC (dec other [])
		 where
		   dec (Node v ts) vs = vertex_fn v : foldr dec vs ts
    mentions_itself v = v `elem` (graph ! v)

-------------------------------------------------------------------------
--									-
--	Graphs
--									-
-------------------------------------------------------------------------

-- | Abstract representation of vertices.
type Vertex  = Int
-- | Table indexed by a contiguous set of vertices.
type Table a = Array Vertex a
-- | Adjacency list representation of a graph, mapping each vertex to its
-- list of successors.
type Graph   = Table [Vertex]
-- | The bounds of a 'Table'.
type Bounds  = (Vertex, Vertex)
-- | An edge from the first vertex to the second.
type Edge    = (Vertex, Vertex)

-- | All vertices of a graph.
vertices :: Graph -> [Vertex]
vertices  = indices

-- | All edges of a graph.
edges    :: Graph -> [Edge]
edges g   = [ (v, w) | v <- vertices g, w <- g!v ]

mapT    :: (Vertex -> a -> b) -> Table a -> Table b
mapT f t = array (bounds t) [ (,) v (f v (t!v)) | v <- indices t ]

-- | Build a graph from a list of edges.
buildG :: Bounds -> [Edge] -> Graph
buildG bounds0 edges0 = accumArray (flip (:)) [] bounds0 edges0

-- | The graph obtained by reversing all edges.
transposeG  :: Graph -> Graph
transposeG g = buildG (bounds g) (reverseE g)

reverseE    :: Graph -> [Edge]
reverseE g   = [ (w, v) | (v, w) <- edges g ]

-- | A table of the count of edges from each node.
outdegree :: Graph -> Table Int
outdegree  = mapT numEdges
             where numEdges _ ws = length ws

-- | A table of the count of edges into each node.
indegree :: Graph -> Table Int
indegree  = outdegree . transposeG

-- | Identical to 'graphFromEdges', except that the return value
-- does not include the function which maps keys to vertices.  This
-- version of 'graphFromEdges' is for backwards compatibility.
graphFromEdges'
	:: Ord key
	=> [(node, key, [key])]
	-> (Graph, Vertex -> (node, key, [key]))
graphFromEdges' x = (a,b) where
    (a,b,_) = graphFromEdges x

-- | Build a graph from a list of nodes uniquely identified by keys,
-- with a list of keys of nodes this node should have edges to.
-- The out-list may contain keys that don't correspond to
-- nodes of the graph; they are ignored.
graphFromEdges
	:: Ord key
	=> [(node, key, [key])]
	-> (Graph, Vertex -> (node, key, [key]), key -> Maybe Vertex)
graphFromEdges edges0
  = (graph, \v -> vertex_map ! v, key_vertex)
  where
    max_v      	    = length edges0 - 1
    bounds0         = (0,max_v) :: (Vertex, Vertex)
    sorted_edges    = sortBy lt edges0
    edges1	    = zipWith (,) [0..] sorted_edges

    graph	    = array bounds0 [(,) v (mapMaybe key_vertex ks) | (,) v (_,    _, ks) <- edges1]
    key_map	    = array bounds0 [(,) v k			   | (,) v (_,    k, _ ) <- edges1]
    vertex_map	    = array bounds0 edges1

    (_,k1,_) `lt` (_,k2,_) = k1 `compare` k2

    -- key_vertex :: key -> Maybe Vertex
    -- 	returns Nothing for non-interesting vertices
    key_vertex k   = findVertex 0 max_v
		   where
		     findVertex a b | a > b
			      = Nothing
		     findVertex a b = case compare k (key_map ! mid) of
				   LT -> findVertex a (mid-1)
				   EQ -> Just mid
				   GT -> findVertex (mid+1) b
			      where
			 	mid = (a + b) `div` 2

-------------------------------------------------------------------------
--									-
--	Depth first search
--									-
-------------------------------------------------------------------------

type Set s    = STArray s Vertex Bool

mkEmpty      :: Bounds -> ST s (Set s)
mkEmpty bnds  = newArray bnds False

contains     :: Set s -> Vertex -> ST s Bool
contains m v  = readArray m v

include      :: Set s -> Vertex -> ST s ()
include m v   = writeArray m v True

-- | A spanning forest of the graph, obtained from a depth-first search of
-- the graph starting from each vertex in an unspecified order.
dff          :: Graph -> Forest Vertex
dff g         = dfs g (vertices g)

-- | A spanning forest of the part of the graph reachable from the listed
-- vertices, obtained from a depth-first search of the graph starting at
-- each of the listed vertices in order.
dfs          :: Graph -> [Vertex] -> Forest Vertex
dfs g vs      = prune (bounds g) (map (generate g) vs)

generate     :: Graph -> Vertex -> Tree Vertex
generate g v  = Node v (map (generate g) (g!v))

prune        :: Bounds -> Forest Vertex -> Forest Vertex
prune bnds ts = runST (mkEmpty bnds  >>= \m ->
                       chop m ts)

chop         :: Set s -> Forest Vertex -> ST s (Forest Vertex)
chop _ []     = return []
chop m (Node v ts : us)
              = contains m v >>= \visited ->
                if visited then
                  chop m us
                else
                  include m v >>= \_  ->
                  chop m ts   >>= \as ->
                  chop m us   >>= \bs ->
                  return (Node v as : bs)

-------------------------------------------------------------------------
--									-
--	Algorithms
--									-
-------------------------------------------------------------------------

------------------------------------------------------------
-- Algorithm 1: depth first search numbering
------------------------------------------------------------

preorder            :: Tree a -> [a]
preorder (Node a ts) = a : preorderF ts

preorderF           :: Forest a -> [a]
preorderF ts         = concat (map preorder ts)

tabulate        :: Bounds -> [Vertex] -> Table Int
tabulate bnds vs = array bnds (zipWith (,) vs [1..])

preArr          :: Bounds -> Forest Vertex -> Table Int
preArr bnds      = tabulate bnds . preorderF

------------------------------------------------------------
-- Algorithm 2: topological sorting
------------------------------------------------------------

postorder :: Tree a -> [a]
postorder (Node a ts) = postorderF ts ++ [a]

postorderF   :: Forest a -> [a]
postorderF ts = concat (map postorder ts)

postOrd      :: Graph -> [Vertex]
postOrd       = postorderF . dff

-- | A topological sort of the graph.
-- The order is partially specified by the condition that a vertex /i/
-- precedes /j/ whenever /j/ is reachable from /i/ but not vice versa.
topSort      :: Graph -> [Vertex]
topSort       = reverse . postOrd

------------------------------------------------------------
-- Algorithm 3: connected components
------------------------------------------------------------

-- | The connected components of a graph.
-- Two vertices are connected if there is a path between them, traversing
-- edges in either direction.
components   :: Graph -> Forest Vertex
components    = dff . undirected

undirected   :: Graph -> Graph
undirected g  = buildG (bounds g) (edges g ++ reverseE g)

-- Algorithm 4: strongly connected components

-- | The strongly connected components of a graph.
scc  :: Graph -> Forest Vertex
scc g = dfs g (reverse (postOrd (transposeG g)))

------------------------------------------------------------
-- Algorithm 5: Classifying edges
------------------------------------------------------------

tree              :: Bounds -> Forest Vertex -> Graph
tree bnds ts       = buildG bnds (concat (map flat ts))
 where flat (Node v ts) = [ (v, w) | Node w _us <- ts ] ++ concat (map flat ts)

back              :: Graph -> Table Int -> Graph
back g post        = mapT select g
 where select v ws = [ w | w <- ws, post!v < post!w ]

cross             :: Graph -> Table Int -> Table Int -> Graph
cross g pre post   = mapT select g
 where select v ws = [ w | w <- ws, post!v > post!w, pre!v > pre!w ]

forward           :: Graph -> Graph -> Table Int -> Graph
forward g tree pre = mapT select g
 where select v ws = [ w | w <- ws, pre!v < pre!w ] \\ tree!v

------------------------------------------------------------
-- Algorithm 6: Finding reachable vertices
------------------------------------------------------------

-- | A list of vertices reachable from a given vertex.
reachable    :: Graph -> Vertex -> [Vertex]
reachable g v = preorderF (dfs g [v])

-- | Is the second vertex reachable from the first?
path         :: Graph -> Vertex -> Vertex -> Bool
path g v w    = w `elem` (reachable g v)

------------------------------------------------------------
-- Algorithm 7: Biconnected components
------------------------------------------------------------

-- | The biconnected components of a graph.
-- An undirected graph is biconnected if the deletion of any vertex
-- leaves it connected.
bcc :: Graph -> Forest [Vertex]
bcc g = (concat . map bicomps . map (do_label g dnum)) forest
 where forest = dff g
       dnum   = preArr (bounds g) forest

do_label :: Graph -> Table Int -> Tree Vertex -> Tree (Vertex,Int,Int)
do_label g dnum (Node v ts) = Node (v,dnum!v,lv) us
 where us = map (do_label g dnum) ts
       lv = minimum ([dnum!v] ++ [dnum!w | w <- g!v]
                     ++ [lu | Node (u,du,lu) xs <- us])

bicomps :: Tree (Vertex,Int,Int) -> Forest [Vertex]
bicomps (Node (v,_,_) ts)
      = [ Node (v:vs) us | (l,Node vs us) <- map collect ts]

collect :: Tree (Vertex,Int,Int) -> (Int, Tree [Vertex])
collect (Node (v,dv,lv) ts) = (lv, Node (v:vs) cs)
 where collected = map collect ts
       vs = concat [ ws | (lw, Node ws us) <- collected, lw<dv]
       cs = concat [ if lw<dv then us else [Node (v:ws) us]
                        | (lw, Node ws us) <- collected ]
{-# OPTIONS_GHC -fno-implicit-prelude #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  Data.HashTable
-- Copyright   :  (c) The University of Glasgow 2003
-- License     :  BSD-style (see the file libraries/base/LICENSE)
--
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- An implementation of extensible hash tables, as described in
-- Per-Ake Larson, /Dynamic Hash Tables/, CACM 31(4), April 1988,
-- pp. 446--457.  The implementation is also derived from the one
-- in GHC's runtime system (@ghc\/rts\/Hash.{c,h}@).
--
-----------------------------------------------------------------------------

module Data.HashTable (
	-- * Basic hash table operations
	HashTable, new, insert, delete, lookup, update,
	-- * Converting to and from lists
	fromList, toList,
	-- * Hash functions
	-- $hash_functions
	hashInt, hashString,
	prime,
	-- * Diagnostics
	longestChain
 ) where

-- This module is imported by Data.Dynamic, which is pretty low down in the
-- module hierarchy, so don't import "high-level" modules




import Prelude	hiding	( lookup )

import Data.Tuple	( fst )
import Data.Bits
import Data.Maybe
import Data.List	( maximumBy, length, concat, foldl', partition )
import Data.Int		( Int32 )











import Data.Char	( ord )
import Data.IORef	( IORef, newIORef, readIORef, writeIORef )
import System.IO.Unsafe	( unsafePerformIO )
import Data.Int		( Int64 )

import Hugs.IOArray	( IOArray, newIOArray,
			  unsafeReadIOArray, unsafeWriteIOArray )




import Control.Monad	( mapM, mapM_, sequence_ )


-----------------------------------------------------------------------

iNSTRUMENTED :: Bool
iNSTRUMENTED = False

-----------------------------------------------------------------------

readHTArray  :: HTArray a -> Int32 -> IO a
writeMutArray :: MutArray a -> Int32 -> a -> IO ()
freezeArray  :: MutArray a -> IO (HTArray a)
thawArray    :: HTArray a -> IO (MutArray a)
newMutArray   :: (Int32, Int32) -> a -> IO (MutArray a)









type MutArray a = IOArray Int32 a
type HTArray a = MutArray a -- Array Int32 a
newMutArray = newIOArray
readHTArray arr i = readMutArray arr i -- return $! (unsafeAt arr (fromIntegral i))
readMutArray  :: MutArray a -> Int32 -> IO a
readMutArray arr i = unsafeReadIOArray arr (fromIntegral i)
writeMutArray arr i x = unsafeWriteIOArray arr (fromIntegral i) x
freezeArray = return -- unsafeFreeze
thawArray = return -- unsafeThaw


data HashTable key val = HashTable {
	                             cmp     :: !(key -> key -> Bool),
	                             hash_fn :: !(key -> Int32),
                                     tab     :: !(IORef (HT key val))
                                   }
-- TODO: the IORef should really be an MVar.

data HT key val
  = HT {
	kcount  :: !Int32,              -- Total number of keys.
        bmask   :: !Int32,
	buckets :: !(HTArray [(key,val)])
       }

-- ------------------------------------------------------------
-- Instrumentation for performance tuning

-- This ought to be roundly ignored after optimization when
-- iNSTRUMENTED=False.

-- STRICT version of modifyIORef!
modifyIORef :: IORef a -> (a -> a) -> IO ()
modifyIORef r f = do
  v <- readIORef r
  let z = f v in z `seq` writeIORef r z

data HashData = HD {
  tables :: !Integer,
  insertions :: !Integer,
  lookups :: !Integer,
  totBuckets :: !Integer,
  maxEntries :: !Int32,
  maxChain :: !Int,
  maxBuckets :: !Int32
} deriving (Eq, Show)

{-# NOINLINE hashData #-}
hashData :: IORef HashData
hashData =  unsafePerformIO (newIORef (HD { tables=0, insertions=0, lookups=0,
                                            totBuckets=0, maxEntries=0,
                                            maxChain=0, maxBuckets=tABLE_MIN } ))

instrument :: (HashData -> HashData) -> IO ()
instrument i | iNSTRUMENTED = modifyIORef hashData i
             | otherwise    = return ()

recordNew :: IO ()
recordNew = instrument rec
  where rec hd@HD{ tables=t, totBuckets=b } =
               hd{ tables=t+1, totBuckets=b+fromIntegral tABLE_MIN }

recordIns :: Int32 -> Int32 -> [a] -> IO ()
recordIns i sz bkt = instrument rec
  where rec hd@HD{ insertions=ins, maxEntries=mx, maxChain=mc } =
               hd{ insertions=ins+fromIntegral i, maxEntries=mx `max` sz,
                   maxChain=mc `max` length bkt }

recordResize :: Int32 -> Int32 -> IO ()
recordResize older newer = instrument rec
  where rec hd@HD{ totBuckets=b, maxBuckets=mx } =
               hd{ totBuckets=b+fromIntegral (newer-older),
                   maxBuckets=mx `max` newer }

recordLookup :: IO ()
recordLookup = instrument lkup
  where lkup hd@HD{ lookups=l } = hd{ lookups=l+1 }

-- stats :: IO String
-- stats =  fmap show $ readIORef hashData

-- -----------------------------------------------------------------------------
-- Sample hash functions

-- $hash_functions
--
-- This implementation of hash tables uses the low-order /n/ bits of the hash
-- value for a key, where /n/ varies as the hash table grows.  A good hash
-- function therefore will give an even distribution regardless of /n/.
--
-- If your keyspace is integrals such that the low-order bits between
-- keys are highly variable, then you could get away with using 'id'
-- as the hash function.
--
-- We provide some sample hash functions for 'Int' and 'String' below.

golden :: Int32
golden = -1640531527

-- | A sample (and useful) hash function for Int and Int32,
-- implemented by extracting the uppermost 32 bits of the 64-bit
-- result of multiplying by a 32-bit constant.  The constant is from
-- Knuth, derived from the golden ratio:
--
-- > golden = round ((sqrt 5 - 1) * 2^31) :: Int
hashInt :: Int -> Int32
hashInt x = mulHi (fromIntegral x) golden

-- hi 32 bits of a x-bit * 32 bit -> 64-bit multiply
mulHi :: Int32 -> Int32 -> Int32
mulHi a b = fromIntegral (r `shiftR` 32)
  where r :: Int64
        r = fromIntegral a * fromIntegral b :: Int64

-- | A sample hash function for Strings.  We keep multiplying by the
-- golden ratio and adding.  The implementation is:
--
-- > hashString = foldl' f 0
-- >   where f m c = fromIntegral (ord c) + mulHi m golden
--
-- Note that this has not been extensively tested for reasonability,
-- but Knuth argues that repeated multiplication by the golden ratio
-- will minimize gaps in the hash space.
hashString :: String -> Int32
hashString = foldl' f 0
  where f m c = fromIntegral (ord c) + mulHi m golden

-- | A prime larger than the maximum hash table size
prime :: Int32
prime = 33554467

-- -----------------------------------------------------------------------------
-- Parameters

tABLE_MAX :: Int32
tABLE_MAX  = 32 * 1024 * 1024   -- Maximum size of hash table
tABLE_MIN :: Int32
tABLE_MIN  = 8

hLOAD :: Int32
hLOAD = 7                       -- Maximum average load of a single hash bucket

hYSTERESIS :: Int32
hYSTERESIS = 64                 -- entries to ignore in load computation

{- Hysteresis favors long association-list-like behavior for small tables. -}

-- -----------------------------------------------------------------------------
-- Creating a new hash table

-- | Creates a new hash table.  The following property should hold for the @eq@
-- and @hash@ functions passed to 'new':
--
-- >   eq A B  =>  hash A == hash B
--
new
  :: (key -> key -> Bool)    -- ^ @eq@: An equality comparison on keys
  -> (key -> Int32)	     -- ^ @hash@: A hash function on keys
  -> IO (HashTable key val)  -- ^ Returns: an empty hash table

new cmpr hash = do
  recordNew
  -- make a new hash table with a single, empty, segment
  let mask = tABLE_MIN-1
  bkts'  <- newMutArray (0,mask) []
  bkts   <- freezeArray bkts'

  let
    kcnt = 0
    ht = HT {  buckets=bkts, kcount=kcnt, bmask=mask }

  table <- newIORef ht
  return (HashTable { tab=table, hash_fn=hash, cmp=cmpr })

-- -----------------------------------------------------------------------------
-- Inserting a key\/value pair into the hash table

-- | Inserts a key\/value mapping into the hash table.
--
-- Note that 'insert' doesn't remove the old entry from the table -
-- the behaviour is like an association list, where 'lookup' returns
-- the most-recently-inserted mapping for a key in the table.  The
-- reason for this is to keep 'insert' as efficient as possible.  If
-- you need to update a mapping, then we provide 'update'.
--
insert :: HashTable key val -> key -> val -> IO ()

insert ht key val =
  updatingBucket CanInsert (\bucket -> ((key,val):bucket, 1, ())) ht key


-- ------------------------------------------------------------
-- The core of the implementation is lurking down here, in findBucket,
-- updatingBucket, and expandHashTable.

tooBig :: Int32 -> Int32 -> Bool
tooBig k b = k-hYSTERESIS > hLOAD * b

-- index of bucket within table.
bucketIndex :: Int32 -> Int32 -> Int32
bucketIndex mask h = h .&. mask

-- find the bucket in which the key belongs.
-- returns (key equality, bucket index, bucket)
--
-- This rather grab-bag approach gives enough power to do pretty much
-- any bucket-finding thing you might want to do.  We rely on inlining
-- to throw away the stuff we don't want.  I'm proud to say that this
-- plus updatingBucket below reduce most of the other definitions to a
-- few lines of code, while actually speeding up the hashtable
-- implementation when compared with a version which does everything
-- from scratch.
{-# INLINE findBucket #-}
findBucket :: HashTable key val -> key -> IO (HT key val, Int32, [(key,val)])
findBucket HashTable{ tab=ref, hash_fn=hash} key = do
  table@HT{ buckets=bkts, bmask=b } <- readIORef ref
  let indx = bucketIndex b (hash key)
  bucket <- readHTArray bkts indx
  return (table, indx, bucket)

data Inserts = CanInsert
             | Can'tInsert
             deriving (Eq)

-- updatingBucket is the real workhorse of all single-element table
-- updates.  It takes a hashtable and a key, along with a function
-- describing what to do with the bucket in which that key belongs.  A
-- flag indicates whether this function may perform table insertions.
-- The function returns the new contents of the bucket, the number of
-- bucket entries inserted (negative if entries were deleted), and a
-- value which becomes the return value for the function as a whole.
-- The table sizing is enforced here, calling out to expandSubTable as
-- necessary.

-- This function is intended to be inlined and specialized for every
-- calling context (eg every provided bucketFn).
{-# INLINE updatingBucket #-}

updatingBucket :: Inserts -> ([(key,val)] -> ([(key,val)], Int32, a)) ->
                  HashTable key val -> key ->
                  IO a
updatingBucket canEnlarge bucketFn
               ht@HashTable{ tab=ref, hash_fn=hash } key = do
  (table@HT{ kcount=k, buckets=bkts, bmask=b },
   indx, bckt) <- findBucket ht key
  (bckt', inserts, result) <- return $ bucketFn bckt
  let k' = k + inserts
      table1 = table { kcount=k' }
  bkts' <- thawArray bkts
  writeMutArray bkts' indx bckt'
  freezeArray bkts'
  table2 <- if canEnlarge == CanInsert && inserts > 0 then do
               recordIns inserts k' bckt'
               if tooBig k' b
                  then expandHashTable hash table1
                  else return table1
            else return table1
  writeIORef ref table2
  return result

expandHashTable :: (key -> Int32) -> HT key val -> IO (HT key val)
expandHashTable hash table@HT{ buckets=bkts, bmask=mask } = do
   let
      oldsize = mask + 1
      newmask = mask + mask + 1
   recordResize oldsize (newmask+1)
   --
   if newmask > tABLE_MAX-1
      then return table
      else do
   --
    newbkts' <- newMutArray (0,newmask) []

    let
     splitBucket oldindex = do
       bucket <- readHTArray bkts oldindex
       let (oldb,newb) =
              partition ((oldindex==). bucketIndex newmask . hash . fst) bucket
       writeMutArray newbkts' oldindex oldb
       writeMutArray newbkts' (oldindex + oldsize) newb
    mapM_ splitBucket [0..mask]

    newbkts <- freezeArray newbkts'

    return ( table{ buckets=newbkts, bmask=newmask } )

-- -----------------------------------------------------------------------------
-- Deleting a mapping from the hash table

-- Remove a key from a bucket
deleteBucket :: (key -> Bool) -> [(key,val)] -> ([(key, val)], Int32, ())
deleteBucket _   [] = ([],0,())
deleteBucket del (pair@(k,_):bucket) =
  case deleteBucket del bucket of
    (bucket', dels, _) | del k     -> dels' `seq` (bucket', dels', ())
                       | otherwise -> (pair:bucket', dels, ())
      where dels' = dels - 1

-- | Remove an entry from the hash table.
delete :: HashTable key val -> key -> IO ()

delete ht@HashTable{ cmp=eq } key =
  updatingBucket Can'tInsert (deleteBucket (eq key)) ht key

-- -----------------------------------------------------------------------------
-- Updating a mapping in the hash table

-- | Updates an entry in the hash table, returning 'True' if there was
-- already an entry for this key, or 'False' otherwise.  After 'update'
-- there will always be exactly one entry for the given key in the table.
--
-- 'insert' is more efficient than 'update' if you don't care about
-- multiple entries, or you know for sure that multiple entries can't
-- occur.  However, 'update' is more efficient than 'delete' followed
-- by 'insert'.
update :: HashTable key val -> key -> val -> IO Bool

update ht@HashTable{ cmp=eq } key val =
  updatingBucket CanInsert
    (\bucket -> let (bucket', dels, _) = deleteBucket (eq key) bucket
                in  ((key,val):bucket', 1+dels, dels/=0))
    ht key

-- -----------------------------------------------------------------------------
-- Looking up an entry in the hash table

-- | Looks up the value of a key in the hash table.
lookup :: HashTable key val -> key -> IO (Maybe val)

lookup ht@HashTable{ cmp=eq } key = do
  recordLookup
  (_, _, bucket) <- findBucket ht key
  let firstHit (k,v) r | eq key k  = Just v
                       | otherwise = r
  return (foldr firstHit Nothing bucket)

-- -----------------------------------------------------------------------------
-- Converting to/from lists

-- | Convert a list of key\/value pairs into a hash table.  Equality on keys
-- is taken from the Eq instance for the key type.
--
fromList :: (Eq key) => (key -> Int32) -> [(key,val)] -> IO (HashTable key val)
fromList hash list = do
  table <- new (==) hash
  sequence_ [ insert table k v | (k,v) <- list ]
  return table

-- | Converts a hash table to a list of key\/value pairs.
--
toList :: HashTable key val -> IO [(key,val)]
toList = mapReduce id concat

{-# INLINE mapReduce #-}
mapReduce :: ([(key,val)] -> r) -> ([r] -> r) -> HashTable key val -> IO r
mapReduce m r HashTable{ tab=ref } = do
  HT{ buckets=bckts, bmask=b } <- readIORef ref
  fmap r (mapM (fmap m . readHTArray bckts) [0..b])

-- -----------------------------------------------------------------------------
-- Diagnostics

-- | This function is useful for determining whether your hash
-- function is working well for your data set.  It returns the longest
-- chain of key\/value pairs in the hash table for which all the keys
-- hash to the same bucket.  If this chain is particularly long (say,
-- longer than 14 elements or so), then it might be a good idea to try
-- a different hash function.
--
longestChain :: HashTable key val -> IO [(key,val)]
longestChain = mapReduce id (maximumBy lengthCmp)
  where lengthCmp (_:x)(_:y) = lengthCmp x y
        lengthCmp []   []    = EQ
        lengthCmp []   _     = LT
        lengthCmp _    []    = GT
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.IORef
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- Mutable references in the IO monad.
--
-----------------------------------------------------------------------------

module Data.IORef
  ( 
	-- * IORefs
	IORef,		      -- abstract, instance of: Eq, Typeable
	newIORef,	      -- :: a -> IO (IORef a)
        readIORef,	      -- :: IORef a -> IO a
        writeIORef,	      -- :: IORef a -> a -> IO ()
	modifyIORef,	      -- :: IORef a -> (a -> a) -> IO ()
	atomicModifyIORef,    -- :: IORef a -> (a -> (a,b)) -> IO b




	) where

import Prelude	-- Explicit dependency helps 'make depend' do the right thing


import Hugs.IORef




























-- |Mutate the contents of an 'IORef'
modifyIORef :: IORef a -> (a -> a) -> IO ()
modifyIORef ref f = writeIORef ref . f =<< readIORef ref


-- |Atomically modifies the contents of an 'IORef'.
--
-- This function is useful for using 'IORef' in a safe way in a multithreaded
-- program.  If you only have one 'IORef', then using 'atomicModifyIORef' to
-- access and modify it will prevent race conditions.
--
-- Extending the atomicity to multiple 'IORef's is problematic, so it
-- is recommended that if you need to do anything more complicated
-- then using 'Control.Concurrent.MVar.MVar' instead is a good idea.
--
atomicModifyIORef :: IORef a -> (a -> (a,b)) -> IO b




atomicModifyIORef = plainModifyIORef	-- Hugs has no preemption
  where plainModifyIORef r f = do
		a <- readIORef r
		case f a of (a',b) -> writeIORef r a' >> return b








{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Int
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- Signed integer types
--
-----------------------------------------------------------------------------

module Data.Int
  ( 
	-- * Signed integer types
	Int,
	Int8, Int16, Int32, Int64,

	-- * Notes

	-- $notes
	) where







import Hugs.Int ( Int8, Int16, Int32, Int64 )









{- $notes

* All arithmetic is performed modulo 2^n, where @n@ is the number of
  bits in the type.

* For coercing between any two integer types, use 'Prelude.fromIntegral',
  which is specialized for all the common cases so should be fast
  enough.  Coercing word types (see "Data.Word") to and from integer
  types preserves representation, not sign.

* The rules that hold for 'Prelude.Enum' instances over a
  bounded type such as 'Int' (see the section of the
  Haskell report dealing with arithmetic sequences) also hold for the
  'Prelude.Enum' instances over the various
  'Int' types defined here.

* Right and left shifts by amounts greater than or equal to the width
  of the type result in either zero or -1, depending on the sign of
  the value being shifted.  This is contrary to the behaviour in C,
  which is undefined; a common interpretation is to truncate the shift
  count to the width of the type, for example @1 \<\< 32
  == 1@ in some C implementations.
-}
{-# OPTIONS -cpp -fglasgow-exts -fno-bang-patterns #-} 
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.IntMap
-- Copyright   :  (c) Daan Leijen 2002
-- License     :  BSD-style
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- An efficient implementation of maps from integer keys to values.
--
-- Since many function names (but not the type name) clash with
-- "Prelude" names, this module is usually imported @qualified@, e.g.
--
-- >  import Data.IntMap (IntMap)
-- >  import qualified Data.IntMap as IntMap
--
-- The implementation is based on /big-endian patricia trees/.  This data
-- structure performs especially well on binary operations like 'union'
-- and 'intersection'.  However, my benchmarks show that it is also
-- (much) faster on insertions and deletions when compared to a generic
-- size-balanced map implementation (see "Data.Map" and "Data.FiniteMap").
--
--    * Chris Okasaki and Andy Gill,  \"/Fast Mergeable Integer Maps/\",
--	Workshop on ML, September 1998, pages 77-86,
--	<http://www.cse.ogi.edu/~andy/pub/finite.htm>
--
--    * D.R. Morrison, \"/PATRICIA -- Practical Algorithm To Retrieve
--	Information Coded In Alphanumeric/\", Journal of the ACM, 15(4),
--	October 1968, pages 514-534.
--
-- Many operations have a worst-case complexity of /O(min(n,W))/.
-- This means that the operation can become linear in the number of
-- elements with a maximum of /W/ -- the number of bits in an 'Int'
-- (32 or 64).
-----------------------------------------------------------------------------

module Data.IntMap  ( 
            -- * Map type
              IntMap, Key          -- instance Eq,Show

            -- * Operators
            , (!), (\\)

            -- * Query
            , null
            , size
            , member
            , notMember
	    , lookup
            , findWithDefault
            
            -- * Construction
            , empty
            , singleton

            -- ** Insertion
            , insert
            , insertWith, insertWithKey, insertLookupWithKey
            
            -- ** Delete\/Update
            , delete
            , adjust
            , adjustWithKey
            , update
            , updateWithKey
            , updateLookupWithKey
            , alter
  
            -- * Combine

            -- ** Union
            , union         
            , unionWith          
            , unionWithKey
            , unions
            , unionsWith

            -- ** Difference
            , difference
            , differenceWith
            , differenceWithKey
            
            -- ** Intersection
            , intersection           
            , intersectionWith
            , intersectionWithKey

            -- * Traversal
            -- ** Map
            , map
            , mapWithKey
            , mapAccum
            , mapAccumWithKey
            
            -- ** Fold
            , fold
            , foldWithKey

            -- * Conversion
            , elems
            , keys
	    , keysSet
            , assocs
            
            -- ** Lists
            , toList
            , fromList
            , fromListWith
            , fromListWithKey

            -- ** Ordered lists
            , toAscList
            , fromAscList
            , fromAscListWith
            , fromAscListWithKey
            , fromDistinctAscList

            -- * Filter 
            , filter
            , filterWithKey
            , partition
            , partitionWithKey

            , mapMaybe
            , mapMaybeWithKey
            , mapEither
            , mapEitherWithKey

            , split         
            , splitLookup   

            -- * Submap
            , isSubmapOf, isSubmapOfBy
            , isProperSubmapOf, isProperSubmapOfBy
            
            -- * Debugging
            , showTree
            , showTreeWith
            ) where


import Prelude hiding (lookup,map,filter,foldr,foldl,null)
import Data.Bits 
import Data.Int
import qualified Data.IntSet as IntSet
import Data.Monoid (Monoid(..))
import Data.Typeable
import Data.Foldable (Foldable(foldMap))

{-
-- just for testing
import qualified Prelude
import Debug.QuickCheck 
import List (nub,sort)
import qualified List
-}  














import Data.Word


infixl 9 \\{-This comment teaches CPP correct behaviour -}

-- A "Nat" is a natural machine word (an unsigned Int)
type Nat = Word

natFromInt :: Key -> Nat
natFromInt i = fromIntegral i

intFromNat :: Nat -> Key
intFromNat w = fromIntegral w

shiftRL :: Nat -> Key -> Nat







shiftRL x i   = shiftR x i


{--------------------------------------------------------------------
  Operators
--------------------------------------------------------------------}

-- | /O(min(n,W))/. Find the value at a key.
-- Calls 'error' when the element can not be found.

(!) :: IntMap a -> Key -> a
m ! k    = find' k m

-- | /O(n+m)/. See 'difference'.
(\\) :: IntMap a -> IntMap b -> IntMap a
m1 \\ m2 = difference m1 m2

{--------------------------------------------------------------------
  Types  
--------------------------------------------------------------------}
-- | A map of integers to values @a@.
data IntMap a = Nil
              | Tip {-# UNPACK #-} !Key a
              | Bin {-# UNPACK #-} !Prefix {-# UNPACK #-} !Mask !(IntMap a) !(IntMap a) 

type Prefix = Int
type Mask   = Int
type Key    = Int

instance Monoid (IntMap a) where
    mempty  = empty
    mappend = union
    mconcat = unions

instance Foldable IntMap where
    foldMap f Nil = mempty
    foldMap f (Tip _k v) = f v
    foldMap f (Bin _ _ l r) = foldMap f l `mappend` foldMap f r



















{--------------------------------------------------------------------
  Query
--------------------------------------------------------------------}
-- | /O(1)/. Is the map empty?
null :: IntMap a -> Bool
null Nil   = True
null other = False

-- | /O(n)/. Number of elements in the map.
size :: IntMap a -> Int
size t
  = case t of
      Bin p m l r -> size l + size r
      Tip k x -> 1
      Nil     -> 0

-- | /O(min(n,W))/. Is the key a member of the map?
member :: Key -> IntMap a -> Bool
member k m
  = case lookup k m of
      Nothing -> False
      Just x  -> True
    
-- | /O(log n)/. Is the key not a member of the map?
notMember :: Key -> IntMap a -> Bool
notMember k m = not $ member k m

-- | /O(min(n,W))/. Lookup the value at a key in the map.
lookup :: (Monad m) => Key -> IntMap a -> m a
lookup k t = case lookup' k t of
    Just x -> return x
    Nothing -> fail "Data.IntMap.lookup: Key not found"

lookup' :: Key -> IntMap a -> Maybe a
lookup' k t
  = let nk = natFromInt k  in seq nk (lookupN nk t)

lookupN :: Nat -> IntMap a -> Maybe a
lookupN k t
  = case t of
      Bin p m l r 
        | zeroN k (natFromInt m) -> lookupN k l
        | otherwise              -> lookupN k r
      Tip kx x 
        | (k == natFromInt kx)  -> Just x
        | otherwise             -> Nothing
      Nil -> Nothing

find' :: Key -> IntMap a -> a
find' k m
  = case lookup k m of
      Nothing -> error ("IntMap.find: key " ++ show k ++ " is not an element of the map")
      Just x  -> x


-- | /O(min(n,W))/. The expression @('findWithDefault' def k map)@
-- returns the value at key @k@ or returns @def@ when the key is not an
-- element of the map.
findWithDefault :: a -> Key -> IntMap a -> a
findWithDefault def k m
  = case lookup k m of
      Nothing -> def
      Just x  -> x

{--------------------------------------------------------------------
  Construction
--------------------------------------------------------------------}
-- | /O(1)/. The empty map.
empty :: IntMap a
empty
  = Nil

-- | /O(1)/. A map of one element.
singleton :: Key -> a -> IntMap a
singleton k x
  = Tip k x

{--------------------------------------------------------------------
  Insert
--------------------------------------------------------------------}
-- | /O(min(n,W))/. Insert a new key\/value pair in the map.
-- If the key is already present in the map, the associated value is
-- replaced with the supplied value, i.e. 'insert' is equivalent to
-- @'insertWith' 'const'@.
insert :: Key -> a -> IntMap a -> IntMap a
insert k x t
  = case t of
      Bin p m l r 
        | nomatch k p m -> join k (Tip k x) p t
        | zero k m      -> Bin p m (insert k x l) r
        | otherwise     -> Bin p m l (insert k x r)
      Tip ky y 
        | k==ky         -> Tip k x
        | otherwise     -> join k (Tip k x) ky t
      Nil -> Tip k x

-- right-biased insertion, used by 'union'
-- | /O(min(n,W))/. Insert with a combining function.
-- @'insertWith' f key value mp@ 
-- will insert the pair (key, value) into @mp@ if key does
-- not exist in the map. If the key does exist, the function will
-- insert @f new_value old_value@.
insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
insertWith f k x t
  = insertWithKey (\k x y -> f x y) k x t

-- | /O(min(n,W))/. Insert with a combining function.
-- @'insertWithKey' f key value mp@ 
-- will insert the pair (key, value) into @mp@ if key does
-- not exist in the map. If the key does exist, the function will
-- insert @f key new_value old_value@.
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
insertWithKey f k x t
  = case t of
      Bin p m l r 
        | nomatch k p m -> join k (Tip k x) p t
        | zero k m      -> Bin p m (insertWithKey f k x l) r
        | otherwise     -> Bin p m l (insertWithKey f k x r)
      Tip ky y 
        | k==ky         -> Tip k (f k x y)
        | otherwise     -> join k (Tip k x) ky t
      Nil -> Tip k x


-- | /O(min(n,W))/. The expression (@'insertLookupWithKey' f k x map@)
-- is a pair where the first element is equal to (@'lookup' k map@)
-- and the second element equal to (@'insertWithKey' f k x map@).
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a)
insertLookupWithKey f k x t
  = case t of
      Bin p m l r 
        | nomatch k p m -> (Nothing,join k (Tip k x) p t)
        | zero k m      -> let (found,l') = insertLookupWithKey f k x l in (found,Bin p m l' r)
        | otherwise     -> let (found,r') = insertLookupWithKey f k x r in (found,Bin p m l r')
      Tip ky y 
        | k==ky         -> (Just y,Tip k (f k x y))
        | otherwise     -> (Nothing,join k (Tip k x) ky t)
      Nil -> (Nothing,Tip k x)


{--------------------------------------------------------------------
  Deletion
  [delete] is the inlined version of [deleteWith (\k x -> Nothing)]
--------------------------------------------------------------------}
-- | /O(min(n,W))/. Delete a key and its value from the map. When the key is not
-- a member of the map, the original map is returned.
delete :: Key -> IntMap a -> IntMap a
delete k t
  = case t of
      Bin p m l r 
        | nomatch k p m -> t
        | zero k m      -> bin p m (delete k l) r
        | otherwise     -> bin p m l (delete k r)
      Tip ky y 
        | k==ky         -> Nil
        | otherwise     -> t
      Nil -> Nil

-- | /O(min(n,W))/. Adjust a value at a specific key. When the key is not
-- a member of the map, the original map is returned.
adjust ::  (a -> a) -> Key -> IntMap a -> IntMap a
adjust f k m
  = adjustWithKey (\k x -> f x) k m

-- | /O(min(n,W))/. Adjust a value at a specific key. When the key is not
-- a member of the map, the original map is returned.
adjustWithKey ::  (Key -> a -> a) -> Key -> IntMap a -> IntMap a
adjustWithKey f k m
  = updateWithKey (\k x -> Just (f k x)) k m

-- | /O(min(n,W))/. The expression (@'update' f k map@) updates the value @x@
-- at @k@ (if it is in the map). If (@f x@) is 'Nothing', the element is
-- deleted. If it is (@'Just' y@), the key @k@ is bound to the new value @y@.
update ::  (a -> Maybe a) -> Key -> IntMap a -> IntMap a
update f k m
  = updateWithKey (\k x -> f x) k m

-- | /O(min(n,W))/. The expression (@'update' f k map@) updates the value @x@
-- at @k@ (if it is in the map). If (@f k x@) is 'Nothing', the element is
-- deleted. If it is (@'Just' y@), the key @k@ is bound to the new value @y@.
updateWithKey ::  (Key -> a -> Maybe a) -> Key -> IntMap a -> IntMap a
updateWithKey f k t
  = case t of
      Bin p m l r 
        | nomatch k p m -> t
        | zero k m      -> bin p m (updateWithKey f k l) r
        | otherwise     -> bin p m l (updateWithKey f k r)
      Tip ky y 
        | k==ky         -> case (f k y) of
                             Just y' -> Tip ky y'
                             Nothing -> Nil
        | otherwise     -> t
      Nil -> Nil

-- | /O(min(n,W))/. Lookup and update.
updateLookupWithKey ::  (Key -> a -> Maybe a) -> Key -> IntMap a -> (Maybe a,IntMap a)
updateLookupWithKey f k t
  = case t of
      Bin p m l r 
        | nomatch k p m -> (Nothing,t)
        | zero k m      -> let (found,l') = updateLookupWithKey f k l in (found,bin p m l' r)
        | otherwise     -> let (found,r') = updateLookupWithKey f k r in (found,bin p m l r')
      Tip ky y 
        | k==ky         -> case (f k y) of
                             Just y' -> (Just y,Tip ky y')
                             Nothing -> (Just y,Nil)
        | otherwise     -> (Nothing,t)
      Nil -> (Nothing,Nil)



-- | /O(log n)/. The expression (@'alter' f k map@) alters the value @x@ at @k@, or absence thereof.
-- 'alter' can be used to insert, delete, or update a value in a 'Map'.
-- In short : @'lookup' k ('alter' f k m) = f ('lookup' k m)@
alter f k t
  = case t of
      Bin p m l r 
        | nomatch k p m -> case f Nothing of 
                             Nothing -> t
                             Just x -> join k (Tip k x) p t
        | zero k m      -> bin p m (alter f k l) r
        | otherwise     -> bin p m l (alter f k r)
      Tip ky y          
        | k==ky         -> case f (Just y) of
                             Just x -> Tip ky x
                             Nothing -> Nil
        | otherwise     -> case f Nothing of
                             Just x -> join k (Tip k x) ky t
                             Nothing -> Tip ky y
      Nil               -> case f Nothing of
                             Just x -> Tip k x
                             Nothing -> Nil


{--------------------------------------------------------------------
  Union
--------------------------------------------------------------------}
-- | The union of a list of maps.
unions :: [IntMap a] -> IntMap a
unions xs
  = foldlStrict union empty xs

-- | The union of a list of maps, with a combining operation
unionsWith :: (a->a->a) -> [IntMap a] -> IntMap a
unionsWith f ts
  = foldlStrict (unionWith f) empty ts

-- | /O(n+m)/. The (left-biased) union of two maps. 
-- It prefers the first map when duplicate keys are encountered,
-- i.e. (@'union' == 'unionWith' 'const'@).
union :: IntMap a -> IntMap a -> IntMap a
union t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
  | shorter m1 m2  = union1
  | shorter m2 m1  = union2
  | p1 == p2       = Bin p1 m1 (union l1 l2) (union r1 r2)
  | otherwise      = join p1 t1 p2 t2
  where
    union1  | nomatch p2 p1 m1  = join p1 t1 p2 t2
            | zero p2 m1        = Bin p1 m1 (union l1 t2) r1
            | otherwise         = Bin p1 m1 l1 (union r1 t2)

    union2  | nomatch p1 p2 m2  = join p1 t1 p2 t2
            | zero p1 m2        = Bin p2 m2 (union t1 l2) r2
            | otherwise         = Bin p2 m2 l2 (union t1 r2)

union (Tip k x) t = insert k x t
union t (Tip k x) = insertWith (\x y -> y) k x t  -- right bias
union Nil t       = t
union t Nil       = t

-- | /O(n+m)/. The union with a combining function. 
unionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
unionWith f m1 m2
  = unionWithKey (\k x y -> f x y) m1 m2

-- | /O(n+m)/. The union with a combining function. 
unionWithKey :: (Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
unionWithKey f t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
  | shorter m1 m2  = union1
  | shorter m2 m1  = union2
  | p1 == p2       = Bin p1 m1 (unionWithKey f l1 l2) (unionWithKey f r1 r2)
  | otherwise      = join p1 t1 p2 t2
  where
    union1  | nomatch p2 p1 m1  = join p1 t1 p2 t2
            | zero p2 m1        = Bin p1 m1 (unionWithKey f l1 t2) r1
            | otherwise         = Bin p1 m1 l1 (unionWithKey f r1 t2)

    union2  | nomatch p1 p2 m2  = join p1 t1 p2 t2
            | zero p1 m2        = Bin p2 m2 (unionWithKey f t1 l2) r2
            | otherwise         = Bin p2 m2 l2 (unionWithKey f t1 r2)

unionWithKey f (Tip k x) t = insertWithKey f k x t
unionWithKey f t (Tip k x) = insertWithKey (\k x y -> f k y x) k x t  -- right bias
unionWithKey f Nil t  = t
unionWithKey f t Nil  = t

{--------------------------------------------------------------------
  Difference
--------------------------------------------------------------------}
-- | /O(n+m)/. Difference between two maps (based on keys). 
difference :: IntMap a -> IntMap b -> IntMap a
difference t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
  | shorter m1 m2  = difference1
  | shorter m2 m1  = difference2
  | p1 == p2       = bin p1 m1 (difference l1 l2) (difference r1 r2)
  | otherwise      = t1
  where
    difference1 | nomatch p2 p1 m1  = t1
                | zero p2 m1        = bin p1 m1 (difference l1 t2) r1
                | otherwise         = bin p1 m1 l1 (difference r1 t2)

    difference2 | nomatch p1 p2 m2  = t1
                | zero p1 m2        = difference t1 l2
                | otherwise         = difference t1 r2

difference t1@(Tip k x) t2 
  | member k t2  = Nil
  | otherwise    = t1

difference Nil t       = Nil
difference t (Tip k x) = delete k t
difference t Nil       = t

-- | /O(n+m)/. Difference with a combining function. 
differenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
differenceWith f m1 m2
  = differenceWithKey (\k x y -> f x y) m1 m2

-- | /O(n+m)/. Difference with a combining function. When two equal keys are
-- encountered, the combining function is applied to the key and both values.
-- If it returns 'Nothing', the element is discarded (proper set difference).
-- If it returns (@'Just' y@), the element is updated with a new value @y@. 
differenceWithKey :: (Key -> a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
differenceWithKey f t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
  | shorter m1 m2  = difference1
  | shorter m2 m1  = difference2
  | p1 == p2       = bin p1 m1 (differenceWithKey f l1 l2) (differenceWithKey f r1 r2)
  | otherwise      = t1
  where
    difference1 | nomatch p2 p1 m1  = t1
                | zero p2 m1        = bin p1 m1 (differenceWithKey f l1 t2) r1
                | otherwise         = bin p1 m1 l1 (differenceWithKey f r1 t2)

    difference2 | nomatch p1 p2 m2  = t1
                | zero p1 m2        = differenceWithKey f t1 l2
                | otherwise         = differenceWithKey f t1 r2

differenceWithKey f t1@(Tip k x) t2 
  = case lookup k t2 of
      Just y  -> case f k x y of
                   Just y' -> Tip k y'
                   Nothing -> Nil
      Nothing -> t1

differenceWithKey f Nil t       = Nil
differenceWithKey f t (Tip k y) = updateWithKey (\k x -> f k x y) k t
differenceWithKey f t Nil       = t


{--------------------------------------------------------------------
  Intersection
--------------------------------------------------------------------}
-- | /O(n+m)/. The (left-biased) intersection of two maps (based on keys). 
intersection :: IntMap a -> IntMap b -> IntMap a
intersection t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
  | shorter m1 m2  = intersection1
  | shorter m2 m1  = intersection2
  | p1 == p2       = bin p1 m1 (intersection l1 l2) (intersection r1 r2)
  | otherwise      = Nil
  where
    intersection1 | nomatch p2 p1 m1  = Nil
                  | zero p2 m1        = intersection l1 t2
                  | otherwise         = intersection r1 t2

    intersection2 | nomatch p1 p2 m2  = Nil
                  | zero p1 m2        = intersection t1 l2
                  | otherwise         = intersection t1 r2

intersection t1@(Tip k x) t2 
  | member k t2  = t1
  | otherwise    = Nil
intersection t (Tip k x) 
  = case lookup k t of
      Just y  -> Tip k y
      Nothing -> Nil
intersection Nil t = Nil
intersection t Nil = Nil

-- | /O(n+m)/. The intersection with a combining function. 
intersectionWith :: (a -> b -> a) -> IntMap a -> IntMap b -> IntMap a
intersectionWith f m1 m2
  = intersectionWithKey (\k x y -> f x y) m1 m2

-- | /O(n+m)/. The intersection with a combining function. 
intersectionWithKey :: (Key -> a -> b -> a) -> IntMap a -> IntMap b -> IntMap a
intersectionWithKey f t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
  | shorter m1 m2  = intersection1
  | shorter m2 m1  = intersection2
  | p1 == p2       = bin p1 m1 (intersectionWithKey f l1 l2) (intersectionWithKey f r1 r2)
  | otherwise      = Nil
  where
    intersection1 | nomatch p2 p1 m1  = Nil
                  | zero p2 m1        = intersectionWithKey f l1 t2
                  | otherwise         = intersectionWithKey f r1 t2

    intersection2 | nomatch p1 p2 m2  = Nil
                  | zero p1 m2        = intersectionWithKey f t1 l2
                  | otherwise         = intersectionWithKey f t1 r2

intersectionWithKey f t1@(Tip k x) t2 
  = case lookup k t2 of
      Just y  -> Tip k (f k x y)
      Nothing -> Nil
intersectionWithKey f t1 (Tip k y) 
  = case lookup k t1 of
      Just x  -> Tip k (f k x y)
      Nothing -> Nil
intersectionWithKey f Nil t = Nil
intersectionWithKey f t Nil = Nil


{--------------------------------------------------------------------
  Submap
--------------------------------------------------------------------}
-- | /O(n+m)/. Is this a proper submap? (ie. a submap but not equal). 
-- Defined as (@'isProperSubmapOf' = 'isProperSubmapOfBy' (==)@).
isProperSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
isProperSubmapOf m1 m2
  = isProperSubmapOfBy (==) m1 m2

{- | /O(n+m)/. Is this a proper submap? (ie. a submap but not equal).
 The expression (@'isProperSubmapOfBy' f m1 m2@) returns 'True' when
 @m1@ and @m2@ are not equal,
 all keys in @m1@ are in @m2@, and when @f@ returns 'True' when
 applied to their respective values. For example, the following 
 expressions are all 'True':
 
  > isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
  > isProperSubmapOfBy (<=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])

 But the following are all 'False':
 
  > isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
  > isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
  > isProperSubmapOfBy (<)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])
-}
isProperSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool
isProperSubmapOfBy pred t1 t2
  = case submapCmp pred t1 t2 of 
      LT -> True
      ge -> False

submapCmp pred t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
  | shorter m1 m2  = GT
  | shorter m2 m1  = submapCmpLt
  | p1 == p2       = submapCmpEq
  | otherwise      = GT  -- disjoint
  where
    submapCmpLt | nomatch p1 p2 m2  = GT
                | zero p1 m2        = submapCmp pred t1 l2
                | otherwise         = submapCmp pred t1 r2
    submapCmpEq = case (submapCmp pred l1 l2, submapCmp pred r1 r2) of
                    (GT,_ ) -> GT
                    (_ ,GT) -> GT
                    (EQ,EQ) -> EQ
                    other   -> LT

submapCmp pred (Bin p m l r) t  = GT
submapCmp pred (Tip kx x) (Tip ky y)  
  | (kx == ky) && pred x y = EQ
  | otherwise              = GT  -- disjoint
submapCmp pred (Tip k x) t      
  = case lookup k t of
     Just y  | pred x y -> LT
     other   -> GT -- disjoint
submapCmp pred Nil Nil = EQ
submapCmp pred Nil t   = LT

-- | /O(n+m)/. Is this a submap?
-- Defined as (@'isSubmapOf' = 'isSubmapOfBy' (==)@).
isSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
isSubmapOf m1 m2
  = isSubmapOfBy (==) m1 m2

{- | /O(n+m)/. 
 The expression (@'isSubmapOfBy' f m1 m2@) returns 'True' if
 all keys in @m1@ are in @m2@, and when @f@ returns 'True' when
 applied to their respective values. For example, the following 
 expressions are all 'True':
 
  > isSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
  > isSubmapOfBy (<=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
  > isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])

 But the following are all 'False':
 
  > isSubmapOfBy (==) (fromList [(1,2)]) (fromList [(1,1),(2,2)])
  > isSubmapOfBy (<) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
  > isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
-}

isSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool
isSubmapOfBy pred t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
  | shorter m1 m2  = False
  | shorter m2 m1  = match p1 p2 m2 && (if zero p1 m2 then isSubmapOfBy pred t1 l2
                                                      else isSubmapOfBy pred t1 r2)                     
  | otherwise      = (p1==p2) && isSubmapOfBy pred l1 l2 && isSubmapOfBy pred r1 r2
isSubmapOfBy pred (Bin p m l r) t  = False
isSubmapOfBy pred (Tip k x) t      = case lookup k t of
                                   Just y  -> pred x y
                                   Nothing -> False 
isSubmapOfBy pred Nil t            = True

{--------------------------------------------------------------------
  Mapping
--------------------------------------------------------------------}
-- | /O(n)/. Map a function over all values in the map.
map :: (a -> b) -> IntMap a -> IntMap b
map f m
  = mapWithKey (\k x -> f x) m

-- | /O(n)/. Map a function over all values in the map.
mapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b
mapWithKey f t  
  = case t of
      Bin p m l r -> Bin p m (mapWithKey f l) (mapWithKey f r)
      Tip k x     -> Tip k (f k x)
      Nil         -> Nil

-- | /O(n)/. The function @'mapAccum'@ threads an accumulating
-- argument through the map in ascending order of keys.
mapAccum :: (a -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)
mapAccum f a m
  = mapAccumWithKey (\a k x -> f a x) a m

-- | /O(n)/. The function @'mapAccumWithKey'@ threads an accumulating
-- argument through the map in ascending order of keys.
mapAccumWithKey :: (a -> Key -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)
mapAccumWithKey f a t
  = mapAccumL f a t

-- | /O(n)/. The function @'mapAccumL'@ threads an accumulating
-- argument through the map in ascending order of keys.
mapAccumL :: (a -> Key -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)
mapAccumL f a t
  = case t of
      Bin p m l r -> let (a1,l') = mapAccumL f a l
                         (a2,r') = mapAccumL f a1 r
                     in (a2,Bin p m l' r')
      Tip k x     -> let (a',x') = f a k x in (a',Tip k x')
      Nil         -> (a,Nil)


-- | /O(n)/. The function @'mapAccumR'@ threads an accumulating
-- argument throught the map in descending order of keys.
mapAccumR :: (a -> Key -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)
mapAccumR f a t
  = case t of
      Bin p m l r -> let (a1,r') = mapAccumR f a r
                         (a2,l') = mapAccumR f a1 l
                     in (a2,Bin p m l' r')
      Tip k x     -> let (a',x') = f a k x in (a',Tip k x')
      Nil         -> (a,Nil)

{--------------------------------------------------------------------
  Filter
--------------------------------------------------------------------}
-- | /O(n)/. Filter all values that satisfy some predicate.
filter :: (a -> Bool) -> IntMap a -> IntMap a
filter p m
  = filterWithKey (\k x -> p x) m

-- | /O(n)/. Filter all keys\/values that satisfy some predicate.
filterWithKey :: (Key -> a -> Bool) -> IntMap a -> IntMap a
filterWithKey pred t
  = case t of
      Bin p m l r 
        -> bin p m (filterWithKey pred l) (filterWithKey pred r)
      Tip k x 
        | pred k x  -> t
        | otherwise -> Nil
      Nil -> Nil

-- | /O(n)/. partition the map according to some predicate. The first
-- map contains all elements that satisfy the predicate, the second all
-- elements that fail the predicate. See also 'split'.
partition :: (a -> Bool) -> IntMap a -> (IntMap a,IntMap a)
partition p m
  = partitionWithKey (\k x -> p x) m

-- | /O(n)/. partition the map according to some predicate. The first
-- map contains all elements that satisfy the predicate, the second all
-- elements that fail the predicate. See also 'split'.
partitionWithKey :: (Key -> a -> Bool) -> IntMap a -> (IntMap a,IntMap a)
partitionWithKey pred t
  = case t of
      Bin p m l r 
        -> let (l1,l2) = partitionWithKey pred l
               (r1,r2) = partitionWithKey pred r
           in (bin p m l1 r1, bin p m l2 r2)
      Tip k x 
        | pred k x  -> (t,Nil)
        | otherwise -> (Nil,t)
      Nil -> (Nil,Nil)

-- | /O(n)/. Map values and collect the 'Just' results.
mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
mapMaybe f m
  = mapMaybeWithKey (\k x -> f x) m

-- | /O(n)/. Map keys\/values and collect the 'Just' results.
mapMaybeWithKey :: (Key -> a -> Maybe b) -> IntMap a -> IntMap b
mapMaybeWithKey f (Bin p m l r)
  = bin p m (mapMaybeWithKey f l) (mapMaybeWithKey f r)
mapMaybeWithKey f (Tip k x) = case f k x of
  Just y  -> Tip k y
  Nothing -> Nil
mapMaybeWithKey f Nil = Nil

-- | /O(n)/. Map values and separate the 'Left' and 'Right' results.
mapEither :: (a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)
mapEither f m
  = mapEitherWithKey (\k x -> f x) m

-- | /O(n)/. Map keys\/values and separate the 'Left' and 'Right' results.
mapEitherWithKey :: (Key -> a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)
mapEitherWithKey f (Bin p m l r)
  = (bin p m l1 r1, bin p m l2 r2)
  where
    (l1,l2) = mapEitherWithKey f l
    (r1,r2) = mapEitherWithKey f r
mapEitherWithKey f (Tip k x) = case f k x of
  Left y  -> (Tip k y, Nil)
  Right z -> (Nil, Tip k z)
mapEitherWithKey f Nil = (Nil, Nil)

-- | /O(log n)/. The expression (@'split' k map@) is a pair @(map1,map2)@
-- where all keys in @map1@ are lower than @k@ and all keys in
-- @map2@ larger than @k@. Any key equal to @k@ is found in neither @map1@ nor @map2@.
split :: Key -> IntMap a -> (IntMap a,IntMap a)
split k t
  = case t of
      Bin p m l r 
          | m < 0 -> (if k >= 0 -- handle negative numbers.
                      then let (lt,gt) = split' k l in (union r lt, gt)
                      else let (lt,gt) = split' k r in (lt, union gt l))
          | otherwise   -> split' k t
      Tip ky y 
        | k>ky      -> (t,Nil)
        | k<ky      -> (Nil,t)
        | otherwise -> (Nil,Nil)
      Nil -> (Nil,Nil)

split' :: Key -> IntMap a -> (IntMap a,IntMap a)
split' k t
  = case t of
      Bin p m l r
        | nomatch k p m -> if k>p then (t,Nil) else (Nil,t)
        | zero k m  -> let (lt,gt) = split k l in (lt,union gt r)
        | otherwise -> let (lt,gt) = split k r in (union l lt,gt)
      Tip ky y 
        | k>ky      -> (t,Nil)
        | k<ky      -> (Nil,t)
        | otherwise -> (Nil,Nil)
      Nil -> (Nil,Nil)

-- | /O(log n)/. Performs a 'split' but also returns whether the pivot
-- key was found in the original map.
splitLookup :: Key -> IntMap a -> (IntMap a,Maybe a,IntMap a)
splitLookup k t
  = case t of
      Bin p m l r
          | m < 0 -> (if k >= 0 -- handle negative numbers.
                      then let (lt,found,gt) = splitLookup' k l in (union r lt,found, gt)
                      else let (lt,found,gt) = splitLookup' k r in (lt,found, union gt l))
          | otherwise   -> splitLookup' k t
      Tip ky y 
        | k>ky      -> (t,Nothing,Nil)
        | k<ky      -> (Nil,Nothing,t)
        | otherwise -> (Nil,Just y,Nil)
      Nil -> (Nil,Nothing,Nil)

splitLookup' :: Key -> IntMap a -> (IntMap a,Maybe a,IntMap a)
splitLookup' k t
  = case t of
      Bin p m l r
        | nomatch k p m -> if k>p then (t,Nothing,Nil) else (Nil,Nothing,t)
        | zero k m  -> let (lt,found,gt) = splitLookup k l in (lt,found,union gt r)
        | otherwise -> let (lt,found,gt) = splitLookup k r in (union l lt,found,gt)
      Tip ky y 
        | k>ky      -> (t,Nothing,Nil)
        | k<ky      -> (Nil,Nothing,t)
        | otherwise -> (Nil,Just y,Nil)
      Nil -> (Nil,Nothing,Nil)

{--------------------------------------------------------------------
  Fold
--------------------------------------------------------------------}
-- | /O(n)/. Fold the values in the map, such that
-- @'fold' f z == 'Prelude.foldr' f z . 'elems'@.
-- For example,
--
-- > elems map = fold (:) [] map
--
fold :: (a -> b -> b) -> b -> IntMap a -> b
fold f z t
  = foldWithKey (\k x y -> f x y) z t

-- | /O(n)/. Fold the keys and values in the map, such that
-- @'foldWithKey' f z == 'Prelude.foldr' ('uncurry' f) z . 'toAscList'@.
-- For example,
--
-- > keys map = foldWithKey (\k x ks -> k:ks) [] map
--
foldWithKey :: (Key -> a -> b -> b) -> b -> IntMap a -> b
foldWithKey f z t
  = foldr f z t

foldr :: (Key -> a -> b -> b) -> b -> IntMap a -> b
foldr f z t
  = case t of
      Bin 0 m l r | m < 0 -> foldr' f (foldr' f z l) r  -- put negative numbers before.
      Bin _ _ _ _ -> foldr' f z t
      Tip k x     -> f k x z
      Nil         -> z

foldr' :: (Key -> a -> b -> b) -> b -> IntMap a -> b
foldr' f z t
  = case t of
      Bin p m l r -> foldr' f (foldr' f z r) l
      Tip k x     -> f k x z
      Nil         -> z



{--------------------------------------------------------------------
  List variations 
--------------------------------------------------------------------}
-- | /O(n)/.
-- Return all elements of the map in the ascending order of their keys.
elems :: IntMap a -> [a]
elems m
  = foldWithKey (\k x xs -> x:xs) [] m  

-- | /O(n)/. Return all keys of the map in ascending order.
keys  :: IntMap a -> [Key]
keys m
  = foldWithKey (\k x ks -> k:ks) [] m

-- | /O(n*min(n,W))/. The set of all keys of the map.
keysSet :: IntMap a -> IntSet.IntSet
keysSet m = IntSet.fromDistinctAscList (keys m)


-- | /O(n)/. Return all key\/value pairs in the map in ascending key order.
assocs :: IntMap a -> [(Key,a)]
assocs m
  = toList m


{--------------------------------------------------------------------
  Lists 
--------------------------------------------------------------------}
-- | /O(n)/. Convert the map to a list of key\/value pairs.
toList :: IntMap a -> [(Key,a)]
toList t
  = foldWithKey (\k x xs -> (k,x):xs) [] t

-- | /O(n)/. Convert the map to a list of key\/value pairs where the
-- keys are in ascending order.
toAscList :: IntMap a -> [(Key,a)]
toAscList t   
  = -- NOTE: the following algorithm only works for big-endian trees
    let (pos,neg) = span (\(k,x) -> k >=0) (foldr (\k x xs -> (k,x):xs) [] t) in neg ++ pos

-- | /O(n*min(n,W))/. Create a map from a list of key\/value pairs.
fromList :: [(Key,a)] -> IntMap a
fromList xs
  = foldlStrict ins empty xs
  where
    ins t (k,x)  = insert k x t

-- | /O(n*min(n,W))/.  Create a map from a list of key\/value pairs with a combining function. See also 'fromAscListWith'.
fromListWith :: (a -> a -> a) -> [(Key,a)] -> IntMap a 
fromListWith f xs
  = fromListWithKey (\k x y -> f x y) xs

-- | /O(n*min(n,W))/.  Build a map from a list of key\/value pairs with a combining function. See also fromAscListWithKey'.
fromListWithKey :: (Key -> a -> a -> a) -> [(Key,a)] -> IntMap a 
fromListWithKey f xs 
  = foldlStrict ins empty xs
  where
    ins t (k,x) = insertWithKey f k x t

-- | /O(n*min(n,W))/. Build a map from a list of key\/value pairs where
-- the keys are in ascending order.
fromAscList :: [(Key,a)] -> IntMap a
fromAscList xs
  = fromList xs

-- | /O(n*min(n,W))/. Build a map from a list of key\/value pairs where
-- the keys are in ascending order, with a combining function on equal keys.
fromAscListWith :: (a -> a -> a) -> [(Key,a)] -> IntMap a
fromAscListWith f xs
  = fromListWith f xs

-- | /O(n*min(n,W))/. Build a map from a list of key\/value pairs where
-- the keys are in ascending order, with a combining function on equal keys.
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key,a)] -> IntMap a
fromAscListWithKey f xs
  = fromListWithKey f xs

-- | /O(n*min(n,W))/. Build a map from a list of key\/value pairs where
-- the keys are in ascending order and all distinct.
fromDistinctAscList :: [(Key,a)] -> IntMap a
fromDistinctAscList xs
  = fromList xs


{--------------------------------------------------------------------
  Eq 
--------------------------------------------------------------------}
instance Eq a => Eq (IntMap a) where
  t1 == t2  = equal t1 t2
  t1 /= t2  = nequal t1 t2

equal :: Eq a => IntMap a -> IntMap a -> Bool
equal (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)
  = (m1 == m2) && (p1 == p2) && (equal l1 l2) && (equal r1 r2) 
equal (Tip kx x) (Tip ky y)
  = (kx == ky) && (x==y)
equal Nil Nil = True
equal t1 t2   = False

nequal :: Eq a => IntMap a -> IntMap a -> Bool
nequal (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)
  = (m1 /= m2) || (p1 /= p2) || (nequal l1 l2) || (nequal r1 r2) 
nequal (Tip kx x) (Tip ky y)
  = (kx /= ky) || (x/=y)
nequal Nil Nil = False
nequal t1 t2   = True

{--------------------------------------------------------------------
  Ord 
--------------------------------------------------------------------}

instance Ord a => Ord (IntMap a) where
    compare m1 m2 = compare (toList m1) (toList m2)

{--------------------------------------------------------------------
  Functor 
--------------------------------------------------------------------}

instance Functor IntMap where
    fmap = map

{--------------------------------------------------------------------
  Show 
--------------------------------------------------------------------}

instance Show a => Show (IntMap a) where
  showsPrec d m   = showParen (d > 10) $
    showString "fromList " . shows (toList m)

showMap :: (Show a) => [(Key,a)] -> ShowS
showMap []     
  = showString "{}" 
showMap (x:xs) 
  = showChar '{' . showElem x . showTail xs
  where
    showTail []     = showChar '}'
    showTail (x:xs) = showChar ',' . showElem x . showTail xs
    
    showElem (k,x)  = shows k . showString ":=" . shows x

{--------------------------------------------------------------------
  Read
--------------------------------------------------------------------}
instance (Read e) => Read (IntMap e) where








  readsPrec p = readParen (p > 10) $ \ r -> do
    ("fromList",s) <- lex r
    (xs,t) <- reads s
    return (fromList xs,t)


{--------------------------------------------------------------------
  Typeable
--------------------------------------------------------------------}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      























































intMapTc = mkTyCon "IntMap"; instance Typeable1 IntMap where { typeOf1 _ = mkTyConApp intMapTc [] }; instance Typeable a => Typeable (IntMap a) where { typeOf = typeOfDefault }

{--------------------------------------------------------------------
  Debugging
--------------------------------------------------------------------}
-- | /O(n)/. Show the tree that implements the map. The tree is shown
-- in a compressed, hanging format.
showTree :: Show a => IntMap a -> String
showTree s
  = showTreeWith True False s


{- | /O(n)/. The expression (@'showTreeWith' hang wide map@) shows
 the tree that implements the map. If @hang@ is
 'True', a /hanging/ tree is shown otherwise a rotated tree is shown. If
 @wide@ is 'True', an extra wide version is shown.
-}
showTreeWith :: Show a => Bool -> Bool -> IntMap a -> String
showTreeWith hang wide t
  | hang      = (showsTreeHang wide [] t) ""
  | otherwise = (showsTree wide [] [] t) ""

showsTree :: Show a => Bool -> [String] -> [String] -> IntMap a -> ShowS
showsTree wide lbars rbars t
  = case t of
      Bin p m l r
          -> showsTree wide (withBar rbars) (withEmpty rbars) r .
             showWide wide rbars .
             showsBars lbars . showString (showBin p m) . showString "\n" .
             showWide wide lbars .
             showsTree wide (withEmpty lbars) (withBar lbars) l
      Tip k x
          -> showsBars lbars . showString " " . shows k . showString ":=" . shows x . showString "\n" 
      Nil -> showsBars lbars . showString "|\n"

showsTreeHang :: Show a => Bool -> [String] -> IntMap a -> ShowS
showsTreeHang wide bars t
  = case t of
      Bin p m l r
          -> showsBars bars . showString (showBin p m) . showString "\n" . 
             showWide wide bars .
             showsTreeHang wide (withBar bars) l .
             showWide wide bars .
             showsTreeHang wide (withEmpty bars) r
      Tip k x
          -> showsBars bars . showString " " . shows k . showString ":=" . shows x . showString "\n" 
      Nil -> showsBars bars . showString "|\n" 
      
showBin p m
  = "*" -- ++ show (p,m)

showWide wide bars 
  | wide      = showString (concat (reverse bars)) . showString "|\n" 
  | otherwise = id

showsBars :: [String] -> ShowS
showsBars bars
  = case bars of
      [] -> id
      _  -> showString (concat (reverse (tail bars))) . showString node

node           = "+--"
withBar bars   = "|  ":bars
withEmpty bars = "   ":bars


{--------------------------------------------------------------------
  Helpers
--------------------------------------------------------------------}
{--------------------------------------------------------------------
  Join
--------------------------------------------------------------------}
join :: Prefix -> IntMap a -> Prefix -> IntMap a -> IntMap a
join p1 t1 p2 t2
  | zero p1 m = Bin p m t1 t2
  | otherwise = Bin p m t2 t1
  where
    m = branchMask p1 p2
    p = mask p1 m

{--------------------------------------------------------------------
  @bin@ assures that we never have empty trees within a tree.
--------------------------------------------------------------------}
bin :: Prefix -> Mask -> IntMap a -> IntMap a -> IntMap a
bin p m l Nil = l
bin p m Nil r = r
bin p m l r   = Bin p m l r

  
{--------------------------------------------------------------------
  Endian independent bit twiddling
--------------------------------------------------------------------}
zero :: Key -> Mask -> Bool
zero i m
  = (natFromInt i) .&. (natFromInt m) == 0

nomatch,match :: Key -> Prefix -> Mask -> Bool
nomatch i p m
  = (mask i m) /= p

match i p m
  = (mask i m) == p

mask :: Key -> Mask -> Prefix
mask i m
  = maskW (natFromInt i) (natFromInt m)


zeroN :: Nat -> Nat -> Bool
zeroN i m = (i .&. m) == 0

{--------------------------------------------------------------------
  Big endian operations  
--------------------------------------------------------------------}
maskW :: Nat -> Nat -> Prefix
maskW i m
  = intFromNat (i .&. (complement (m-1) `xor` m))

shorter :: Mask -> Mask -> Bool
shorter m1 m2
  = (natFromInt m1) > (natFromInt m2)

branchMask :: Prefix -> Prefix -> Mask
branchMask p1 p2
  = intFromNat (highestBitMask (natFromInt p1 `xor` natFromInt p2))
  
{----------------------------------------------------------------------
  Finding the highest bit (mask) in a word [x] can be done efficiently in
  three ways:
  * convert to a floating point value and the mantissa tells us the 
    [log2(x)] that corresponds with the highest bit position. The mantissa 
    is retrieved either via the standard C function [frexp] or by some bit 
    twiddling on IEEE compatible numbers (float). Note that one needs to 
    use at least [double] precision for an accurate mantissa of 32 bit 
    numbers.
  * use bit twiddling, a logarithmic sequence of bitwise or's and shifts (bit).
  * use processor specific assembler instruction (asm).

  The most portable way would be [bit], but is it efficient enough?
  I have measured the cycle counts of the different methods on an AMD 
  Athlon-XP 1800 (~ Pentium III 1.8Ghz) using the RDTSC instruction:

  highestBitMask: method  cycles
                  --------------
                   frexp   200
                   float    33
                   bit      11
                   asm      12

  highestBit:     method  cycles
                  --------------
                   frexp   195
                   float    33
                   bit      11
                   asm      11

  Wow, the bit twiddling is on today's RISC like machines even faster
  than a single CISC instruction (BSR)!
----------------------------------------------------------------------}

{----------------------------------------------------------------------
  [highestBitMask] returns a word where only the highest bit is set.
  It is found by first setting all bits in lower positions than the 
  highest bit and than taking an exclusive or with the original value.
  Allthough the function may look expensive, GHC compiles this into
  excellent C code that subsequently compiled into highly efficient
  machine code. The algorithm is derived from Jorg Arndt's FXT library.
----------------------------------------------------------------------}
highestBitMask :: Nat -> Nat
highestBitMask x
  = case (x .|. shiftRL x 1) of 
     x -> case (x .|. shiftRL x 2) of 
      x -> case (x .|. shiftRL x 4) of 
       x -> case (x .|. shiftRL x 8) of 
        x -> case (x .|. shiftRL x 16) of 
         x -> case (x .|. shiftRL x 32) of   -- for 64 bit platforms
          x -> (x `xor` (shiftRL x 1))


{--------------------------------------------------------------------
  Utilities 
--------------------------------------------------------------------}
foldlStrict f z xs
  = case xs of
      []     -> z
      (x:xx) -> let z' = f z x in seq z' (foldlStrict f z' xx)

{-
{--------------------------------------------------------------------
  Testing
--------------------------------------------------------------------}
testTree :: [Int] -> IntMap Int
testTree xs   = fromList [(x,x*x*30696 `mod` 65521) | x <- xs]
test1 = testTree [1..20]
test2 = testTree [30,29..10]
test3 = testTree [1,4,6,89,2323,53,43,234,5,79,12,9,24,9,8,423,8,42,4,8,9,3]

{--------------------------------------------------------------------
  QuickCheck
--------------------------------------------------------------------}
qcheck prop
  = check config prop
  where
    config = Config
      { configMaxTest = 500
      , configMaxFail = 5000
      , configSize    = \n -> (div n 2 + 3)
      , configEvery   = \n args -> let s = show n in s ++ [ '\b' | _ <- s ]
      }


{--------------------------------------------------------------------
  Arbitrary, reasonably balanced trees
--------------------------------------------------------------------}
instance Arbitrary a => Arbitrary (IntMap a) where
  arbitrary = do{ ks <- arbitrary
                ; xs <- mapM (\k -> do{ x <- arbitrary; return (k,x)}) ks
                ; return (fromList xs)
                }


{--------------------------------------------------------------------
  Single, Insert, Delete
--------------------------------------------------------------------}
prop_Single :: Key -> Int -> Bool
prop_Single k x
  = (insert k x empty == singleton k x)

prop_InsertDelete :: Key -> Int -> IntMap Int -> Property
prop_InsertDelete k x t
  = not (member k t) ==> delete k (insert k x t) == t

prop_UpdateDelete :: Key -> IntMap Int -> Bool  
prop_UpdateDelete k t
  = update (const Nothing) k t == delete k t


{--------------------------------------------------------------------
  Union
--------------------------------------------------------------------}
prop_UnionInsert :: Key -> Int -> IntMap Int -> Bool
prop_UnionInsert k x t
  = union (singleton k x) t == insert k x t

prop_UnionAssoc :: IntMap Int -> IntMap Int -> IntMap Int -> Bool
prop_UnionAssoc t1 t2 t3
  = union t1 (union t2 t3) == union (union t1 t2) t3

prop_UnionComm :: IntMap Int -> IntMap Int -> Bool
prop_UnionComm t1 t2
  = (union t1 t2 == unionWith (\x y -> y) t2 t1)


prop_Diff :: [(Key,Int)] -> [(Key,Int)] -> Bool
prop_Diff xs ys
  =  List.sort (keys (difference (fromListWith (+) xs) (fromListWith (+) ys))) 
    == List.sort ((List.\\) (nub (Prelude.map fst xs))  (nub (Prelude.map fst ys)))

prop_Int :: [(Key,Int)] -> [(Key,Int)] -> Bool
prop_Int xs ys
  =  List.sort (keys (intersection (fromListWith (+) xs) (fromListWith (+) ys))) 
    == List.sort (nub ((List.intersect) (Prelude.map fst xs)  (Prelude.map fst ys)))

{--------------------------------------------------------------------
  Lists
--------------------------------------------------------------------}
prop_Ordered
  = forAll (choose (5,100)) $ \n ->
    let xs = [(x,()) | x <- [0..n::Int]] 
    in fromAscList xs == fromList xs

prop_List :: [Key] -> Bool
prop_List xs
  = (sort (nub xs) == [x | (x,()) <- toAscList (fromList [(x,()) | x <- xs])])
-}
{-# OPTIONS -cpp -fglasgow-exts #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.IntSet
-- Copyright   :  (c) Daan Leijen 2002
-- License     :  BSD-style
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- An efficient implementation of integer sets.
--
-- Since many function names (but not the type name) clash with
-- "Prelude" names, this module is usually imported @qualified@, e.g.
--
-- >  import Data.IntSet (IntSet)
-- >  import qualified Data.IntSet as IntSet
--
-- The implementation is based on /big-endian patricia trees/.  This data
-- structure performs especially well on binary operations like 'union'
-- and 'intersection'.  However, my benchmarks show that it is also
-- (much) faster on insertions and deletions when compared to a generic
-- size-balanced set implementation (see "Data.Set").
--
--    * Chris Okasaki and Andy Gill,  \"/Fast Mergeable Integer Maps/\",
--	Workshop on ML, September 1998, pages 77-86,
--	<http://www.cse.ogi.edu/~andy/pub/finite.htm>
--
--    * D.R. Morrison, \"/PATRICIA -- Practical Algorithm To Retrieve
--	Information Coded In Alphanumeric/\", Journal of the ACM, 15(4),
--	October 1968, pages 514-534.
--
-- Many operations have a worst-case complexity of /O(min(n,W))/.
-- This means that the operation can become linear in the number of
-- elements with a maximum of /W/ -- the number of bits in an 'Int'
-- (32 or 64).
-----------------------------------------------------------------------------

module Data.IntSet  ( 
            -- * Set type
              IntSet          -- instance Eq,Show

            -- * Operators
            , (\\)

            -- * Query
            , null
            , size
            , member
            , notMember
            , isSubsetOf
            , isProperSubsetOf
            
            -- * Construction
            , empty
            , singleton
            , insert
            , delete
            
            -- * Combine
            , union, unions
            , difference
            , intersection
            
            -- * Filter
            , filter
            , partition
            , split
            , splitMember

            -- * Map
	    , map

            -- * Fold
            , fold

            -- * Conversion
            -- ** List
            , elems
            , toList
            , fromList
            
            -- ** Ordered list
            , toAscList
            , fromAscList
            , fromDistinctAscList
                        
            -- * Debugging
            , showTree
            , showTreeWith
            ) where


import Prelude hiding (lookup,filter,foldr,foldl,null,map)
import Data.Bits 
import Data.Int

import qualified Data.List as List
import Data.Monoid (Monoid(..))
import Data.Typeable

{-
-- just for testing
import QuickCheck 
import List (nub,sort)
import qualified List
-}














import Data.Word


infixl 9 \\{-This comment teaches CPP correct behaviour -}

-- A "Nat" is a natural machine word (an unsigned Int)
type Nat = Word

natFromInt :: Int -> Nat
natFromInt i = fromIntegral i

intFromNat :: Nat -> Int
intFromNat w = fromIntegral w

shiftRL :: Nat -> Int -> Nat







shiftRL x i   = shiftR x i


{--------------------------------------------------------------------
  Operators
--------------------------------------------------------------------}
-- | /O(n+m)/. See 'difference'.
(\\) :: IntSet -> IntSet -> IntSet
m1 \\ m2 = difference m1 m2

{--------------------------------------------------------------------
  Types  
--------------------------------------------------------------------}
-- | A set of integers.
data IntSet = Nil
            | Tip {-# UNPACK #-} !Int
            | Bin {-# UNPACK #-} !Prefix {-# UNPACK #-} !Mask !IntSet !IntSet

type Prefix = Int
type Mask   = Int

instance Monoid IntSet where
    mempty  = empty
    mappend = union
    mconcat = unions


















{--------------------------------------------------------------------
  Query
--------------------------------------------------------------------}
-- | /O(1)/. Is the set empty?
null :: IntSet -> Bool
null Nil   = True
null other = False

-- | /O(n)/. Cardinality of the set.
size :: IntSet -> Int
size t
  = case t of
      Bin p m l r -> size l + size r
      Tip y -> 1
      Nil   -> 0

-- | /O(min(n,W))/. Is the value a member of the set?
member :: Int -> IntSet -> Bool
member x t
  = case t of
      Bin p m l r 
        | nomatch x p m -> False
        | zero x m      -> member x l
        | otherwise     -> member x r
      Tip y -> (x==y)
      Nil   -> False
    
-- | /O(log n)/. Is the element not in the set?
notMember :: Int -> IntSet -> Bool
notMember k = not . member k

-- 'lookup' is used by 'intersection' for left-biasing
lookup :: Int -> IntSet -> Maybe Int
lookup k t
  = let nk = natFromInt k  in seq nk (lookupN nk t)

lookupN :: Nat -> IntSet -> Maybe Int
lookupN k t
  = case t of
      Bin p m l r 
        | zeroN k (natFromInt m) -> lookupN k l
        | otherwise              -> lookupN k r
      Tip kx 
        | (k == natFromInt kx)  -> Just kx
        | otherwise             -> Nothing
      Nil -> Nothing

{--------------------------------------------------------------------
  Construction
--------------------------------------------------------------------}
-- | /O(1)/. The empty set.
empty :: IntSet
empty
  = Nil

-- | /O(1)/. A set of one element.
singleton :: Int -> IntSet
singleton x
  = Tip x

{--------------------------------------------------------------------
  Insert
--------------------------------------------------------------------}
-- | /O(min(n,W))/. Add a value to the set. When the value is already
-- an element of the set, it is replaced by the new one, ie. 'insert'
-- is left-biased.
insert :: Int -> IntSet -> IntSet
insert x t
  = case t of
      Bin p m l r 
        | nomatch x p m -> join x (Tip x) p t
        | zero x m      -> Bin p m (insert x l) r
        | otherwise     -> Bin p m l (insert x r)
      Tip y 
        | x==y          -> Tip x
        | otherwise     -> join x (Tip x) y t
      Nil -> Tip x

-- right-biased insertion, used by 'union'
insertR :: Int -> IntSet -> IntSet
insertR x t
  = case t of
      Bin p m l r 
        | nomatch x p m -> join x (Tip x) p t
        | zero x m      -> Bin p m (insert x l) r
        | otherwise     -> Bin p m l (insert x r)
      Tip y 
        | x==y          -> t
        | otherwise     -> join x (Tip x) y t
      Nil -> Tip x

-- | /O(min(n,W))/. Delete a value in the set. Returns the
-- original set when the value was not present.
delete :: Int -> IntSet -> IntSet
delete x t
  = case t of
      Bin p m l r 
        | nomatch x p m -> t
        | zero x m      -> bin p m (delete x l) r
        | otherwise     -> bin p m l (delete x r)
      Tip y 
        | x==y          -> Nil
        | otherwise     -> t
      Nil -> Nil


{--------------------------------------------------------------------
  Union
--------------------------------------------------------------------}
-- | The union of a list of sets.
unions :: [IntSet] -> IntSet
unions xs
  = foldlStrict union empty xs


-- | /O(n+m)/. The union of two sets. 
union :: IntSet -> IntSet -> IntSet
union t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
  | shorter m1 m2  = union1
  | shorter m2 m1  = union2
  | p1 == p2       = Bin p1 m1 (union l1 l2) (union r1 r2)
  | otherwise      = join p1 t1 p2 t2
  where
    union1  | nomatch p2 p1 m1  = join p1 t1 p2 t2
            | zero p2 m1        = Bin p1 m1 (union l1 t2) r1
            | otherwise         = Bin p1 m1 l1 (union r1 t2)

    union2  | nomatch p1 p2 m2  = join p1 t1 p2 t2
            | zero p1 m2        = Bin p2 m2 (union t1 l2) r2
            | otherwise         = Bin p2 m2 l2 (union t1 r2)

union (Tip x) t = insert x t
union t (Tip x) = insertR x t  -- right bias
union Nil t     = t
union t Nil     = t


{--------------------------------------------------------------------
  Difference
--------------------------------------------------------------------}
-- | /O(n+m)/. Difference between two sets. 
difference :: IntSet -> IntSet -> IntSet
difference t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
  | shorter m1 m2  = difference1
  | shorter m2 m1  = difference2
  | p1 == p2       = bin p1 m1 (difference l1 l2) (difference r1 r2)
  | otherwise      = t1
  where
    difference1 | nomatch p2 p1 m1  = t1
                | zero p2 m1        = bin p1 m1 (difference l1 t2) r1
                | otherwise         = bin p1 m1 l1 (difference r1 t2)

    difference2 | nomatch p1 p2 m2  = t1
                | zero p1 m2        = difference t1 l2
                | otherwise         = difference t1 r2

difference t1@(Tip x) t2 
  | member x t2  = Nil
  | otherwise    = t1

difference Nil t     = Nil
difference t (Tip x) = delete x t
difference t Nil     = t



{--------------------------------------------------------------------
  Intersection
--------------------------------------------------------------------}
-- | /O(n+m)/. The intersection of two sets. 
intersection :: IntSet -> IntSet -> IntSet
intersection t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
  | shorter m1 m2  = intersection1
  | shorter m2 m1  = intersection2
  | p1 == p2       = bin p1 m1 (intersection l1 l2) (intersection r1 r2)
  | otherwise      = Nil
  where
    intersection1 | nomatch p2 p1 m1  = Nil
                  | zero p2 m1        = intersection l1 t2
                  | otherwise         = intersection r1 t2

    intersection2 | nomatch p1 p2 m2  = Nil
                  | zero p1 m2        = intersection t1 l2
                  | otherwise         = intersection t1 r2

intersection t1@(Tip x) t2 
  | member x t2  = t1
  | otherwise    = Nil
intersection t (Tip x) 
  = case lookup x t of
      Just y  -> Tip y
      Nothing -> Nil
intersection Nil t = Nil
intersection t Nil = Nil



{--------------------------------------------------------------------
  Subset
--------------------------------------------------------------------}
-- | /O(n+m)/. Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: IntSet -> IntSet -> Bool
isProperSubsetOf t1 t2
  = case subsetCmp t1 t2 of 
      LT -> True
      ge -> False

subsetCmp t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
  | shorter m1 m2  = GT
  | shorter m2 m1  = subsetCmpLt
  | p1 == p2       = subsetCmpEq
  | otherwise      = GT  -- disjoint
  where
    subsetCmpLt | nomatch p1 p2 m2  = GT
                | zero p1 m2        = subsetCmp t1 l2
                | otherwise         = subsetCmp t1 r2
    subsetCmpEq = case (subsetCmp l1 l2, subsetCmp r1 r2) of
                    (GT,_ ) -> GT
                    (_ ,GT) -> GT
                    (EQ,EQ) -> EQ
                    other   -> LT

subsetCmp (Bin p m l r) t  = GT
subsetCmp (Tip x) (Tip y)  
  | x==y       = EQ
  | otherwise  = GT  -- disjoint
subsetCmp (Tip x) t        
  | member x t = LT
  | otherwise  = GT  -- disjoint
subsetCmp Nil Nil = EQ
subsetCmp Nil t   = LT

-- | /O(n+m)/. Is this a subset?
-- @(s1 `isSubsetOf` s2)@ tells whether @s1@ is a subset of @s2@.

isSubsetOf :: IntSet -> IntSet -> Bool
isSubsetOf t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
  | shorter m1 m2  = False
  | shorter m2 m1  = match p1 p2 m2 && (if zero p1 m2 then isSubsetOf t1 l2
                                                      else isSubsetOf t1 r2)                     
  | otherwise      = (p1==p2) && isSubsetOf l1 l2 && isSubsetOf r1 r2
isSubsetOf (Bin p m l r) t  = False
isSubsetOf (Tip x) t        = member x t
isSubsetOf Nil t            = True


{--------------------------------------------------------------------
  Filter
--------------------------------------------------------------------}
-- | /O(n)/. Filter all elements that satisfy some predicate.
filter :: (Int -> Bool) -> IntSet -> IntSet
filter pred t
  = case t of
      Bin p m l r 
        -> bin p m (filter pred l) (filter pred r)
      Tip x 
        | pred x    -> t
        | otherwise -> Nil
      Nil -> Nil

-- | /O(n)/. partition the set according to some predicate.
partition :: (Int -> Bool) -> IntSet -> (IntSet,IntSet)
partition pred t
  = case t of
      Bin p m l r 
        -> let (l1,l2) = partition pred l
               (r1,r2) = partition pred r
           in (bin p m l1 r1, bin p m l2 r2)
      Tip x 
        | pred x    -> (t,Nil)
        | otherwise -> (Nil,t)
      Nil -> (Nil,Nil)


-- | /O(log n)/. The expression (@'split' x set@) is a pair @(set1,set2)@
-- where all elements in @set1@ are lower than @x@ and all elements in
-- @set2@ larger than @x@.
--
-- > split 3 (fromList [1..5]) == (fromList [1,2], fromList [3,4])
split :: Int -> IntSet -> (IntSet,IntSet)
split x t
  = case t of
      Bin p m l r
        | m < 0       -> if x >= 0 then let (lt,gt) = split' x l in (union r lt, gt)
                                   else let (lt,gt) = split' x r in (lt, union gt l)
                                   -- handle negative numbers.
        | otherwise   -> split' x t
      Tip y 
        | x>y         -> (t,Nil)
        | x<y         -> (Nil,t)
        | otherwise   -> (Nil,Nil)
      Nil             -> (Nil, Nil)

split' :: Int -> IntSet -> (IntSet,IntSet)
split' x t
  = case t of
      Bin p m l r
        | match x p m -> if zero x m then let (lt,gt) = split' x l in (lt,union gt r)
                                     else let (lt,gt) = split' x r in (union l lt,gt)
        | otherwise   -> if x < p then (Nil, t)
                                  else (t, Nil)
      Tip y 
        | x>y       -> (t,Nil)
        | x<y       -> (Nil,t)
        | otherwise -> (Nil,Nil)
      Nil -> (Nil,Nil)

-- | /O(log n)/. Performs a 'split' but also returns whether the pivot
-- element was found in the original set.
splitMember :: Int -> IntSet -> (IntSet,Bool,IntSet)
splitMember x t
  = case t of
      Bin p m l r
        | m < 0       -> if x >= 0 then let (lt,found,gt) = splitMember' x l in (union r lt, found, gt)
                                   else let (lt,found,gt) = splitMember' x r in (lt, found, union gt l)
                                   -- handle negative numbers.
        | otherwise   -> splitMember' x t
      Tip y 
        | x>y       -> (t,False,Nil)
        | x<y       -> (Nil,False,t)
        | otherwise -> (Nil,True,Nil)
      Nil -> (Nil,False,Nil)

splitMember' :: Int -> IntSet -> (IntSet,Bool,IntSet)
splitMember' x t
  = case t of
      Bin p m l r
         | match x p m ->  if zero x m then let (lt,found,gt) = splitMember x l in (lt,found,union gt r)
                                       else let (lt,found,gt) = splitMember x r in (union l lt,found,gt)
         | otherwise   -> if x < p then (Nil, False, t)
                                   else (t, False, Nil)
      Tip y 
        | x>y       -> (t,False,Nil)
        | x<y       -> (Nil,False,t)
        | otherwise -> (Nil,True,Nil)
      Nil -> (Nil,False,Nil)

{----------------------------------------------------------------------
  Map
----------------------------------------------------------------------}

-- | /O(n*min(n,W))/. 
-- @'map' f s@ is the set obtained by applying @f@ to each element of @s@.
-- 
-- It's worth noting that the size of the result may be smaller if,
-- for some @(x,y)@, @x \/= y && f x == f y@

map :: (Int->Int) -> IntSet -> IntSet
map f = fromList . List.map f . toList

{--------------------------------------------------------------------
  Fold
--------------------------------------------------------------------}
-- | /O(n)/. Fold over the elements of a set in an unspecified order.
--
-- > sum set   == fold (+) 0 set
-- > elems set == fold (:) [] set
fold :: (Int -> b -> b) -> b -> IntSet -> b
fold f z t
  = case t of
      Bin 0 m l r | m < 0 -> foldr f (foldr f z l) r  
      -- put negative numbers before.
      Bin p m l r -> foldr f z t
      Tip x       -> f x z
      Nil         -> z

foldr :: (Int -> b -> b) -> b -> IntSet -> b
foldr f z t
  = case t of
      Bin p m l r -> foldr f (foldr f z r) l
      Tip x       -> f x z
      Nil         -> z
          
{--------------------------------------------------------------------
  List variations 
--------------------------------------------------------------------}
-- | /O(n)/. The elements of a set. (For sets, this is equivalent to toList)
elems :: IntSet -> [Int]
elems s
  = toList s

{--------------------------------------------------------------------
  Lists 
--------------------------------------------------------------------}
-- | /O(n)/. Convert the set to a list of elements.
toList :: IntSet -> [Int]
toList t
  = fold (:) [] t

-- | /O(n)/. Convert the set to an ascending list of elements.
toAscList :: IntSet -> [Int]
toAscList t = toList t

-- | /O(n*min(n,W))/. Create a set from a list of integers.
fromList :: [Int] -> IntSet
fromList xs
  = foldlStrict ins empty xs
  where
    ins t x  = insert x t

-- | /O(n*min(n,W))/. Build a set from an ascending list of elements.
fromAscList :: [Int] -> IntSet 
fromAscList xs
  = fromList xs

-- | /O(n*min(n,W))/. Build a set from an ascending list of distinct elements.
fromDistinctAscList :: [Int] -> IntSet
fromDistinctAscList xs
  = fromList xs


{--------------------------------------------------------------------
  Eq 
--------------------------------------------------------------------}
instance Eq IntSet where
  t1 == t2  = equal t1 t2
  t1 /= t2  = nequal t1 t2

equal :: IntSet -> IntSet -> Bool
equal (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)
  = (m1 == m2) && (p1 == p2) && (equal l1 l2) && (equal r1 r2) 
equal (Tip x) (Tip y)
  = (x==y)
equal Nil Nil = True
equal t1 t2   = False

nequal :: IntSet -> IntSet -> Bool
nequal (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)
  = (m1 /= m2) || (p1 /= p2) || (nequal l1 l2) || (nequal r1 r2) 
nequal (Tip x) (Tip y)
  = (x/=y)
nequal Nil Nil = False
nequal t1 t2   = True

{--------------------------------------------------------------------
  Ord 
--------------------------------------------------------------------}

instance Ord IntSet where
    compare s1 s2 = compare (toAscList s1) (toAscList s2) 
    -- tentative implementation. See if more efficient exists.

{--------------------------------------------------------------------
  Show
--------------------------------------------------------------------}
instance Show IntSet where
  showsPrec p xs = showParen (p > 10) $
    showString "fromList " . shows (toList xs)

showSet :: [Int] -> ShowS
showSet []     
  = showString "{}" 
showSet (x:xs) 
  = showChar '{' . shows x . showTail xs
  where
    showTail []     = showChar '}'
    showTail (x:xs) = showChar ',' . shows x . showTail xs

{--------------------------------------------------------------------
  Read
--------------------------------------------------------------------}
instance Read IntSet where








  readsPrec p = readParen (p > 10) $ \ r -> do
    ("fromList",s) <- lex r
    (xs,t) <- reads s
    return (fromList xs,t)


{--------------------------------------------------------------------
  Typeable
--------------------------------------------------------------------}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      























































intSetTc = mkTyCon "IntSet"; instance Typeable IntSet where { typeOf _ = mkTyConApp intSetTc [] }

{--------------------------------------------------------------------
  Debugging
--------------------------------------------------------------------}
-- | /O(n)/. Show the tree that implements the set. The tree is shown
-- in a compressed, hanging format.
showTree :: IntSet -> String
showTree s
  = showTreeWith True False s


{- | /O(n)/. The expression (@'showTreeWith' hang wide map@) shows
 the tree that implements the set. If @hang@ is
 'True', a /hanging/ tree is shown otherwise a rotated tree is shown. If
 @wide@ is 'True', an extra wide version is shown.
-}
showTreeWith :: Bool -> Bool -> IntSet -> String
showTreeWith hang wide t
  | hang      = (showsTreeHang wide [] t) ""
  | otherwise = (showsTree wide [] [] t) ""

showsTree :: Bool -> [String] -> [String] -> IntSet -> ShowS
showsTree wide lbars rbars t
  = case t of
      Bin p m l r
          -> showsTree wide (withBar rbars) (withEmpty rbars) r .
             showWide wide rbars .
             showsBars lbars . showString (showBin p m) . showString "\n" .
             showWide wide lbars .
             showsTree wide (withEmpty lbars) (withBar lbars) l
      Tip x
          -> showsBars lbars . showString " " . shows x . showString "\n" 
      Nil -> showsBars lbars . showString "|\n"

showsTreeHang :: Bool -> [String] -> IntSet -> ShowS
showsTreeHang wide bars t
  = case t of
      Bin p m l r
          -> showsBars bars . showString (showBin p m) . showString "\n" . 
             showWide wide bars .
             showsTreeHang wide (withBar bars) l .
             showWide wide bars .
             showsTreeHang wide (withEmpty bars) r
      Tip x
          -> showsBars bars . showString " " . shows x . showString "\n" 
      Nil -> showsBars bars . showString "|\n" 
      
showBin p m
  = "*" -- ++ show (p,m)

showWide wide bars 
  | wide      = showString (concat (reverse bars)) . showString "|\n" 
  | otherwise = id

showsBars :: [String] -> ShowS
showsBars bars
  = case bars of
      [] -> id
      _  -> showString (concat (reverse (tail bars))) . showString node

node           = "+--"
withBar bars   = "|  ":bars
withEmpty bars = "   ":bars


{--------------------------------------------------------------------
  Helpers
--------------------------------------------------------------------}
{--------------------------------------------------------------------
  Join
--------------------------------------------------------------------}
join :: Prefix -> IntSet -> Prefix -> IntSet -> IntSet
join p1 t1 p2 t2
  | zero p1 m = Bin p m t1 t2
  | otherwise = Bin p m t2 t1
  where
    m = branchMask p1 p2
    p = mask p1 m

{--------------------------------------------------------------------
  @bin@ assures that we never have empty trees within a tree.
--------------------------------------------------------------------}
bin :: Prefix -> Mask -> IntSet -> IntSet -> IntSet
bin p m l Nil = l
bin p m Nil r = r
bin p m l r   = Bin p m l r

  
{--------------------------------------------------------------------
  Endian independent bit twiddling
--------------------------------------------------------------------}
zero :: Int -> Mask -> Bool
zero i m
  = (natFromInt i) .&. (natFromInt m) == 0

nomatch,match :: Int -> Prefix -> Mask -> Bool
nomatch i p m
  = (mask i m) /= p

match i p m
  = (mask i m) == p

mask :: Int -> Mask -> Prefix
mask i m
  = maskW (natFromInt i) (natFromInt m)

zeroN :: Nat -> Nat -> Bool
zeroN i m = (i .&. m) == 0

{--------------------------------------------------------------------
  Big endian operations  
--------------------------------------------------------------------}
maskW :: Nat -> Nat -> Prefix
maskW i m
  = intFromNat (i .&. (complement (m-1) `xor` m))

shorter :: Mask -> Mask -> Bool
shorter m1 m2
  = (natFromInt m1) > (natFromInt m2)

branchMask :: Prefix -> Prefix -> Mask
branchMask p1 p2
  = intFromNat (highestBitMask (natFromInt p1 `xor` natFromInt p2))
  
{----------------------------------------------------------------------
  Finding the highest bit (mask) in a word [x] can be done efficiently in
  three ways:
  * convert to a floating point value and the mantissa tells us the 
    [log2(x)] that corresponds with the highest bit position. The mantissa 
    is retrieved either via the standard C function [frexp] or by some bit 
    twiddling on IEEE compatible numbers (float). Note that one needs to 
    use at least [double] precision for an accurate mantissa of 32 bit 
    numbers.
  * use bit twiddling, a logarithmic sequence of bitwise or's and shifts (bit).
  * use processor specific assembler instruction (asm).

  The most portable way would be [bit], but is it efficient enough?
  I have measured the cycle counts of the different methods on an AMD 
  Athlon-XP 1800 (~ Pentium III 1.8Ghz) using the RDTSC instruction:

  highestBitMask: method  cycles
                  --------------
                   frexp   200
                   float    33
                   bit      11
                   asm      12

  highestBit:     method  cycles
                  --------------
                   frexp   195
                   float    33
                   bit      11
                   asm      11

  Wow, the bit twiddling is on today's RISC like machines even faster
  than a single CISC instruction (BSR)!
----------------------------------------------------------------------}

{----------------------------------------------------------------------
  [highestBitMask] returns a word where only the highest bit is set.
  It is found by first setting all bits in lower positions than the 
  highest bit and than taking an exclusive or with the original value.
  Allthough the function may look expensive, GHC compiles this into
  excellent C code that subsequently compiled into highly efficient
  machine code. The algorithm is derived from Jorg Arndt's FXT library.
----------------------------------------------------------------------}
highestBitMask :: Nat -> Nat
highestBitMask x
  = case (x .|. shiftRL x 1) of 
     x -> case (x .|. shiftRL x 2) of 
      x -> case (x .|. shiftRL x 4) of 
       x -> case (x .|. shiftRL x 8) of 
        x -> case (x .|. shiftRL x 16) of 
         x -> case (x .|. shiftRL x 32) of   -- for 64 bit platforms
          x -> (x `xor` (shiftRL x 1))


{--------------------------------------------------------------------
  Utilities 
--------------------------------------------------------------------}
foldlStrict f z xs
  = case xs of
      []     -> z
      (x:xx) -> let z' = f z x in seq z' (foldlStrict f z' xx)


{-
{--------------------------------------------------------------------
  Testing
--------------------------------------------------------------------}
testTree :: [Int] -> IntSet
testTree xs   = fromList xs
test1 = testTree [1..20]
test2 = testTree [30,29..10]
test3 = testTree [1,4,6,89,2323,53,43,234,5,79,12,9,24,9,8,423,8,42,4,8,9,3]

{--------------------------------------------------------------------
  QuickCheck
--------------------------------------------------------------------}
qcheck prop
  = check config prop
  where
    config = Config
      { configMaxTest = 500
      , configMaxFail = 5000
      , configSize    = \n -> (div n 2 + 3)
      , configEvery   = \n args -> let s = show n in s ++ [ '\b' | _ <- s ]
      }


{--------------------------------------------------------------------
  Arbitrary, reasonably balanced trees
--------------------------------------------------------------------}
instance Arbitrary IntSet where
  arbitrary = do{ xs <- arbitrary
                ; return (fromList xs)
                }


{--------------------------------------------------------------------
  Single, Insert, Delete
--------------------------------------------------------------------}
prop_Single :: Int -> Bool
prop_Single x
  = (insert x empty == singleton x)

prop_InsertDelete :: Int -> IntSet -> Property
prop_InsertDelete k t
  = not (member k t) ==> delete k (insert k t) == t


{--------------------------------------------------------------------
  Union
--------------------------------------------------------------------}
prop_UnionInsert :: Int -> IntSet -> Bool
prop_UnionInsert x t
  = union t (singleton x) == insert x t

prop_UnionAssoc :: IntSet -> IntSet -> IntSet -> Bool
prop_UnionAssoc t1 t2 t3
  = union t1 (union t2 t3) == union (union t1 t2) t3

prop_UnionComm :: IntSet -> IntSet -> Bool
prop_UnionComm t1 t2
  = (union t1 t2 == union t2 t1)

prop_Diff :: [Int] -> [Int] -> Bool
prop_Diff xs ys
  =  toAscList (difference (fromList xs) (fromList ys))
    == List.sort ((List.\\) (nub xs)  (nub ys))

prop_Int :: [Int] -> [Int] -> Bool
prop_Int xs ys
  =  toAscList (intersection (fromList xs) (fromList ys))
    == List.sort (nub ((List.intersect) (xs)  (ys)))

{--------------------------------------------------------------------
  Lists
--------------------------------------------------------------------}
prop_Ordered
  = forAll (choose (5,100)) $ \n ->
    let xs = [0..n::Int]
    in fromAscList xs == fromList xs

prop_List :: [Int] -> Bool
prop_List xs
  = (sort (nub xs) == toAscList (fromList xs))
-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Ix
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  stable
-- Portability :  portable
--
-- The 'Ix' class is used to map a contiguous subrange of values in
-- type onto integers.  It is used primarily for array indexing
-- (see "Data.Array", "Data.Array.IArray" and "Data.Array.MArray").
-- 
-----------------------------------------------------------------------------
module Data.Ix
    (
    -- * The 'Ix' class
	Ix
	  ( range	-- :: (Ix a) => (a,a) -> [a]
	  , index       -- :: (Ix a) => (a,a) -> a   -> Int
	  , inRange     -- :: (Ix a) => (a,a) -> a   -> Bool
	  , rangeSize	-- :: (Ix a) => (a,a) -> Int
	  )
    -- Ix instances:
    --
    --  Ix Char
    --  Ix Int
    --  Ix Integer
    --  Ix Bool
    --  Ix Ordering
    --  Ix ()
    --  (Ix a, Ix b) => Ix (a, b)
    --  ...

    -- Implementation checked wrt. Haskell 98 lib report, 1/99.

    -- * Deriving Instances of 'Ix'
    -- | Derived instance declarations for the class 'Ix' are only possible
    -- for enumerations (i.e. datatypes having only nullary constructors)
    -- and single-constructor datatypes, including arbitrarily large tuples,
    -- whose constituent types are instances of 'Ix'. 
    -- 
    -- * For an enumeration, the nullary constructors are assumed to be
    -- numbered left-to-right with the indices being 0 to n-1 inclusive. This
    -- is the same numbering defined by the 'Enum' class. For example, given
    -- the datatype: 
    -- 
    -- >	data Colour = Red | Orange | Yellow | Green | Blue | Indigo | Violet
    -- 
    -- we would have: 
    -- 
    -- >	range   (Yellow,Blue)        ==  [Yellow,Green,Blue]
    -- >	index   (Yellow,Blue) Green  ==  1
    -- >	inRange (Yellow,Blue) Red    ==  False
    -- 
    -- * For single-constructor datatypes, the derived instance declarations
    -- are as shown for tuples in Figure 1
    -- <http://www.haskell.org/onlinelibrary/ix.html#prelude-index>.

    ) where

import Prelude






import Hugs.Prelude( Ix(..) )






{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.List
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  stable
-- Portability :  portable
--
-- Operations on lists.
--
-----------------------------------------------------------------------------

module Data.List
   ( 





   -- * Basic functions

     (++)	       -- :: [a] -> [a] -> [a]
   , head	       -- :: [a] -> a
   , last	       -- :: [a] -> a
   , tail	       -- :: [a] -> [a]
   , init              -- :: [a] -> [a]
   , null	       -- :: [a] -> Bool
   , length	       -- :: [a] -> Int

   -- * List transformations
   , map               -- :: (a -> b) -> [a] -> [b]
   , reverse           -- :: [a] -> [a]

   , intersperse       -- :: a -> [a] -> [a]
   , transpose         -- :: [[a]] -> [[a]]

   -- * Reducing lists (folds)

   , foldl	       -- :: (a -> b -> a) -> a -> [b] -> a
   , foldl'	       -- :: (a -> b -> a) -> a -> [b] -> a
   , foldl1	       -- :: (a -> a -> a) -> [a] -> a
   , foldl1'	       -- :: (a -> a -> a) -> [a] -> a
   , foldr             -- :: (a -> b -> b) -> b -> [a] -> b
   , foldr1            -- :: (a -> a -> a) -> [a] -> a

   -- ** Special folds

   , concat            -- :: [[a]] -> [a]
   , concatMap         -- :: (a -> [b]) -> [a] -> [b]
   , and	       -- :: [Bool] -> Bool
   , or                -- :: [Bool] -> Bool
   , any               -- :: (a -> Bool) -> [a] -> Bool
   , all               -- :: (a -> Bool) -> [a] -> Bool
   , sum               -- :: (Num a) => [a] -> a
   , product           -- :: (Num a) => [a] -> a
   , maximum           -- :: (Ord a) => [a] -> a
   , minimum           -- :: (Ord a) => [a] -> a

   -- * Building lists

   -- ** Scans
   , scanl             -- :: (a -> b -> a) -> a -> [b] -> [a]
   , scanl1            -- :: (a -> a -> a) -> [a] -> [a]
   , scanr             -- :: (a -> b -> b) -> b -> [a] -> [b]
   , scanr1            -- :: (a -> a -> a) -> [a] -> [a]

   -- ** Accumulating maps
   , mapAccumL         -- :: (a -> b -> (a,c)) -> a -> [b] -> (a,[c])
   , mapAccumR         -- :: (a -> b -> (a,c)) -> a -> [b] -> (a,[c])

   -- ** Infinite lists
   , iterate           -- :: (a -> a) -> a -> [a]
   , repeat            -- :: a -> [a]
   , replicate         -- :: Int -> a -> [a]
   , cycle             -- :: [a] -> [a]

   -- ** Unfolding
   , unfoldr	       -- :: (b -> Maybe (a, b)) -> b -> [a]

   -- * Sublists

   -- ** Extracting sublists
   , take              -- :: Int -> [a] -> [a]
   , drop              -- :: Int -> [a] -> [a]
   , splitAt           -- :: Int -> [a] -> ([a], [a])

   , takeWhile         -- :: (a -> Bool) -> [a] -> [a]
   , dropWhile         -- :: (a -> Bool) -> [a] -> [a]
   , span              -- :: (a -> Bool) -> [a] -> ([a], [a])
   , break             -- :: (a -> Bool) -> [a] -> ([a], [a])

   , group             -- :: Eq a => [a] -> [[a]]

   , inits             -- :: [a] -> [[a]]
   , tails             -- :: [a] -> [[a]]

   -- ** Predicates
   , isPrefixOf        -- :: (Eq a) => [a] -> [a] -> Bool
   , isSuffixOf        -- :: (Eq a) => [a] -> [a] -> Bool
   , isInfixOf         -- :: (Eq a) => [a] -> [a] -> Bool

   -- * Searching lists

   -- ** Searching by equality
   , elem              -- :: a -> [a] -> Bool
   , notElem           -- :: a -> [a] -> Bool
   , lookup            -- :: (Eq a) => a -> [(a,b)] -> Maybe b

   -- ** Searching with a predicate
   , find	       -- :: (a -> Bool) -> [a] -> Maybe a
   , filter	       -- :: (a -> Bool) -> [a] -> [a]
   , partition         -- :: (a -> Bool) -> [a] -> ([a], [a])

   -- * Indexing lists
   -- | These functions treat a list @xs@ as a indexed collection,
   -- with indices ranging from 0 to @'length' xs - 1@.

   , (!!)	       -- :: [a] -> Int -> a

   , elemIndex	       -- :: (Eq a) => a -> [a] -> Maybe Int
   , elemIndices       -- :: (Eq a) => a -> [a] -> [Int]

   , findIndex	       -- :: (a -> Bool) -> [a] -> Maybe Int
   , findIndices       -- :: (a -> Bool) -> [a] -> [Int]

   -- * Zipping and unzipping lists

   , zip               -- :: [a] -> [b] -> [(a,b)]
   , zip3  
   , zip4, zip5, zip6, zip7

   , zipWith           -- :: (a -> b -> c) -> [a] -> [b] -> [c]
   , zipWith3
   , zipWith4, zipWith5, zipWith6, zipWith7

   , unzip             -- :: [(a,b)] -> ([a],[b])
   , unzip3
   , unzip4, unzip5, unzip6, unzip7

   -- * Special lists

   -- ** Functions on strings
   , lines	       -- :: String   -> [String]
   , words	       -- :: String   -> [String]
   , unlines           -- :: [String] -> String
   , unwords           -- :: [String] -> String

   -- ** \"Set\" operations
   
   , nub               -- :: (Eq a) => [a] -> [a]

   , delete            -- :: (Eq a) => a -> [a] -> [a]
   , (\\)              -- :: (Eq a) => [a] -> [a] -> [a]
   
   , union             -- :: (Eq a) => [a] -> [a] -> [a]
   , intersect         -- :: (Eq a) => [a] -> [a] -> [a]

   -- ** Ordered lists
   , sort              -- :: (Ord a) => [a] -> [a]
   , insert            -- :: (Ord a) => a -> [a] -> [a]

   -- * Generalized functions

   -- ** The \"@By@\" operations
   -- | By convention, overloaded functions have a non-overloaded
   -- counterpart whose name is suffixed with \`@By@\'.

   -- *** User-supplied equality (replacing an @Eq@ context)
   -- | The predicate is assumed to define an equivalence.
   , nubBy             -- :: (a -> a -> Bool) -> [a] -> [a]
   , deleteBy          -- :: (a -> a -> Bool) -> a -> [a] -> [a]
   , deleteFirstsBy    -- :: (a -> a -> Bool) -> [a] -> [a] -> [a]
   , unionBy           -- :: (a -> a -> Bool) -> [a] -> [a] -> [a]
   , intersectBy       -- :: (a -> a -> Bool) -> [a] -> [a] -> [a]
   , groupBy           -- :: (a -> a -> Bool) -> [a] -> [[a]]

   -- *** User-supplied comparison (replacing an @Ord@ context)
   -- | The function is assumed to define a total ordering.
   , sortBy            -- :: (a -> a -> Ordering) -> [a] -> [a]
   , insertBy          -- :: (a -> a -> Ordering) -> a -> [a] -> [a]
   , maximumBy	       -- :: (a -> a -> Ordering) -> [a] -> a
   , minimumBy         -- :: (a -> a -> Ordering) -> [a] -> a

   -- ** The \"@generic@\" operations
   -- | The prefix \`@generic@\' indicates an overloaded function that
   -- is a generalized version of a "Prelude" function.

   , genericLength     -- :: (Integral a) => [b] -> a
   , genericTake       -- :: (Integral a) => a -> [b] -> [b]
   , genericDrop       -- :: (Integral a) => a -> [b] -> [b]
   , genericSplitAt    -- :: (Integral a) => a -> [b] -> ([b], [b])
   , genericIndex      -- :: (Integral a) => [b] -> a -> b
   , genericReplicate  -- :: (Integral a) => a -> b -> [b]

   ) where





import Data.Maybe
import Data.Char	( isSpace )








infix 5 \\ -- comment to fool cpp

-- -----------------------------------------------------------------------------
-- List functions

-- | The 'elemIndex' function returns the index of the first element
-- in the given list which is equal (by '==') to the query element,
-- or 'Nothing' if there is no such element.
elemIndex	:: Eq a => a -> [a] -> Maybe Int
elemIndex x     = findIndex (x==)

-- | The 'elemIndices' function extends 'elemIndex', by returning the
-- indices of all elements equal to the query element, in ascending order.
elemIndices     :: Eq a => a -> [a] -> [Int]
elemIndices x   = findIndices (x==)

-- | The 'find' function takes a predicate and a list and returns the
-- first element in the list matching the predicate, or 'Nothing' if
-- there is no such element.
find		:: (a -> Bool) -> [a] -> Maybe a
find p          = listToMaybe . filter p

-- | The 'findIndex' function takes a predicate and a list and returns
-- the index of the first element in the list satisfying the predicate,
-- or 'Nothing' if there is no such element.
findIndex       :: (a -> Bool) -> [a] -> Maybe Int
findIndex p     = listToMaybe . findIndices p

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices      :: (a -> Bool) -> [a] -> [Int]


findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]









-- | The 'isPrefixOf' function takes two lists and returns 'True'
-- iff the first list is a prefix of the second.
isPrefixOf              :: (Eq a) => [a] -> [a] -> Bool
isPrefixOf [] _         =  True
isPrefixOf _  []        =  False
isPrefixOf (x:xs) (y:ys)=  x == y && isPrefixOf xs ys

-- | The 'isSuffixOf' function takes two lists and returns 'True'
-- iff the first list is a suffix of the second.
-- Both lists must be finite.
isSuffixOf              :: (Eq a) => [a] -> [a] -> Bool
isSuffixOf x y          =  reverse x `isPrefixOf` reverse y

-- | The 'isInfixOf' function takes two lists and returns 'True'
-- iff the first list is contained, wholly and intact,
-- anywhere within the second.
--
-- Example:
--
-- >isInfixOf "Haskell" "I really like Haskell." -> True
-- >isInfixOf "Ial" "I really like Haskell." -> False
isInfixOf               :: (Eq a) => [a] -> [a] -> Bool
isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)

-- | The 'nub' function removes duplicate elements from a list.
-- In particular, it keeps only the first occurrence of each element.
-- (The name 'nub' means \`essence\'.)
-- It is a special case of 'nubBy', which allows the programmer to supply
-- their own equality test.
nub                     :: (Eq a) => [a] -> [a]



-- stolen from HBC
nub l                   = nub' l []		-- '
  where
    nub' [] _		= []			-- '
    nub' (x:xs) ls				-- '
	| x `elem` ls   = nub' xs ls		-- '
	| otherwise     = x : nub' xs (x:ls)	-- '


-- | The 'nubBy' function behaves just like 'nub', except it uses a
-- user-supplied equality predicate instead of the overloaded '=='
-- function.
nubBy			:: (a -> a -> Bool) -> [a] -> [a]




nubBy eq l              = nubBy' l []
  where
    nubBy' [] _		= []
    nubBy' (y:ys) xs
       | elem_by eq y xs = nubBy' ys xs 
       | otherwise	 = y : nubBy' ys (y:xs)

-- Not exported:
-- Note that we keep the call to `eq` with arguments in the
-- same order as in the reference implementation
-- 'xs' is the list of things we've seen so far, 
-- 'y' is the potential new element
elem_by :: (a -> a -> Bool) -> a -> [a] -> Bool
elem_by _  _ []		=  False
elem_by eq y (x:xs)	=  x `eq` y || elem_by eq y xs



-- | 'delete' @x@ removes the first occurrence of @x@ from its list argument.
-- For example,
--
-- > delete 'a' "banana" == "bnana"
--
-- It is a special case of 'deleteBy', which allows the programmer to
-- supply their own equality test.

delete                  :: (Eq a) => a -> [a] -> [a]
delete                  =  deleteBy (==)

-- | The 'deleteBy' function behaves like 'delete', but takes a
-- user-supplied equality predicate.
deleteBy                :: (a -> a -> Bool) -> a -> [a] -> [a]
deleteBy _  _ []        = []
deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys

-- | The '\\' function is list difference ((non-associative).
-- In the result of @xs@ '\\' @ys@, the first occurrence of each element of
-- @ys@ in turn (if any) has been removed from @xs@.  Thus
--
-- > (xs ++ ys) \\ xs == ys.
--
-- It is a special case of 'deleteFirstsBy', which allows the programmer
-- to supply their own equality test.

(\\)			:: (Eq a) => [a] -> [a] -> [a]
(\\)		        =  foldl (flip delete)

-- | The 'union' function returns the list union of the two lists.
-- For example,
--
-- > "dog" `union` "cow" == "dogcw"
--
-- Duplicates, and elements of the first list, are removed from the
-- the second list, but if the first list contains duplicates, so will
-- the result.
-- It is a special case of 'unionBy', which allows the programmer to supply
-- their own equality test.

union			:: (Eq a) => [a] -> [a] -> [a]
union 			= unionBy (==)

-- | The 'unionBy' function is the non-overloaded version of 'union'.
unionBy                 :: (a -> a -> Bool) -> [a] -> [a] -> [a]
unionBy eq xs ys        =  xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs

-- | The 'intersect' function takes the list intersection of two lists.
-- For example,
--
-- > [1,2,3,4] `intersect` [2,4,6,8] == [2,4]
--
-- If the first list contains duplicates, so will the result.
-- It is a special case of 'intersectBy', which allows the programmer to
-- supply their own equality test.

intersect               :: (Eq a) => [a] -> [a] -> [a]
intersect               =  intersectBy (==)

-- | The 'intersectBy' function is the non-overloaded version of 'intersect'.
intersectBy             :: (a -> a -> Bool) -> [a] -> [a] -> [a]
intersectBy eq xs ys    =  [x | x <- xs, any (eq x) ys]

-- | The 'intersperse' function takes an element and a list and
-- \`intersperses\' that element between the elements of the list.
-- For example,
--
-- > intersperse ',' "abcde" == "a,b,c,d,e"

intersperse		:: a -> [a] -> [a]
intersperse _   []      = []
intersperse _   [x]     = [x]
intersperse sep (x:xs)  = x : sep : intersperse sep xs

-- | The 'transpose' function transposes the rows and columns of its argument.
-- For example,
--
-- > transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]

transpose		:: [[a]] -> [[a]]
transpose []		 = []
transpose ([]	: xss)   = transpose xss
transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])


-- | The 'partition' function takes a predicate a list and returns
-- the pair of lists of elements which do and do not satisfy the
-- predicate, respectively; i.e.,
--
-- > partition p xs == (filter p xs, filter (not . p) xs)

partition		:: (a -> Bool) -> [a] -> ([a],[a])
{-# INLINE partition #-}
partition p xs = foldr (select p) ([],[]) xs

select p x ~(ts,fs) | p x       = (x:ts,fs)
                    | otherwise = (ts, x:fs)

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a list, passing
-- an accumulating parameter from left to right, and returning a final
-- value of this accumulator together with the new list.
mapAccumL :: (acc -> x -> (acc, y)) -- Function of elt of input list
				    -- and accumulator, returning new
				    -- accumulator and elt of result list
   	  -> acc	    -- Initial accumulator 
	  -> [x]	    -- Input list
	  -> (acc, [y])	    -- Final accumulator and result list
mapAccumL _ s []     	=  (s, [])
mapAccumL f s (x:xs) 	=  (s'',y:ys)
		           where (s', y ) = f s x
			         (s'',ys) = mapAccumL f s' xs

-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a list, passing
-- an accumulating parameter from right to left, and returning a final
-- value of this accumulator together with the new list.
mapAccumR :: (acc -> x -> (acc, y)) 	-- Function of elt of input list
					-- and accumulator, returning new
					-- accumulator and elt of result list
	    -> acc 		-- Initial accumulator
	    -> [x] 		-- Input list
	    -> (acc, [y])		-- Final accumulator and result list
mapAccumR _ s []     	=  (s, [])
mapAccumR f s (x:xs)	=  (s'', y:ys)
		           where (s'',y ) = f s' x
			         (s', ys) = mapAccumR f s xs

-- | The 'insert' function takes an element and a list and inserts the
-- element into the list at the last position where it is still less
-- than or equal to the next element.  In particular, if the list
-- is sorted before the call, the result will also be sorted.
-- It is a special case of 'insertBy', which allows the programmer to
-- supply their own comparison function.
insert :: Ord a => a -> [a] -> [a]
insert e ls = insertBy (compare) e ls

-- | The non-overloaded version of 'insert'.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
insertBy _   x [] = [x]
insertBy cmp x ys@(y:ys')
 = case cmp x y of
     GT -> y : insertBy cmp x ys'
     _  -> x : ys










































-- | The 'maximumBy' function takes a comparison function and a list
-- and returns the greatest element of the list by the comparison function.
-- The list must be finite and non-empty.
maximumBy		:: (a -> a -> Ordering) -> [a] -> a
maximumBy _ []		=  error "List.maximumBy: empty list"
maximumBy cmp xs	=  foldl1 max xs
			where
			   max x y = case cmp x y of
					GT -> x
					_  -> y

-- | The 'minimumBy' function takes a comparison function and a list
-- and returns the least element of the list by the comparison function.
-- The list must be finite and non-empty.
minimumBy		:: (a -> a -> Ordering) -> [a] -> a
minimumBy _ []		=  error "List.minimumBy: empty list"
minimumBy cmp xs	=  foldl1 min xs
			where
			   min x y = case cmp x y of
					GT -> y
					_  -> x

-- | The 'genericLength' function is an overloaded version of 'length'.  In
-- particular, instead of returning an 'Int', it returns any type which is
-- an instance of 'Num'.  It is, however, less efficient than 'length'.
genericLength           :: (Num i) => [b] -> i
genericLength []        =  0
genericLength (_:l)     =  1 + genericLength l

-- | The 'genericTake' function is an overloaded version of 'take', which
-- accepts any 'Integral' value as the number of elements to take.
genericTake		:: (Integral i) => i -> [a] -> [a]
genericTake 0 _         =  []
genericTake _ []        =  []
genericTake n (x:xs) | n > 0  =  x : genericTake (n-1) xs
genericTake _  _        =  error "List.genericTake: negative argument"

-- | The 'genericDrop' function is an overloaded version of 'drop', which
-- accepts any 'Integral' value as the number of elements to drop.
genericDrop		:: (Integral i) => i -> [a] -> [a]
genericDrop 0 xs        =  xs
genericDrop _ []        =  []
genericDrop n (_:xs) | n > 0  =  genericDrop (n-1) xs
genericDrop _ _		=  error "List.genericDrop: negative argument"

-- | The 'genericSplitAt' function is an overloaded version of 'splitAt', which
-- accepts any 'Integral' value as the position at which to split.
genericSplitAt          :: (Integral i) => i -> [b] -> ([b],[b])
genericSplitAt 0 xs     =  ([],xs)
genericSplitAt _ []     =  ([],[])
genericSplitAt n (x:xs) | n > 0  =  (x:xs',xs'') where
                               (xs',xs'') = genericSplitAt (n-1) xs
genericSplitAt _ _      =  error "List.genericSplitAt: negative argument"

-- | The 'genericIndex' function is an overloaded version of '!!', which
-- accepts any 'Integral' value as the index.
genericIndex :: (Integral a) => [b] -> a -> b
genericIndex (x:_)  0 = x
genericIndex (_:xs) n 
 | n > 0     = genericIndex xs (n-1)
 | otherwise = error "List.genericIndex: negative argument."
genericIndex _ _      = error "List.genericIndex: index too large."

-- | The 'genericReplicate' function is an overloaded version of 'replicate',
-- which accepts any 'Integral' value as the number of repetitions to make.
genericReplicate	:: (Integral i) => i -> a -> [a]
genericReplicate n x	=  genericTake n (repeat x)

-- | The 'zip4' function takes four lists and returns a list of
-- quadruples, analogous to 'zip'.
zip4			:: [a] -> [b] -> [c] -> [d] -> [(a,b,c,d)]
zip4			=  zipWith4 (,,,)

-- | The 'zip5' function takes five lists and returns a list of
-- five-tuples, analogous to 'zip'.
zip5			:: [a] -> [b] -> [c] -> [d] -> [e] -> [(a,b,c,d,e)]
zip5			=  zipWith5 (,,,,)

-- | The 'zip6' function takes six lists and returns a list of six-tuples,
-- analogous to 'zip'.
zip6			:: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> 
                              [(a,b,c,d,e,f)]
zip6			=  zipWith6 (,,,,,)

-- | The 'zip7' function takes seven lists and returns a list of
-- seven-tuples, analogous to 'zip'.
zip7			:: [a] -> [b] -> [c] -> [d] -> [e] -> [f] ->
                              [g] -> [(a,b,c,d,e,f,g)]
zip7			=  zipWith7 (,,,,,,)

-- | The 'zipWith4' function takes a function which combines four
-- elements, as well as four lists and returns a list of their point-wise
-- combination, analogous to 'zipWith'.
zipWith4		:: (a->b->c->d->e) -> [a]->[b]->[c]->[d]->[e]
zipWith4 z (a:as) (b:bs) (c:cs) (d:ds)
			=  z a b c d : zipWith4 z as bs cs ds
zipWith4 _ _ _ _ _	=  []

-- | The 'zipWith5' function takes a function which combines five
-- elements, as well as five lists and returns a list of their point-wise
-- combination, analogous to 'zipWith'.
zipWith5		:: (a->b->c->d->e->f) -> 
                           [a]->[b]->[c]->[d]->[e]->[f]
zipWith5 z (a:as) (b:bs) (c:cs) (d:ds) (e:es)
			=  z a b c d e : zipWith5 z as bs cs ds es
zipWith5 _ _ _ _ _ _	= []

-- | The 'zipWith6' function takes a function which combines six
-- elements, as well as six lists and returns a list of their point-wise
-- combination, analogous to 'zipWith'.
zipWith6		:: (a->b->c->d->e->f->g) ->
                           [a]->[b]->[c]->[d]->[e]->[f]->[g]
zipWith6 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs)
			=  z a b c d e f : zipWith6 z as bs cs ds es fs
zipWith6 _ _ _ _ _ _ _	= []

-- | The 'zipWith7' function takes a function which combines seven
-- elements, as well as seven lists and returns a list of their point-wise
-- combination, analogous to 'zipWith'.
zipWith7		:: (a->b->c->d->e->f->g->h) ->
                           [a]->[b]->[c]->[d]->[e]->[f]->[g]->[h]
zipWith7 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs)
		   =  z a b c d e f g : zipWith7 z as bs cs ds es fs gs
zipWith7 _ _ _ _ _ _ _ _ = []

-- | The 'unzip4' function takes a list of quadruples and returns four
-- lists, analogous to 'unzip'.
unzip4			:: [(a,b,c,d)] -> ([a],[b],[c],[d])
unzip4			=  foldr (\(a,b,c,d) ~(as,bs,cs,ds) ->
					(a:as,b:bs,c:cs,d:ds))
				 ([],[],[],[])

-- | The 'unzip5' function takes a list of five-tuples and returns five
-- lists, analogous to 'unzip'.
unzip5			:: [(a,b,c,d,e)] -> ([a],[b],[c],[d],[e])
unzip5			=  foldr (\(a,b,c,d,e) ~(as,bs,cs,ds,es) ->
					(a:as,b:bs,c:cs,d:ds,e:es))
				 ([],[],[],[],[])

-- | The 'unzip6' function takes a list of six-tuples and returns six
-- lists, analogous to 'unzip'.
unzip6			:: [(a,b,c,d,e,f)] -> ([a],[b],[c],[d],[e],[f])
unzip6			=  foldr (\(a,b,c,d,e,f) ~(as,bs,cs,ds,es,fs) ->
					(a:as,b:bs,c:cs,d:ds,e:es,f:fs))
				 ([],[],[],[],[],[])

-- | The 'unzip7' function takes a list of seven-tuples and returns
-- seven lists, analogous to 'unzip'.
unzip7		:: [(a,b,c,d,e,f,g)] -> ([a],[b],[c],[d],[e],[f],[g])
unzip7		=  foldr (\(a,b,c,d,e,f,g) ~(as,bs,cs,ds,es,fs,gs) ->
				(a:as,b:bs,c:cs,d:ds,e:es,f:fs,g:gs))
			 ([],[],[],[],[],[],[])


-- | The 'deleteFirstsBy' function takes a predicate and two lists and
-- returns the first list with the first occurrence of each element of
-- the second list removed.
deleteFirstsBy          :: (a -> a -> Bool) -> [a] -> [a] -> [a]
deleteFirstsBy eq       =  foldl (flip (deleteBy eq))

-- | The 'group' function takes a list and returns a list of lists such
-- that the concatenation of the result is equal to the argument.  Moreover,
-- each sublist in the result contains only equal elements.  For example,
--
-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--
-- It is a special case of 'groupBy', which allows the programmer to supply
-- their own equality test.
group	 		:: Eq a => [a] -> [[a]]
group                   =  groupBy (==)

-- | The 'groupBy' function is the non-overloaded version of 'group'.
groupBy 		:: (a -> a -> Bool) -> [a] -> [[a]]
groupBy _  []		=  []
groupBy eq (x:xs)	=  (x:ys) : groupBy eq zs
                           where (ys,zs) = span (eq x) xs

-- | The 'inits' function returns all initial segments of the argument,
-- shortest first.  For example,
--
-- > inits "abc" == ["","a","ab","abc"]
--
inits 			:: [a] -> [[a]]
inits []		=  [[]]
inits (x:xs) 		=  [[]] ++ map (x:) (inits xs)

-- | The 'tails' function returns all final segments of the argument,
-- longest first.  For example,
--
-- > tails "abc" == ["abc", "bc", "c",""]
--
tails 			:: [a] -> [[a]]
tails []	        =  [[]]
tails xxs@(_:xs) 	=  xxs : tails xs


------------------------------------------------------------------------------
-- Quick Sort algorithm taken from HBC's QSort library.

-- | The 'sort' function implements a stable sorting algorithm.
-- It is a special case of 'sortBy', which allows the programmer to supply
-- their own comparison function.
sort :: (Ord a) => [a] -> [a]

-- | The 'sortBy' function is the non-overloaded version of 'sort'.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]






sortBy cmp l = mergesort cmp l
sort l = mergesort compare l

{-
Quicksort replaced by mergesort, 14/5/2002.

From: Ian Lynagh <igloo@earth.li>

I am curious as to why the List.sort implementation in GHC is a
quicksort algorithm rather than an algorithm that guarantees n log n
time in the worst case? I have attached a mergesort implementation along
with a few scripts to time it's performance, the results of which are
shown below (* means it didn't finish successfully - in all cases this
was due to a stack overflow).

If I heap profile the random_list case with only 10000 then I see
random_list peaks at using about 2.5M of memory, whereas in the same
program using List.sort it uses only 100k.

Input style     Input length     Sort data     Sort alg    User time
stdin           10000            random_list   sort        2.82
stdin           10000            random_list   mergesort   2.96
stdin           10000            sorted        sort        31.37
stdin           10000            sorted        mergesort   1.90
stdin           10000            revsorted     sort        31.21
stdin           10000            revsorted     mergesort   1.88
stdin           100000           random_list   sort        *
stdin           100000           random_list   mergesort   *
stdin           100000           sorted        sort        *
stdin           100000           sorted        mergesort   *
stdin           100000           revsorted     sort        *
stdin           100000           revsorted     mergesort   *
func            10000            random_list   sort        0.31
func            10000            random_list   mergesort   0.91
func            10000            sorted        sort        19.09
func            10000            sorted        mergesort   0.15
func            10000            revsorted     sort        19.17
func            10000            revsorted     mergesort   0.16
func            100000           random_list   sort        3.85
func            100000           random_list   mergesort   *
func            100000           sorted        sort        5831.47
func            100000           sorted        mergesort   2.23
func            100000           revsorted     sort        5872.34
func            100000           revsorted     mergesort   2.24
-}

mergesort :: (a -> a -> Ordering) -> [a] -> [a]
mergesort cmp = mergesort' cmp . map wrap

mergesort' :: (a -> a -> Ordering) -> [[a]] -> [a]
mergesort' cmp [] = []
mergesort' cmp [xs] = xs
mergesort' cmp xss = mergesort' cmp (merge_pairs cmp xss)

merge_pairs :: (a -> a -> Ordering) -> [[a]] -> [[a]]
merge_pairs cmp [] = []
merge_pairs cmp [xs] = [xs]
merge_pairs cmp (xs:ys:xss) = merge cmp xs ys : merge_pairs cmp xss

merge :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
merge cmp xs [] = xs
merge cmp [] ys = ys
merge cmp (x:xs) (y:ys)
 = case x `cmp` y of
        GT -> y : merge cmp (x:xs)   ys
        _  -> x : merge cmp    xs (y:ys)

wrap :: a -> [a]
wrap x = [x]

{-
OLD: qsort version

-- qsort is stable and does not concatenate.
qsort :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
qsort _   []     r = r
qsort _   [x]    r = x:r
qsort cmp (x:xs) r = qpart cmp x xs [] [] r

-- qpart partitions and sorts the sublists
qpart :: (a -> a -> Ordering) -> a -> [a] -> [a] -> [a] -> [a] -> [a]
qpart cmp x [] rlt rge r =
    -- rlt and rge are in reverse order and must be sorted with an
    -- anti-stable sorting
    rqsort cmp rlt (x:rqsort cmp rge r)
qpart cmp x (y:ys) rlt rge r =
    case cmp x y of
	GT -> qpart cmp x ys (y:rlt) rge r
        _  -> qpart cmp x ys rlt (y:rge) r

-- rqsort is as qsort but anti-stable, i.e. reverses equal elements
rqsort :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
rqsort _   []     r = r
rqsort _   [x]    r = x:r
rqsort cmp (x:xs) r = rqpart cmp x xs [] [] r

rqpart :: (a -> a -> Ordering) -> a -> [a] -> [a] -> [a] -> [a] -> [a]
rqpart cmp x [] rle rgt r =
    qsort cmp rle (x:qsort cmp rgt r)
rqpart cmp x (y:ys) rle rgt r =
    case cmp y x of
	GT -> rqpart cmp x ys rle (y:rgt) r
    	_  -> rqpart cmp x ys (y:rle) rgt r
-}



-- | The 'unfoldr' function is a \`dual\' to 'foldr': while 'foldr'
-- reduces a list to a summary value, 'unfoldr' builds a list from
-- a seed value.  The function takes the element and returns 'Nothing'
-- if it is done producing the list or returns 'Just' @(a,b)@, in which
-- case, @a@ is a prepended to the list and @b@ is used as the next
-- element in a recursive call.  For example,
--
-- > iterate f == unfoldr (\x -> Just (x, f x))
--
-- In some cases, 'unfoldr' can undo a 'foldr' operation:
--
-- > unfoldr f' (foldr f z xs) == xs
--
-- if the following holds:
--
-- > f' (f x y) = Just (x,y)
-- > f' z       = Nothing

unfoldr      :: (b -> Maybe (a, b)) -> b -> [a]
unfoldr f b  =
  case f b of
   Just (a,new_b) -> a : unfoldr f new_b
   Nothing        -> []

-- -----------------------------------------------------------------------------

-- | A strict version of 'foldl'.
foldl'           :: (a -> b -> a) -> a -> [b] -> a
foldl' f a []     = a
foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs









-- | A strict version of 'foldl1'
foldl1'                  :: (a -> a -> a) -> [a] -> a
foldl1' f (x:xs)         =  foldl' f x xs
foldl1' _ []             =  errorEmptyList "foldl1'"












































































errorEmptyList :: String -> a
errorEmptyList fun =
  error ("Prelude." ++ fun ++ ": empty list")


{-# OPTIONS_GHC -fno-bang-patterns #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Map
-- Copyright   :  (c) Daan Leijen 2002
-- License     :  BSD-style
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- An efficient implementation of maps from keys to values (dictionaries).
--
-- Since many function names (but not the type name) clash with
-- "Prelude" names, this module is usually imported @qualified@, e.g.
--
-- >  import Data.Map (Map)
-- >  import qualified Data.Map as Map
--
-- The implementation of 'Map' is based on /size balanced/ binary trees (or
-- trees of /bounded balance/) as described by:
--
--    * Stephen Adams, \"/Efficient sets: a balancing act/\",
--	Journal of Functional Programming 3(4):553-562, October 1993,
--	<http://www.swiss.ai.mit.edu/~adams/BB>.
--
--    * J. Nievergelt and E.M. Reingold,
--	\"/Binary search trees of bounded balance/\",
--	SIAM journal of computing 2(1), March 1973.
--
-- Note that the implementation is /left-biased/ -- the elements of a
-- first argument are always preferred to the second, for example in
-- 'union' or 'insert'.
-----------------------------------------------------------------------------

module Data.Map  ( 
            -- * Map type
              Map          -- instance Eq,Show,Read

            -- * Operators
            , (!), (\\)


            -- * Query
            , null
            , size
            , member
            , notMember
            , lookup
            , findWithDefault
            
            -- * Construction
            , empty
            , singleton

            -- ** Insertion
            , insert
            , insertWith, insertWithKey, insertLookupWithKey
            , insertWith', insertWithKey'
            
            -- ** Delete\/Update
            , delete
            , adjust
            , adjustWithKey
            , update
            , updateWithKey
            , updateLookupWithKey
            , alter

            -- * Combine

            -- ** Union
            , union         
            , unionWith          
            , unionWithKey
            , unions
	    , unionsWith

            -- ** Difference
            , difference
            , differenceWith
            , differenceWithKey
            
            -- ** Intersection
            , intersection           
            , intersectionWith
            , intersectionWithKey

            -- * Traversal
            -- ** Map
            , map
            , mapWithKey
            , mapAccum
            , mapAccumWithKey
	    , mapKeys
	    , mapKeysWith
	    , mapKeysMonotonic

            -- ** Fold
            , fold
            , foldWithKey

            -- * Conversion
            , elems
            , keys
	    , keysSet
            , assocs
            
            -- ** Lists
            , toList
            , fromList
            , fromListWith
            , fromListWithKey

            -- ** Ordered lists
            , toAscList
            , fromAscList
            , fromAscListWith
            , fromAscListWithKey
            , fromDistinctAscList

            -- * Filter 
            , filter
            , filterWithKey
            , partition
            , partitionWithKey

            , mapMaybe
            , mapMaybeWithKey
            , mapEither
            , mapEitherWithKey

            , split         
            , splitLookup   

            -- * Submap
            , isSubmapOf, isSubmapOfBy
            , isProperSubmapOf, isProperSubmapOfBy

            -- * Indexed 
            , lookupIndex
            , findIndex
            , elemAt
            , updateAt
            , deleteAt

            -- * Min\/Max
            , findMin
            , findMax
            , deleteMin
            , deleteMax
            , deleteFindMin
            , deleteFindMax
            , updateMin
            , updateMax
            , updateMinWithKey
            , updateMaxWithKey
            , minView
            , maxView
            
            -- * Debugging
            , showTree
            , showTreeWith
            , valid
            ) where

import Prelude hiding (lookup,map,filter,foldr,foldl,null)
import qualified Data.Set as Set
import qualified Data.List as List
import Data.Monoid (Monoid(..))
import Data.Typeable
import Control.Applicative (Applicative(..), (<$>))
import Data.Traversable (Traversable(traverse))
import Data.Foldable (Foldable(foldMap))

{-
-- for quick check
import qualified Prelude
import qualified List
import Debug.QuickCheck       
import List(nub,sort)    
-}







{--------------------------------------------------------------------
  Operators
--------------------------------------------------------------------}
infixl 9 !,\\ --

-- | /O(log n)/. Find the value at a key.
-- Calls 'error' when the element can not be found.
(!) :: Ord k => Map k a -> k -> a
m ! k    = find k m

-- | /O(n+m)/. See 'difference'.
(\\) :: Ord k => Map k a -> Map k b -> Map k a
m1 \\ m2 = difference m1 m2

{--------------------------------------------------------------------
  Size balanced trees.
--------------------------------------------------------------------}
-- | A Map from keys @k@ to values @a@. 
data Map k a  = Tip 
              | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a) 

type Size     = Int

instance (Ord k) => Monoid (Map k v) where
    mempty  = empty
    mappend = union
    mconcat = unions



















{--------------------------------------------------------------------
  Query
--------------------------------------------------------------------}
-- | /O(1)/. Is the map empty?
null :: Map k a -> Bool
null t
  = case t of
      Tip             -> True
      Bin sz k x l r  -> False

-- | /O(1)/. The number of elements in the map.
size :: Map k a -> Int
size t
  = case t of
      Tip             -> 0
      Bin sz k x l r  -> sz


-- | /O(log n)/. Lookup the value at a key in the map. 
--
-- The function will 
-- @return@ the result in the monad or @fail@ in it the key isn't in the 
-- map. Often, the monad to use is 'Maybe', so you get either 
-- @('Just' result)@ or @'Nothing'@.
lookup :: (Monad m,Ord k) => k -> Map k a -> m a
lookup k t = case lookup' k t of
    Just x -> return x
    Nothing -> fail "Data.Map.lookup: Key not found"
lookup' :: Ord k => k -> Map k a -> Maybe a
lookup' k t
  = case t of
      Tip -> Nothing
      Bin sz kx x l r
          -> case compare k kx of
               LT -> lookup' k l
               GT -> lookup' k r
               EQ -> Just x       

lookupAssoc :: Ord k => k -> Map k a -> Maybe (k,a)
lookupAssoc  k t
  = case t of
      Tip -> Nothing
      Bin sz kx x l r
          -> case compare k kx of
               LT -> lookupAssoc k l
               GT -> lookupAssoc k r
               EQ -> Just (kx,x)

-- | /O(log n)/. Is the key a member of the map?
member :: Ord k => k -> Map k a -> Bool
member k m
  = case lookup k m of
      Nothing -> False
      Just x  -> True

-- | /O(log n)/. Is the key not a member of the map?
notMember :: Ord k => k -> Map k a -> Bool
notMember k m = not $ member k m

-- | /O(log n)/. Find the value at a key.
-- Calls 'error' when the element can not be found.
find :: Ord k => k -> Map k a -> a
find k m
  = case lookup k m of
      Nothing -> error "Map.find: element not in the map"
      Just x  -> x

-- | /O(log n)/. The expression @('findWithDefault' def k map)@ returns
-- the value at key @k@ or returns @def@ when the key is not in the map.
findWithDefault :: Ord k => a -> k -> Map k a -> a
findWithDefault def k m
  = case lookup k m of
      Nothing -> def
      Just x  -> x



{--------------------------------------------------------------------
  Construction
--------------------------------------------------------------------}
-- | /O(1)/. The empty map.
empty :: Map k a
empty 
  = Tip

-- | /O(1)/. A map with a single element.
singleton :: k -> a -> Map k a
singleton k x  
  = Bin 1 k x Tip Tip

{--------------------------------------------------------------------
  Insertion
--------------------------------------------------------------------}
-- | /O(log n)/. Insert a new key and value in the map.
-- If the key is already present in the map, the associated value is
-- replaced with the supplied value, i.e. 'insert' is equivalent to
-- @'insertWith' 'const'@.
insert :: Ord k => k -> a -> Map k a -> Map k a
insert kx x t
  = case t of
      Tip -> singleton kx x
      Bin sz ky y l r
          -> case compare kx ky of
               LT -> balance ky y (insert kx x l) r
               GT -> balance ky y l (insert kx x r)
               EQ -> Bin sz kx x l r

-- | /O(log n)/. Insert with a combining function.
-- @'insertWith' f key value mp@ 
-- will insert the pair (key, value) into @mp@ if key does
-- not exist in the map. If the key does exist, the function will
-- insert the pair @(key, f new_value old_value)@.
insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
insertWith f k x m          
  = insertWithKey (\k x y -> f x y) k x m

-- | Same as 'insertWith', but the combining function is applied strictly.
insertWith' :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
insertWith' f k x m          
  = insertWithKey' (\k x y -> f x y) k x m


-- | /O(log n)/. Insert with a combining function.
-- @'insertWithKey' f key value mp@ 
-- will insert the pair (key, value) into @mp@ if key does
-- not exist in the map. If the key does exist, the function will
-- insert the pair @(key,f key new_value old_value)@.
-- Note that the key passed to f is the same key passed to 'insertWithKey'.
insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
insertWithKey f kx x t
  = case t of
      Tip -> singleton kx x
      Bin sy ky y l r
          -> case compare kx ky of
               LT -> balance ky y (insertWithKey f kx x l) r
               GT -> balance ky y l (insertWithKey f kx x r)
               EQ -> Bin sy kx (f kx x y) l r

-- | Same as 'insertWithKey', but the combining function is applied strictly.
insertWithKey' :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
insertWithKey' f kx x t
  = case t of
      Tip -> singleton kx x
      Bin sy ky y l r
          -> case compare kx ky of
               LT -> balance ky y (insertWithKey' f kx x l) r
               GT -> balance ky y l (insertWithKey' f kx x r)
               EQ -> let x' = f kx x y in seq x' (Bin sy kx x' l r)


-- | /O(log n)/. The expression (@'insertLookupWithKey' f k x map@)
-- is a pair where the first element is equal to (@'lookup' k map@)
-- and the second element equal to (@'insertWithKey' f k x map@).
insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a,Map k a)
insertLookupWithKey f kx x t
  = case t of
      Tip -> (Nothing, singleton kx x)
      Bin sy ky y l r
          -> case compare kx ky of
               LT -> let (found,l') = insertLookupWithKey f kx x l in (found,balance ky y l' r)
               GT -> let (found,r') = insertLookupWithKey f kx x r in (found,balance ky y l r')
               EQ -> (Just y, Bin sy kx (f kx x y) l r)

{--------------------------------------------------------------------
  Deletion
  [delete] is the inlined version of [deleteWith (\k x -> Nothing)]
--------------------------------------------------------------------}
-- | /O(log n)/. Delete a key and its value from the map. When the key is not
-- a member of the map, the original map is returned.
delete :: Ord k => k -> Map k a -> Map k a
delete k t
  = case t of
      Tip -> Tip
      Bin sx kx x l r 
          -> case compare k kx of
               LT -> balance kx x (delete k l) r
               GT -> balance kx x l (delete k r)
               EQ -> glue l r

-- | /O(log n)/. Adjust a value at a specific key. When the key is not
-- a member of the map, the original map is returned.
adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
adjust f k m
  = adjustWithKey (\k x -> f x) k m

-- | /O(log n)/. Adjust a value at a specific key. When the key is not
-- a member of the map, the original map is returned.
adjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
adjustWithKey f k m
  = updateWithKey (\k x -> Just (f k x)) k m

-- | /O(log n)/. The expression (@'update' f k map@) updates the value @x@
-- at @k@ (if it is in the map). If (@f x@) is 'Nothing', the element is
-- deleted. If it is (@'Just' y@), the key @k@ is bound to the new value @y@.
update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
update f k m
  = updateWithKey (\k x -> f x) k m

-- | /O(log n)/. The expression (@'updateWithKey' f k map@) updates the
-- value @x@ at @k@ (if it is in the map). If (@f k x@) is 'Nothing',
-- the element is deleted. If it is (@'Just' y@), the key @k@ is bound
-- to the new value @y@.
updateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a
updateWithKey f k t
  = case t of
      Tip -> Tip
      Bin sx kx x l r 
          -> case compare k kx of
               LT -> balance kx x (updateWithKey f k l) r
               GT -> balance kx x l (updateWithKey f k r)
               EQ -> case f kx x of
                       Just x' -> Bin sx kx x' l r
                       Nothing -> glue l r

-- | /O(log n)/. Lookup and update.
updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a,Map k a)
updateLookupWithKey f k t
  = case t of
      Tip -> (Nothing,Tip)
      Bin sx kx x l r 
          -> case compare k kx of
               LT -> let (found,l') = updateLookupWithKey f k l in (found,balance kx x l' r)
               GT -> let (found,r') = updateLookupWithKey f k r in (found,balance kx x l r') 
               EQ -> case f kx x of
                       Just x' -> (Just x',Bin sx kx x' l r)
                       Nothing -> (Just x,glue l r)

-- | /O(log n)/. The expression (@'alter' f k map@) alters the value @x@ at @k@, or absence thereof.
-- 'alter' can be used to insert, delete, or update a value in a 'Map'.
-- In short : @'lookup' k ('alter' f k m) = f ('lookup' k m)@
alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
alter f k t
  = case t of
      Tip -> case f Nothing of
               Nothing -> Tip
               Just x -> singleton k x
      Bin sx kx x l r 
          -> case compare k kx of
               LT -> balance kx x (alter f k l) r
               GT -> balance kx x l (alter f k r)
               EQ -> case f (Just x) of
                       Just x' -> Bin sx kx x' l r
                       Nothing -> glue l r

{--------------------------------------------------------------------
  Indexing
--------------------------------------------------------------------}
-- | /O(log n)/. Return the /index/ of a key. The index is a number from
-- /0/ up to, but not including, the 'size' of the map. Calls 'error' when
-- the key is not a 'member' of the map.
findIndex :: Ord k => k -> Map k a -> Int
findIndex k t
  = case lookupIndex k t of
      Nothing  -> error "Map.findIndex: element is not in the map"
      Just idx -> idx

-- | /O(log n)/. Lookup the /index/ of a key. The index is a number from
-- /0/ up to, but not including, the 'size' of the map. 
lookupIndex :: (Monad m,Ord k) => k -> Map k a -> m Int
lookupIndex k t = case lookup 0 t of
    Nothing -> fail "Data.Map.lookupIndex: Key not found."
    Just x -> return x
  where
    lookup idx Tip  = Nothing
    lookup idx (Bin _ kx x l r)
      = case compare k kx of
          LT -> lookup idx l
          GT -> lookup (idx + size l + 1) r 
          EQ -> Just (idx + size l)

-- | /O(log n)/. Retrieve an element by /index/. Calls 'error' when an
-- invalid index is used.
elemAt :: Int -> Map k a -> (k,a)
elemAt i Tip = error "Map.elemAt: index out of range"
elemAt i (Bin _ kx x l r)
  = case compare i sizeL of
      LT -> elemAt i l
      GT -> elemAt (i-sizeL-1) r
      EQ -> (kx,x)
  where
    sizeL = size l

-- | /O(log n)/. Update the element at /index/. Calls 'error' when an
-- invalid index is used.
updateAt :: (k -> a -> Maybe a) -> Int -> Map k a -> Map k a
updateAt f i Tip  = error "Map.updateAt: index out of range"
updateAt f i (Bin sx kx x l r)
  = case compare i sizeL of
      LT -> updateAt f i l
      GT -> updateAt f (i-sizeL-1) r
      EQ -> case f kx x of
              Just x' -> Bin sx kx x' l r
              Nothing -> glue l r
  where
    sizeL = size l

-- | /O(log n)/. Delete the element at /index/.
-- Defined as (@'deleteAt' i map = 'updateAt' (\k x -> 'Nothing') i map@).
deleteAt :: Int -> Map k a -> Map k a
deleteAt i map
  = updateAt (\k x -> Nothing) i map


{--------------------------------------------------------------------
  Minimal, Maximal
--------------------------------------------------------------------}
-- | /O(log n)/. The minimal key of the map.
findMin :: Map k a -> (k,a)
findMin (Bin _ kx x Tip r)  = (kx,x)
findMin (Bin _ kx x l r)    = findMin l
findMin Tip                 = error "Map.findMin: empty map has no minimal element"

-- | /O(log n)/. The maximal key of the map.
findMax :: Map k a -> (k,a)
findMax (Bin _ kx x l Tip)  = (kx,x)
findMax (Bin _ kx x l r)    = findMax r
findMax Tip                 = error "Map.findMax: empty map has no maximal element"

-- | /O(log n)/. Delete the minimal key.
deleteMin :: Map k a -> Map k a
deleteMin (Bin _ kx x Tip r)  = r
deleteMin (Bin _ kx x l r)    = balance kx x (deleteMin l) r
deleteMin Tip                 = Tip

-- | /O(log n)/. Delete the maximal key.
deleteMax :: Map k a -> Map k a
deleteMax (Bin _ kx x l Tip)  = l
deleteMax (Bin _ kx x l r)    = balance kx x l (deleteMax r)
deleteMax Tip                 = Tip

-- | /O(log n)/. Update the value at the minimal key.
updateMin :: (a -> Maybe a) -> Map k a -> Map k a
updateMin f m
  = updateMinWithKey (\k x -> f x) m

-- | /O(log n)/. Update the value at the maximal key.
updateMax :: (a -> Maybe a) -> Map k a -> Map k a
updateMax f m
  = updateMaxWithKey (\k x -> f x) m


-- | /O(log n)/. Update the value at the minimal key.
updateMinWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
updateMinWithKey f t
  = case t of
      Bin sx kx x Tip r  -> case f kx x of
                              Nothing -> r
                              Just x' -> Bin sx kx x' Tip r
      Bin sx kx x l r    -> balance kx x (updateMinWithKey f l) r
      Tip                -> Tip

-- | /O(log n)/. Update the value at the maximal key.
updateMaxWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
updateMaxWithKey f t
  = case t of
      Bin sx kx x l Tip  -> case f kx x of
                              Nothing -> l
                              Just x' -> Bin sx kx x' l Tip
      Bin sx kx x l r    -> balance kx x l (updateMaxWithKey f r)
      Tip                -> Tip

-- | /O(log n)/. Retrieves the minimal key of the map, and the map stripped from that element
-- @fail@s (in the monad) when passed an empty map.
minView :: Monad m => Map k a -> m (Map k a, (k,a))
minView Tip = fail "Map.minView: empty map"
minView x = return (swap $ deleteFindMin x)

-- | /O(log n)/. Retrieves the maximal key of the map, and the map stripped from that element
-- @fail@s (in the monad) when passed an empty map.
maxView :: Monad m => Map k a -> m (Map k a, (k,a))
maxView Tip = fail "Map.maxView: empty map"
maxView x = return (swap $ deleteFindMax x)

swap (a,b) = (b,a)

{--------------------------------------------------------------------
  Union. 
--------------------------------------------------------------------}
-- | The union of a list of maps:
--   (@'unions' == 'Prelude.foldl' 'union' 'empty'@).
unions :: Ord k => [Map k a] -> Map k a
unions ts
  = foldlStrict union empty ts

-- | The union of a list of maps, with a combining operation:
--   (@'unionsWith' f == 'Prelude.foldl' ('unionWith' f) 'empty'@).
unionsWith :: Ord k => (a->a->a) -> [Map k a] -> Map k a
unionsWith f ts
  = foldlStrict (unionWith f) empty ts

-- | /O(n+m)/.
-- The expression (@'union' t1 t2@) takes the left-biased union of @t1@ and @t2@. 
-- It prefers @t1@ when duplicate keys are encountered,
-- i.e. (@'union' == 'unionWith' 'const'@).
-- The implementation uses the efficient /hedge-union/ algorithm.
-- Hedge-union is more efficient on (bigset `union` smallset)
union :: Ord k => Map k a -> Map k a -> Map k a
union Tip t2  = t2
union t1 Tip  = t1
union t1 t2 = hedgeUnionL (const LT) (const GT) t1 t2

-- left-biased hedge union
hedgeUnionL cmplo cmphi t1 Tip 
  = t1
hedgeUnionL cmplo cmphi Tip (Bin _ kx x l r)
  = join kx x (filterGt cmplo l) (filterLt cmphi r)
hedgeUnionL cmplo cmphi (Bin _ kx x l r) t2
  = join kx x (hedgeUnionL cmplo cmpkx l (trim cmplo cmpkx t2)) 
              (hedgeUnionL cmpkx cmphi r (trim cmpkx cmphi t2))
  where
    cmpkx k  = compare kx k

-- right-biased hedge union
hedgeUnionR cmplo cmphi t1 Tip 
  = t1
hedgeUnionR cmplo cmphi Tip (Bin _ kx x l r)
  = join kx x (filterGt cmplo l) (filterLt cmphi r)
hedgeUnionR cmplo cmphi (Bin _ kx x l r) t2
  = join kx newx (hedgeUnionR cmplo cmpkx l lt) 
                 (hedgeUnionR cmpkx cmphi r gt)
  where
    cmpkx k     = compare kx k
    lt          = trim cmplo cmpkx t2
    (found,gt)  = trimLookupLo kx cmphi t2
    newx        = case found of
                    Nothing -> x
                    Just (_,y) -> y

{--------------------------------------------------------------------
  Union with a combining function
--------------------------------------------------------------------}
-- | /O(n+m)/. Union with a combining function. The implementation uses the efficient /hedge-union/ algorithm.
unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
unionWith f m1 m2
  = unionWithKey (\k x y -> f x y) m1 m2

-- | /O(n+m)/.
-- Union with a combining function. The implementation uses the efficient /hedge-union/ algorithm.
-- Hedge-union is more efficient on (bigset `union` smallset).
unionWithKey :: Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a
unionWithKey f Tip t2  = t2
unionWithKey f t1 Tip  = t1
unionWithKey f t1 t2 = hedgeUnionWithKey f (const LT) (const GT) t1 t2

hedgeUnionWithKey f cmplo cmphi t1 Tip 
  = t1
hedgeUnionWithKey f cmplo cmphi Tip (Bin _ kx x l r)
  = join kx x (filterGt cmplo l) (filterLt cmphi r)
hedgeUnionWithKey f cmplo cmphi (Bin _ kx x l r) t2
  = join kx newx (hedgeUnionWithKey f cmplo cmpkx l lt) 
                 (hedgeUnionWithKey f cmpkx cmphi r gt)
  where
    cmpkx k     = compare kx k
    lt          = trim cmplo cmpkx t2
    (found,gt)  = trimLookupLo kx cmphi t2
    newx        = case found of
                    Nothing -> x
                    Just (_,y) -> f kx x y

{--------------------------------------------------------------------
  Difference
--------------------------------------------------------------------}
-- | /O(n+m)/. Difference of two maps. 
-- The implementation uses an efficient /hedge/ algorithm comparable with /hedge-union/.
difference :: Ord k => Map k a -> Map k b -> Map k a
difference Tip t2  = Tip
difference t1 Tip  = t1
difference t1 t2   = hedgeDiff (const LT) (const GT) t1 t2

hedgeDiff cmplo cmphi Tip t     
  = Tip
hedgeDiff cmplo cmphi (Bin _ kx x l r) Tip 
  = join kx x (filterGt cmplo l) (filterLt cmphi r)
hedgeDiff cmplo cmphi t (Bin _ kx x l r) 
  = merge (hedgeDiff cmplo cmpkx (trim cmplo cmpkx t) l) 
          (hedgeDiff cmpkx cmphi (trim cmpkx cmphi t) r)
  where
    cmpkx k = compare kx k   

-- | /O(n+m)/. Difference with a combining function. 
-- The implementation uses an efficient /hedge/ algorithm comparable with /hedge-union/.
differenceWith :: Ord k => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
differenceWith f m1 m2
  = differenceWithKey (\k x y -> f x y) m1 m2

-- | /O(n+m)/. Difference with a combining function. When two equal keys are
-- encountered, the combining function is applied to the key and both values.
-- If it returns 'Nothing', the element is discarded (proper set difference). If
-- it returns (@'Just' y@), the element is updated with a new value @y@. 
-- The implementation uses an efficient /hedge/ algorithm comparable with /hedge-union/.
differenceWithKey :: Ord k => (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
differenceWithKey f Tip t2  = Tip
differenceWithKey f t1 Tip  = t1
differenceWithKey f t1 t2   = hedgeDiffWithKey f (const LT) (const GT) t1 t2

hedgeDiffWithKey f cmplo cmphi Tip t     
  = Tip
hedgeDiffWithKey f cmplo cmphi (Bin _ kx x l r) Tip 
  = join kx x (filterGt cmplo l) (filterLt cmphi r)
hedgeDiffWithKey f cmplo cmphi t (Bin _ kx x l r) 
  = case found of
      Nothing -> merge tl tr
      Just (ky,y) -> 
          case f ky y x of
            Nothing -> merge tl tr
            Just z  -> join ky z tl tr
  where
    cmpkx k     = compare kx k   
    lt          = trim cmplo cmpkx t
    (found,gt)  = trimLookupLo kx cmphi t
    tl          = hedgeDiffWithKey f cmplo cmpkx lt l
    tr          = hedgeDiffWithKey f cmpkx cmphi gt r



{--------------------------------------------------------------------
  Intersection
--------------------------------------------------------------------}
-- | /O(n+m)/. Intersection of two maps. The values in the first
-- map are returned, i.e. (@'intersection' m1 m2 == 'intersectionWith' 'const' m1 m2@).
intersection :: Ord k => Map k a -> Map k b -> Map k a
intersection m1 m2
  = intersectionWithKey (\k x y -> x) m1 m2

-- | /O(n+m)/. Intersection with a combining function.
intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
intersectionWith f m1 m2
  = intersectionWithKey (\k x y -> f x y) m1 m2

-- | /O(n+m)/. Intersection with a combining function.
-- Intersection is more efficient on (bigset `intersection` smallset)
--intersectionWithKey :: Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c
--intersectionWithKey f Tip t = Tip
--intersectionWithKey f t Tip = Tip
--intersectionWithKey f t1 t2 = intersectWithKey f t1 t2
--
--intersectWithKey f Tip t = Tip
--intersectWithKey f t Tip = Tip
--intersectWithKey f t (Bin _ kx x l r)
--  = case found of
--      Nothing -> merge tl tr
--      Just y  -> join kx (f kx y x) tl tr
--  where
--    (lt,found,gt) = splitLookup kx t
--    tl            = intersectWithKey f lt l
--    tr            = intersectWithKey f gt r


intersectionWithKey :: Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c
intersectionWithKey f Tip t = Tip
intersectionWithKey f t Tip = Tip
intersectionWithKey f t1@(Bin s1 k1 x1 l1 r1) t2@(Bin s2 k2 x2 l2 r2) =
   if s1 >= s2 then
      let (lt,found,gt) = splitLookupWithKey k2 t1
          tl            = intersectionWithKey f lt l2
          tr            = intersectionWithKey f gt r2
      in case found of
      Just (k,x) -> join k (f k x x2) tl tr
      Nothing -> merge tl tr
   else let (lt,found,gt) = splitLookup k1 t2
            tl            = intersectionWithKey f l1 lt
            tr            = intersectionWithKey f r1 gt
      in case found of
      Just x -> join k1 (f k1 x1 x) tl tr
      Nothing -> merge tl tr



{--------------------------------------------------------------------
  Submap
--------------------------------------------------------------------}
-- | /O(n+m)/. 
-- This function is defined as (@'isSubmapOf' = 'isSubmapOfBy' (==)@).
isSubmapOf :: (Ord k,Eq a) => Map k a -> Map k a -> Bool
isSubmapOf m1 m2
  = isSubmapOfBy (==) m1 m2

{- | /O(n+m)/. 
 The expression (@'isSubmapOfBy' f t1 t2@) returns 'True' if
 all keys in @t1@ are in tree @t2@, and when @f@ returns 'True' when
 applied to their respective values. For example, the following 
 expressions are all 'True':
 
 > isSubmapOfBy (==) (fromList [('a',1)]) (fromList [('a',1),('b',2)])
 > isSubmapOfBy (<=) (fromList [('a',1)]) (fromList [('a',1),('b',2)])
 > isSubmapOfBy (==) (fromList [('a',1),('b',2)]) (fromList [('a',1),('b',2)])

 But the following are all 'False':
 
 > isSubmapOfBy (==) (fromList [('a',2)]) (fromList [('a',1),('b',2)])
 > isSubmapOfBy (<)  (fromList [('a',1)]) (fromList [('a',1),('b',2)])
 > isSubmapOfBy (==) (fromList [('a',1),('b',2)]) (fromList [('a',1)])
-}
isSubmapOfBy :: Ord k => (a->b->Bool) -> Map k a -> Map k b -> Bool
isSubmapOfBy f t1 t2
  = (size t1 <= size t2) && (submap' f t1 t2)

submap' f Tip t = True
submap' f t Tip = False
submap' f (Bin _ kx x l r) t
  = case found of
      Nothing -> False
      Just y  -> f x y && submap' f l lt && submap' f r gt
  where
    (lt,found,gt) = splitLookup kx t

-- | /O(n+m)/. Is this a proper submap? (ie. a submap but not equal). 
-- Defined as (@'isProperSubmapOf' = 'isProperSubmapOfBy' (==)@).
isProperSubmapOf :: (Ord k,Eq a) => Map k a -> Map k a -> Bool
isProperSubmapOf m1 m2
  = isProperSubmapOfBy (==) m1 m2

{- | /O(n+m)/. Is this a proper submap? (ie. a submap but not equal).
 The expression (@'isProperSubmapOfBy' f m1 m2@) returns 'True' when
 @m1@ and @m2@ are not equal,
 all keys in @m1@ are in @m2@, and when @f@ returns 'True' when
 applied to their respective values. For example, the following 
 expressions are all 'True':
 
  > isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
  > isProperSubmapOfBy (<=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])

 But the following are all 'False':
 
  > isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
  > isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
  > isProperSubmapOfBy (<)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])
-}
isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
isProperSubmapOfBy f t1 t2
  = (size t1 < size t2) && (submap' f t1 t2)

{--------------------------------------------------------------------
  Filter and partition
--------------------------------------------------------------------}
-- | /O(n)/. Filter all values that satisfy the predicate.
filter :: Ord k => (a -> Bool) -> Map k a -> Map k a
filter p m
  = filterWithKey (\k x -> p x) m

-- | /O(n)/. Filter all keys\/values that satisfy the predicate.
filterWithKey :: Ord k => (k -> a -> Bool) -> Map k a -> Map k a
filterWithKey p Tip = Tip
filterWithKey p (Bin _ kx x l r)
  | p kx x    = join kx x (filterWithKey p l) (filterWithKey p r)
  | otherwise = merge (filterWithKey p l) (filterWithKey p r)


-- | /O(n)/. partition the map according to a predicate. The first
-- map contains all elements that satisfy the predicate, the second all
-- elements that fail the predicate. See also 'split'.
partition :: Ord k => (a -> Bool) -> Map k a -> (Map k a,Map k a)
partition p m
  = partitionWithKey (\k x -> p x) m

-- | /O(n)/. partition the map according to a predicate. The first
-- map contains all elements that satisfy the predicate, the second all
-- elements that fail the predicate. See also 'split'.
partitionWithKey :: Ord k => (k -> a -> Bool) -> Map k a -> (Map k a,Map k a)
partitionWithKey p Tip = (Tip,Tip)
partitionWithKey p (Bin _ kx x l r)
  | p kx x    = (join kx x l1 r1,merge l2 r2)
  | otherwise = (merge l1 r1,join kx x l2 r2)
  where
    (l1,l2) = partitionWithKey p l
    (r1,r2) = partitionWithKey p r

-- | /O(n)/. Map values and collect the 'Just' results.
mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
mapMaybe f m
  = mapMaybeWithKey (\k x -> f x) m

-- | /O(n)/. Map keys\/values and collect the 'Just' results.
mapMaybeWithKey :: Ord k => (k -> a -> Maybe b) -> Map k a -> Map k b
mapMaybeWithKey f Tip = Tip
mapMaybeWithKey f (Bin _ kx x l r) = case f kx x of
  Just y  -> join kx y (mapMaybeWithKey f l) (mapMaybeWithKey f r)
  Nothing -> merge (mapMaybeWithKey f l) (mapMaybeWithKey f r)

-- | /O(n)/. Map values and separate the 'Left' and 'Right' results.
mapEither :: Ord k => (a -> Either b c) -> Map k a -> (Map k b, Map k c)
mapEither f m
  = mapEitherWithKey (\k x -> f x) m

-- | /O(n)/. Map keys\/values and separate the 'Left' and 'Right' results.
mapEitherWithKey :: Ord k =>
  (k -> a -> Either b c) -> Map k a -> (Map k b, Map k c)
mapEitherWithKey f Tip = (Tip, Tip)
mapEitherWithKey f (Bin _ kx x l r) = case f kx x of
  Left y  -> (join kx y l1 r1, merge l2 r2)
  Right z -> (merge l1 r1, join kx z l2 r2)
  where
    (l1,l2) = mapEitherWithKey f l
    (r1,r2) = mapEitherWithKey f r

{--------------------------------------------------------------------
  Mapping
--------------------------------------------------------------------}
-- | /O(n)/. Map a function over all values in the map.
map :: (a -> b) -> Map k a -> Map k b
map f m
  = mapWithKey (\k x -> f x) m

-- | /O(n)/. Map a function over all values in the map.
mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
mapWithKey f Tip = Tip
mapWithKey f (Bin sx kx x l r) 
  = Bin sx kx (f kx x) (mapWithKey f l) (mapWithKey f r)

-- | /O(n)/. The function 'mapAccum' threads an accumulating
-- argument through the map in ascending order of keys.
mapAccum :: (a -> b -> (a,c)) -> a -> Map k b -> (a,Map k c)
mapAccum f a m
  = mapAccumWithKey (\a k x -> f a x) a m

-- | /O(n)/. The function 'mapAccumWithKey' threads an accumulating
-- argument through the map in ascending order of keys.
mapAccumWithKey :: (a -> k -> b -> (a,c)) -> a -> Map k b -> (a,Map k c)
mapAccumWithKey f a t
  = mapAccumL f a t

-- | /O(n)/. The function 'mapAccumL' threads an accumulating
-- argument throught the map in ascending order of keys.
mapAccumL :: (a -> k -> b -> (a,c)) -> a -> Map k b -> (a,Map k c)
mapAccumL f a t
  = case t of
      Tip -> (a,Tip)
      Bin sx kx x l r
          -> let (a1,l') = mapAccumL f a l
                 (a2,x') = f a1 kx x
                 (a3,r') = mapAccumL f a2 r
             in (a3,Bin sx kx x' l' r')

-- | /O(n)/. The function 'mapAccumR' threads an accumulating
-- argument throught the map in descending order of keys.
mapAccumR :: (a -> k -> b -> (a,c)) -> a -> Map k b -> (a,Map k c)
mapAccumR f a t
  = case t of
      Tip -> (a,Tip)
      Bin sx kx x l r 
          -> let (a1,r') = mapAccumR f a r
                 (a2,x') = f a1 kx x
                 (a3,l') = mapAccumR f a2 l
             in (a3,Bin sx kx x' l' r')

-- | /O(n*log n)/. 
-- @'mapKeys' f s@ is the map obtained by applying @f@ to each key of @s@.
-- 
-- The size of the result may be smaller if @f@ maps two or more distinct
-- keys to the same new key.  In this case the value at the smallest of
-- these keys is retained.

mapKeys :: Ord k2 => (k1->k2) -> Map k1 a -> Map k2 a
mapKeys = mapKeysWith (\x y->x)

-- | /O(n*log n)/. 
-- @'mapKeysWith' c f s@ is the map obtained by applying @f@ to each key of @s@.
-- 
-- The size of the result may be smaller if @f@ maps two or more distinct
-- keys to the same new key.  In this case the associated values will be
-- combined using @c@.

mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1->k2) -> Map k1 a -> Map k2 a
mapKeysWith c f = fromListWith c . List.map fFirst . toList
    where fFirst (x,y) = (f x, y)


-- | /O(n)/.
-- @'mapKeysMonotonic' f s == 'mapKeys' f s@, but works only when @f@
-- is strictly monotonic.
-- /The precondition is not checked./
-- Semi-formally, we have:
-- 
-- > and [x < y ==> f x < f y | x <- ls, y <- ls] 
-- >                     ==> mapKeysMonotonic f s == mapKeys f s
-- >     where ls = keys s

mapKeysMonotonic :: (k1->k2) -> Map k1 a -> Map k2 a
mapKeysMonotonic f Tip = Tip
mapKeysMonotonic f (Bin sz k x l r) =
    Bin sz (f k) x (mapKeysMonotonic f l) (mapKeysMonotonic f r)

{--------------------------------------------------------------------
  Folds  
--------------------------------------------------------------------}

-- | /O(n)/. Fold the values in the map, such that
-- @'fold' f z == 'Prelude.foldr' f z . 'elems'@.
-- For example,
--
-- > elems map = fold (:) [] map
--
fold :: (a -> b -> b) -> b -> Map k a -> b
fold f z m
  = foldWithKey (\k x z -> f x z) z m

-- | /O(n)/. Fold the keys and values in the map, such that
-- @'foldWithKey' f z == 'Prelude.foldr' ('uncurry' f) z . 'toAscList'@.
-- For example,
--
-- > keys map = foldWithKey (\k x ks -> k:ks) [] map
--
foldWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b
foldWithKey f z t
  = foldr f z t

-- | /O(n)/. In-order fold.
foldi :: (k -> a -> b -> b -> b) -> b -> Map k a -> b 
foldi f z Tip               = z
foldi f z (Bin _ kx x l r)  = f kx x (foldi f z l) (foldi f z r)

-- | /O(n)/. Post-order fold.
foldr :: (k -> a -> b -> b) -> b -> Map k a -> b
foldr f z Tip              = z
foldr f z (Bin _ kx x l r) = foldr f (f kx x (foldr f z r)) l

-- | /O(n)/. Pre-order fold.
foldl :: (b -> k -> a -> b) -> b -> Map k a -> b
foldl f z Tip              = z
foldl f z (Bin _ kx x l r) = foldl f (f (foldl f z l) kx x) r

{--------------------------------------------------------------------
  List variations 
--------------------------------------------------------------------}
-- | /O(n)/.
-- Return all elements of the map in the ascending order of their keys.
elems :: Map k a -> [a]
elems m
  = [x | (k,x) <- assocs m]

-- | /O(n)/. Return all keys of the map in ascending order.
keys  :: Map k a -> [k]
keys m
  = [k | (k,x) <- assocs m]

-- | /O(n)/. The set of all keys of the map.
keysSet :: Map k a -> Set.Set k
keysSet m = Set.fromDistinctAscList (keys m)

-- | /O(n)/. Return all key\/value pairs in the map in ascending key order.
assocs :: Map k a -> [(k,a)]
assocs m
  = toList m

{--------------------------------------------------------------------
  Lists 
  use [foldlStrict] to reduce demand on the control-stack
--------------------------------------------------------------------}
-- | /O(n*log n)/. Build a map from a list of key\/value pairs. See also 'fromAscList'.
fromList :: Ord k => [(k,a)] -> Map k a 
fromList xs       
  = foldlStrict ins empty xs
  where
    ins t (k,x) = insert k x t

-- | /O(n*log n)/. Build a map from a list of key\/value pairs with a combining function. See also 'fromAscListWith'.
fromListWith :: Ord k => (a -> a -> a) -> [(k,a)] -> Map k a 
fromListWith f xs
  = fromListWithKey (\k x y -> f x y) xs

-- | /O(n*log n)/. Build a map from a list of key\/value pairs with a combining function. See also 'fromAscListWithKey'.
fromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k,a)] -> Map k a 
fromListWithKey f xs 
  = foldlStrict ins empty xs
  where
    ins t (k,x) = insertWithKey f k x t

-- | /O(n)/. Convert to a list of key\/value pairs.
toList :: Map k a -> [(k,a)]
toList t      = toAscList t

-- | /O(n)/. Convert to an ascending list.
toAscList :: Map k a -> [(k,a)]
toAscList t   = foldr (\k x xs -> (k,x):xs) [] t

-- | /O(n)/. 
toDescList :: Map k a -> [(k,a)]
toDescList t  = foldl (\xs k x -> (k,x):xs) [] t


{--------------------------------------------------------------------
  Building trees from ascending/descending lists can be done in linear time.
  
  Note that if [xs] is ascending that: 
    fromAscList xs       == fromList xs
    fromAscListWith f xs == fromListWith f xs
--------------------------------------------------------------------}
-- | /O(n)/. Build a map from an ascending list in linear time.
-- /The precondition (input list is ascending) is not checked./
fromAscList :: Eq k => [(k,a)] -> Map k a 
fromAscList xs
  = fromAscListWithKey (\k x y -> x) xs

-- | /O(n)/. Build a map from an ascending list in linear time with a combining function for equal keys.
-- /The precondition (input list is ascending) is not checked./
fromAscListWith :: Eq k => (a -> a -> a) -> [(k,a)] -> Map k a 
fromAscListWith f xs
  = fromAscListWithKey (\k x y -> f x y) xs

-- | /O(n)/. Build a map from an ascending list in linear time with a
-- combining function for equal keys.
-- /The precondition (input list is ascending) is not checked./
fromAscListWithKey :: Eq k => (k -> a -> a -> a) -> [(k,a)] -> Map k a 
fromAscListWithKey f xs
  = fromDistinctAscList (combineEq f xs)
  where
  -- [combineEq f xs] combines equal elements with function [f] in an ordered list [xs]
  combineEq f xs
    = case xs of
        []     -> []
        [x]    -> [x]
        (x:xx) -> combineEq' x xx

  combineEq' z [] = [z]
  combineEq' z@(kz,zz) (x@(kx,xx):xs)
    | kx==kz    = let yy = f kx xx zz in combineEq' (kx,yy) xs
    | otherwise = z:combineEq' x xs


-- | /O(n)/. Build a map from an ascending list of distinct elements in linear time.
-- /The precondition is not checked./
fromDistinctAscList :: [(k,a)] -> Map k a 
fromDistinctAscList xs
  = build const (length xs) xs
  where
    -- 1) use continutations so that we use heap space instead of stack space.
    -- 2) special case for n==5 to build bushier trees. 
    build c 0 xs   = c Tip xs 
    build c 5 xs   = case xs of
                       ((k1,x1):(k2,x2):(k3,x3):(k4,x4):(k5,x5):xx) 
                            -> c (bin k4 x4 (bin k2 x2 (singleton k1 x1) (singleton k3 x3)) (singleton k5 x5)) xx
    build c n xs   = seq nr $ build (buildR nr c) nl xs
                   where
                     nl = n `div` 2
                     nr = n - nl - 1

    buildR n c l ((k,x):ys) = build (buildB l k x c) n ys
    buildB l k x c r zs     = c (bin k x l r) zs
                      


{--------------------------------------------------------------------
  Utility functions that return sub-ranges of the original
  tree. Some functions take a comparison function as argument to
  allow comparisons against infinite values. A function [cmplo k]
  should be read as [compare lo k].

  [trim cmplo cmphi t]  A tree that is either empty or where [cmplo k == LT]
                        and [cmphi k == GT] for the key [k] of the root.
  [filterGt cmp t]      A tree where for all keys [k]. [cmp k == LT]
  [filterLt cmp t]      A tree where for all keys [k]. [cmp k == GT]

  [split k t]           Returns two trees [l] and [r] where all keys
                        in [l] are <[k] and all keys in [r] are >[k].
  [splitLookup k t]     Just like [split] but also returns whether [k]
                        was found in the tree.
--------------------------------------------------------------------}

{--------------------------------------------------------------------
  [trim lo hi t] trims away all subtrees that surely contain no
  values between the range [lo] to [hi]. The returned tree is either
  empty or the key of the root is between @lo@ and @hi@.
--------------------------------------------------------------------}
trim :: (k -> Ordering) -> (k -> Ordering) -> Map k a -> Map k a
trim cmplo cmphi Tip = Tip
trim cmplo cmphi t@(Bin sx kx x l r)
  = case cmplo kx of
      LT -> case cmphi kx of
              GT -> t
              le -> trim cmplo cmphi l
      ge -> trim cmplo cmphi r
              
trimLookupLo :: Ord k => k -> (k -> Ordering) -> Map k a -> (Maybe (k,a), Map k a)
trimLookupLo lo cmphi Tip = (Nothing,Tip)
trimLookupLo lo cmphi t@(Bin sx kx x l r)
  = case compare lo kx of
      LT -> case cmphi kx of
              GT -> (lookupAssoc lo t, t)
              le -> trimLookupLo lo cmphi l
      GT -> trimLookupLo lo cmphi r
      EQ -> (Just (kx,x),trim (compare lo) cmphi r)


{--------------------------------------------------------------------
  [filterGt k t] filter all keys >[k] from tree [t]
  [filterLt k t] filter all keys <[k] from tree [t]
--------------------------------------------------------------------}
filterGt :: Ord k => (k -> Ordering) -> Map k a -> Map k a
filterGt cmp Tip = Tip
filterGt cmp (Bin sx kx x l r)
  = case cmp kx of
      LT -> join kx x (filterGt cmp l) r
      GT -> filterGt cmp r
      EQ -> r
      
filterLt :: Ord k => (k -> Ordering) -> Map k a -> Map k a
filterLt cmp Tip = Tip
filterLt cmp (Bin sx kx x l r)
  = case cmp kx of
      LT -> filterLt cmp l
      GT -> join kx x l (filterLt cmp r)
      EQ -> l

{--------------------------------------------------------------------
  Split
--------------------------------------------------------------------}
-- | /O(log n)/. The expression (@'split' k map@) is a pair @(map1,map2)@ where
-- the keys in @map1@ are smaller than @k@ and the keys in @map2@ larger than @k@. Any key equal to @k@ is found in neither @map1@ nor @map2@.
split :: Ord k => k -> Map k a -> (Map k a,Map k a)
split k Tip = (Tip,Tip)
split k (Bin sx kx x l r)
  = case compare k kx of
      LT -> let (lt,gt) = split k l in (lt,join kx x gt r)
      GT -> let (lt,gt) = split k r in (join kx x l lt,gt)
      EQ -> (l,r)

-- | /O(log n)/. The expression (@'splitLookup' k map@) splits a map just
-- like 'split' but also returns @'lookup' k map@.
splitLookup :: Ord k => k -> Map k a -> (Map k a,Maybe a,Map k a)
splitLookup k Tip = (Tip,Nothing,Tip)
splitLookup k (Bin sx kx x l r)
  = case compare k kx of
      LT -> let (lt,z,gt) = splitLookup k l in (lt,z,join kx x gt r)
      GT -> let (lt,z,gt) = splitLookup k r in (join kx x l lt,z,gt)
      EQ -> (l,Just x,r)

-- | /O(log n)/.
splitLookupWithKey :: Ord k => k -> Map k a -> (Map k a,Maybe (k,a),Map k a)
splitLookupWithKey k Tip = (Tip,Nothing,Tip)
splitLookupWithKey k (Bin sx kx x l r)
  = case compare k kx of
      LT -> let (lt,z,gt) = splitLookupWithKey k l in (lt,z,join kx x gt r)
      GT -> let (lt,z,gt) = splitLookupWithKey k r in (join kx x l lt,z,gt)
      EQ -> (l,Just (kx, x),r)

-- | /O(log n)/. Performs a 'split' but also returns whether the pivot
-- element was found in the original set.
splitMember :: Ord k => k -> Map k a -> (Map k a,Bool,Map k a)
splitMember x t = let (l,m,r) = splitLookup x t in
     (l,maybe False (const True) m,r)


{--------------------------------------------------------------------
  Utility functions that maintain the balance properties of the tree.
  All constructors assume that all values in [l] < [k] and all values
  in [r] > [k], and that [l] and [r] are valid trees.
  
  In order of sophistication:
    [Bin sz k x l r]  The type constructor.
    [bin k x l r]     Maintains the correct size, assumes that both [l]
                      and [r] are balanced with respect to each other.
    [balance k x l r] Restores the balance and size.
                      Assumes that the original tree was balanced and
                      that [l] or [r] has changed by at most one element.
    [join k x l r]    Restores balance and size. 

  Furthermore, we can construct a new tree from two trees. Both operations
  assume that all values in [l] < all values in [r] and that [l] and [r]
  are valid:
    [glue l r]        Glues [l] and [r] together. Assumes that [l] and
                      [r] are already balanced with respect to each other.
    [merge l r]       Merges two trees and restores balance.

  Note: in contrast to Adam's paper, we use (<=) comparisons instead
  of (<) comparisons in [join], [merge] and [balance]. 
  Quickcheck (on [difference]) showed that this was necessary in order 
  to maintain the invariants. It is quite unsatisfactory that I haven't 
  been able to find out why this is actually the case! Fortunately, it 
  doesn't hurt to be a bit more conservative.
--------------------------------------------------------------------}

{--------------------------------------------------------------------
  Join 
--------------------------------------------------------------------}
join :: Ord k => k -> a -> Map k a -> Map k a -> Map k a
join kx x Tip r  = insertMin kx x r
join kx x l Tip  = insertMax kx x l
join kx x l@(Bin sizeL ky y ly ry) r@(Bin sizeR kz z lz rz)
  | delta*sizeL <= sizeR  = balance kz z (join kx x l lz) rz
  | delta*sizeR <= sizeL  = balance ky y ly (join kx x ry r)
  | otherwise             = bin kx x l r


-- insertMin and insertMax don't perform potentially expensive comparisons.
insertMax,insertMin :: k -> a -> Map k a -> Map k a 
insertMax kx x t
  = case t of
      Tip -> singleton kx x
      Bin sz ky y l r
          -> balance ky y l (insertMax kx x r)
             
insertMin kx x t
  = case t of
      Tip -> singleton kx x
      Bin sz ky y l r
          -> balance ky y (insertMin kx x l) r
             
{--------------------------------------------------------------------
  [merge l r]: merges two trees.
--------------------------------------------------------------------}
merge :: Map k a -> Map k a -> Map k a
merge Tip r   = r
merge l Tip   = l
merge l@(Bin sizeL kx x lx rx) r@(Bin sizeR ky y ly ry)
  | delta*sizeL <= sizeR = balance ky y (merge l ly) ry
  | delta*sizeR <= sizeL = balance kx x lx (merge rx r)
  | otherwise            = glue l r

{--------------------------------------------------------------------
  [glue l r]: glues two trees together.
  Assumes that [l] and [r] are already balanced with respect to each other.
--------------------------------------------------------------------}
glue :: Map k a -> Map k a -> Map k a
glue Tip r = r
glue l Tip = l
glue l r   
  | size l > size r = let ((km,m),l') = deleteFindMax l in balance km m l' r
  | otherwise       = let ((km,m),r') = deleteFindMin r in balance km m l r'


-- | /O(log n)/. Delete and find the minimal element.
deleteFindMin :: Map k a -> ((k,a),Map k a)
deleteFindMin t 
  = case t of
      Bin _ k x Tip r -> ((k,x),r)
      Bin _ k x l r   -> let (km,l') = deleteFindMin l in (km,balance k x l' r)
      Tip             -> (error "Map.deleteFindMin: can not return the minimal element of an empty map", Tip)

-- | /O(log n)/. Delete and find the maximal element.
deleteFindMax :: Map k a -> ((k,a),Map k a)
deleteFindMax t
  = case t of
      Bin _ k x l Tip -> ((k,x),l)
      Bin _ k x l r   -> let (km,r') = deleteFindMax r in (km,balance k x l r')
      Tip             -> (error "Map.deleteFindMax: can not return the maximal element of an empty map", Tip)


{--------------------------------------------------------------------
  [balance l x r] balances two trees with value x.
  The sizes of the trees should balance after decreasing the
  size of one of them. (a rotation).

  [delta] is the maximal relative difference between the sizes of
          two trees, it corresponds with the [w] in Adams' paper.
  [ratio] is the ratio between an outer and inner sibling of the
          heavier subtree in an unbalanced setting. It determines
          whether a double or single rotation should be performed
          to restore balance. It is correspondes with the inverse
          of $\alpha$ in Adam's article.

  Note that:
  - [delta] should be larger than 4.646 with a [ratio] of 2.
  - [delta] should be larger than 3.745 with a [ratio] of 1.534.
  
  - A lower [delta] leads to a more 'perfectly' balanced tree.
  - A higher [delta] performs less rebalancing.

  - Balancing is automatic for random data and a balancing
    scheme is only necessary to avoid pathological worst cases.
    Almost any choice will do, and in practice, a rather large
    [delta] may perform better than smaller one.

  Note: in contrast to Adam's paper, we use a ratio of (at least) [2]
  to decide whether a single or double rotation is needed. Allthough
  he actually proves that this ratio is needed to maintain the
  invariants, his implementation uses an invalid ratio of [1].
--------------------------------------------------------------------}
delta,ratio :: Int
delta = 5
ratio = 2

balance :: k -> a -> Map k a -> Map k a -> Map k a
balance k x l r
  | sizeL + sizeR <= 1    = Bin sizeX k x l r
  | sizeR >= delta*sizeL  = rotateL k x l r
  | sizeL >= delta*sizeR  = rotateR k x l r
  | otherwise             = Bin sizeX k x l r
  where
    sizeL = size l
    sizeR = size r
    sizeX = sizeL + sizeR + 1

-- rotate
rotateL k x l r@(Bin _ _ _ ly ry)
  | size ly < ratio*size ry = singleL k x l r
  | otherwise               = doubleL k x l r

rotateR k x l@(Bin _ _ _ ly ry) r
  | size ry < ratio*size ly = singleR k x l r
  | otherwise               = doubleR k x l r

-- basic rotations
singleL k1 x1 t1 (Bin _ k2 x2 t2 t3)  = bin k2 x2 (bin k1 x1 t1 t2) t3
singleR k1 x1 (Bin _ k2 x2 t1 t2) t3  = bin k2 x2 t1 (bin k1 x1 t2 t3)

doubleL k1 x1 t1 (Bin _ k2 x2 (Bin _ k3 x3 t2 t3) t4) = bin k3 x3 (bin k1 x1 t1 t2) (bin k2 x2 t3 t4)
doubleR k1 x1 (Bin _ k2 x2 t1 (Bin _ k3 x3 t2 t3)) t4 = bin k3 x3 (bin k2 x2 t1 t2) (bin k1 x1 t3 t4)


{--------------------------------------------------------------------
  The bin constructor maintains the size of the tree
--------------------------------------------------------------------}
bin :: k -> a -> Map k a -> Map k a -> Map k a
bin k x l r
  = Bin (size l + size r + 1) k x l r


{--------------------------------------------------------------------
  Eq converts the tree to a list. In a lazy setting, this 
  actually seems one of the faster methods to compare two trees 
  and it is certainly the simplest :-)
--------------------------------------------------------------------}
instance (Eq k,Eq a) => Eq (Map k a) where
  t1 == t2  = (size t1 == size t2) && (toAscList t1 == toAscList t2)

{--------------------------------------------------------------------
  Ord 
--------------------------------------------------------------------}

instance (Ord k, Ord v) => Ord (Map k v) where
    compare m1 m2 = compare (toAscList m1) (toAscList m2)

{--------------------------------------------------------------------
  Functor
--------------------------------------------------------------------}
instance Functor (Map k) where
  fmap f m  = map f m

instance Traversable (Map k) where
  traverse f Tip = pure Tip
  traverse f (Bin s k v l r)
    = flip (Bin s k) <$> traverse f l <*> f v <*> traverse f r

instance Foldable (Map k) where
  foldMap _f Tip = mempty
  foldMap f (Bin _s _k v l r)
    = foldMap f l `mappend` f v `mappend` foldMap f r

{--------------------------------------------------------------------
  Read
--------------------------------------------------------------------}
instance (Ord k, Read k, Read e) => Read (Map k e) where








  readsPrec p = readParen (p > 10) $ \ r -> do
    ("fromList",s) <- lex r
    (xs,t) <- reads s
    return (fromList xs,t)


-- parses a pair of things with the syntax a:=b
readPair :: (Read a, Read b) => ReadS (a,b)
readPair s = do (a, ct1)    <- reads s
                (":=", ct2) <- lex ct1
                (b, ct3)    <- reads ct2
                return ((a,b), ct3)

{--------------------------------------------------------------------
  Show
--------------------------------------------------------------------}
instance (Show k, Show a) => Show (Map k a) where
  showsPrec d m  = showParen (d > 10) $
    showString "fromList " . shows (toList m)

showMap :: (Show k,Show a) => [(k,a)] -> ShowS
showMap []     
  = showString "{}" 
showMap (x:xs) 
  = showChar '{' . showElem x . showTail xs
  where
    showTail []     = showChar '}'
    showTail (x:xs) = showString ", " . showElem x . showTail xs
    
    showElem (k,x)  = shows k . showString " := " . shows x
  

-- | /O(n)/. Show the tree that implements the map. The tree is shown
-- in a compressed, hanging format.
showTree :: (Show k,Show a) => Map k a -> String
showTree m
  = showTreeWith showElem True False m
  where
    showElem k x  = show k ++ ":=" ++ show x


{- | /O(n)/. The expression (@'showTreeWith' showelem hang wide map@) shows
 the tree that implements the map. Elements are shown using the @showElem@ function. If @hang@ is
 'True', a /hanging/ tree is shown otherwise a rotated tree is shown. If
 @wide@ is 'True', an extra wide version is shown.

>  Map> let t = fromDistinctAscList [(x,()) | x <- [1..5]]
>  Map> putStrLn $ showTreeWith (\k x -> show (k,x)) True False t
>  (4,())
>  +--(2,())
>  |  +--(1,())
>  |  +--(3,())
>  +--(5,())
>
>  Map> putStrLn $ showTreeWith (\k x -> show (k,x)) True True t
>  (4,())
>  |
>  +--(2,())
>  |  |
>  |  +--(1,())
>  |  |
>  |  +--(3,())
>  |
>  +--(5,())
>
>  Map> putStrLn $ showTreeWith (\k x -> show (k,x)) False True t
>  +--(5,())
>  |
>  (4,())
>  |
>  |  +--(3,())
>  |  |
>  +--(2,())
>     |
>     +--(1,())

-}
showTreeWith :: (k -> a -> String) -> Bool -> Bool -> Map k a -> String
showTreeWith showelem hang wide t
  | hang      = (showsTreeHang showelem wide [] t) ""
  | otherwise = (showsTree showelem wide [] [] t) ""

showsTree :: (k -> a -> String) -> Bool -> [String] -> [String] -> Map k a -> ShowS
showsTree showelem wide lbars rbars t
  = case t of
      Tip -> showsBars lbars . showString "|\n"
      Bin sz kx x Tip Tip
          -> showsBars lbars . showString (showelem kx x) . showString "\n" 
      Bin sz kx x l r
          -> showsTree showelem wide (withBar rbars) (withEmpty rbars) r .
             showWide wide rbars .
             showsBars lbars . showString (showelem kx x) . showString "\n" .
             showWide wide lbars .
             showsTree showelem wide (withEmpty lbars) (withBar lbars) l

showsTreeHang :: (k -> a -> String) -> Bool -> [String] -> Map k a -> ShowS
showsTreeHang showelem wide bars t
  = case t of
      Tip -> showsBars bars . showString "|\n" 
      Bin sz kx x Tip Tip
          -> showsBars bars . showString (showelem kx x) . showString "\n" 
      Bin sz kx x l r
          -> showsBars bars . showString (showelem kx x) . showString "\n" . 
             showWide wide bars .
             showsTreeHang showelem wide (withBar bars) l .
             showWide wide bars .
             showsTreeHang showelem wide (withEmpty bars) r


showWide wide bars 
  | wide      = showString (concat (reverse bars)) . showString "|\n" 
  | otherwise = id

showsBars :: [String] -> ShowS
showsBars bars
  = case bars of
      [] -> id
      _  -> showString (concat (reverse (tail bars))) . showString node

node           = "+--"
withBar bars   = "|  ":bars
withEmpty bars = "   ":bars

{--------------------------------------------------------------------
  Typeable
--------------------------------------------------------------------}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      























































mapTc = mkTyCon "Map"; instance Typeable2 Map where { typeOf2 _ = mkTyConApp mapTc [] }; instance Typeable a => Typeable1 (Map a) where {   typeOf1 = typeOf1Default }; instance (Typeable a, Typeable b) => Typeable (Map a b) where {   typeOf = typeOfDefault }

{--------------------------------------------------------------------
  Assertions
--------------------------------------------------------------------}
-- | /O(n)/. Test if the internal map structure is valid.
valid :: Ord k => Map k a -> Bool
valid t
  = balanced t && ordered t && validsize t

ordered t
  = bounded (const True) (const True) t
  where
    bounded lo hi t
      = case t of
          Tip              -> True
          Bin sz kx x l r  -> (lo kx) && (hi kx) && bounded lo (<kx) l && bounded (>kx) hi r

-- | Exported only for "Debug.QuickCheck"
balanced :: Map k a -> Bool
balanced t
  = case t of
      Tip              -> True
      Bin sz kx x l r  -> (size l + size r <= 1 || (size l <= delta*size r && size r <= delta*size l)) &&
                          balanced l && balanced r


validsize t
  = (realsize t == Just (size t))
  where
    realsize t
      = case t of
          Tip             -> Just 0
          Bin sz kx x l r -> case (realsize l,realsize r) of
                              (Just n,Just m)  | n+m+1 == sz  -> Just sz
                              other            -> Nothing

{--------------------------------------------------------------------
  Utilities
--------------------------------------------------------------------}
foldlStrict f z xs
  = case xs of
      []     -> z
      (x:xx) -> let z' = f z x in seq z' (foldlStrict f z' xx)


{-
{--------------------------------------------------------------------
  Testing
--------------------------------------------------------------------}
testTree xs   = fromList [(x,"*") | x <- xs]
test1 = testTree [1..20]
test2 = testTree [30,29..10]
test3 = testTree [1,4,6,89,2323,53,43,234,5,79,12,9,24,9,8,423,8,42,4,8,9,3]

{--------------------------------------------------------------------
  QuickCheck
--------------------------------------------------------------------}
qcheck prop
  = check config prop
  where
    config = Config
      { configMaxTest = 500
      , configMaxFail = 5000
      , configSize    = \n -> (div n 2 + 3)
      , configEvery   = \n args -> let s = show n in s ++ [ '\b' | _ <- s ]
      }


{--------------------------------------------------------------------
  Arbitrary, reasonably balanced trees
--------------------------------------------------------------------}
instance (Enum k,Arbitrary a) => Arbitrary (Map k a) where
  arbitrary = sized (arbtree 0 maxkey)
            where maxkey  = 10000

arbtree :: (Enum k,Arbitrary a) => Int -> Int -> Int -> Gen (Map k a)
arbtree lo hi n
  | n <= 0        = return Tip
  | lo >= hi      = return Tip
  | otherwise     = do{ x  <- arbitrary 
                      ; i  <- choose (lo,hi)
                      ; m  <- choose (1,30)
                      ; let (ml,mr)  | m==(1::Int)= (1,2)
                                     | m==2       = (2,1)
                                     | m==3       = (1,1)
                                     | otherwise  = (2,2)
                      ; l  <- arbtree lo (i-1) (n `div` ml)
                      ; r  <- arbtree (i+1) hi (n `div` mr)
                      ; return (bin (toEnum i) x l r)
                      }  


{--------------------------------------------------------------------
  Valid tree's
--------------------------------------------------------------------}
forValid :: (Show k,Enum k,Show a,Arbitrary a,Testable b) => (Map k a -> b) -> Property
forValid f
  = forAll arbitrary $ \t -> 
--    classify (balanced t) "balanced" $
    classify (size t == 0) "empty" $
    classify (size t > 0  && size t <= 10) "small" $
    classify (size t > 10 && size t <= 64) "medium" $
    classify (size t > 64) "large" $
    balanced t ==> f t

forValidIntTree :: Testable a => (Map Int Int -> a) -> Property
forValidIntTree f
  = forValid f

forValidUnitTree :: Testable a => (Map Int () -> a) -> Property
forValidUnitTree f
  = forValid f


prop_Valid 
  = forValidUnitTree $ \t -> valid t

{--------------------------------------------------------------------
  Single, Insert, Delete
--------------------------------------------------------------------}
prop_Single :: Int -> Int -> Bool
prop_Single k x
  = (insert k x empty == singleton k x)

prop_InsertValid :: Int -> Property
prop_InsertValid k
  = forValidUnitTree $ \t -> valid (insert k () t)

prop_InsertDelete :: Int -> Map Int () -> Property
prop_InsertDelete k t
  = (lookup k t == Nothing) ==> delete k (insert k () t) == t

prop_DeleteValid :: Int -> Property
prop_DeleteValid k
  = forValidUnitTree $ \t -> 
    valid (delete k (insert k () t))

{--------------------------------------------------------------------
  Balance
--------------------------------------------------------------------}
prop_Join :: Int -> Property 
prop_Join k 
  = forValidUnitTree $ \t ->
    let (l,r) = split k t
    in valid (join k () l r)

prop_Merge :: Int -> Property 
prop_Merge k
  = forValidUnitTree $ \t ->
    let (l,r) = split k t
    in valid (merge l r)


{--------------------------------------------------------------------
  Union
--------------------------------------------------------------------}
prop_UnionValid :: Property
prop_UnionValid
  = forValidUnitTree $ \t1 ->
    forValidUnitTree $ \t2 ->
    valid (union t1 t2)

prop_UnionInsert :: Int -> Int -> Map Int Int -> Bool
prop_UnionInsert k x t
  = union (singleton k x) t == insert k x t

prop_UnionAssoc :: Map Int Int -> Map Int Int -> Map Int Int -> Bool
prop_UnionAssoc t1 t2 t3
  = union t1 (union t2 t3) == union (union t1 t2) t3

prop_UnionComm :: Map Int Int -> Map Int Int -> Bool
prop_UnionComm t1 t2
  = (union t1 t2 == unionWith (\x y -> y) t2 t1)

prop_UnionWithValid 
  = forValidIntTree $ \t1 ->
    forValidIntTree $ \t2 ->
    valid (unionWithKey (\k x y -> x+y) t1 t2)

prop_UnionWith :: [(Int,Int)] -> [(Int,Int)] -> Bool
prop_UnionWith xs ys
  = sum (elems (unionWith (+) (fromListWith (+) xs) (fromListWith (+) ys))) 
    == (sum (Prelude.map snd xs) + sum (Prelude.map snd ys))

prop_DiffValid
  = forValidUnitTree $ \t1 ->
    forValidUnitTree $ \t2 ->
    valid (difference t1 t2)

prop_Diff :: [(Int,Int)] -> [(Int,Int)] -> Bool
prop_Diff xs ys
  =  List.sort (keys (difference (fromListWith (+) xs) (fromListWith (+) ys))) 
    == List.sort ((List.\\) (nub (Prelude.map fst xs))  (nub (Prelude.map fst ys)))

prop_IntValid
  = forValidUnitTree $ \t1 ->
    forValidUnitTree $ \t2 ->
    valid (intersection t1 t2)

prop_Int :: [(Int,Int)] -> [(Int,Int)] -> Bool
prop_Int xs ys
  =  List.sort (keys (intersection (fromListWith (+) xs) (fromListWith (+) ys))) 
    == List.sort (nub ((List.intersect) (Prelude.map fst xs)  (Prelude.map fst ys)))

{--------------------------------------------------------------------
  Lists
--------------------------------------------------------------------}
prop_Ordered
  = forAll (choose (5,100)) $ \n ->
    let xs = [(x,()) | x <- [0..n::Int]] 
    in fromAscList xs == fromList xs

prop_List :: [Int] -> Bool
prop_List xs
  = (sort (nub xs) == [x | (x,()) <- toList (fromList [(x,()) | x <- xs])])
-}
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Maybe
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  stable
-- Portability :  portable
--
-- The Maybe type, and associated operations.
--
-----------------------------------------------------------------------------

module Data.Maybe
   (
     Maybe(Nothing,Just)-- instance of: Eq, Ord, Show, Read,
			--		Functor, Monad, MonadPlus

   , maybe		-- :: b -> (a -> b) -> Maybe a -> b

   , isJust		-- :: Maybe a -> Bool
   , isNothing		-- :: Maybe a -> Bool
   , fromJust		-- :: Maybe a -> a
   , fromMaybe		-- :: a -> Maybe a -> a
   , listToMaybe        -- :: [a] -> Maybe a
   , maybeToList	-- :: Maybe a -> [a]
   , catMaybes		-- :: [Maybe a] -> [a]
   , mapMaybe		-- :: (a -> Maybe b) -> [a] -> [b]
   ) where
































































-- | The 'isJust' function returns 'True' iff its argument is of the
-- form @Just _@.
isJust         :: Maybe a -> Bool
isJust Nothing = False
isJust _       = True

-- | The 'isNothing' function returns 'True' iff its argument is 'Nothing'.
isNothing         :: Maybe a -> Bool
isNothing Nothing = True
isNothing _       = False

-- | The 'fromJust' function extracts the element out of a 'Just' and
-- throws an error if its argument is 'Nothing'.
fromJust          :: Maybe a -> a
fromJust Nothing  = error "Maybe.fromJust: Nothing" -- yuck
fromJust (Just x) = x

-- | The 'fromMaybe' function takes a default value and and 'Maybe'
-- value.  If the 'Maybe' is 'Nothing', it returns the default values;
-- otherwise, it returns the value contained in the 'Maybe'.
fromMaybe     :: a -> Maybe a -> a
fromMaybe d x = case x of {Nothing -> d;Just v  -> v}

-- | The 'maybeToList' function returns an empty list when given
-- 'Nothing' or a singleton list when not given 'Nothing'.
maybeToList            :: Maybe a -> [a]
maybeToList  Nothing   = []
maybeToList  (Just x)  = [x]

-- | The 'listToMaybe' function returns 'Nothing' on an empty list
-- or @'Just' a@ where @a@ is the first element of the list.
listToMaybe           :: [a] -> Maybe a
listToMaybe []        =  Nothing
listToMaybe (a:_)     =  Just a

-- | The 'catMaybes' function takes a list of 'Maybe's and returns
-- a list of all the 'Just' values. 
catMaybes              :: [Maybe a] -> [a]
catMaybes ls = [x | Just x <- ls]

-- | The 'mapMaybe' function is a version of 'map' which can throw
-- out elements.  In particular, the functional argument returns
-- something of type @'Maybe' b@.  If this is 'Nothing', no element
-- is added on to the result list.  If it just @'Just' b@, then @b@ is
-- included in the result list.
mapMaybe          :: (a -> Maybe b) -> [a] -> [b]
mapMaybe _ []     = []
mapMaybe f (x:xs) =
 let rs = mapMaybe f xs in
 case f x of
  Nothing -> rs
  Just r  -> r:rs


-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Monoid
-- Copyright   :  (c) Andy Gill 2001,
-- 		  (c) Oregon Graduate Institute of Science and Technology, 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- The Monoid class with various general-purpose instances.
--
--	  Inspired by the paper
--	  /Functional Programming with Overloading and
--	      Higher-Order Polymorphism/, 
--	    Mark P Jones (<http://www.cse.ogi.edu/~mpj/>)
--		  Advanced School of Functional Programming, 1995.
-----------------------------------------------------------------------------

module Data.Monoid (
 	Monoid(..),
	Dual(..),
	Endo(..),
	All(..),
	Any(..),
	Sum(..),
	Product(..)
  ) where

import Prelude

-- ---------------------------------------------------------------------------
-- | The monoid class.
-- A minimal complete definition must supply 'mempty' and 'mappend',
-- and these should satisfy the monoid laws.

class Monoid a where
	mempty  :: a
	-- ^ Identity of 'mappend'
	mappend :: a -> a -> a
	-- ^ An associative operation
	mconcat :: [a] -> a

	-- ^ Fold a list using the monoid.
	-- For most types, the default definition for 'mconcat' will be
	-- used, but the function is included in the class definition so
	-- that an optimized version can be provided for specific types.

	mconcat = foldr mappend mempty

-- Monoid instances.

instance Monoid [a] where
	mempty  = []
	mappend = (++)

instance Monoid b => Monoid (a -> b) where
	mempty _ = mempty
	mappend f g x = f x `mappend` g x

instance Monoid () where
	-- Should it be strict?
	mempty        = ()
	_ `mappend` _ = ()
	mconcat _     = ()

instance (Monoid a, Monoid b) => Monoid (a,b) where
	mempty = (mempty, mempty)
	(a1,b1) `mappend` (a2,b2) =
		(a1 `mappend` a2, b1 `mappend` b2)

instance (Monoid a, Monoid b, Monoid c) => Monoid (a,b,c) where
	mempty = (mempty, mempty, mempty)
	(a1,b1,c1) `mappend` (a2,b2,c2) =
		(a1 `mappend` a2, b1 `mappend` b2, c1 `mappend` c2)

instance (Monoid a, Monoid b, Monoid c, Monoid d) => Monoid (a,b,c,d) where
	mempty = (mempty, mempty, mempty, mempty)
	(a1,b1,c1,d1) `mappend` (a2,b2,c2,d2) =
		(a1 `mappend` a2, b1 `mappend` b2,
		 c1 `mappend` c2, d1 `mappend` d2)

instance (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =>
		Monoid (a,b,c,d,e) where
	mempty = (mempty, mempty, mempty, mempty, mempty)
	(a1,b1,c1,d1,e1) `mappend` (a2,b2,c2,d2,e2) =
		(a1 `mappend` a2, b1 `mappend` b2, c1 `mappend` c2,
		 d1 `mappend` d2, e1 `mappend` e2)

-- lexicographical ordering
instance Monoid Ordering where
	mempty         = EQ
	LT `mappend` _ = LT
	EQ `mappend` y = y
	GT `mappend` _ = GT

-- | The dual of a monoid, obtained by swapping the arguments of 'mappend'.
newtype Dual a = Dual { getDual :: a }

instance Monoid a => Monoid (Dual a) where
	mempty = Dual mempty
	Dual x `mappend` Dual y = Dual (y `mappend` x)

-- | The monoid of endomorphisms under composition.
newtype Endo a = Endo { appEndo :: a -> a }

instance Monoid (Endo a) where
	mempty = Endo id
	Endo f `mappend` Endo g = Endo (f . g)

-- | Boolean monoid under conjunction.
newtype All = All { getAll :: Bool }
	deriving (Eq, Ord, Read, Show, Bounded)

instance Monoid All where
	mempty = All True
	All x `mappend` All y = All (x && y)

-- | Boolean monoid under disjunction.
newtype Any = Any { getAny :: Bool }
	deriving (Eq, Ord, Read, Show, Bounded)

instance Monoid Any where
	mempty = Any False
	Any x `mappend` Any y = Any (x || y)

-- | Monoid under addition.
newtype Sum a = Sum { getSum :: a }
	deriving (Eq, Ord, Read, Show, Bounded)

instance Num a => Monoid (Sum a) where
	mempty = Sum 0
	Sum x `mappend` Sum y = Sum (x + y)

-- | Monoid under multiplication.
newtype Product a = Product { getProduct :: a }
	deriving (Eq, Ord, Read, Show, Bounded)

instance Num a => Monoid (Product a) where
	mempty = Product 1
	Product x `mappend` Product y = Product (x * y)
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Ord
-- Copyright   :  (c) The University of Glasgow 2005
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  stable
-- Portability :  portable
--
-- Orderings
--
-----------------------------------------------------------------------------

module Data.Ord (
   Ord(..),
   Ordering(..),
   comparing,
 ) where





-- | 
-- > comparing p x y = compare (p x) (p y)
--
-- Useful combinator for use in conjunction with the @xxxBy@ family
-- of functions from "Data.List", for example:
--
-- >   ... sortBy (comparing fst) ...
comparing :: (Ord a) => (b -> a) -> b -> b -> Ordering
comparing p x y = compare (p x) (p y)
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.PackedString
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- This API is deprecated.  You might be able to use "Data.ByteString"
-- or "Data.ByteString.Char8", provided you don't need full Unicode support.
-- The long term aim is to provide a Unicode layer on "Data.ByteString",
-- and then to provide a replacement for this "Data.PackedString" API based on
-- that.
--
-----------------------------------------------------------------------------

-- Original GHC implementation by Bryan O\'Sullivan, 
-- rewritten to use UArray by Simon Marlow.

module Data.PackedString 
  {-# DEPRECATED "use Data.ByteString, Data.ByteString.Char8, or plain String." #-}
  (
	-- * The @PackedString@ type
        PackedString,      -- abstract, instances: Eq, Ord, Show, Typeable

         -- * Converting to and from @PackedString@s
	packString,  -- :: String -> PackedString
	unpackPS,    -- :: PackedString -> String


	-- * I\/O with @PackedString@s	
	hPutPS,      -- :: Handle -> PackedString -> IO ()
	hGetPS,      -- :: Handle -> Int -> IO PackedString


	-- * List-like manipulation functions
	nilPS,       -- :: PackedString
	consPS,      -- :: Char -> PackedString -> PackedString
	headPS,      -- :: PackedString -> Char
	tailPS,      -- :: PackedString -> PackedString
	nullPS,      -- :: PackedString -> Bool
	appendPS,    -- :: PackedString -> PackedString -> PackedString
	lengthPS,    -- :: PackedString -> Int
	indexPS,     -- :: PackedString -> Int -> Char
	mapPS,       -- :: (Char -> Char) -> PackedString -> PackedString
	filterPS,    -- :: (Char -> Bool) -> PackedString -> PackedString
	reversePS,   -- :: PackedString -> PackedString
	concatPS,    -- :: [PackedString] -> PackedString
	elemPS,      -- :: Char -> PackedString -> Bool
	substrPS,    -- :: PackedString -> Int -> Int -> PackedString
	takePS,      -- :: Int -> PackedString -> PackedString
	dropPS,      -- :: Int -> PackedString -> PackedString
	splitAtPS,   -- :: Int -> PackedString -> (PackedString, PackedString)

	foldlPS,     -- :: (a -> Char -> a) -> a -> PackedString -> a
	foldrPS,     -- :: (Char -> a -> a) -> a -> PackedString -> a
	takeWhilePS, -- :: (Char -> Bool) -> PackedString -> PackedString
	dropWhilePS, -- :: (Char -> Bool) -> PackedString -> PackedString
	spanPS,      -- :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
	breakPS,     -- :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
	linesPS,     -- :: PackedString -> [PackedString]
	unlinesPS,   -- :: [PackedString] -> PackedString
	wordsPS,     -- :: PackedString -> [PackedString]
	unwordsPS,   -- :: [PackedString] -> PackedString
	splitPS,     -- :: Char -> PackedString -> [PackedString]
	splitWithPS, -- :: (Char -> Bool) -> PackedString -> [PackedString]

	joinPS,      -- :: PackedString -> [PackedString] -> PackedString

    ) where

import Prelude



import Data.Array.Unboxed
import Data.Array.IO
import Data.Typeable
import Data.Char

import System.IO

-- -----------------------------------------------------------------------------
-- PackedString type declaration

-- | A space-efficient representation of a 'String', which supports various
-- efficient operations.  A 'PackedString' contains full Unicode 'Char's.
newtype PackedString = PS (UArray Int Char)

-- ToDo: we could support "slices", i.e. include offset and length fields into
-- the string, so that operations like take/drop could be O(1).  Perhaps making
-- a slice should be conditional on the ratio of the slice/string size to
-- limit memory leaks.

instance Eq PackedString where
   (PS x) == (PS y)  =  x == y

instance Ord PackedString where
    compare (PS x) (PS y) = compare x y

--instance Read PackedString: ToDo

instance Show PackedString where
    showsPrec p ps r = showsPrec p (unpackPS ps) r

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      























































packedStringTc = mkTyCon "PackedString"; instance Typeable PackedString where { typeOf _ = mkTyConApp packedStringTc [] }

-- -----------------------------------------------------------------------------
-- Constructor functions

-- | The 'nilPS' value is the empty string.
nilPS :: PackedString
nilPS = PS (array (0,-1) [])

-- | The 'consPS' function prepends the given character to the
-- given string.
consPS :: Char -> PackedString -> PackedString
consPS c cs = packString (c : (unpackPS cs)) -- ToDo:better

-- | Convert a 'String' into a 'PackedString'
packString :: String -> PackedString
packString str = packNChars (length str) str

-- | The 'packNChars' function creates a 'PackedString' out of the
-- first @len@ elements of the given 'String'.
packNChars :: Int -> [Char] -> PackedString
packNChars len str = PS (listArray (0,len-1) str)

-- -----------------------------------------------------------------------------
-- Destructor functions (taking PackedStrings apart)

-- | Convert a 'PackedString' into a 'String'
unpackPS :: PackedString -> String
unpackPS (PS ps) = elems ps

-- -----------------------------------------------------------------------------
-- List-mimicking functions for PackedStrings

-- | The 'lengthPS' function returns the length of the input list.  Analogous to 'length'.
lengthPS :: PackedString -> Int
lengthPS (PS ps) = rangeSize (bounds ps)

-- | The 'indexPS' function returns the character in the string at the given position.
indexPS :: PackedString -> Int -> Char
indexPS (PS ps) i = ps ! i

-- | The 'headPS' function returns the first element of a 'PackedString' or throws an
-- error if the string is empty.
headPS :: PackedString -> Char
headPS ps
  | nullPS ps = error "Data.PackedString.headPS: head []"
  | otherwise  = indexPS ps 0

-- | The 'tailPS' function returns the tail of a 'PackedString' or throws an error
-- if the string is empty.
tailPS :: PackedString -> PackedString
tailPS ps
  | len <= 0 = error "Data.PackedString.tailPS: tail []"
  | len == 1 = nilPS
  | otherwise  = substrPS ps 1 (len - 1)
  where
    len = lengthPS ps

-- | The 'nullPS' function returns True iff the argument is null.
nullPS :: PackedString -> Bool
nullPS (PS ps) = rangeSize (bounds ps) == 0

-- | The 'appendPS' function appends the second string onto the first.
appendPS :: PackedString -> PackedString -> PackedString
appendPS xs ys
  | nullPS xs = ys
  | nullPS ys = xs
  | otherwise  = concatPS [xs,ys]

-- | The 'mapPS' function applies a function to each character in the string.
mapPS :: (Char -> Char) -> PackedString -> PackedString
mapPS f (PS ps) = PS (amap f ps)

-- | The 'filterPS' function filters out the appropriate substring.
filterPS :: (Char -> Bool) -> PackedString -> PackedString {-or String?-}
filterPS pred ps = packString (filter pred (unpackPS ps))

-- | The 'foldlPS' function behaves like 'foldl' on 'PackedString's.
foldlPS :: (a -> Char -> a) -> a -> PackedString -> a
foldlPS f b ps = foldl f b (unpackPS ps)

-- | The 'foldrPS' function behaves like 'foldr' on 'PackedString's.
foldrPS :: (Char -> a -> a) -> a -> PackedString -> a
foldrPS f v ps = foldr f v (unpackPS ps)

-- | The 'takePS' function takes the first @n@ characters of a 'PackedString'.
takePS :: Int -> PackedString -> PackedString
takePS n ps = substrPS ps 0 (n-1)

-- | The 'dropPS' function drops the first @n@ characters of a 'PackedString'.
dropPS	:: Int -> PackedString -> PackedString
dropPS n ps = substrPS ps n (lengthPS ps - 1)

-- | The 'splitWithPS' function splits a 'PackedString' at a given index.
splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
splitAtPS  n ps  = (takePS n ps, dropPS n ps)

-- | The 'takeWhilePS' function is analogous to the 'takeWhile' function.
takeWhilePS :: (Char -> Bool) -> PackedString -> PackedString
takeWhilePS pred ps = packString (takeWhile pred (unpackPS ps))

-- | The 'dropWhilePS' function is analogous to the 'dropWhile' function.
dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
dropWhilePS pred ps = packString (dropWhile pred (unpackPS ps))

-- | The 'elemPS' function returns True iff the given element is in the string.
elemPS :: Char -> PackedString -> Bool
elemPS c ps = c `elem` unpackPS ps

-- | The 'spanPS' function returns a pair containing the result of
-- running both 'takeWhilePS' and 'dropWhilePS'.
spanPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
spanPS  p ps = (takeWhilePS p ps, dropWhilePS p ps)

-- | The 'breakPS' function breaks a string at the first position which
-- satisfies the predicate.
breakPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
breakPS p ps = spanPS (not . p) ps

-- | The 'linesPS' function splits the input on line-breaks.
linesPS :: PackedString -> [PackedString]
linesPS ps = splitPS '\n' ps

-- | The 'unlinesPS' function concatenates the input list after
-- interspersing newlines.
unlinesPS :: [PackedString] -> PackedString
unlinesPS = joinPS (packString "\n")

-- | The 'wordsPS' function is analogous to the 'words' function.
wordsPS :: PackedString -> [PackedString]
wordsPS ps = filter (not.nullPS) (splitWithPS isSpace ps)

-- | The 'unwordsPS' function is analogous to the 'unwords' function.
unwordsPS :: [PackedString] -> PackedString
unwordsPS = joinPS (packString " ")

-- | The 'reversePS' function reverses the string.
reversePS :: PackedString -> PackedString
reversePS ps = packString (reverse (unpackPS ps))

-- | The 'concatPS' function concatenates a list of 'PackedString's.
concatPS :: [PackedString] -> PackedString
concatPS pss = packString (concat (map unpackPS pss))

------------------------------------------------------------

-- | The 'joinPS' function takes a 'PackedString' and a list of 'PackedString's
-- and concatenates the list after interspersing the first argument between
-- each element of the list.
joinPS :: PackedString -> [PackedString] -> PackedString
joinPS filler pss = concatPS (splice pss)
 where
  splice []  = []
  splice [x] = [x]
  splice (x:y:xs) = x:filler:splice (y:xs)

-- ToDo: the obvious generalisation
{-
  Some properties that hold:

  * splitPS x ls = ls'   
      where False = any (map (x `elemPS`) ls')

  * joinPS (packString [x]) (splitPS x ls) = ls
-}

-- | The 'splitPS' function splits the input string on each occurrence of the given 'Char'.
splitPS :: Char -> PackedString -> [PackedString]
splitPS c = splitWithPS (== c)

-- | The 'splitWithPS' function takes a character predicate and splits the input string
-- at each character which satisfies the predicate.
splitWithPS :: (Char -> Bool) -> PackedString -> [PackedString]
splitWithPS pred (PS ps) =
 splitify 0
 where
  len = lengthPS (PS ps)
  
  splitify n 
   | n >= len = []
   | otherwise =
      let
       break_pt = first_pos_that_satisfies pred ps len n
      in
      if break_pt == n then -- immediate match, empty substring
         nilPS
	 : splitify (break_pt + 1)
      else 
         substrPS (PS ps) n (break_pt - 1) -- leave out the matching character
         : splitify (break_pt + 1)

first_pos_that_satisfies pred ps len n = 
   case [ m | m <- [n..len-1], pred (ps ! m) ] of
	[]    -> len
	(m:_) -> m

-- -----------------------------------------------------------------------------
-- Local utility functions

-- The definition of @_substrPS@ is essentially:
-- @take (end - begin + 1) (drop begin str)@.

-- | The 'substrPS' function takes a 'PackedString' and two indices
-- and returns the substring of the input string between (and including)
-- these indices.
substrPS :: PackedString -> Int -> Int -> PackedString
substrPS (PS ps) begin end = packString [ ps ! i | i <- [begin..end] ]

-- -----------------------------------------------------------------------------
-- hPutPS

-- | Outputs a 'PackedString' to the specified 'Handle'.
--
-- NOTE: the representation of the 'PackedString' in the file is assumed to
-- be in the ISO-8859-1 encoding.  In other words, only the least significant
-- byte is taken from each character in the 'PackedString'.
hPutPS :: Handle -> PackedString -> IO ()
hPutPS h (PS ps) = do
  let l = lengthPS (PS ps)
  arr <- newArray_ (0, l-1)
  sequence_ [ writeArray arr i (fromIntegral (ord (ps ! i))) | i <- [0..l-1] ]
  hPutArray h arr l

-- -----------------------------------------------------------------------------
-- hGetPS

-- | Read a 'PackedString' directly from the specified 'Handle'.
-- This is far more efficient than reading the characters into a 'String'
-- and then using 'packString'.  
--
-- NOTE: as with 'hPutPS', the string representation in the file is 
-- assumed to be ISO-8859-1.
hGetPS :: Handle -> Int -> IO PackedString
hGetPS h i = do
  arr <- newArray_ (0, i-1)
  l <- hGetArray h arr i
  chars <- mapM (\i -> readArray arr i >>= return.chr.fromIntegral) [0..l-1]
  return (packNChars l chars)
























































































-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Queue
-- Copyright   :  (c) The University of Glasgow 2002
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- NOTE: This module is DEPRECATED.
-- The data structure in "Data.Sequence" is a faster queue and also
-- supports a wider variety of operations.
--
-- Queues with constant time operations, from
-- /Simple and efficient purely functional queues and deques/,
-- by Chris Okasaki, /JFP/ 5(4):583-592, October 1995.
--
-----------------------------------------------------------------------------

module Data.Queue
{-# DEPRECATED "Use Data.Sequence instead: it's faster and has more operations" #-}
	(Queue,
	-- * Primitive operations
	-- | Each of these requires /O(1)/ time in the worst case.
	emptyQueue, addToQueue, deQueue,
	-- * Queues and lists
	listToQueue, queueToList
    ) where

import Prelude -- necessary to get dependencies right
import Data.Typeable

-- | The type of FIFO queues.
data Queue a = Q [a] [a] [a]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      























































queueTc = mkTyCon "Queue"; instance Typeable1 Queue where { typeOf1 _ = mkTyConApp queueTc [] }; instance Typeable a => Typeable (Queue a) where { typeOf = typeOfDefault }

-- Invariants for Q xs ys xs':
--	length xs = length ys + length xs'
--	xs' = drop (length ys) xs	-- in fact, shared (except after fmap)
-- The queue then represents the list xs ++ reverse ys

instance Functor Queue where
	fmap f (Q xs ys xs') = Q (map f xs) (map f ys) (map f xs')
	-- The new xs' does not share the tail of the new xs, but it does
	-- share the tail of the old xs, so it still forces the rotations.
	-- Note that elements of xs' are ignored.

-- | The empty queue.
emptyQueue :: Queue a
emptyQueue = Q [] [] []

-- | Add an element to the back of a queue.
addToQueue :: Queue a -> a -> Queue a
addToQueue (Q xs ys xs') y = makeQ xs (y:ys) xs'

-- | Attempt to extract the front element from a queue.
-- If the queue is empty, 'Nothing',
-- otherwise the first element paired with the remainder of the queue.
deQueue :: Queue a -> Maybe (a, Queue a)
deQueue (Q [] _ _) = Nothing
deQueue (Q (x:xs) ys xs') = Just (x, makeQ xs ys xs')

-- Assuming
--	length ys <= length xs + 1
--	xs' = drop (length ys - 1) xs
-- construct a queue respecting the invariant.
makeQ :: [a] -> [a] -> [a] -> Queue a
makeQ xs ys [] = listToQueue (rotate xs ys [])
makeQ xs ys (_:xs') = Q xs ys xs'

-- Assuming length ys = length xs + 1,
--	rotate xs ys zs = xs ++ reverse ys ++ zs
rotate :: [a] -> [a] -> [a] -> [a]
rotate [] (y:_) zs = y : zs		-- the _ here must be []
rotate (x:xs) (y:ys) zs = x : rotate xs ys (y:zs)

-- | A queue with the same elements as the list.
listToQueue :: [a] -> Queue a
listToQueue xs = Q xs [] xs

-- | The elements of a queue, front first.
queueToList :: Queue a -> [a]
queueToList (Q xs ys _) = xs ++ reverse ys
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Ratio
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  stable
-- Portability :  portable
--
-- Standard functions on rational numbers
--
-----------------------------------------------------------------------------

module Data.Ratio
    ( Ratio
    , Rational
    , (%)		-- :: (Integral a) => a -> a -> Ratio a
    , numerator		-- :: (Integral a) => Ratio a -> a
    , denominator	-- :: (Integral a) => Ratio a -> a
    , approxRational	-- :: (RealFrac a) => a -> a -> Rational

    -- Ratio instances: 
    --   (Integral a) => Eq   (Ratio a)
    --   (Integral a) => Ord  (Ratio a)
    --   (Integral a) => Num  (Ratio a)
    --   (Integral a) => Real (Ratio a)
    --   (Integral a) => Fractional (Ratio a)
    --   (Integral a) => RealFrac (Ratio a)
    --   (Integral a) => Enum	  (Ratio a)
    --   (Read a, Integral a) => Read (Ratio a)
    --   (Integral a) => Show	  (Ratio a)

  ) where

import Prelude






import Hugs.Prelude(Ratio(..), (%), numerator, denominator)






-- -----------------------------------------------------------------------------
-- approxRational

-- | 'approxRational', applied to two real fractional numbers @x@ and @epsilon@,
-- returns the simplest rational number within @epsilon@ of @x@.
-- A rational number @y@ is said to be /simpler/ than another @y'@ if
--
-- * @'abs' ('numerator' y) <= 'abs' ('numerator' y')@, and
--
-- * @'denominator' y <= 'denominator' y'@.
--
-- Any real interval contains a unique simplest rational;
-- in particular, note that @0\/1@ is the simplest rational of all.

-- Implementation details: Here, for simplicity, we assume a closed rational
-- interval.  If such an interval includes at least one whole number, then
-- the simplest rational is the absolutely least whole number.  Otherwise,
-- the bounds are of the form q%1 + r%d and q%1 + r'%d', where abs r < d
-- and abs r' < d', and the simplest rational is q%1 + the reciprocal of
-- the simplest rational between d'%r' and d%r.

approxRational		:: (RealFrac a) => a -> a -> Rational
approxRational rat eps	=  simplest (rat-eps) (rat+eps)
	where simplest x y | y < x	=  simplest y x
			   | x == y	=  xr
			   | x > 0	=  simplest' n d n' d'
			   | y < 0	=  - simplest' (-n') d' (-n) d
			   | otherwise	=  0 :% 1
					where xr  = toRational x
					      n   = numerator xr
					      d   = denominator xr
					      nd' = toRational y
					      n'  = numerator nd'
					      d'  = denominator nd'

	      simplest' n d n' d'	-- assumes 0 < n%d < n'%d'
			| r == 0     =	q :% 1
			| q /= q'    =	(q+1) :% 1
			| otherwise  =	(q*n''+d'') :% n''
				     where (q,r)      =	 quotRem n d
					   (q',r')    =	 quotRem n' d'
					   nd''       =  simplest' d' r' d r
					   n''        =  numerator nd''
					   d''        =	 denominator nd''

-----------------------------------------------------------------------------
-- |
-- Module      :  Data.STRef
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (uses Control.Monad.ST)
--
-- Mutable references in the (strict) ST monad.
--
-----------------------------------------------------------------------------

module Data.STRef (
	-- * STRefs
	STRef,		-- abstract, instance Eq
	newSTRef,	-- :: a -> ST s (STRef s a)
	readSTRef,	-- :: STRef s a -> ST s a
	writeSTRef,	-- :: STRef s a -> a -> ST s ()
	modifySTRef	-- :: STRef s a -> (a -> a) -> ST s ()
 ) where

import Prelude







import Hugs.ST
import Data.Typeable

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      























































stRefTc = mkTyCon "STRef"; instance Typeable2 STRef where { typeOf2 _ = mkTyConApp stRefTc [] }; instance Typeable a => Typeable1 (STRef a) where {   typeOf1 = typeOf1Default }; instance (Typeable a, Typeable b) => Typeable (STRef a b) where {   typeOf = typeOfDefault }


-- |Mutate the contents of an 'STRef'
modifySTRef :: STRef s a -> (a -> a) -> ST s ()
modifySTRef ref f = writeSTRef ref . f =<< readSTRef ref
{-# OPTIONS -cpp -fglasgow-exts #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Sequence
-- Copyright   :  (c) Ross Paterson 2005
-- License     :  BSD-style
-- Maintainer  :  ross@soi.city.ac.uk
-- Stability   :  experimental
-- Portability :  portable
--
-- General purpose finite sequences.
-- Apart from being finite and having strict operations, sequences
-- also differ from lists in supporting a wider variety of operations
-- efficiently.
--
-- An amortized running time is given for each operation, with /n/ referring
-- to the length of the sequence and /i/ being the integral index used by
-- some operations.  These bounds hold even in a persistent (shared) setting.
--
-- The implementation uses 2-3 finger trees annotated with sizes,
-- as described in section 4.2 of
--
--    * Ralf Hinze and Ross Paterson,
--	\"Finger trees: a simple general-purpose data structure\",
--	/Journal of Functional Programming/ 16:2 (2006) pp 197-217.
--	<http://www.soi.city.ac.uk/~ross/papers/FingerTree.html>
--
-- /Note/: Many of these operations have the same names as similar
-- operations on lists in the "Prelude".  The ambiguity may be resolved
-- using either qualification or the @hiding@ clause.
--
-----------------------------------------------------------------------------

module Data.Sequence (
	Seq,
	-- * Construction
	empty,		-- :: Seq a
	singleton,	-- :: a -> Seq a
	(<|),		-- :: a -> Seq a -> Seq a
	(|>),		-- :: Seq a -> a -> Seq a
	(><),		-- :: Seq a -> Seq a -> Seq a
	fromList,	-- :: [a] -> Seq a
	-- * Deconstruction
	-- ** Queries
	null,		-- :: Seq a -> Bool
	length,		-- :: Seq a -> Int
	-- ** Views
	ViewL(..),
	viewl,		-- :: Seq a -> ViewL a
	ViewR(..),
	viewr,		-- :: Seq a -> ViewR a
	-- ** Indexing
	index,		-- :: Seq a -> Int -> a
	adjust,		-- :: (a -> a) -> Int -> Seq a -> Seq a
	update,		-- :: Int -> a -> Seq a -> Seq a
	take,		-- :: Int -> Seq a -> Seq a
	drop,		-- :: Int -> Seq a -> Seq a
	splitAt,	-- :: Int -> Seq a -> (Seq a, Seq a)
	-- * Transformations
	reverse,	-- :: Seq a -> Seq a



	) where

import Prelude hiding (
	null, length, take, drop, splitAt, foldl, foldl1, foldr, foldr1,
	reverse)
import qualified Data.List (foldl')
import Control.Applicative (Applicative(..), (<$>))
import Control.Monad (MonadPlus(..))
import Data.Monoid (Monoid(..))
import Data.Foldable
import Data.Traversable
import Data.Typeable













infixr 5 `consTree`
infixl 5 `snocTree`

infixr 5 ><
infixr 5 <|, :<
infixl 5 |>, :>

class Sized a where
	size :: a -> Int

-- | General-purpose finite sequences.
newtype Seq a = Seq (FingerTree (Elem a))

instance Functor Seq where
	fmap f (Seq xs) = Seq (fmap (fmap f) xs)

instance Foldable Seq where
	foldr f z (Seq xs) = foldr (flip (foldr f)) z xs
	foldl f z (Seq xs) = foldl (foldl f) z xs

	foldr1 f (Seq xs) = getElem (foldr1 f' xs)
	  where f' (Elem x) (Elem y) = Elem (f x y)

	foldl1 f (Seq xs) = getElem (foldl1 f' xs)
	  where f' (Elem x) (Elem y) = Elem (f x y)

instance Traversable Seq where
	traverse f (Seq xs) = Seq <$> traverse (traverse f) xs

instance Monad Seq where
	return = singleton
	xs >>= f = foldl' add empty xs
	  where add ys x = ys >< f x

instance MonadPlus Seq where
	mzero = empty
	mplus = (><)

instance Eq a => Eq (Seq a) where
	xs == ys = length xs == length ys && toList xs == toList ys

instance Ord a => Ord (Seq a) where
	compare xs ys = compare (toList xs) (toList ys)





instance Show a => Show (Seq a) where
	showsPrec p xs = showParen (p > 10) $
		showString "fromList " . shows (toList xs)


instance Read a => Read (Seq a) where








	readsPrec p = readParen (p > 10) $ \ r -> do
		("fromList",s) <- lex r
		(xs,t) <- reads s
		return (fromList xs,t)


instance Monoid (Seq a) where
	mempty = empty
	mappend = (><)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      























































seqTc = mkTyCon "Seq"; instance Typeable1 Seq where { typeOf1 _ = mkTyConApp seqTc [] }; instance Typeable a => Typeable (Seq a) where { typeOf = typeOfDefault }

























-- Finger trees

data FingerTree a
	= Empty
	| Single a
	| Deep {-# UNPACK #-} !Int !(Digit a) (FingerTree (Node a)) !(Digit a)




instance Sized a => Sized (FingerTree a) where
	{-# SPECIALIZE instance Sized (FingerTree (Elem a)) #-}
	{-# SPECIALIZE instance Sized (FingerTree (Node a)) #-}
	size Empty		= 0
	size (Single x)		= size x
	size (Deep v _ _ _)	= v

instance Foldable FingerTree where
	foldr _ z Empty = z
	foldr f z (Single x) = x `f` z
	foldr f z (Deep _ pr m sf) =
		foldr f (foldr (flip (foldr f)) (foldr f z sf) m) pr

	foldl _ z Empty = z
	foldl f z (Single x) = z `f` x
	foldl f z (Deep _ pr m sf) =
		foldl f (foldl (foldl f) (foldl f z pr) m) sf

	foldr1 _ Empty = error "foldr1: empty sequence"
	foldr1 _ (Single x) = x
	foldr1 f (Deep _ pr m sf) =
		foldr f (foldr (flip (foldr f)) (foldr1 f sf) m) pr

	foldl1 _ Empty = error "foldl1: empty sequence"
	foldl1 _ (Single x) = x
	foldl1 f (Deep _ pr m sf) =
		foldl f (foldl (foldl f) (foldl1 f pr) m) sf

instance Functor FingerTree where
	fmap _ Empty = Empty
	fmap f (Single x) = Single (f x)
	fmap f (Deep v pr m sf) =
		Deep v (fmap f pr) (fmap (fmap f) m) (fmap f sf)

instance Traversable FingerTree where
	traverse _ Empty = pure Empty
	traverse f (Single x) = Single <$> f x
	traverse f (Deep v pr m sf) =
		Deep v <$> traverse f pr <*> traverse (traverse f) m <*>
			traverse f sf

{-# INLINE deep #-}
{-# SPECIALIZE deep :: Digit (Elem a) -> FingerTree (Node (Elem a)) -> Digit (Elem a) -> FingerTree (Elem a) #-}
{-# SPECIALIZE deep :: Digit (Node a) -> FingerTree (Node (Node a)) -> Digit (Node a) -> FingerTree (Node a) #-}
deep		:: Sized a => Digit a -> FingerTree (Node a) -> Digit a -> FingerTree a
deep pr m sf	=  Deep (size pr + size m + size sf) pr m sf

-- Digits

data Digit a
	= One a
	| Two a a
	| Three a a a
	| Four a a a a




instance Foldable Digit where
	foldr f z (One a) = a `f` z
	foldr f z (Two a b) = a `f` (b `f` z)
	foldr f z (Three a b c) = a `f` (b `f` (c `f` z))
	foldr f z (Four a b c d) = a `f` (b `f` (c `f` (d `f` z)))

	foldl f z (One a) = z `f` a
	foldl f z (Two a b) = (z `f` a) `f` b
	foldl f z (Three a b c) = ((z `f` a) `f` b) `f` c
	foldl f z (Four a b c d) = (((z `f` a) `f` b) `f` c) `f` d

	foldr1 f (One a) = a
	foldr1 f (Two a b) = a `f` b
	foldr1 f (Three a b c) = a `f` (b `f` c)
	foldr1 f (Four a b c d) = a `f` (b `f` (c `f` d))

	foldl1 f (One a) = a
	foldl1 f (Two a b) = a `f` b
	foldl1 f (Three a b c) = (a `f` b) `f` c
	foldl1 f (Four a b c d) = ((a `f` b) `f` c) `f` d

instance Functor Digit where
	fmap = fmapDefault

instance Traversable Digit where
	traverse f (One a) = One <$> f a
	traverse f (Two a b) = Two <$> f a <*> f b
	traverse f (Three a b c) = Three <$> f a <*> f b <*> f c
	traverse f (Four a b c d) = Four <$> f a <*> f b <*> f c <*> f d

instance Sized a => Sized (Digit a) where
	{-# SPECIALIZE instance Sized (Digit (Elem a)) #-}
	{-# SPECIALIZE instance Sized (Digit (Node a)) #-}
	size xs = foldl (\ i x -> i + size x) 0 xs

{-# SPECIALIZE digitToTree :: Digit (Elem a) -> FingerTree (Elem a) #-}
{-# SPECIALIZE digitToTree :: Digit (Node a) -> FingerTree (Node a) #-}
digitToTree	:: Sized a => Digit a -> FingerTree a
digitToTree (One a) = Single a
digitToTree (Two a b) = deep (One a) Empty (One b)
digitToTree (Three a b c) = deep (Two a b) Empty (One c)
digitToTree (Four a b c d) = deep (Two a b) Empty (Two c d)

-- Nodes

data Node a
	= Node2 {-# UNPACK #-} !Int a a
	| Node3 {-# UNPACK #-} !Int a a a




instance Foldable Node where
	foldr f z (Node2 _ a b) = a `f` (b `f` z)
	foldr f z (Node3 _ a b c) = a `f` (b `f` (c `f` z))

	foldl f z (Node2 _ a b) = (z `f` a) `f` b
	foldl f z (Node3 _ a b c) = ((z `f` a) `f` b) `f` c

instance Functor Node where
	fmap = fmapDefault

instance Traversable Node where
	traverse f (Node2 v a b) = Node2 v <$> f a <*> f b
	traverse f (Node3 v a b c) = Node3 v <$> f a <*> f b <*> f c

instance Sized (Node a) where
	size (Node2 v _ _)	= v
	size (Node3 v _ _ _)	= v

{-# INLINE node2 #-}
{-# SPECIALIZE node2 :: Elem a -> Elem a -> Node (Elem a) #-}
{-# SPECIALIZE node2 :: Node a -> Node a -> Node (Node a) #-}
node2		:: Sized a => a -> a -> Node a
node2 a b	=  Node2 (size a + size b) a b

{-# INLINE node3 #-}
{-# SPECIALIZE node3 :: Elem a -> Elem a -> Elem a -> Node (Elem a) #-}
{-# SPECIALIZE node3 :: Node a -> Node a -> Node a -> Node (Node a) #-}
node3		:: Sized a => a -> a -> a -> Node a
node3 a b c	=  Node3 (size a + size b + size c) a b c

nodeToDigit :: Node a -> Digit a
nodeToDigit (Node2 _ a b) = Two a b
nodeToDigit (Node3 _ a b c) = Three a b c

-- Elements

newtype Elem a  =  Elem { getElem :: a }

instance Sized (Elem a) where
	size _ = 1

instance Functor Elem where
	fmap f (Elem x) = Elem (f x)

instance Foldable Elem where
	foldr f z (Elem x) = f x z
	foldl f z (Elem x) = f z x

instance Traversable Elem where
	traverse f (Elem x) = Elem <$> f x






------------------------------------------------------------------------
-- Construction
------------------------------------------------------------------------

-- | /O(1)/. The empty sequence.
empty		:: Seq a
empty		=  Seq Empty

-- | /O(1)/. A singleton sequence.
singleton	:: a -> Seq a
singleton x	=  Seq (Single (Elem x))

-- | /O(1)/. Add an element to the left end of a sequence.
-- Mnemonic: a triangle with the single element at the pointy end.
(<|)		:: a -> Seq a -> Seq a
x <| Seq xs	=  Seq (Elem x `consTree` xs)

{-# SPECIALIZE consTree :: Elem a -> FingerTree (Elem a) -> FingerTree (Elem a) #-}
{-# SPECIALIZE consTree :: Node a -> FingerTree (Node a) -> FingerTree (Node a) #-}
consTree	:: Sized a => a -> FingerTree a -> FingerTree a
consTree a Empty	= Single a
consTree a (Single b)	= deep (One a) Empty (One b)
consTree a (Deep s (Four b c d e) m sf) = m `seq`
	Deep (size a + s) (Two a b) (node3 c d e `consTree` m) sf
consTree a (Deep s (Three b c d) m sf) =
	Deep (size a + s) (Four a b c d) m sf
consTree a (Deep s (Two b c) m sf) =
	Deep (size a + s) (Three a b c) m sf
consTree a (Deep s (One b) m sf) =
	Deep (size a + s) (Two a b) m sf

-- | /O(1)/. Add an element to the right end of a sequence.
-- Mnemonic: a triangle with the single element at the pointy end.
(|>)		:: Seq a -> a -> Seq a
Seq xs |> x	=  Seq (xs `snocTree` Elem x)

{-# SPECIALIZE snocTree :: FingerTree (Elem a) -> Elem a -> FingerTree (Elem a) #-}
{-# SPECIALIZE snocTree :: FingerTree (Node a) -> Node a -> FingerTree (Node a) #-}
snocTree	:: Sized a => FingerTree a -> a -> FingerTree a
snocTree Empty a	=  Single a
snocTree (Single a) b	=  deep (One a) Empty (One b)
snocTree (Deep s pr m (Four a b c d)) e = m `seq`
	Deep (s + size e) pr (m `snocTree` node3 a b c) (Two d e)
snocTree (Deep s pr m (Three a b c)) d =
	Deep (s + size d) pr m (Four a b c d)
snocTree (Deep s pr m (Two a b)) c =
	Deep (s + size c) pr m (Three a b c)
snocTree (Deep s pr m (One a)) b =
	Deep (s + size b) pr m (Two a b)

-- | /O(log(min(n1,n2)))/. Concatenate two sequences.
(><)		:: Seq a -> Seq a -> Seq a
Seq xs >< Seq ys = Seq (appendTree0 xs ys)

-- The appendTree/addDigits gunk below is machine generated

appendTree0 :: FingerTree (Elem a) -> FingerTree (Elem a) -> FingerTree (Elem a)
appendTree0 Empty xs =
	xs
appendTree0 xs Empty =
	xs
appendTree0 (Single x) xs =
	x `consTree` xs
appendTree0 xs (Single x) =
	xs `snocTree` x
appendTree0 (Deep s1 pr1 m1 sf1) (Deep s2 pr2 m2 sf2) =
	Deep (s1 + s2) pr1 (addDigits0 m1 sf1 pr2 m2) sf2

addDigits0 :: FingerTree (Node (Elem a)) -> Digit (Elem a) -> Digit (Elem a) -> FingerTree (Node (Elem a)) -> FingerTree (Node (Elem a))
addDigits0 m1 (One a) (One b) m2 =
	appendTree1 m1 (node2 a b) m2
addDigits0 m1 (One a) (Two b c) m2 =
	appendTree1 m1 (node3 a b c) m2
addDigits0 m1 (One a) (Three b c d) m2 =
	appendTree2 m1 (node2 a b) (node2 c d) m2
addDigits0 m1 (One a) (Four b c d e) m2 =
	appendTree2 m1 (node3 a b c) (node2 d e) m2
addDigits0 m1 (Two a b) (One c) m2 =
	appendTree1 m1 (node3 a b c) m2
addDigits0 m1 (Two a b) (Two c d) m2 =
	appendTree2 m1 (node2 a b) (node2 c d) m2
addDigits0 m1 (Two a b) (Three c d e) m2 =
	appendTree2 m1 (node3 a b c) (node2 d e) m2
addDigits0 m1 (Two a b) (Four c d e f) m2 =
	appendTree2 m1 (node3 a b c) (node3 d e f) m2
addDigits0 m1 (Three a b c) (One d) m2 =
	appendTree2 m1 (node2 a b) (node2 c d) m2
addDigits0 m1 (Three a b c) (Two d e) m2 =
	appendTree2 m1 (node3 a b c) (node2 d e) m2
addDigits0 m1 (Three a b c) (Three d e f) m2 =
	appendTree2 m1 (node3 a b c) (node3 d e f) m2
addDigits0 m1 (Three a b c) (Four d e f g) m2 =
	appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
addDigits0 m1 (Four a b c d) (One e) m2 =
	appendTree2 m1 (node3 a b c) (node2 d e) m2
addDigits0 m1 (Four a b c d) (Two e f) m2 =
	appendTree2 m1 (node3 a b c) (node3 d e f) m2
addDigits0 m1 (Four a b c d) (Three e f g) m2 =
	appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
addDigits0 m1 (Four a b c d) (Four e f g h) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2

appendTree1 :: FingerTree (Node a) -> Node a -> FingerTree (Node a) -> FingerTree (Node a)
appendTree1 Empty a xs =
	a `consTree` xs
appendTree1 xs a Empty =
	xs `snocTree` a
appendTree1 (Single x) a xs =
	x `consTree` a `consTree` xs
appendTree1 xs a (Single x) =
	xs `snocTree` a `snocTree` x
appendTree1 (Deep s1 pr1 m1 sf1) a (Deep s2 pr2 m2 sf2) =
	Deep (s1 + size a + s2) pr1 (addDigits1 m1 sf1 a pr2 m2) sf2

addDigits1 :: FingerTree (Node (Node a)) -> Digit (Node a) -> Node a -> Digit (Node a) -> FingerTree (Node (Node a)) -> FingerTree (Node (Node a))
addDigits1 m1 (One a) b (One c) m2 =
	appendTree1 m1 (node3 a b c) m2
addDigits1 m1 (One a) b (Two c d) m2 =
	appendTree2 m1 (node2 a b) (node2 c d) m2
addDigits1 m1 (One a) b (Three c d e) m2 =
	appendTree2 m1 (node3 a b c) (node2 d e) m2
addDigits1 m1 (One a) b (Four c d e f) m2 =
	appendTree2 m1 (node3 a b c) (node3 d e f) m2
addDigits1 m1 (Two a b) c (One d) m2 =
	appendTree2 m1 (node2 a b) (node2 c d) m2
addDigits1 m1 (Two a b) c (Two d e) m2 =
	appendTree2 m1 (node3 a b c) (node2 d e) m2
addDigits1 m1 (Two a b) c (Three d e f) m2 =
	appendTree2 m1 (node3 a b c) (node3 d e f) m2
addDigits1 m1 (Two a b) c (Four d e f g) m2 =
	appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
addDigits1 m1 (Three a b c) d (One e) m2 =
	appendTree2 m1 (node3 a b c) (node2 d e) m2
addDigits1 m1 (Three a b c) d (Two e f) m2 =
	appendTree2 m1 (node3 a b c) (node3 d e f) m2
addDigits1 m1 (Three a b c) d (Three e f g) m2 =
	appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
addDigits1 m1 (Three a b c) d (Four e f g h) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
addDigits1 m1 (Four a b c d) e (One f) m2 =
	appendTree2 m1 (node3 a b c) (node3 d e f) m2
addDigits1 m1 (Four a b c d) e (Two f g) m2 =
	appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
addDigits1 m1 (Four a b c d) e (Three f g h) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
addDigits1 m1 (Four a b c d) e (Four f g h i) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2

appendTree2 :: FingerTree (Node a) -> Node a -> Node a -> FingerTree (Node a) -> FingerTree (Node a)
appendTree2 Empty a b xs =
	a `consTree` b `consTree` xs
appendTree2 xs a b Empty =
	xs `snocTree` a `snocTree` b
appendTree2 (Single x) a b xs =
	x `consTree` a `consTree` b `consTree` xs
appendTree2 xs a b (Single x) =
	xs `snocTree` a `snocTree` b `snocTree` x
appendTree2 (Deep s1 pr1 m1 sf1) a b (Deep s2 pr2 m2 sf2) =
	Deep (s1 + size a + size b + s2) pr1 (addDigits2 m1 sf1 a b pr2 m2) sf2

addDigits2 :: FingerTree (Node (Node a)) -> Digit (Node a) -> Node a -> Node a -> Digit (Node a) -> FingerTree (Node (Node a)) -> FingerTree (Node (Node a))
addDigits2 m1 (One a) b c (One d) m2 =
	appendTree2 m1 (node2 a b) (node2 c d) m2
addDigits2 m1 (One a) b c (Two d e) m2 =
	appendTree2 m1 (node3 a b c) (node2 d e) m2
addDigits2 m1 (One a) b c (Three d e f) m2 =
	appendTree2 m1 (node3 a b c) (node3 d e f) m2
addDigits2 m1 (One a) b c (Four d e f g) m2 =
	appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
addDigits2 m1 (Two a b) c d (One e) m2 =
	appendTree2 m1 (node3 a b c) (node2 d e) m2
addDigits2 m1 (Two a b) c d (Two e f) m2 =
	appendTree2 m1 (node3 a b c) (node3 d e f) m2
addDigits2 m1 (Two a b) c d (Three e f g) m2 =
	appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
addDigits2 m1 (Two a b) c d (Four e f g h) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
addDigits2 m1 (Three a b c) d e (One f) m2 =
	appendTree2 m1 (node3 a b c) (node3 d e f) m2
addDigits2 m1 (Three a b c) d e (Two f g) m2 =
	appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
addDigits2 m1 (Three a b c) d e (Three f g h) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
addDigits2 m1 (Three a b c) d e (Four f g h i) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
addDigits2 m1 (Four a b c d) e f (One g) m2 =
	appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
addDigits2 m1 (Four a b c d) e f (Two g h) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
addDigits2 m1 (Four a b c d) e f (Three g h i) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
addDigits2 m1 (Four a b c d) e f (Four g h i j) m2 =
	appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2

appendTree3 :: FingerTree (Node a) -> Node a -> Node a -> Node a -> FingerTree (Node a) -> FingerTree (Node a)
appendTree3 Empty a b c xs =
	a `consTree` b `consTree` c `consTree` xs
appendTree3 xs a b c Empty =
	xs `snocTree` a `snocTree` b `snocTree` c
appendTree3 (Single x) a b c xs =
	x `consTree` a `consTree` b `consTree` c `consTree` xs
appendTree3 xs a b c (Single x) =
	xs `snocTree` a `snocTree` b `snocTree` c `snocTree` x
appendTree3 (Deep s1 pr1 m1 sf1) a b c (Deep s2 pr2 m2 sf2) =
	Deep (s1 + size a + size b + size c + s2) pr1 (addDigits3 m1 sf1 a b c pr2 m2) sf2

addDigits3 :: FingerTree (Node (Node a)) -> Digit (Node a) -> Node a -> Node a -> Node a -> Digit (Node a) -> FingerTree (Node (Node a)) -> FingerTree (Node (Node a))
addDigits3 m1 (One a) b c d (One e) m2 =
	appendTree2 m1 (node3 a b c) (node2 d e) m2
addDigits3 m1 (One a) b c d (Two e f) m2 =
	appendTree2 m1 (node3 a b c) (node3 d e f) m2
addDigits3 m1 (One a) b c d (Three e f g) m2 =
	appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
addDigits3 m1 (One a) b c d (Four e f g h) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
addDigits3 m1 (Two a b) c d e (One f) m2 =
	appendTree2 m1 (node3 a b c) (node3 d e f) m2
addDigits3 m1 (Two a b) c d e (Two f g) m2 =
	appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
addDigits3 m1 (Two a b) c d e (Three f g h) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
addDigits3 m1 (Two a b) c d e (Four f g h i) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
addDigits3 m1 (Three a b c) d e f (One g) m2 =
	appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
addDigits3 m1 (Three a b c) d e f (Two g h) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
addDigits3 m1 (Three a b c) d e f (Three g h i) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
addDigits3 m1 (Three a b c) d e f (Four g h i j) m2 =
	appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2
addDigits3 m1 (Four a b c d) e f g (One h) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
addDigits3 m1 (Four a b c d) e f g (Two h i) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
addDigits3 m1 (Four a b c d) e f g (Three h i j) m2 =
	appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2
addDigits3 m1 (Four a b c d) e f g (Four h i j k) m2 =
	appendTree4 m1 (node3 a b c) (node3 d e f) (node3 g h i) (node2 j k) m2

appendTree4 :: FingerTree (Node a) -> Node a -> Node a -> Node a -> Node a -> FingerTree (Node a) -> FingerTree (Node a)
appendTree4 Empty a b c d xs =
	a `consTree` b `consTree` c `consTree` d `consTree` xs
appendTree4 xs a b c d Empty =
	xs `snocTree` a `snocTree` b `snocTree` c `snocTree` d
appendTree4 (Single x) a b c d xs =
	x `consTree` a `consTree` b `consTree` c `consTree` d `consTree` xs
appendTree4 xs a b c d (Single x) =
	xs `snocTree` a `snocTree` b `snocTree` c `snocTree` d `snocTree` x
appendTree4 (Deep s1 pr1 m1 sf1) a b c d (Deep s2 pr2 m2 sf2) =
	Deep (s1 + size a + size b + size c + size d + s2) pr1 (addDigits4 m1 sf1 a b c d pr2 m2) sf2

addDigits4 :: FingerTree (Node (Node a)) -> Digit (Node a) -> Node a -> Node a -> Node a -> Node a -> Digit (Node a) -> FingerTree (Node (Node a)) -> FingerTree (Node (Node a))
addDigits4 m1 (One a) b c d e (One f) m2 =
	appendTree2 m1 (node3 a b c) (node3 d e f) m2
addDigits4 m1 (One a) b c d e (Two f g) m2 =
	appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
addDigits4 m1 (One a) b c d e (Three f g h) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
addDigits4 m1 (One a) b c d e (Four f g h i) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
addDigits4 m1 (Two a b) c d e f (One g) m2 =
	appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
addDigits4 m1 (Two a b) c d e f (Two g h) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
addDigits4 m1 (Two a b) c d e f (Three g h i) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
addDigits4 m1 (Two a b) c d e f (Four g h i j) m2 =
	appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2
addDigits4 m1 (Three a b c) d e f g (One h) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
addDigits4 m1 (Three a b c) d e f g (Two h i) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
addDigits4 m1 (Three a b c) d e f g (Three h i j) m2 =
	appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2
addDigits4 m1 (Three a b c) d e f g (Four h i j k) m2 =
	appendTree4 m1 (node3 a b c) (node3 d e f) (node3 g h i) (node2 j k) m2
addDigits4 m1 (Four a b c d) e f g h (One i) m2 =
	appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
addDigits4 m1 (Four a b c d) e f g h (Two i j) m2 =
	appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2
addDigits4 m1 (Four a b c d) e f g h (Three i j k) m2 =
	appendTree4 m1 (node3 a b c) (node3 d e f) (node3 g h i) (node2 j k) m2
addDigits4 m1 (Four a b c d) e f g h (Four i j k l) m2 =
	appendTree4 m1 (node3 a b c) (node3 d e f) (node3 g h i) (node3 j k l) m2

------------------------------------------------------------------------
-- Deconstruction
------------------------------------------------------------------------

-- | /O(1)/. Is this the empty sequence?
null		:: Seq a -> Bool
null (Seq Empty) = True
null _		=  False

-- | /O(1)/. The number of elements in the sequence.
length		:: Seq a -> Int
length (Seq xs) =  size xs

-- Views

data Maybe2 a b = Nothing2 | Just2 a b

-- | View of the left end of a sequence.
data ViewL a
	= EmptyL	-- ^ empty sequence
	| a :< Seq a	-- ^ leftmost element and the rest of the sequence




	deriving (Eq, Ord, Show, Read)









viewLTc = mkTyCon "ViewL"; instance Typeable1 ViewL where { typeOf1 _ = mkTyConApp viewLTc [] }; instance Typeable a => Typeable (ViewL a) where { typeOf = typeOfDefault }

instance Functor ViewL where
	fmap = fmapDefault

instance Foldable ViewL where
	foldr f z EmptyL = z
	foldr f z (x :< xs) = f x (foldr f z xs)

	foldl f z EmptyL = z
	foldl f z (x :< xs) = foldl f (f z x) xs

	foldl1 f EmptyL = error "foldl1: empty view"
	foldl1 f (x :< xs) = foldl f x xs

instance Traversable ViewL where
	traverse _ EmptyL	= pure EmptyL
	traverse f (x :< xs)	= (:<) <$> f x <*> traverse f xs

-- | /O(1)/. Analyse the left end of a sequence.
viewl		::  Seq a -> ViewL a
viewl (Seq xs)	=  case viewLTree xs of
	Nothing2 -> EmptyL
	Just2 (Elem x) xs' -> x :< Seq xs'

{-# SPECIALIZE viewLTree :: FingerTree (Elem a) -> Maybe2 (Elem a) (FingerTree (Elem a)) #-}
{-# SPECIALIZE viewLTree :: FingerTree (Node a) -> Maybe2 (Node a) (FingerTree (Node a)) #-}
viewLTree	:: Sized a => FingerTree a -> Maybe2 a (FingerTree a)
viewLTree Empty			= Nothing2
viewLTree (Single a)		= Just2 a Empty
viewLTree (Deep s (One a) m sf) = Just2 a (case viewLTree m of
	Nothing2	-> digitToTree sf
	Just2 b m'	-> Deep (s - size a) (nodeToDigit b) m' sf)
viewLTree (Deep s (Two a b) m sf) =
	Just2 a (Deep (s - size a) (One b) m sf)
viewLTree (Deep s (Three a b c) m sf) =
	Just2 a (Deep (s - size a) (Two b c) m sf)
viewLTree (Deep s (Four a b c d) m sf) =
	Just2 a (Deep (s - size a) (Three b c d) m sf)

-- | View of the right end of a sequence.
data ViewR a
	= EmptyR	-- ^ empty sequence
	| Seq a :> a	-- ^ the sequence minus the rightmost element,
			-- and the rightmost element




	deriving (Eq, Ord, Show, Read)









viewRTc = mkTyCon "ViewR"; instance Typeable1 ViewR where { typeOf1 _ = mkTyConApp viewRTc [] }; instance Typeable a => Typeable (ViewR a) where { typeOf = typeOfDefault }

instance Functor ViewR where
	fmap = fmapDefault

instance Foldable ViewR where
	foldr f z EmptyR = z
	foldr f z (xs :> x) = foldr f (f x z) xs

	foldl f z EmptyR = z
	foldl f z (xs :> x) = f (foldl f z xs) x

	foldr1 f EmptyR = error "foldr1: empty view"
	foldr1 f (xs :> x) = foldr f x xs

instance Traversable ViewR where
	traverse _ EmptyR	= pure EmptyR
	traverse f (xs :> x)	= (:>) <$> traverse f xs <*> f x

-- | /O(1)/. Analyse the right end of a sequence.
viewr		::  Seq a -> ViewR a
viewr (Seq xs)	=  case viewRTree xs of
	Nothing2 -> EmptyR
	Just2 xs' (Elem x) -> Seq xs' :> x

{-# SPECIALIZE viewRTree :: FingerTree (Elem a) -> Maybe2 (FingerTree (Elem a)) (Elem a) #-}
{-# SPECIALIZE viewRTree :: FingerTree (Node a) -> Maybe2 (FingerTree (Node a)) (Node a) #-}
viewRTree	:: Sized a => FingerTree a -> Maybe2 (FingerTree a) a
viewRTree Empty			= Nothing2
viewRTree (Single z)		= Just2 Empty z
viewRTree (Deep s pr m (One z)) = Just2 (case viewRTree m of
	Nothing2	->  digitToTree pr
	Just2 m' y	->  Deep (s - size z) pr m' (nodeToDigit y)) z
viewRTree (Deep s pr m (Two y z)) =
	Just2 (Deep (s - size z) pr m (One y)) z
viewRTree (Deep s pr m (Three x y z)) =
	Just2 (Deep (s - size z) pr m (Two x y)) z
viewRTree (Deep s pr m (Four w x y z)) =
	Just2 (Deep (s - size z) pr m (Three w x y)) z

-- Indexing

-- | /O(log(min(i,n-i)))/. The element at the specified position
index		:: Seq a -> Int -> a
index (Seq xs) i
  | 0 <= i && i < size xs = case lookupTree i xs of
				Place _ (Elem x) -> x
  | otherwise	= error "index out of bounds"

data Place a = Place {-# UNPACK #-} !Int a




{-# SPECIALIZE lookupTree :: Int -> FingerTree (Elem a) -> Place (Elem a) #-}
{-# SPECIALIZE lookupTree :: Int -> FingerTree (Node a) -> Place (Node a) #-}
lookupTree :: Sized a => Int -> FingerTree a -> Place a
lookupTree _ Empty = error "lookupTree of empty tree"
lookupTree i (Single x) = Place i x
lookupTree i (Deep _ pr m sf)
  | i < spr	=  lookupDigit i pr
  | i < spm	=  case lookupTree (i - spr) m of
			Place i' xs -> lookupNode i' xs
  | otherwise	=  lookupDigit (i - spm) sf
  where	spr	= size pr
	spm	= spr + size m

{-# SPECIALIZE lookupNode :: Int -> Node (Elem a) -> Place (Elem a) #-}
{-# SPECIALIZE lookupNode :: Int -> Node (Node a) -> Place (Node a) #-}
lookupNode :: Sized a => Int -> Node a -> Place a
lookupNode i (Node2 _ a b)
  | i < sa	= Place i a
  | otherwise	= Place (i - sa) b
  where	sa	= size a
lookupNode i (Node3 _ a b c)
  | i < sa	= Place i a
  | i < sab	= Place (i - sa) b
  | otherwise	= Place (i - sab) c
  where	sa	= size a
	sab	= sa + size b

{-# SPECIALIZE lookupDigit :: Int -> Digit (Elem a) -> Place (Elem a) #-}
{-# SPECIALIZE lookupDigit :: Int -> Digit (Node a) -> Place (Node a) #-}
lookupDigit :: Sized a => Int -> Digit a -> Place a
lookupDigit i (One a) = Place i a
lookupDigit i (Two a b)
  | i < sa	= Place i a
  | otherwise	= Place (i - sa) b
  where	sa	= size a
lookupDigit i (Three a b c)
  | i < sa	= Place i a
  | i < sab	= Place (i - sa) b
  | otherwise	= Place (i - sab) c
  where	sa	= size a
	sab	= sa + size b
lookupDigit i (Four a b c d)
  | i < sa	= Place i a
  | i < sab	= Place (i - sa) b
  | i < sabc	= Place (i - sab) c
  | otherwise	= Place (i - sabc) d
  where	sa	= size a
	sab	= sa + size b
	sabc	= sab + size c

-- | /O(log(min(i,n-i)))/. Replace the element at the specified position
update		:: Int -> a -> Seq a -> Seq a
update i x	= adjust (const x) i

-- | /O(log(min(i,n-i)))/. Update the element at the specified position
adjust		:: (a -> a) -> Int -> Seq a -> Seq a
adjust f i (Seq xs)
  | 0 <= i && i < size xs = Seq (adjustTree (const (fmap f)) i xs)
  | otherwise	= Seq xs

{-# SPECIALIZE adjustTree :: (Int -> Elem a -> Elem a) -> Int -> FingerTree (Elem a) -> FingerTree (Elem a) #-}
{-# SPECIALIZE adjustTree :: (Int -> Node a -> Node a) -> Int -> FingerTree (Node a) -> FingerTree (Node a) #-}
adjustTree	:: Sized a => (Int -> a -> a) ->
			Int -> FingerTree a -> FingerTree a
adjustTree _ _ Empty = error "adjustTree of empty tree"
adjustTree f i (Single x) = Single (f i x)
adjustTree f i (Deep s pr m sf)
  | i < spr	= Deep s (adjustDigit f i pr) m sf
  | i < spm	= Deep s pr (adjustTree (adjustNode f) (i - spr) m) sf
  | otherwise	= Deep s pr m (adjustDigit f (i - spm) sf)
  where	spr	= size pr
	spm	= spr + size m

{-# SPECIALIZE adjustNode :: (Int -> Elem a -> Elem a) -> Int -> Node (Elem a) -> Node (Elem a) #-}
{-# SPECIALIZE adjustNode :: (Int -> Node a -> Node a) -> Int -> Node (Node a) -> Node (Node a) #-}
adjustNode	:: Sized a => (Int -> a -> a) -> Int -> Node a -> Node a
adjustNode f i (Node2 s a b)
  | i < sa	= Node2 s (f i a) b
  | otherwise	= Node2 s a (f (i - sa) b)
  where	sa	= size a
adjustNode f i (Node3 s a b c)
  | i < sa	= Node3 s (f i a) b c
  | i < sab	= Node3 s a (f (i - sa) b) c
  | otherwise	= Node3 s a b (f (i - sab) c)
  where	sa	= size a
	sab	= sa + size b

{-# SPECIALIZE adjustDigit :: (Int -> Elem a -> Elem a) -> Int -> Digit (Elem a) -> Digit (Elem a) #-}
{-# SPECIALIZE adjustDigit :: (Int -> Node a -> Node a) -> Int -> Digit (Node a) -> Digit (Node a) #-}
adjustDigit	:: Sized a => (Int -> a -> a) -> Int -> Digit a -> Digit a
adjustDigit f i (One a) = One (f i a)
adjustDigit f i (Two a b)
  | i < sa	= Two (f i a) b
  | otherwise	= Two a (f (i - sa) b)
  where	sa	= size a
adjustDigit f i (Three a b c)
  | i < sa	= Three (f i a) b c
  | i < sab	= Three a (f (i - sa) b) c
  | otherwise	= Three a b (f (i - sab) c)
  where	sa	= size a
	sab	= sa + size b
adjustDigit f i (Four a b c d)
  | i < sa	= Four (f i a) b c d
  | i < sab	= Four a (f (i - sa) b) c d
  | i < sabc	= Four a b (f (i - sab) c) d
  | otherwise	= Four a b c (f (i- sabc) d)
  where	sa	= size a
	sab	= sa + size b
	sabc	= sab + size c

-- Splitting

-- | /O(log(min(i,n-i)))/. The first @i@ elements of a sequence.
take		:: Int -> Seq a -> Seq a
take i		=  fst . splitAt i

-- | /O(log(min(i,n-i)))/. Elements of a sequence after the first @i@.
drop		:: Int -> Seq a -> Seq a
drop i		=  snd . splitAt i

-- | /O(log(min(i,n-i)))/. Split a sequence at a given position.
splitAt			:: Int -> Seq a -> (Seq a, Seq a)
splitAt i (Seq xs)	=  (Seq l, Seq r)
  where	(l, r)		=  split i xs

split :: Int -> FingerTree (Elem a) ->
	(FingerTree (Elem a), FingerTree (Elem a))
split i Empty	= i `seq` (Empty, Empty)
split i xs
  | size xs > i	= (l, consTree x r)
  | otherwise	= (xs, Empty)
  where Split l x r = splitTree i xs

data Split t a = Split t a t




{-# SPECIALIZE splitTree :: Int -> FingerTree (Elem a) -> Split (FingerTree (Elem a)) (Elem a) #-}
{-# SPECIALIZE splitTree :: Int -> FingerTree (Node a) -> Split (FingerTree (Node a)) (Node a) #-}
splitTree :: Sized a => Int -> FingerTree a -> Split (FingerTree a) a
splitTree _ Empty = error "splitTree of empty tree"
splitTree i (Single x) = i `seq` Split Empty x Empty
splitTree i (Deep _ pr m sf)
  | i < spr	= case splitDigit i pr of
			Split l x r -> Split (maybe Empty digitToTree l) x (deepL r m sf)
  | i < spm	= case splitTree im m of
			Split ml xs mr -> case splitNode (im - size ml) xs of
			    Split l x r -> Split (deepR pr  ml l) x (deepL r mr sf)
  | otherwise	= case splitDigit (i - spm) sf of
			Split l x r -> Split (deepR pr  m  l) x (maybe Empty digitToTree r)
  where	spr	= size pr
	spm	= spr + size m
	im	= i - spr

{-# SPECIALIZE deepL :: Maybe (Digit (Elem a)) -> FingerTree (Node (Elem a)) -> Digit (Elem a) -> FingerTree (Elem a) #-}
{-# SPECIALIZE deepL :: Maybe (Digit (Node a)) -> FingerTree (Node (Node a)) -> Digit (Node a) -> FingerTree (Node a) #-}
deepL :: Sized a => Maybe (Digit a) -> FingerTree (Node a) -> Digit a -> FingerTree a
deepL Nothing m sf	= case viewLTree m of
	Nothing2	-> digitToTree sf
	Just2 a m'	-> deep (nodeToDigit a) m' sf
deepL (Just pr) m sf	= deep pr m sf

{-# SPECIALIZE deepR :: Digit (Elem a) -> FingerTree (Node (Elem a)) -> Maybe (Digit (Elem a)) -> FingerTree (Elem a) #-}
{-# SPECIALIZE deepR :: Digit (Node a) -> FingerTree (Node (Node a)) -> Maybe (Digit (Node a)) -> FingerTree (Node a) #-}
deepR :: Sized a => Digit a -> FingerTree (Node a) -> Maybe (Digit a) -> FingerTree a
deepR pr m Nothing	= case viewRTree m of
	Nothing2	-> digitToTree pr
	Just2 m' a	-> deep pr m' (nodeToDigit a)
deepR pr m (Just sf)	= deep pr m sf

{-# SPECIALIZE splitNode :: Int -> Node (Elem a) -> Split (Maybe (Digit (Elem a))) (Elem a) #-}
{-# SPECIALIZE splitNode :: Int -> Node (Node a) -> Split (Maybe (Digit (Node a))) (Node a) #-}
splitNode :: Sized a => Int -> Node a -> Split (Maybe (Digit a)) a
splitNode i (Node2 _ a b)
  | i < sa	= Split Nothing a (Just (One b))
  | otherwise	= Split (Just (One a)) b Nothing
  where	sa	= size a
splitNode i (Node3 _ a b c)
  | i < sa	= Split Nothing a (Just (Two b c))
  | i < sab	= Split (Just (One a)) b (Just (One c))
  | otherwise	= Split (Just (Two a b)) c Nothing
  where	sa	= size a
	sab	= sa + size b

{-# SPECIALIZE splitDigit :: Int -> Digit (Elem a) -> Split (Maybe (Digit (Elem a))) (Elem a) #-}
{-# SPECIALIZE splitDigit :: Int -> Digit (Node a) -> Split (Maybe (Digit (Node a))) (Node a) #-}
splitDigit :: Sized a => Int -> Digit a -> Split (Maybe (Digit a)) a
splitDigit i (One a) = i `seq` Split Nothing a Nothing
splitDigit i (Two a b)
  | i < sa	= Split Nothing a (Just (One b))
  | otherwise	= Split (Just (One a)) b Nothing
  where	sa	= size a
splitDigit i (Three a b c)
  | i < sa	= Split Nothing a (Just (Two b c))
  | i < sab	= Split (Just (One a)) b (Just (One c))
  | otherwise	= Split (Just (Two a b)) c Nothing
  where	sa	= size a
	sab	= sa + size b
splitDigit i (Four a b c d)
  | i < sa	= Split Nothing a (Just (Three b c d))
  | i < sab	= Split (Just (One a)) b (Just (Two c d))
  | i < sabc	= Split (Just (Two a b)) c (Just (One d))
  | otherwise	= Split (Just (Three a b c)) d Nothing
  where	sa	= size a
	sab	= sa + size b
	sabc	= sab + size c

------------------------------------------------------------------------
-- Lists
------------------------------------------------------------------------

-- | /O(n)/. Create a sequence from a finite list of elements.
fromList  	:: [a] -> Seq a
fromList  	=  Data.List.foldl' (|>) empty

------------------------------------------------------------------------
-- Reverse
------------------------------------------------------------------------

-- | /O(n)/. The reverse of a sequence.
reverse :: Seq a -> Seq a
reverse (Seq xs) = Seq (reverseTree id xs)

reverseTree :: (a -> a) -> FingerTree a -> FingerTree a
reverseTree _ Empty = Empty
reverseTree f (Single x) = Single (f x)
reverseTree f (Deep s pr m sf) =
	Deep s (reverseDigit f sf)
		(reverseTree (reverseNode f) m)
		(reverseDigit f pr)

reverseDigit :: (a -> a) -> Digit a -> Digit a
reverseDigit f (One a) = One (f a)
reverseDigit f (Two a b) = Two (f b) (f a)
reverseDigit f (Three a b c) = Three (f c) (f b) (f a)
reverseDigit f (Four a b c d) = Four (f d) (f c) (f b) (f a)

reverseNode :: (a -> a) -> Node a -> Node a
reverseNode f (Node2 s a b) = Node2 s (f b) (f a)
reverseNode f (Node3 s a b c) = Node3 s (f c) (f b) (f a)

















































































-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Set
-- Copyright   :  (c) Daan Leijen 2002
-- License     :  BSD-style
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- An efficient implementation of sets.
--
-- Since many function names (but not the type name) clash with
-- "Prelude" names, this module is usually imported @qualified@, e.g.
--
-- >  import Data.Set (Set)
-- >  import qualified Data.Set as Set
--
-- The implementation of 'Set' is based on /size balanced/ binary trees (or
-- trees of /bounded balance/) as described by:
--
--    * Stephen Adams, \"/Efficient sets: a balancing act/\",
--	Journal of Functional Programming 3(4):553-562, October 1993,
--	<http://www.swiss.ai.mit.edu/~adams/BB>.
--
--    * J. Nievergelt and E.M. Reingold,
--	\"/Binary search trees of bounded balance/\",
--	SIAM journal of computing 2(1), March 1973.
--
-- Note that the implementation is /left-biased/ -- the elements of a
-- first argument are always preferred to the second, for example in
-- 'union' or 'insert'.  Of course, left-biasing can only be observed
-- when equality is an equivalence relation instead of structural
-- equality.
-----------------------------------------------------------------------------

module Data.Set  ( 
            -- * Set type
              Set          -- instance Eq,Ord,Show,Read,Data,Typeable

            -- * Operators
            , (\\)

            -- * Query
            , null
            , size
            , member
            , notMember
            , isSubsetOf
            , isProperSubsetOf
            
            -- * Construction
            , empty
            , singleton
            , insert
            , delete
            
            -- * Combine
            , union, unions
            , difference
            , intersection
            
            -- * Filter
            , filter
            , partition
            , split
            , splitMember

            -- * Map
	    , map
	    , mapMonotonic

            -- * Fold
            , fold

            -- * Min\/Max
            , findMin
            , findMax
            , deleteMin
            , deleteMax
            , deleteFindMin
            , deleteFindMax
            , maxView
            , minView

            -- * Conversion

            -- ** List
            , elems
            , toList
            , fromList
            
            -- ** Ordered list
            , toAscList
            , fromAscList
            , fromDistinctAscList
                        
            -- * Debugging
            , showTree
            , showTreeWith
            , valid
            ) where

import Prelude hiding (filter,foldr,null,map)
import qualified Data.List as List
import Data.Monoid (Monoid(..))
import Data.Typeable
import Data.Foldable (Foldable(foldMap))

{-
-- just for testing
import QuickCheck 
import List (nub,sort)
import qualified List
-}







{--------------------------------------------------------------------
  Operators
--------------------------------------------------------------------}
infixl 9 \\ --

-- | /O(n+m)/. See 'difference'.
(\\) :: Ord a => Set a -> Set a -> Set a
m1 \\ m2 = difference m1 m2

{--------------------------------------------------------------------
  Sets are size balanced trees
--------------------------------------------------------------------}
-- | A set of values @a@.
data Set a    = Tip 
              | Bin {-# UNPACK #-} !Size a !(Set a) !(Set a) 

type Size     = Int

instance Ord a => Monoid (Set a) where
    mempty  = empty
    mappend = union
    mconcat = unions

instance Foldable Set where
    foldMap f Tip = mempty
    foldMap f (Bin _s k l r) = foldMap f l `mappend` f k `mappend` foldMap f r



















{--------------------------------------------------------------------
  Query
--------------------------------------------------------------------}
-- | /O(1)/. Is this the empty set?
null :: Set a -> Bool
null t
  = case t of
      Tip           -> True
      Bin sz x l r  -> False

-- | /O(1)/. The number of elements in the set.
size :: Set a -> Int
size t
  = case t of
      Tip           -> 0
      Bin sz x l r  -> sz

-- | /O(log n)/. Is the element in the set?
member :: Ord a => a -> Set a -> Bool
member x t
  = case t of
      Tip -> False
      Bin sz y l r
          -> case compare x y of
               LT -> member x l
               GT -> member x r
               EQ -> True       

-- | /O(log n)/. Is the element not in the set?
notMember :: Ord a => a -> Set a -> Bool
notMember x t = not $ member x t

{--------------------------------------------------------------------
  Construction
--------------------------------------------------------------------}
-- | /O(1)/. The empty set.
empty  :: Set a
empty
  = Tip

-- | /O(1)/. Create a singleton set.
singleton :: a -> Set a
singleton x 
  = Bin 1 x Tip Tip

{--------------------------------------------------------------------
  Insertion, Deletion
--------------------------------------------------------------------}
-- | /O(log n)/. Insert an element in a set.
-- If the set already contains an element equal to the given value,
-- it is replaced with the new value.
insert :: Ord a => a -> Set a -> Set a
insert x t
  = case t of
      Tip -> singleton x
      Bin sz y l r
          -> case compare x y of
               LT -> balance y (insert x l) r
               GT -> balance y l (insert x r)
               EQ -> Bin sz x l r


-- | /O(log n)/. Delete an element from a set.
delete :: Ord a => a -> Set a -> Set a
delete x t
  = case t of
      Tip -> Tip
      Bin sz y l r 
          -> case compare x y of
               LT -> balance y (delete x l) r
               GT -> balance y l (delete x r)
               EQ -> glue l r

{--------------------------------------------------------------------
  Subset
--------------------------------------------------------------------}
-- | /O(n+m)/. Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
isProperSubsetOf s1 s2
    = (size s1 < size s2) && (isSubsetOf s1 s2)


-- | /O(n+m)/. Is this a subset?
-- @(s1 `isSubsetOf` s2)@ tells whether @s1@ is a subset of @s2@.
isSubsetOf :: Ord a => Set a -> Set a -> Bool
isSubsetOf t1 t2
  = (size t1 <= size t2) && (isSubsetOfX t1 t2)

isSubsetOfX Tip t = True
isSubsetOfX t Tip = False
isSubsetOfX (Bin _ x l r) t
  = found && isSubsetOfX l lt && isSubsetOfX r gt
  where
    (lt,found,gt) = splitMember x t


{--------------------------------------------------------------------
  Minimal, Maximal
--------------------------------------------------------------------}
-- | /O(log n)/. The minimal element of a set.
findMin :: Set a -> a
findMin (Bin _ x Tip r) = x
findMin (Bin _ x l r)   = findMin l
findMin Tip             = error "Set.findMin: empty set has no minimal element"

-- | /O(log n)/. The maximal element of a set.
findMax :: Set a -> a
findMax (Bin _ x l Tip)  = x
findMax (Bin _ x l r)    = findMax r
findMax Tip              = error "Set.findMax: empty set has no maximal element"

-- | /O(log n)/. Delete the minimal element.
deleteMin :: Set a -> Set a
deleteMin (Bin _ x Tip r) = r
deleteMin (Bin _ x l r)   = balance x (deleteMin l) r
deleteMin Tip             = Tip

-- | /O(log n)/. Delete the maximal element.
deleteMax :: Set a -> Set a
deleteMax (Bin _ x l Tip) = l
deleteMax (Bin _ x l r)   = balance x l (deleteMax r)
deleteMax Tip             = Tip


{--------------------------------------------------------------------
  Union. 
--------------------------------------------------------------------}
-- | The union of a list of sets: (@'unions' == 'foldl' 'union' 'empty'@).
unions :: Ord a => [Set a] -> Set a
unions ts
  = foldlStrict union empty ts


-- | /O(n+m)/. The union of two sets, preferring the first set when
-- equal elements are encountered.
-- The implementation uses the efficient /hedge-union/ algorithm.
-- Hedge-union is more efficient on (bigset `union` smallset).
union :: Ord a => Set a -> Set a -> Set a
union Tip t2  = t2
union t1 Tip  = t1
union t1 t2 = hedgeUnion (const LT) (const GT) t1 t2

hedgeUnion cmplo cmphi t1 Tip 
  = t1
hedgeUnion cmplo cmphi Tip (Bin _ x l r)
  = join x (filterGt cmplo l) (filterLt cmphi r)
hedgeUnion cmplo cmphi (Bin _ x l r) t2
  = join x (hedgeUnion cmplo cmpx l (trim cmplo cmpx t2)) 
           (hedgeUnion cmpx cmphi r (trim cmpx cmphi t2))
  where
    cmpx y  = compare x y

{--------------------------------------------------------------------
  Difference
--------------------------------------------------------------------}
-- | /O(n+m)/. Difference of two sets. 
-- The implementation uses an efficient /hedge/ algorithm comparable with /hedge-union/.
difference :: Ord a => Set a -> Set a -> Set a
difference Tip t2  = Tip
difference t1 Tip  = t1
difference t1 t2   = hedgeDiff (const LT) (const GT) t1 t2

hedgeDiff cmplo cmphi Tip t     
  = Tip
hedgeDiff cmplo cmphi (Bin _ x l r) Tip 
  = join x (filterGt cmplo l) (filterLt cmphi r)
hedgeDiff cmplo cmphi t (Bin _ x l r) 
  = merge (hedgeDiff cmplo cmpx (trim cmplo cmpx t) l) 
          (hedgeDiff cmpx cmphi (trim cmpx cmphi t) r)
  where
    cmpx y = compare x y

{--------------------------------------------------------------------
  Intersection
--------------------------------------------------------------------}
-- | /O(n+m)/. The intersection of two sets.
-- Elements of the result come from the first set.
intersection :: Ord a => Set a -> Set a -> Set a
intersection Tip t = Tip
intersection t Tip = Tip
intersection t1@(Bin s1 x1 l1 r1) t2@(Bin s2 x2 l2 r2) =
   if s1 >= s2 then
      let (lt,found,gt) = splitLookup x2 t1
          tl            = intersection lt l2
          tr            = intersection gt r2
      in case found of
      Just x -> join x tl tr
      Nothing -> merge tl tr
   else let (lt,found,gt) = splitMember x1 t2
            tl            = intersection l1 lt
            tr            = intersection r1 gt
        in if found then join x1 tl tr
           else merge tl tr

{--------------------------------------------------------------------
  Filter and partition
--------------------------------------------------------------------}
-- | /O(n)/. Filter all elements that satisfy the predicate.
filter :: Ord a => (a -> Bool) -> Set a -> Set a
filter p Tip = Tip
filter p (Bin _ x l r)
  | p x       = join x (filter p l) (filter p r)
  | otherwise = merge (filter p l) (filter p r)

-- | /O(n)/. Partition the set into two sets, one with all elements that satisfy
-- the predicate and one with all elements that don't satisfy the predicate.
-- See also 'split'.
partition :: Ord a => (a -> Bool) -> Set a -> (Set a,Set a)
partition p Tip = (Tip,Tip)
partition p (Bin _ x l r)
  | p x       = (join x l1 r1,merge l2 r2)
  | otherwise = (merge l1 r1,join x l2 r2)
  where
    (l1,l2) = partition p l
    (r1,r2) = partition p r

{----------------------------------------------------------------------
  Map
----------------------------------------------------------------------}

-- | /O(n*log n)/. 
-- @'map' f s@ is the set obtained by applying @f@ to each element of @s@.
-- 
-- It's worth noting that the size of the result may be smaller if,
-- for some @(x,y)@, @x \/= y && f x == f y@

map :: (Ord a, Ord b) => (a->b) -> Set a -> Set b
map f = fromList . List.map f . toList

-- | /O(n)/. The 
--
-- @'mapMonotonic' f s == 'map' f s@, but works only when @f@ is monotonic.
-- /The precondition is not checked./
-- Semi-formally, we have:
-- 
-- > and [x < y ==> f x < f y | x <- ls, y <- ls] 
-- >                     ==> mapMonotonic f s == map f s
-- >     where ls = toList s

mapMonotonic :: (a->b) -> Set a -> Set b
mapMonotonic f Tip = Tip
mapMonotonic f (Bin sz x l r) =
    Bin sz (f x) (mapMonotonic f l) (mapMonotonic f r)


{--------------------------------------------------------------------
  Fold
--------------------------------------------------------------------}
-- | /O(n)/. Fold over the elements of a set in an unspecified order.
fold :: (a -> b -> b) -> b -> Set a -> b
fold f z s
  = foldr f z s

-- | /O(n)/. Post-order fold.
foldr :: (a -> b -> b) -> b -> Set a -> b
foldr f z Tip           = z
foldr f z (Bin _ x l r) = foldr f (f x (foldr f z r)) l

{--------------------------------------------------------------------
  List variations 
--------------------------------------------------------------------}
-- | /O(n)/. The elements of a set.
elems :: Set a -> [a]
elems s
  = toList s

{--------------------------------------------------------------------
  Lists 
--------------------------------------------------------------------}
-- | /O(n)/. Convert the set to a list of elements.
toList :: Set a -> [a]
toList s
  = toAscList s

-- | /O(n)/. Convert the set to an ascending list of elements.
toAscList :: Set a -> [a]
toAscList t   
  = foldr (:) [] t


-- | /O(n*log n)/. Create a set from a list of elements.
fromList :: Ord a => [a] -> Set a 
fromList xs 
  = foldlStrict ins empty xs
  where
    ins t x = insert x t

{--------------------------------------------------------------------
  Building trees from ascending/descending lists can be done in linear time.
  
  Note that if [xs] is ascending that: 
    fromAscList xs == fromList xs
--------------------------------------------------------------------}
-- | /O(n)/. Build a set from an ascending list in linear time.
-- /The precondition (input list is ascending) is not checked./
fromAscList :: Eq a => [a] -> Set a 
fromAscList xs
  = fromDistinctAscList (combineEq xs)
  where
  -- [combineEq xs] combines equal elements with [const] in an ordered list [xs]
  combineEq xs
    = case xs of
        []     -> []
        [x]    -> [x]
        (x:xx) -> combineEq' x xx

  combineEq' z [] = [z]
  combineEq' z (x:xs)
    | z==x      = combineEq' z xs
    | otherwise = z:combineEq' x xs


-- | /O(n)/. Build a set from an ascending list of distinct elements in linear time.
-- /The precondition (input list is strictly ascending) is not checked./
fromDistinctAscList :: [a] -> Set a 
fromDistinctAscList xs
  = build const (length xs) xs
  where
    -- 1) use continutations so that we use heap space instead of stack space.
    -- 2) special case for n==5 to build bushier trees. 
    build c 0 xs   = c Tip xs 
    build c 5 xs   = case xs of
                       (x1:x2:x3:x4:x5:xx) 
                            -> c (bin x4 (bin x2 (singleton x1) (singleton x3)) (singleton x5)) xx
    build c n xs   = seq nr $ build (buildR nr c) nl xs
                   where
                     nl = n `div` 2
                     nr = n - nl - 1

    buildR n c l (x:ys) = build (buildB l x c) n ys
    buildB l x c r zs   = c (bin x l r) zs

{--------------------------------------------------------------------
  Eq converts the set to a list. In a lazy setting, this 
  actually seems one of the faster methods to compare two trees 
  and it is certainly the simplest :-)
--------------------------------------------------------------------}
instance Eq a => Eq (Set a) where
  t1 == t2  = (size t1 == size t2) && (toAscList t1 == toAscList t2)

{--------------------------------------------------------------------
  Ord 
--------------------------------------------------------------------}

instance Ord a => Ord (Set a) where
    compare s1 s2 = compare (toAscList s1) (toAscList s2) 

{--------------------------------------------------------------------
  Show
--------------------------------------------------------------------}
instance Show a => Show (Set a) where
  showsPrec p xs = showParen (p > 10) $
    showString "fromList " . shows (toList xs)

showSet :: (Show a) => [a] -> ShowS
showSet []     
  = showString "{}" 
showSet (x:xs) 
  = showChar '{' . shows x . showTail xs
  where
    showTail []     = showChar '}'
    showTail (x:xs) = showChar ',' . shows x . showTail xs

{--------------------------------------------------------------------
  Read
--------------------------------------------------------------------}
instance (Read a, Ord a) => Read (Set a) where








  readsPrec p = readParen (p > 10) $ \ r -> do
    ("fromList",s) <- lex r
    (xs,t) <- reads s
    return (fromList xs,t)


{--------------------------------------------------------------------
  Typeable/Data
--------------------------------------------------------------------}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      























































setTc = mkTyCon "Set"; instance Typeable1 Set where { typeOf1 _ = mkTyConApp setTc [] }; instance Typeable a => Typeable (Set a) where { typeOf = typeOfDefault }

{--------------------------------------------------------------------
  Utility functions that return sub-ranges of the original
  tree. Some functions take a comparison function as argument to
  allow comparisons against infinite values. A function [cmplo x]
  should be read as [compare lo x].

  [trim cmplo cmphi t]  A tree that is either empty or where [cmplo x == LT]
                        and [cmphi x == GT] for the value [x] of the root.
  [filterGt cmp t]      A tree where for all values [k]. [cmp k == LT]
  [filterLt cmp t]      A tree where for all values [k]. [cmp k == GT]

  [split k t]           Returns two trees [l] and [r] where all values
                        in [l] are <[k] and all keys in [r] are >[k].
  [splitMember k t]     Just like [split] but also returns whether [k]
                        was found in the tree.
--------------------------------------------------------------------}

{--------------------------------------------------------------------
  [trim lo hi t] trims away all subtrees that surely contain no
  values between the range [lo] to [hi]. The returned tree is either
  empty or the key of the root is between @lo@ and @hi@.
--------------------------------------------------------------------}
trim :: (a -> Ordering) -> (a -> Ordering) -> Set a -> Set a
trim cmplo cmphi Tip = Tip
trim cmplo cmphi t@(Bin sx x l r)
  = case cmplo x of
      LT -> case cmphi x of
              GT -> t
              le -> trim cmplo cmphi l
      ge -> trim cmplo cmphi r
              
trimMemberLo :: Ord a => a -> (a -> Ordering) -> Set a -> (Bool, Set a)
trimMemberLo lo cmphi Tip = (False,Tip)
trimMemberLo lo cmphi t@(Bin sx x l r)
  = case compare lo x of
      LT -> case cmphi x of
              GT -> (member lo t, t)
              le -> trimMemberLo lo cmphi l
      GT -> trimMemberLo lo cmphi r
      EQ -> (True,trim (compare lo) cmphi r)


{--------------------------------------------------------------------
  [filterGt x t] filter all values >[x] from tree [t]
  [filterLt x t] filter all values <[x] from tree [t]
--------------------------------------------------------------------}
filterGt :: (a -> Ordering) -> Set a -> Set a
filterGt cmp Tip = Tip
filterGt cmp (Bin sx x l r)
  = case cmp x of
      LT -> join x (filterGt cmp l) r
      GT -> filterGt cmp r
      EQ -> r
      
filterLt :: (a -> Ordering) -> Set a -> Set a
filterLt cmp Tip = Tip
filterLt cmp (Bin sx x l r)
  = case cmp x of
      LT -> filterLt cmp l
      GT -> join x l (filterLt cmp r)
      EQ -> l


{--------------------------------------------------------------------
  Split
--------------------------------------------------------------------}
-- | /O(log n)/. The expression (@'split' x set@) is a pair @(set1,set2)@
-- where all elements in @set1@ are lower than @x@ and all elements in
-- @set2@ larger than @x@. @x@ is not found in neither @set1@ nor @set2@.
split :: Ord a => a -> Set a -> (Set a,Set a)
split x Tip = (Tip,Tip)
split x (Bin sy y l r)
  = case compare x y of
      LT -> let (lt,gt) = split x l in (lt,join y gt r)
      GT -> let (lt,gt) = split x r in (join y l lt,gt)
      EQ -> (l,r)

-- | /O(log n)/. Performs a 'split' but also returns whether the pivot
-- element was found in the original set.
splitMember :: Ord a => a -> Set a -> (Set a,Bool,Set a)
splitMember x t = let (l,m,r) = splitLookup x t in
     (l,maybe False (const True) m,r)

-- | /O(log n)/. Performs a 'split' but also returns the pivot
-- element that was found in the original set.
splitLookup :: Ord a => a -> Set a -> (Set a,Maybe a,Set a)
splitLookup x Tip = (Tip,Nothing,Tip)
splitLookup x (Bin sy y l r)
   = case compare x y of
       LT -> let (lt,found,gt) = splitLookup x l in (lt,found,join y gt r)
       GT -> let (lt,found,gt) = splitLookup x r in (join y l lt,found,gt)
       EQ -> (l,Just y,r)

{--------------------------------------------------------------------
  Utility functions that maintain the balance properties of the tree.
  All constructors assume that all values in [l] < [x] and all values
  in [r] > [x], and that [l] and [r] are valid trees.
  
  In order of sophistication:
    [Bin sz x l r]    The type constructor.
    [bin x l r]       Maintains the correct size, assumes that both [l]
                      and [r] are balanced with respect to each other.
    [balance x l r]   Restores the balance and size.
                      Assumes that the original tree was balanced and
                      that [l] or [r] has changed by at most one element.
    [join x l r]      Restores balance and size. 

  Furthermore, we can construct a new tree from two trees. Both operations
  assume that all values in [l] < all values in [r] and that [l] and [r]
  are valid:
    [glue l r]        Glues [l] and [r] together. Assumes that [l] and
                      [r] are already balanced with respect to each other.
    [merge l r]       Merges two trees and restores balance.

  Note: in contrast to Adam's paper, we use (<=) comparisons instead
  of (<) comparisons in [join], [merge] and [balance]. 
  Quickcheck (on [difference]) showed that this was necessary in order 
  to maintain the invariants. It is quite unsatisfactory that I haven't 
  been able to find out why this is actually the case! Fortunately, it 
  doesn't hurt to be a bit more conservative.
--------------------------------------------------------------------}

{--------------------------------------------------------------------
  Join 
--------------------------------------------------------------------}
join :: a -> Set a -> Set a -> Set a
join x Tip r  = insertMin x r
join x l Tip  = insertMax x l
join x l@(Bin sizeL y ly ry) r@(Bin sizeR z lz rz)
  | delta*sizeL <= sizeR  = balance z (join x l lz) rz
  | delta*sizeR <= sizeL  = balance y ly (join x ry r)
  | otherwise             = bin x l r


-- insertMin and insertMax don't perform potentially expensive comparisons.
insertMax,insertMin :: a -> Set a -> Set a 
insertMax x t
  = case t of
      Tip -> singleton x
      Bin sz y l r
          -> balance y l (insertMax x r)
             
insertMin x t
  = case t of
      Tip -> singleton x
      Bin sz y l r
          -> balance y (insertMin x l) r
             
{--------------------------------------------------------------------
  [merge l r]: merges two trees.
--------------------------------------------------------------------}
merge :: Set a -> Set a -> Set a
merge Tip r   = r
merge l Tip   = l
merge l@(Bin sizeL x lx rx) r@(Bin sizeR y ly ry)
  | delta*sizeL <= sizeR = balance y (merge l ly) ry
  | delta*sizeR <= sizeL = balance x lx (merge rx r)
  | otherwise            = glue l r

{--------------------------------------------------------------------
  [glue l r]: glues two trees together.
  Assumes that [l] and [r] are already balanced with respect to each other.
--------------------------------------------------------------------}
glue :: Set a -> Set a -> Set a
glue Tip r = r
glue l Tip = l
glue l r   
  | size l > size r = let (m,l') = deleteFindMax l in balance m l' r
  | otherwise       = let (m,r') = deleteFindMin r in balance m l r'


-- | /O(log n)/. Delete and find the minimal element.
-- 
-- > deleteFindMin set = (findMin set, deleteMin set)

deleteFindMin :: Set a -> (a,Set a)
deleteFindMin t 
  = case t of
      Bin _ x Tip r -> (x,r)
      Bin _ x l r   -> let (xm,l') = deleteFindMin l in (xm,balance x l' r)
      Tip           -> (error "Set.deleteFindMin: can not return the minimal element of an empty set", Tip)

-- | /O(log n)/. Delete and find the maximal element.
-- 
-- > deleteFindMax set = (findMax set, deleteMax set)
deleteFindMax :: Set a -> (a,Set a)
deleteFindMax t
  = case t of
      Bin _ x l Tip -> (x,l)
      Bin _ x l r   -> let (xm,r') = deleteFindMax r in (xm,balance x l r')
      Tip           -> (error "Set.deleteFindMax: can not return the maximal element of an empty set", Tip)

-- | /O(log n)/. Retrieves the minimal key of the set, and the set stripped from that element
-- @fail@s (in the monad) when passed an empty set.
minView :: Monad m => Set a -> m (Set a, a)
minView Tip = fail "Set.minView: empty set"
minView x = return (swap $ deleteFindMin x)

-- | /O(log n)/. Retrieves the maximal key of the set, and the set stripped from that element
-- @fail@s (in the monad) when passed an empty set.
maxView :: Monad m => Set a -> m (Set a, a)
maxView Tip = fail "Set.maxView: empty set"
maxView x = return (swap $ deleteFindMax x)

swap (a,b) = (b,a)



{--------------------------------------------------------------------
  [balance x l r] balances two trees with value x.
  The sizes of the trees should balance after decreasing the
  size of one of them. (a rotation).

  [delta] is the maximal relative difference between the sizes of
          two trees, it corresponds with the [w] in Adams' paper,
          or equivalently, [1/delta] corresponds with the $\alpha$
          in Nievergelt's paper. Adams shows that [delta] should
          be larger than 3.745 in order to garantee that the
          rotations can always restore balance.         

  [ratio] is the ratio between an outer and inner sibling of the
          heavier subtree in an unbalanced setting. It determines
          whether a double or single rotation should be performed
          to restore balance. It is correspondes with the inverse
          of $\alpha$ in Adam's article.

  Note that:
  - [delta] should be larger than 4.646 with a [ratio] of 2.
  - [delta] should be larger than 3.745 with a [ratio] of 1.534.
  
  - A lower [delta] leads to a more 'perfectly' balanced tree.
  - A higher [delta] performs less rebalancing.

  - Balancing is automatic for random data and a balancing
    scheme is only necessary to avoid pathological worst cases.
    Almost any choice will do in practice
    
  - Allthough it seems that a rather large [delta] may perform better 
    than smaller one, measurements have shown that the smallest [delta]
    of 4 is actually the fastest on a wide range of operations. It
    especially improves performance on worst-case scenarios like
    a sequence of ordered insertions.

  Note: in contrast to Adams' paper, we use a ratio of (at least) 2
  to decide whether a single or double rotation is needed. Allthough
  he actually proves that this ratio is needed to maintain the
  invariants, his implementation uses a (invalid) ratio of 1. 
  He is aware of the problem though since he has put a comment in his 
  original source code that he doesn't care about generating a 
  slightly inbalanced tree since it doesn't seem to matter in practice. 
  However (since we use quickcheck :-) we will stick to strictly balanced 
  trees.
--------------------------------------------------------------------}
delta,ratio :: Int
delta = 4
ratio = 2

balance :: a -> Set a -> Set a -> Set a
balance x l r
  | sizeL + sizeR <= 1    = Bin sizeX x l r
  | sizeR >= delta*sizeL  = rotateL x l r
  | sizeL >= delta*sizeR  = rotateR x l r
  | otherwise             = Bin sizeX x l r
  where
    sizeL = size l
    sizeR = size r
    sizeX = sizeL + sizeR + 1

-- rotate
rotateL x l r@(Bin _ _ ly ry)
  | size ly < ratio*size ry = singleL x l r
  | otherwise               = doubleL x l r

rotateR x l@(Bin _ _ ly ry) r
  | size ry < ratio*size ly = singleR x l r
  | otherwise               = doubleR x l r

-- basic rotations
singleL x1 t1 (Bin _ x2 t2 t3)  = bin x2 (bin x1 t1 t2) t3
singleR x1 (Bin _ x2 t1 t2) t3  = bin x2 t1 (bin x1 t2 t3)

doubleL x1 t1 (Bin _ x2 (Bin _ x3 t2 t3) t4) = bin x3 (bin x1 t1 t2) (bin x2 t3 t4)
doubleR x1 (Bin _ x2 t1 (Bin _ x3 t2 t3)) t4 = bin x3 (bin x2 t1 t2) (bin x1 t3 t4)


{--------------------------------------------------------------------
  The bin constructor maintains the size of the tree
--------------------------------------------------------------------}
bin :: a -> Set a -> Set a -> Set a
bin x l r
  = Bin (size l + size r + 1) x l r


{--------------------------------------------------------------------
  Utilities
--------------------------------------------------------------------}
foldlStrict f z xs
  = case xs of
      []     -> z
      (x:xx) -> let z' = f z x in seq z' (foldlStrict f z' xx)


{--------------------------------------------------------------------
  Debugging
--------------------------------------------------------------------}
-- | /O(n)/. Show the tree that implements the set. The tree is shown
-- in a compressed, hanging format.
showTree :: Show a => Set a -> String
showTree s
  = showTreeWith True False s


{- | /O(n)/. The expression (@showTreeWith hang wide map@) shows
 the tree that implements the set. If @hang@ is
 @True@, a /hanging/ tree is shown otherwise a rotated tree is shown. If
 @wide@ is 'True', an extra wide version is shown.

> Set> putStrLn $ showTreeWith True False $ fromDistinctAscList [1..5]
> 4
> +--2
> |  +--1
> |  +--3
> +--5
> 
> Set> putStrLn $ showTreeWith True True $ fromDistinctAscList [1..5]
> 4
> |
> +--2
> |  |
> |  +--1
> |  |
> |  +--3
> |
> +--5
> 
> Set> putStrLn $ showTreeWith False True $ fromDistinctAscList [1..5]
> +--5
> |
> 4
> |
> |  +--3
> |  |
> +--2
>    |
>    +--1

-}
showTreeWith :: Show a => Bool -> Bool -> Set a -> String
showTreeWith hang wide t
  | hang      = (showsTreeHang wide [] t) ""
  | otherwise = (showsTree wide [] [] t) ""

showsTree :: Show a => Bool -> [String] -> [String] -> Set a -> ShowS
showsTree wide lbars rbars t
  = case t of
      Tip -> showsBars lbars . showString "|\n"
      Bin sz x Tip Tip
          -> showsBars lbars . shows x . showString "\n" 
      Bin sz x l r
          -> showsTree wide (withBar rbars) (withEmpty rbars) r .
             showWide wide rbars .
             showsBars lbars . shows x . showString "\n" .
             showWide wide lbars .
             showsTree wide (withEmpty lbars) (withBar lbars) l

showsTreeHang :: Show a => Bool -> [String] -> Set a -> ShowS
showsTreeHang wide bars t
  = case t of
      Tip -> showsBars bars . showString "|\n" 
      Bin sz x Tip Tip
          -> showsBars bars . shows x . showString "\n" 
      Bin sz x l r
          -> showsBars bars . shows x . showString "\n" . 
             showWide wide bars .
             showsTreeHang wide (withBar bars) l .
             showWide wide bars .
             showsTreeHang wide (withEmpty bars) r


showWide wide bars 
  | wide      = showString (concat (reverse bars)) . showString "|\n" 
  | otherwise = id

showsBars :: [String] -> ShowS
showsBars bars
  = case bars of
      [] -> id
      _  -> showString (concat (reverse (tail bars))) . showString node

node           = "+--"
withBar bars   = "|  ":bars
withEmpty bars = "   ":bars

{--------------------------------------------------------------------
  Assertions
--------------------------------------------------------------------}
-- | /O(n)/. Test if the internal set structure is valid.
valid :: Ord a => Set a -> Bool
valid t
  = balanced t && ordered t && validsize t

ordered t
  = bounded (const True) (const True) t
  where
    bounded lo hi t
      = case t of
          Tip           -> True
          Bin sz x l r  -> (lo x) && (hi x) && bounded lo (<x) l && bounded (>x) hi r

balanced :: Set a -> Bool
balanced t
  = case t of
      Tip           -> True
      Bin sz x l r  -> (size l + size r <= 1 || (size l <= delta*size r && size r <= delta*size l)) &&
                       balanced l && balanced r


validsize t
  = (realsize t == Just (size t))
  where
    realsize t
      = case t of
          Tip          -> Just 0
          Bin sz x l r -> case (realsize l,realsize r) of
                            (Just n,Just m)  | n+m+1 == sz  -> Just sz
                            other            -> Nothing

{-
{--------------------------------------------------------------------
  Testing
--------------------------------------------------------------------}
testTree :: [Int] -> Set Int
testTree xs   = fromList xs
test1 = testTree [1..20]
test2 = testTree [30,29..10]
test3 = testTree [1,4,6,89,2323,53,43,234,5,79,12,9,24,9,8,423,8,42,4,8,9,3]

{--------------------------------------------------------------------
  QuickCheck
--------------------------------------------------------------------}
qcheck prop
  = check config prop
  where
    config = Config
      { configMaxTest = 500
      , configMaxFail = 5000
      , configSize    = \n -> (div n 2 + 3)
      , configEvery   = \n args -> let s = show n in s ++ [ '\b' | _ <- s ]
      }


{--------------------------------------------------------------------
  Arbitrary, reasonably balanced trees
--------------------------------------------------------------------}
instance (Enum a) => Arbitrary (Set a) where
  arbitrary = sized (arbtree 0 maxkey)
            where maxkey  = 10000

arbtree :: (Enum a) => Int -> Int -> Int -> Gen (Set a)
arbtree lo hi n
  | n <= 0        = return Tip
  | lo >= hi      = return Tip
  | otherwise     = do{ i  <- choose (lo,hi)
                      ; m  <- choose (1,30)
                      ; let (ml,mr)  | m==(1::Int)= (1,2)
                                     | m==2       = (2,1)
                                     | m==3       = (1,1)
                                     | otherwise  = (2,2)
                      ; l  <- arbtree lo (i-1) (n `div` ml)
                      ; r  <- arbtree (i+1) hi (n `div` mr)
                      ; return (bin (toEnum i) l r)
                      }  


{--------------------------------------------------------------------
  Valid tree's
--------------------------------------------------------------------}
forValid :: (Enum a,Show a,Testable b) => (Set a -> b) -> Property
forValid f
  = forAll arbitrary $ \t -> 
--    classify (balanced t) "balanced" $
    classify (size t == 0) "empty" $
    classify (size t > 0  && size t <= 10) "small" $
    classify (size t > 10 && size t <= 64) "medium" $
    classify (size t > 64) "large" $
    balanced t ==> f t

forValidIntTree :: Testable a => (Set Int -> a) -> Property
forValidIntTree f
  = forValid f

forValidUnitTree :: Testable a => (Set Int -> a) -> Property
forValidUnitTree f
  = forValid f


prop_Valid 
  = forValidUnitTree $ \t -> valid t

{--------------------------------------------------------------------
  Single, Insert, Delete
--------------------------------------------------------------------}
prop_Single :: Int -> Bool
prop_Single x
  = (insert x empty == singleton x)

prop_InsertValid :: Int -> Property
prop_InsertValid k
  = forValidUnitTree $ \t -> valid (insert k t)

prop_InsertDelete :: Int -> Set Int -> Property
prop_InsertDelete k t
  = not (member k t) ==> delete k (insert k t) == t

prop_DeleteValid :: Int -> Property
prop_DeleteValid k
  = forValidUnitTree $ \t -> 
    valid (delete k (insert k t))

{--------------------------------------------------------------------
  Balance
--------------------------------------------------------------------}
prop_Join :: Int -> Property 
prop_Join x
  = forValidUnitTree $ \t ->
    let (l,r) = split x t
    in valid (join x l r)

prop_Merge :: Int -> Property 
prop_Merge x
  = forValidUnitTree $ \t ->
    let (l,r) = split x t
    in valid (merge l r)


{--------------------------------------------------------------------
  Union
--------------------------------------------------------------------}
prop_UnionValid :: Property
prop_UnionValid
  = forValidUnitTree $ \t1 ->
    forValidUnitTree $ \t2 ->
    valid (union t1 t2)

prop_UnionInsert :: Int -> Set Int -> Bool
prop_UnionInsert x t
  = union t (singleton x) == insert x t

prop_UnionAssoc :: Set Int -> Set Int -> Set Int -> Bool
prop_UnionAssoc t1 t2 t3
  = union t1 (union t2 t3) == union (union t1 t2) t3

prop_UnionComm :: Set Int -> Set Int -> Bool
prop_UnionComm t1 t2
  = (union t1 t2 == union t2 t1)


prop_DiffValid
  = forValidUnitTree $ \t1 ->
    forValidUnitTree $ \t2 ->
    valid (difference t1 t2)

prop_Diff :: [Int] -> [Int] -> Bool
prop_Diff xs ys
  =  toAscList (difference (fromList xs) (fromList ys))
    == List.sort ((List.\\) (nub xs)  (nub ys))

prop_IntValid
  = forValidUnitTree $ \t1 ->
    forValidUnitTree $ \t2 ->
    valid (intersection t1 t2)

prop_Int :: [Int] -> [Int] -> Bool
prop_Int xs ys
  =  toAscList (intersection (fromList xs) (fromList ys))
    == List.sort (nub ((List.intersect) (xs)  (ys)))

{--------------------------------------------------------------------
  Lists
--------------------------------------------------------------------}
prop_Ordered
  = forAll (choose (5,100)) $ \n ->
    let xs = [0..n::Int]
    in fromAscList xs == fromList xs

prop_List :: [Int] -> Bool
prop_List xs
  = (sort (nub xs) == toList (fromList xs))
-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Traversable
-- Copyright   :  Conor McBride and Ross Paterson 2005
-- License     :  BSD-style (see the LICENSE file in the distribution)
--
-- Maintainer  :  ross@soi.city.ac.uk
-- Stability   :  experimental
-- Portability :  portable
--
-- Class of data structures that can be traversed from left to right,
-- performing an action on each element.
--
-- See also
--
--  * /Applicative Programming with Effects/,
--    by Conor McBride and Ross Paterson, online at
--    <http://www.soi.city.ac.uk/~ross/papers/Applicative.html>.
--
--  * /The Essence of the Iterator Pattern/,
--    by Jeremy Gibbons and Bruno Oliveira,
--    in /Mathematically-Structured Functional Programming/, 2006, and online at
--    <http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/#iterator>.
--
-- Note that the functions 'mapM' and 'sequence' generalize "Prelude"
-- functions of the same names from lists to any 'Traversable' functor.
-- To avoid ambiguity, either import the "Prelude" hiding these names
-- or qualify uses of these function names with an alias for this module.

module Data.Traversable (
	Traversable(..),
	for,
	forM,
	fmapDefault,
	foldMapDefault,
	) where

import Prelude hiding (mapM, sequence, foldr)
import qualified Prelude (mapM, foldr)
import Control.Applicative
import Data.Foldable (Foldable())
import Data.Monoid (Monoid)
import Data.Array

-- | Functors representing data structures that can be traversed from
-- left to right.
--
-- Minimal complete definition: 'traverse' or 'sequenceA'.
--
-- Instances are similar to 'Functor', e.g. given a data type
--
-- > data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--
-- a suitable instance would be
--
-- > instance Traversable Tree
-- >	traverse f Empty = pure Empty
-- >	traverse f (Leaf x) = Leaf <$> f x
-- >	traverse f (Node l k r) = Node <$> traverse f l <*> f k <*> traverse f r
--
-- This is suitable even for abstract types, as the laws for '<*>'
-- imply a form of associativity.
--
-- The superclass instances should satisfy the following:
--
--  * In the 'Functor' instance, 'fmap' should be equivalent to traversal
--    with the identity applicative functor ('fmapDefault').
--
--  * In the 'Foldable' instance, 'Data.Foldable.foldMap' should be
--    equivalent to traversal with a constant applicative functor
--    ('foldMapDefault').
--
class (Functor t, Foldable t) => Traversable t where
	-- | Map each element of a structure to an action, evaluate
	-- these actions from left to right, and collect the results.
	traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
	traverse f = sequenceA . fmap f

	-- | Evaluate each action in the structure from left to right,
	-- and collect the results.
	sequenceA :: Applicative f => t (f a) -> f (t a)
	sequenceA = traverse id

	-- | Map each element of a structure to an monadic action, evaluate
	-- these actions from left to right, and collect the results.
	mapM :: Monad m => (a -> m b) -> t a -> m (t b)
	mapM f = unwrapMonad . traverse (WrapMonad . f)

	-- | Evaluate each monadic action in the structure from left to right,
	-- and collect the results.
	sequence :: Monad m => t (m a) -> m (t a)
	sequence = mapM id

-- instances for Prelude types

instance Traversable Maybe where
	traverse f Nothing = pure Nothing
	traverse f (Just x) = Just <$> f x

instance Traversable [] where
	traverse f = Prelude.foldr cons_f (pure [])
	  where cons_f x ys = (:) <$> f x <*> ys

	mapM = Prelude.mapM

instance Ix i => Traversable (Array i) where
	traverse f arr = listArray (bounds arr) <$> traverse f (elems arr)

-- general functions

-- | 'for' is 'traverse' with its arguments flipped.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
{-# INLINE for #-}
for = flip traverse

-- | 'forM' is 'mapM' with its arguments flipped.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
{-# INLINE forM #-}
forM = flip mapM

-- | This function may be used as a value for `fmap` in a `Functor` instance.
fmapDefault :: Traversable t => (a -> b) -> t a -> t b
fmapDefault f = getId . traverse (Id . f)

-- | This function may be used as a value for `Data.Foldable.foldMap`
-- in a `Foldable` instance.
foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
foldMapDefault f = getConst . traverse (Const . f)

-- local instances

newtype Id a = Id { getId :: a }

instance Functor Id where
	fmap f (Id x) = Id (f x)

instance Applicative Id where
	pure = Id
	Id f <*> Id x = Id (f x)
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Tree
-- Copyright   :  (c) The University of Glasgow 2002
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- Multi-way trees (/aka/ rose trees) and forests.
--
-----------------------------------------------------------------------------

module Data.Tree(
	Tree(..), Forest,
	-- * Two-dimensional drawing
	drawTree, drawForest,
	-- * Extraction
	flatten, levels,
	-- * Building trees
	unfoldTree, unfoldForest,
	unfoldTreeM, unfoldForestM,
	unfoldTreeM_BF, unfoldForestM_BF,
    ) where





import Control.Applicative (Applicative(..), (<$>))
import Control.Monad
import Data.Monoid (Monoid(..))
import Data.Sequence (Seq, empty, singleton, (<|), (|>), fromList,
			ViewL(..), ViewR(..), viewl, viewr)
import Data.Foldable (Foldable(foldMap), toList)
import Data.Traversable (Traversable(traverse))
import Data.Typeable





-- | Multi-way trees, also known as /rose trees/.
data Tree a   = Node {
		rootLabel :: a,		-- ^ label value
		subForest :: Forest a	-- ^ zero or more child trees
	}




  deriving (Eq, Read, Show)







type Forest a = [Tree a]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      























































treeTc = mkTyCon "Tree"; instance Typeable1 Tree where { typeOf1 _ = mkTyConApp treeTc [] }; instance Typeable a => Typeable (Tree a) where { typeOf = typeOfDefault }

instance Functor Tree where
  fmap f (Node x ts) = Node (f x) (map (fmap f) ts)

instance Traversable Tree where
  traverse f (Node x ts) = Node <$> f x <*> traverse (traverse f) ts

instance Foldable Tree where
  foldMap f (Node x ts) = f x `mappend` foldMap (foldMap f) ts

-- | Neat 2-dimensional drawing of a tree.
drawTree :: Tree String -> String
drawTree  = unlines . draw

-- | Neat 2-dimensional drawing of a forest.
drawForest :: Forest String -> String
drawForest  = unlines . map drawTree

draw :: Tree String -> [String]
draw (Node x ts0) = x : drawSubTrees ts0
  where drawSubTrees [] = []
	drawSubTrees [t] =
		"|" : shift "`- " "   " (draw t)
	drawSubTrees (t:ts) =
		"|" : shift "+- " "|  " (draw t) ++ drawSubTrees ts

	shift first other = zipWith (++) (first : repeat other)

-- | The elements of a tree in pre-order.
flatten :: Tree a -> [a]
flatten t = squish t []
  where squish (Node x ts) xs = x:Prelude.foldr squish xs ts

-- | Lists of nodes at each level of the tree.
levels :: Tree a -> [[a]]
levels t = map (map rootLabel) $
		takeWhile (not . null) $
		iterate (concatMap subForest) [t]

-- | Build a tree from a seed value
unfoldTree :: (b -> (a, [b])) -> b -> Tree a
unfoldTree f b = let (a, bs) = f b in Node a (unfoldForest f bs)

-- | Build a forest from a list of seed values
unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
unfoldForest f = map (unfoldTree f)

-- | Monadic tree builder, in depth-first order
unfoldTreeM :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
unfoldTreeM f b = do
	(a, bs) <- f b
	ts <- unfoldForestM f bs
	return (Node a ts)

-- | Monadic forest builder, in depth-first order

unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)

unfoldForestM f = Prelude.mapM (unfoldTreeM f)

-- | Monadic tree builder, in breadth-first order,
-- using an algorithm adapted from
-- /Breadth-First Numbering: Lessons from a Small Exercise in Algorithm Design/,
-- by Chris Okasaki, /ICFP'00/.
unfoldTreeM_BF :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
unfoldTreeM_BF f b = liftM getElement $ unfoldForestQ f (singleton b)
  where getElement xs = case viewl xs of
		x :< _ -> x
		EmptyL -> error "unfoldTreeM_BF"

-- | Monadic forest builder, in breadth-first order,
-- using an algorithm adapted from
-- /Breadth-First Numbering: Lessons from a Small Exercise in Algorithm Design/,
-- by Chris Okasaki, /ICFP'00/.
unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
unfoldForestM_BF f = liftM toList . unfoldForestQ f . fromList

-- takes a sequence (queue) of seeds
-- produces a sequence (reversed queue) of trees of the same length
unfoldForestQ :: Monad m => (b -> m (a, [b])) -> Seq b -> m (Seq (Tree a))
unfoldForestQ f aQ = case viewl aQ of
	EmptyL -> return empty
	a :< aQ -> do
		(b, as) <- f a
		tQ <- unfoldForestQ f (Prelude.foldl (|>) aQ as)
		let (tQ', ts) = splitOnto [] as tQ
		return (Node b ts <| tQ')
  where splitOnto :: [a'] -> [b'] -> Seq a' -> (Seq a', [a'])
	splitOnto as [] q = (q, as)
	splitOnto as (_:bs) q = case viewr q of
		q' :> a -> splitOnto (a:as) bs q'
		EmptyR -> error "unfoldForestQ"
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Tuple
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- The tuple data types, and associated functions.
--
-----------------------------------------------------------------------------

module Data.Tuple
  ( fst		-- :: (a,b) -> a
  , snd		-- :: (a,b) -> a
  , curry	-- :: ((a, b) -> c) -> a -> b -> c
  , uncurry	-- :: (a -> b -> c) -> ((a, b) -> c)
















  )
    where




























default ()		-- Double isn't available yet





























































































































































































-- ---------------------------------------------------------------------------
-- Standard functions over tuples


















{-# OPTIONS_GHC -fno-implicit-prelude -fallow-overlapping-instances #-}

-- The -fallow-overlapping-instances flag allows the user to over-ride
-- the instances for Typeable given here.  In particular, we provide an instance
--	instance ... => Typeable (s a) 
-- But a user might want to say
--	instance ... => Typeable (MyType a b)

-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Typeable
-- Copyright   :  (c) The University of Glasgow, CWI 2001--2004
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- The 'Typeable' class reifies types to some extent by associating type
-- representations to types. These type representations can be compared,
-- and one can in turn define a type-safe cast operation. To this end,
-- an unsafe cast is guarded by a test for type (representation)
-- equivalence. The module "Data.Dynamic" uses Typeable for an
-- implementation of dynamics. The module "Data.Generics" uses Typeable
-- and type-safe cast (but not dynamics) to support the \"Scrap your
-- boilerplate\" style of generic programming.
--
-----------------------------------------------------------------------------

module Data.Typeable
  (

	-- * The Typeable class
	Typeable( typeOf ),	-- :: a -> TypeRep

	-- * Type-safe cast
	cast,			-- :: (Typeable a, Typeable b) => a -> Maybe b
	gcast,			-- a generalisation of cast

	-- * Type representations
	TypeRep,	-- abstract, instance of: Eq, Show, Typeable
	TyCon,		-- abstract, instance of: Eq, Show, Typeable

	-- * Construction of type representations
	mkTyCon,	-- :: String  -> TyCon
	mkTyConApp,	-- :: TyCon   -> [TypeRep] -> TypeRep
	mkAppTy,	-- :: TypeRep -> TypeRep   -> TypeRep
	mkFunTy,	-- :: TypeRep -> TypeRep   -> TypeRep

	-- * Observation of type representations
	splitTyConApp,	-- :: TypeRep -> (TyCon, [TypeRep])
	funResultTy,	-- :: TypeRep -> TypeRep   -> Maybe TypeRep
	typeRepTyCon,	-- :: TypeRep -> TyCon
	typeRepArgs,	-- :: TypeRep -> [TypeRep]
	tyConString,	-- :: TyCon   -> String

	-- * The other Typeable classes
	-- | /Note:/ The general instances are provided for GHC only.
	Typeable1( typeOf1 ),	-- :: t a -> TypeRep
	Typeable2( typeOf2 ),	-- :: t a b -> TypeRep
	Typeable3( typeOf3 ),	-- :: t a b c -> TypeRep
	Typeable4( typeOf4 ),	-- :: t a b c d -> TypeRep
	Typeable5( typeOf5 ),	-- :: t a b c d e -> TypeRep
	Typeable6( typeOf6 ),	-- :: t a b c d e f -> TypeRep
	Typeable7( typeOf7 ),	-- :: t a b c d e f g -> TypeRep
	gcast1,			-- :: ... => c (t a) -> Maybe (c (t' a))
	gcast2,			-- :: ... => c (t a b) -> Maybe (c (t' a b))

	-- * Default instances
	-- | /Note:/ These are not needed by GHC, for which these instances
	-- are generated by general instance declarations.
	typeOfDefault,	-- :: (Typeable1 t, Typeable a) => t a -> TypeRep
	typeOf1Default,	-- :: (Typeable2 t, Typeable a) => t a b -> TypeRep
	typeOf2Default,	-- :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
	typeOf3Default,	-- :: (Typeable4 t, Typeable a) => t a b c d -> TypeRep
	typeOf4Default,	-- :: (Typeable5 t, Typeable a) => t a b c d e -> TypeRep
	typeOf5Default,	-- :: (Typeable6 t, Typeable a) => t a b c d e f -> TypeRep
	typeOf6Default	-- :: (Typeable7 t, Typeable a) => t a b c d e f g -> TypeRep

  ) where

import qualified Data.HashTable as HT
import Data.Maybe
import Data.Either
import Data.Int
import Data.Word
import Data.List( foldl )




























import Hugs.Prelude	( Key(..), TypeRep(..), TyCon(..), Ratio,
			  Exception, ArithException, IOException,
			  ArrayException, AsyncException, Handle,
			  Ptr, FunPtr, ForeignPtr, StablePtr )
import Hugs.IORef	( IORef, newIORef, readIORef, writeIORef )
import Hugs.IOExts	( unsafePerformIO, unsafeCoerce )
	-- For the Typeable instance
import Hugs.Array	( Array )
import Hugs.ConcBase	( MVar )

















                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

















































































	-- 
	-- let fTy = mkTyCon "Foo" in show (mkTyConApp (mkTyCon ",,")
	--                                 [fTy,fTy,fTy])
	-- 
	-- returns "(Foo,Foo,Foo)"
	--
	-- The TypeRep Show instance promises to print tuple types
	-- correctly. Tuple type constructors are specified by a 
	-- sequence of commas, e.g., (mkTyCon ",,,,") returns
	-- the 5-tuple tycon.

----------------- Construction --------------------

-- | Applies a type constructor to a sequence of types
mkTyConApp  :: TyCon -> [TypeRep] -> TypeRep
mkTyConApp tc@(TyCon tc_k _) args 
  = TypeRep (appKeys tc_k arg_ks) tc args
  where
    arg_ks = [k | TypeRep k _ _ <- args]

-- | A special case of 'mkTyConApp', which applies the function 
-- type constructor to a pair of types.
mkFunTy  :: TypeRep -> TypeRep -> TypeRep
mkFunTy f a = mkTyConApp funTc [f,a]

-- | Splits a type constructor application
splitTyConApp :: TypeRep -> (TyCon,[TypeRep])
splitTyConApp (TypeRep _ tc trs) = (tc,trs)

-- | Applies a type to a function type.  Returns: @'Just' u@ if the
-- first argument represents a function of type @t -> u@ and the
-- second argument represents a function of type @t@.  Otherwise,
-- returns 'Nothing'.
funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep
funResultTy trFun trArg
  = case splitTyConApp trFun of
      (tc, [t1,t2]) | tc == funTc && t1 == trArg -> Just t2
      _ -> Nothing

-- | Adds a TypeRep argument to a TypeRep.
mkAppTy :: TypeRep -> TypeRep -> TypeRep
mkAppTy (TypeRep tr_k tc trs) arg_tr
  = let (TypeRep arg_k _ _) = arg_tr
     in  TypeRep (appKey tr_k arg_k) tc (trs++[arg_tr])

-- If we enforce the restriction that there is only one
-- @TyCon@ for a type & it is shared among all its uses,
-- we can map them onto Ints very simply. The benefit is,
-- of course, that @TyCon@s can then be compared efficiently.

-- Provided the implementor of other @Typeable@ instances
-- takes care of making all the @TyCon@s CAFs (toplevel constants),
-- this will work. 

-- If this constraint does turn out to be a sore thumb, changing
-- the Eq instance for TyCons is trivial.

-- | Builds a 'TyCon' object representing a type constructor.  An
-- implementation of "Data.Typeable" should ensure that the following holds:
--
-- >  mkTyCon "a" == mkTyCon "a"
--

mkTyCon :: String	-- ^ the name of the type constructor (should be unique
			-- in the program, so it might be wise to use the
			-- fully qualified name).
	-> TyCon	-- ^ A unique 'TyCon' object
mkTyCon str = TyCon (mkTyConKey str) str

----------------- Observation ---------------------

-- | Observe the type constructor of a type representation
typeRepTyCon :: TypeRep -> TyCon
typeRepTyCon (TypeRep _ tc _) = tc

-- | Observe the argument types of a type representation
typeRepArgs :: TypeRep -> [TypeRep]
typeRepArgs (TypeRep _ _ args) = args

-- | Observe string encoding of a type representation
tyConString :: TyCon   -> String
tyConString  (TyCon _ str) = str

----------------- Showing TypeReps --------------------

instance Show TypeRep where
  showsPrec p (TypeRep _ tycon tys) =
    case tys of
      [] -> showsPrec p tycon
      [x]   | tycon == listTc -> showChar '[' . shows x . showChar ']'
      [a,r] | tycon == funTc  -> showParen (p > 8) $
			         showsPrec 9 a .
                                 showString " -> " .
                                 showsPrec 8 r
      xs | isTupleTyCon tycon -> showTuple tycon xs
	 | otherwise	     ->
	    showParen (p > 9) $
   	    showsPrec p tycon . 
	    showChar ' '      . 
	    showArgs tys

instance Show TyCon where
  showsPrec _ (TyCon _ s) = showString s

isTupleTyCon :: TyCon -> Bool
isTupleTyCon (TyCon _ (',':_)) = True
isTupleTyCon _		       = False

-- Some (Show.TypeRep) helpers:

showArgs :: Show a => [a] -> ShowS
showArgs [] = id
showArgs [a] = showsPrec 10 a
showArgs (a:as) = showsPrec 10 a . showString " " . showArgs as 

showTuple :: TyCon -> [TypeRep] -> ShowS
showTuple (TyCon _ str) args = showChar '(' . go str args
 where
  go [] [a] = showsPrec 10 a . showChar ')'
  go _  []  = showChar ')' -- a failure condition, really.
  go (',':xs) (a:as) = showsPrec 10 a . showChar ',' . go xs as
  go _ _   = showChar ')'

-------------------------------------------------------------
--
--	The Typeable class and friends
--
-------------------------------------------------------------

-- | The class 'Typeable' allows a concrete representation of a type to
-- be calculated.
class Typeable a where
  typeOf :: a -> TypeRep
  -- ^ Takes a value of type @a@ and returns a concrete representation
  -- of that type.  The /value/ of the argument should be ignored by
  -- any instance of 'Typeable', so that it is safe to pass 'undefined' as
  -- the argument.

-- | Variant for unary type constructors
class Typeable1 t where
  typeOf1 :: t a -> TypeRep

-- | For defining a 'Typeable' instance from any 'Typeable1' instance.
typeOfDefault :: (Typeable1 t, Typeable a) => t a -> TypeRep
typeOfDefault x = typeOf1 x `mkAppTy` typeOf (argType x)
 where
   argType :: t a -> a
   argType =  undefined

-- | Variant for binary type constructors
class Typeable2 t where
  typeOf2 :: t a b -> TypeRep

-- | For defining a 'Typeable1' instance from any 'Typeable2' instance.
typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
typeOf1Default x = typeOf2 x `mkAppTy` typeOf (argType x)
 where
   argType :: t a b -> a
   argType =  undefined

-- | Variant for 3-ary type constructors
class Typeable3 t where
  typeOf3 :: t a b c -> TypeRep

-- | For defining a 'Typeable2' instance from any 'Typeable3' instance.
typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
typeOf2Default x = typeOf3 x `mkAppTy` typeOf (argType x)
 where
   argType :: t a b c -> a
   argType =  undefined

-- | Variant for 4-ary type constructors
class Typeable4 t where
  typeOf4 :: t a b c d -> TypeRep

-- | For defining a 'Typeable3' instance from any 'Typeable4' instance.
typeOf3Default :: (Typeable4 t, Typeable a) => t a b c d -> TypeRep
typeOf3Default x = typeOf4 x `mkAppTy` typeOf (argType x)
 where
   argType :: t a b c d -> a
   argType =  undefined

-- | Variant for 5-ary type constructors
class Typeable5 t where
  typeOf5 :: t a b c d e -> TypeRep

-- | For defining a 'Typeable4' instance from any 'Typeable5' instance.
typeOf4Default :: (Typeable5 t, Typeable a) => t a b c d e -> TypeRep
typeOf4Default x = typeOf5 x `mkAppTy` typeOf (argType x)
 where
   argType :: t a b c d e -> a
   argType =  undefined

-- | Variant for 6-ary type constructors
class Typeable6 t where
  typeOf6 :: t a b c d e f -> TypeRep

-- | For defining a 'Typeable5' instance from any 'Typeable6' instance.
typeOf5Default :: (Typeable6 t, Typeable a) => t a b c d e f -> TypeRep
typeOf5Default x = typeOf6 x `mkAppTy` typeOf (argType x)
 where
   argType :: t a b c d e f -> a
   argType =  undefined

-- | Variant for 7-ary type constructors
class Typeable7 t where
  typeOf7 :: t a b c d e f g -> TypeRep

-- | For defining a 'Typeable6' instance from any 'Typeable7' instance.
typeOf6Default :: (Typeable7 t, Typeable a) => t a b c d e f g -> TypeRep
typeOf6Default x = typeOf7 x `mkAppTy` typeOf (argType x)
 where
   argType :: t a b c d e f g -> a
   argType =  undefined













































-------------------------------------------------------------
--
--		Type-safe cast
--
-------------------------------------------------------------

-- | The type-safe cast operation
cast :: (Typeable a, Typeable b) => a -> Maybe b
cast x = r
       where
	 r = if typeOf x == typeOf (fromJust r)
               then Just $ unsafeCoerce x
	       else Nothing

-- | A flexible variation parameterised in a type constructor
gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
gcast x = r
 where
  r = if typeOf (getArg x) == typeOf (getArg (fromJust r))
        then Just $ unsafeCoerce x
        else Nothing
  getArg :: c x -> x 
  getArg = undefined

-- | Cast for * -> *
gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a)) 
gcast1 x = r
 where
  r = if typeOf1 (getArg x) == typeOf1 (getArg (fromJust r))
       then Just $ unsafeCoerce x
       else Nothing
  getArg :: c x -> x 
  getArg = undefined

-- | Cast for * -> * -> *
gcast2 :: (Typeable2 t, Typeable2 t') => c (t a b) -> Maybe (c (t' a b)) 
gcast2 x = r
 where
  r = if typeOf2 (getArg x) == typeOf2 (getArg (fromJust r))
       then Just $ unsafeCoerce x
       else Nothing
  getArg :: c x -> x 
  getArg = undefined

-------------------------------------------------------------
--
--	Instances of the Typeable classes for Prelude types
--
-------------------------------------------------------------

unitTc = mkTyCon "()"; instance Typeable () where { typeOf _ = mkTyConApp unitTc [] }
listTc = mkTyCon "[]"; instance Typeable1 [] where { typeOf1 _ = mkTyConApp listTc [] }; instance Typeable a => Typeable ([] a) where { typeOf = typeOfDefault }
maybeTc = mkTyCon "Maybe"; instance Typeable1 Maybe where { typeOf1 _ = mkTyConApp maybeTc [] }; instance Typeable a => Typeable (Maybe a) where { typeOf = typeOfDefault }
ratioTc = mkTyCon "Ratio"; instance Typeable1 Ratio where { typeOf1 _ = mkTyConApp ratioTc [] }; instance Typeable a => Typeable (Ratio a) where { typeOf = typeOfDefault }
eitherTc = mkTyCon "Either"; instance Typeable2 Either where { typeOf2 _ = mkTyConApp eitherTc [] }; instance Typeable a => Typeable1 (Either a) where {   typeOf1 = typeOf1Default }; instance (Typeable a, Typeable b) => Typeable (Either a b) where {   typeOf = typeOfDefault }
funTc = mkTyCon "->"; instance Typeable2 (->) where { typeOf2 _ = mkTyConApp funTc [] }; instance Typeable a => Typeable1 ((->) a) where {   typeOf1 = typeOf1Default }; instance (Typeable a, Typeable b) => Typeable ((->) a b) where {   typeOf = typeOfDefault }
ioTc = mkTyCon "IO"; instance Typeable1 IO where { typeOf1 _ = mkTyConApp ioTc [] }; instance Typeable a => Typeable (IO a) where { typeOf = typeOfDefault }


-- Types defined in GHC.IOBase
mvarTc = mkTyCon "MVar"; instance Typeable1 MVar where { typeOf1 _ = mkTyConApp mvarTc [] }; instance Typeable a => Typeable (MVar a) where { typeOf = typeOfDefault }
exceptionTc = mkTyCon "Exception"; instance Typeable Exception where { typeOf _ = mkTyConApp exceptionTc [] }
ioExceptionTc = mkTyCon "IOException"; instance Typeable IOException where { typeOf _ = mkTyConApp ioExceptionTc [] }
arithExceptionTc = mkTyCon "ArithException"; instance Typeable ArithException where { typeOf _ = mkTyConApp arithExceptionTc [] }
arrayExceptionTc = mkTyCon "ArrayException"; instance Typeable ArrayException where { typeOf _ = mkTyConApp arrayExceptionTc [] }
asyncExceptionTc = mkTyCon "AsyncException"; instance Typeable AsyncException where { typeOf _ = mkTyConApp asyncExceptionTc [] }


-- Types defined in GHC.Arr
arrayTc = mkTyCon "Array"; instance Typeable2 Array where { typeOf2 _ = mkTyConApp arrayTc [] }; instance Typeable a => Typeable1 (Array a) where {   typeOf1 = typeOf1Default }; instance (Typeable a, Typeable b) => Typeable (Array a b) where {   typeOf = typeOfDefault }












pairTc = mkTyCon ","; instance Typeable2 (,) where { typeOf2 _ = mkTyConApp pairTc [] }; instance Typeable a => Typeable1 ((,) a) where {   typeOf1 = typeOf1Default }; instance (Typeable a, Typeable b) => Typeable ((,) a b) where {   typeOf = typeOfDefault }
tup3Tc = mkTyCon ",,"; instance Typeable3 (,,) where { typeOf3 _ = mkTyConApp tup3Tc [] }; instance Typeable a => Typeable2 ((,,) a) where {   typeOf2 = typeOf2Default }; instance (Typeable a, Typeable b) => Typeable1 ((,,) a b) where {   typeOf1 = typeOf1Default }; instance (Typeable a, Typeable b, Typeable c) => Typeable ((,,) a b c) where {   typeOf = typeOfDefault }

tup4Tc :: TyCon
tup4Tc = mkTyCon ",,,"

instance Typeable4 (,,,) where
  typeOf4 tu = mkTyConApp tup4Tc []

tup5Tc :: TyCon
tup5Tc = mkTyCon ",,,,"

instance Typeable5 (,,,,) where
  typeOf5 tu = mkTyConApp tup5Tc []

tup6Tc :: TyCon
tup6Tc = mkTyCon ",,,,,"

instance Typeable6 (,,,,,) where
  typeOf6 tu = mkTyConApp tup6Tc []

tup7Tc :: TyCon
tup7Tc = mkTyCon ",,,,,,"

instance Typeable7 (,,,,,,) where
  typeOf7 tu = mkTyConApp tup7Tc []


ptrTc = mkTyCon "Ptr"; instance Typeable1 Ptr where { typeOf1 _ = mkTyConApp ptrTc [] }; instance Typeable a => Typeable (Ptr a) where { typeOf = typeOfDefault }
funPtrTc = mkTyCon "FunPtr"; instance Typeable1 FunPtr where { typeOf1 _ = mkTyConApp funPtrTc [] }; instance Typeable a => Typeable (FunPtr a) where { typeOf = typeOfDefault }
foreignPtrTc = mkTyCon "ForeignPtr"; instance Typeable1 ForeignPtr where { typeOf1 _ = mkTyConApp foreignPtrTc [] }; instance Typeable a => Typeable (ForeignPtr a) where { typeOf = typeOfDefault }
stablePtrTc = mkTyCon "StablePtr"; instance Typeable1 StablePtr where { typeOf1 _ = mkTyConApp stablePtrTc [] }; instance Typeable a => Typeable (StablePtr a) where { typeOf = typeOfDefault }
iORefTc = mkTyCon "IORef"; instance Typeable1 IORef where { typeOf1 _ = mkTyConApp iORefTc [] }; instance Typeable a => Typeable (IORef a) where { typeOf = typeOfDefault }

-------------------------------------------------------
--
-- Generate Typeable instances for standard datatypes
--
-------------------------------------------------------

boolTc = mkTyCon "Bool"; instance Typeable Bool where { typeOf _ = mkTyConApp boolTc [] }
charTc = mkTyCon "Char"; instance Typeable Char where { typeOf _ = mkTyConApp charTc [] }
floatTc = mkTyCon "Float"; instance Typeable Float where { typeOf _ = mkTyConApp floatTc [] }
doubleTc = mkTyCon "Double"; instance Typeable Double where { typeOf _ = mkTyConApp doubleTc [] }
intTc = mkTyCon "Int"; instance Typeable Int where { typeOf _ = mkTyConApp intTc [] }

wordTc = mkTyCon "Word"; instance Typeable Word where { typeOf _ = mkTyConApp wordTc [] }

integerTc = mkTyCon "Integer"; instance Typeable Integer where { typeOf _ = mkTyConApp integerTc [] }
orderingTc = mkTyCon "Ordering"; instance Typeable Ordering where { typeOf _ = mkTyConApp orderingTc [] }
handleTc = mkTyCon "Handle"; instance Typeable Handle where { typeOf _ = mkTyConApp handleTc [] }

int8Tc = mkTyCon "Int8"; instance Typeable Int8 where { typeOf _ = mkTyConApp int8Tc [] }
int16Tc = mkTyCon "Int16"; instance Typeable Int16 where { typeOf _ = mkTyConApp int16Tc [] }
int32Tc = mkTyCon "Int32"; instance Typeable Int32 where { typeOf _ = mkTyConApp int32Tc [] }
int64Tc = mkTyCon "Int64"; instance Typeable Int64 where { typeOf _ = mkTyConApp int64Tc [] }

word8Tc = mkTyCon "Word8"; instance Typeable Word8 where { typeOf _ = mkTyConApp word8Tc [] }
word16Tc = mkTyCon "Word16"; instance Typeable Word16 where { typeOf _ = mkTyConApp word16Tc [] }
word32Tc = mkTyCon "Word32"; instance Typeable Word32 where { typeOf _ = mkTyConApp word32Tc [] }
word64Tc = mkTyCon "Word64"; instance Typeable Word64 where { typeOf _ = mkTyConApp word64Tc [] }

tyconTc = mkTyCon "TyCon"; instance Typeable TyCon where { typeOf _ = mkTyConApp tyconTc [] }
typeRepTc = mkTyCon "TypeRep"; instance Typeable TypeRep where { typeOf _ = mkTyConApp typeRepTc [] }





---------------------------------------------
--
--		Internals 
--
---------------------------------------------





data KeyPr = KeyPr !Key !Key deriving( Eq )

hashKP :: KeyPr -> Int32
hashKP (KeyPr (Key k1) (Key k2)) = (HT.hashInt k1 + HT.hashInt k2) `rem` HT.prime

data Cache = Cache { next_key :: !(IORef Key),	-- Not used by GHC (calls genSym instead)
		     tc_tbl   :: !(HT.HashTable String Key),
		     ap_tbl   :: !(HT.HashTable KeyPr Key) }

{-# NOINLINE cache #-}





cache :: Cache
cache = unsafePerformIO $ do
		empty_tc_tbl <- HT.new (==) HT.hashString
		empty_ap_tbl <- HT.new (==) hashKP
		key_loc      <- newIORef (Key 1) 
		let ret = Cache {	next_key = key_loc,
					tc_tbl = empty_tc_tbl, 
					ap_tbl = empty_ap_tbl }












		return ret


newKey :: IORef Key -> IO Key



newKey kloc = do { k@(Key i) <- readIORef kloc ;
		   writeIORef kloc (Key (i+1)) ;
		   return k }







mkTyConKey :: String -> Key
mkTyConKey str 
  = unsafePerformIO $ do
	let Cache {next_key = kloc, tc_tbl = tbl} = cache
	mb_k <- HT.lookup tbl str
	case mb_k of
	  Just k  -> return k
	  Nothing -> do { k <- newKey kloc ;
			  HT.insert tbl str k ;
			  return k }

appKey :: Key -> Key -> Key
appKey k1 k2
  = unsafePerformIO $ do
	let Cache {next_key = kloc, ap_tbl = tbl} = cache
	mb_k <- HT.lookup tbl kpr
	case mb_k of
	  Just k  -> return k
	  Nothing -> do { k <- newKey kloc ;
			  HT.insert tbl kpr k ;
			  return k }
  where
    kpr = KeyPr k1 k2

appKeys :: Key -> [Key] -> Key
appKeys k ks = foldl appKey k ks
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Unique
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable
--
-- An abstract interface to a unique symbol generator.
--
-----------------------------------------------------------------------------

module Data.Unique (
   -- * Unique objects
   Unique,		-- instance (Eq, Ord)
   newUnique, 		-- :: IO Unique
   hashUnique 		-- :: Unique -> Int
 ) where

import Prelude

import Control.Concurrent.MVar
import System.IO.Unsafe (unsafePerformIO)






-- | An abstract unique object.  Objects of type 'Unique' may be
-- compared for equality and ordering and hashed into 'Int'.
newtype Unique = Unique Integer deriving (Eq,Ord)

uniqSource :: MVar Integer
uniqSource = unsafePerformIO (newMVar 0)
{-# NOINLINE uniqSource #-}

-- | Creates a new object of type 'Unique'.  The value returned will
-- not compare equal to any other value of type 'Unique' returned by
-- previous calls to 'newUnique'.  There is no limit on the number of
-- times 'newUnique' may be called.
newUnique :: IO Unique
newUnique = do
   val <- takeMVar uniqSource
   let next = val+1
   putMVar uniqSource next
   return (Unique next)

-- | Hashes a 'Unique' into an 'Int'.  Two 'Unique's may hash to the
-- same value, although in practice this is unlikely.  The 'Int'
-- returned makes a good hash key.
hashUnique :: Unique -> Int





hashUnique (Unique u) = fromInteger (u `mod` (toInteger (maxBound :: Int) + 1))

-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Version
-- Copyright   :  (c) The University of Glasgow 2004
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (local universal quantification in ReadP)
--
-- A general library for representation and manipulation of versions.
-- 
-- Versioning schemes are many and varied, so the version
-- representation provided by this library is intended to be a
-- compromise between complete generality, where almost no common
-- functionality could reasonably be provided, and fixing a particular
-- versioning scheme, which would probably be too restrictive.
-- 
-- So the approach taken here is to provide a representation which
-- subsumes many of the versioning schemes commonly in use, and we
-- provide implementations of 'Eq', 'Ord' and conversion to\/from 'String'
-- which will be appropriate for some applications, but not all.
--
-----------------------------------------------------------------------------

module Data.Version (
	-- * The @Version@ type
	Version(..),
	-- * A concrete representation of @Version@
	showVersion, parseVersion,
  ) where

import Prelude -- necessary to get dependencies right

-- These #ifdefs are necessary because this code might be compiled as
-- part of ghc/lib/compat, and hence might be compiled by an older version
-- of GHC.  In which case, we might need to pick up ReadP from 
-- Distribution.Compat.ReadP, because the version in 
-- Text.ParserCombinators.ReadP doesn't have all the combinators we need.

import Text.ParserCombinators.ReadP





import Data.Typeable 	( Typeable, TyCon, mkTyCon, mkTyConApp )






import Data.List	( intersperse, sort )
import Control.Monad	( liftM )
import Data.Char	( isDigit, isAlphaNum )

{- |
A 'Version' represents the version of a software entity.  

An instance of 'Eq' is provided, which implements exact equality
modulo reordering of the tags in the 'versionTags' field.

An instance of 'Ord' is also provided, which gives lexicographic
ordering on the 'versionBranch' fields (i.e. 2.1 > 2.0, 1.2.3 > 1.2.2,
etc.).  This is expected to be sufficient for many uses, but note that
you may need to use a more specific ordering for your versioning
scheme.  For example, some versioning schemes may include pre-releases
which have tags @\"pre1\"@, @\"pre2\"@, and so on, and these would need to
be taken into account when determining ordering.  In some cases, date
ordering may be more appropriate, so the application would have to
look for @date@ tags in the 'versionTags' field and compare those.
The bottom line is, don't always assume that 'compare' and other 'Ord'
operations are the right thing for every 'Version'.

Similarly, concrete representations of versions may differ.  One
possible concrete representation is provided (see 'showVersion' and
'parseVersion'), but depending on the application a different concrete
representation may be more appropriate.
-}
data Version = 
  Version { versionBranch :: [Int],
		-- ^ The numeric branch for this version.  This reflects the
		-- fact that most software versions are tree-structured; there
		-- is a main trunk which is tagged with versions at various
		-- points (1,2,3...), and the first branch off the trunk after
		-- version 3 is 3.1, the second branch off the trunk after
		-- version 3 is 3.2, and so on.  The tree can be branched
		-- arbitrarily, just by adding more digits.
		-- 
		-- We represent the branch as a list of 'Int', so
		-- version 3.2.1 becomes [3,2,1].  Lexicographic ordering
		-- (i.e. the default instance of 'Ord' for @[Int]@) gives
		-- the natural ordering of branches.

	   versionTags :: [String]  -- really a bag
		-- ^ A version can be tagged with an arbitrary list of strings.
		-- The interpretation of the list of tags is entirely dependent
		-- on the entity that this version applies to.
	}
  deriving (Read,Show



	)


versionTc :: TyCon
versionTc = mkTyCon "Version"

instance Typeable Version where
  typeOf _ = mkTyConApp versionTc []








instance Eq Version where
  v1 == v2  =  versionBranch v1 == versionBranch v2 
                && sort (versionTags v1) == sort (versionTags v2)
                -- tags may be in any order

instance Ord Version where
  v1 `compare` v2 = versionBranch v1 `compare` versionBranch v2

-- -----------------------------------------------------------------------------
-- A concrete representation of 'Version'

-- | Provides one possible concrete representation for 'Version'.  For
-- a version with 'versionBranch' @= [1,2,3]@ and 'versionTags' 
-- @= [\"tag1\",\"tag2\"]@, the output will be @1.2.3-tag1-tag2@.
--
showVersion :: Version -> String
showVersion (Version branch tags)
  = concat (intersperse "." (map show branch)) ++ 
     concatMap ('-':) tags

-- | A parser for versions in the format produced by 'showVersion'.
--

parseVersion :: ReadP Version





parseVersion = do branch <- sepBy1 (liftM read $ munch1 isDigit) (char '.')
                  tags   <- many (char '-' >> munch1 isAlphaNum)
                  return Version{versionBranch=branch, versionTags=tags}
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Word
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- Unsigned integer types.
--
-----------------------------------------------------------------------------

module Data.Word
  ( 
	-- * Unsigned integral types

	Word,
	Word8, Word16, Word32, Word64,
	
	-- * Notes
	
	-- $notes
	) where






import Hugs.Word








{- $notes

* All arithmetic is performed modulo 2^n, where n is the number of
  bits in the type.  One non-obvious consequence of this is that 'Prelude.negate'
  should /not/ raise an error on negative arguments.

* For coercing between any two integer types, use
  'Prelude.fromIntegral', which is specialized for all the
  common cases so should be fast enough.  Coercing word types to and
  from integer types preserves representation, not sign.

* It would be very natural to add a type @Natural@ providing an unbounded 
  size unsigned integer, just as 'Prelude.Integer' provides unbounded
  size signed integers.  We do not do that yet since there is no demand
  for it.

* The rules that hold for 'Prelude.Enum' instances over a bounded type
  such as 'Prelude.Int' (see the section of the Haskell report dealing
  with arithmetic sequences) also hold for the 'Prelude.Enum' instances
  over the various 'Word' types defined here.

* Right and left shifts by amounts greater than or equal to the width
  of the type result in a zero result.  This is contrary to the
  behaviour in C, which is undefined; a common interpretation is to
  truncate the shift count to the width of the type, for example @1 \<\<
  32 == 1@ in some C implementations. 
-}
{-# OPTIONS_GHC -fno-bang-patterns #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Array.Base
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (MPTCs, uses Control.Monad.ST)
--
-- Basis for IArray and MArray.  Not intended for external consumption;
-- use IArray or MArray instead.
--
-----------------------------------------------------------------------------

-- #hide
module Data.Array.Base where

import Prelude

import Control.Monad.ST.Lazy ( strictToLazyST )
import qualified Control.Monad.ST.Lazy as Lazy (ST)
import Data.Ix		( Ix, range, index, rangeSize )
import Data.Int
import Data.Word
import Foreign.Ptr
import Foreign.StablePtr
















import Data.Bits
import Foreign.Storable
import qualified Hugs.Array as Arr
import qualified Hugs.ST as ArrST
import Hugs.Array ( unsafeIndex )
import Hugs.ST ( STArray, ST(..), runST )
import Hugs.ByteArray


import Data.Typeable
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
























































                                                                                                                                                                                                        

                                                                        
                                                                          

                               
                                                                                                            







                                                      












                                                         












                                


                                  


                                 


                               


                                


                                     


                                 


                                         


                                        


                                         


                                              


                                          


                                  


                                                           


                                                         


                                                         


                                                         


                                                         


                                                          


                                                         


                                                           


                                                            


                                                         


                                                                              


                                              


                                                          


                                                          


                                               


                                            


                                                


                                                  


                                                 


                                               


                                                


                                                     


                                                 


                                                         


                                                        


                                                         


                                                              


                                                          


                                                  


                                                      




















































-----------------------------------------------------------------------------
-- Class of immutable arrays

{- | Class of immutable array types.

An array type has the form @(a i e)@ where @a@ is the array type
constructor (kind @* -> * -> *@), @i@ is the index type (a member of
the class 'Ix'), and @e@ is the element type.  The @IArray@ class is
parameterised over both @a@ and @e@, so that instances specialised to
certain element types can be defined.
-}
class IArray a e where
    -- | Extracts the bounds of an immutable array
    bounds           :: Ix i => a i e -> (i,i)
    unsafeArray      :: Ix i => (i,i) -> [(Int, e)] -> a i e
    unsafeAt         :: Ix i => a i e -> Int -> e
    unsafeReplace    :: Ix i => a i e -> [(Int, e)] -> a i e
    unsafeAccum      :: Ix i => (e -> e' -> e) -> a i e -> [(Int, e')] -> a i e
    unsafeAccumArray :: Ix i => (e -> e' -> e) -> e -> (i,i) -> [(Int, e')] -> a i e

    unsafeReplace arr ies = runST (unsafeReplaceST arr ies >>= unsafeFreeze)
    unsafeAccum f arr ies = runST (unsafeAccumST f arr ies >>= unsafeFreeze)
    unsafeAccumArray f e lu ies = runST (unsafeAccumArrayST f e lu ies >>= unsafeFreeze)

{-# INLINE unsafeReplaceST #-}
unsafeReplaceST :: (IArray a e, Ix i) => a i e -> [(Int, e)] -> ST s (STArray s i e)
unsafeReplaceST arr ies = do
    marr <- thaw arr
    sequence_ [unsafeWrite marr i e | (i, e) <- ies]
    return marr

{-# INLINE unsafeAccumST #-}
unsafeAccumST :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(Int, e')] -> ST s (STArray s i e)
unsafeAccumST f arr ies = do
    marr <- thaw arr
    sequence_ [do
        old <- unsafeRead marr i
        unsafeWrite marr i (f old new)
        | (i, new) <- ies]
    return marr

{-# INLINE unsafeAccumArrayST #-}
unsafeAccumArrayST :: Ix i => (e -> e' -> e) -> e -> (i,i) -> [(Int, e')] -> ST s (STArray s i e)
unsafeAccumArrayST f e (l,u) ies = do
    marr <- newArray (l,u) e
    sequence_ [do
        old <- unsafeRead marr i
        unsafeWrite marr i (f old new)
        | (i, new) <- ies]
    return marr


{-# INLINE array #-} 

{-| Constructs an immutable array from a pair of bounds and a list of
initial associations.

The bounds are specified as a pair of the lowest and highest bounds in
the array respectively.  For example, a one-origin vector of length 10
has bounds (1,10), and a one-origin 10 by 10 matrix has bounds
((1,1),(10,10)).

An association is a pair of the form @(i,x)@, which defines the value of
the array at index @i@ to be @x@.  The array is undefined if any index
in the list is out of bounds.  If any two associations in the list have
the same index, the value at that index is implementation-dependent.
(In GHC, the last value specified for that index is used.
Other implementations will also do this for unboxed arrays, but Haskell
98 requires that for 'Array' the value at such indices is bottom.)

Because the indices must be checked for these errors, 'array' is
strict in the bounds argument and in the indices of the association
list.  Whether @array@ is strict or non-strict in the elements depends
on the array type: 'Data.Array.Array' is a non-strict array type, but
all of the 'Data.Array.Unboxed.UArray' arrays are strict.  Thus in a
non-strict array, recurrences such as the following are possible:

> a = array (1,100) ((1,1) : [(i, i * a!(i-1)) | i \<- [2..100]])

Not every index within the bounds of the array need appear in the
association list, but the values associated with indices that do not
appear will be undefined.

If, in any dimension, the lower bound is greater than the upper bound,
then the array is legal, but empty. Indexing an empty array always
gives an array-bounds error, but 'bounds' still yields the bounds with
which the array was constructed.
-}
array 	:: (IArray a e, Ix i) 
	=> (i,i)	-- ^ bounds of the array: (lowest,highest)
	-> [(i, e)]	-- ^ list of associations
	-> a i e
array (l,u) ies = unsafeArray (l,u) [(index (l,u) i, e) | (i, e) <- ies]

-- Since unsafeFreeze is not guaranteed to be only a cast, we will
-- use unsafeArray and zip instead of a specialized loop to implement
-- listArray, unlike Array.listArray, even though it generates some
-- unnecessary heap allocation. Will use the loop only when we have
-- fast unsafeFreeze, namely for Array and UArray (well, they cover
-- almost all cases).

{-# INLINE listArray #-}

-- | Constructs an immutable array from a list of initial elements.
-- The list gives the elements of the array in ascending order
-- beginning with the lowest index.
listArray :: (IArray a e, Ix i) => (i,i) -> [e] -> a i e
listArray (l,u) es = unsafeArray (l,u) (zip [0 .. rangeSize (l,u) - 1] es)

{-# INLINE listArrayST #-}
listArrayST :: Ix i => (i,i) -> [e] -> ST s (STArray s i e)
listArrayST (l,u) es = do
    marr <- newArray_ (l,u)
    let n = rangeSize (l,u)
    let fillFromList i xs | i == n    = return ()
                          | otherwise = case xs of
            []   -> return ()
            y:ys -> unsafeWrite marr i y >> fillFromList (i+1) ys
    fillFromList 0 es
    return marr

{-# RULES
"listArray/Array" listArray =
    \lu es -> runST (listArrayST lu es >>= ArrST.unsafeFreezeSTArray)
    #-}

{-# INLINE listUArrayST #-}
listUArrayST :: (MArray (STUArray s) e (ST s), Ix i)
             => (i,i) -> [e] -> ST s (STUArray s i e)
listUArrayST (l,u) es = do
    marr <- newArray_ (l,u)
    let n = rangeSize (l,u)
    let fillFromList i xs | i == n    = return ()
                          | otherwise = case xs of
            []   -> return ()
            y:ys -> unsafeWrite marr i y >> fillFromList (i+1) ys
    fillFromList 0 es
    return marr

-- I don't know how to write a single rule for listUArrayST, because
-- the type looks like constrained over 's', which runST doesn't
-- like. In fact all MArray (STUArray s) instances are polymorphic
-- wrt. 's', but runST can't know that.
--
-- More precisely, we'd like to write this:
--   listUArray :: (forall s. MArray (STUArray s) e (ST s), Ix i)
--	        => (i,i) -> [e] -> UArray i e
--   listUArray lu = runST (listUArrayST lu es >>= unsafeFreezeSTUArray)
--   {-# RULES listArray = listUArray
-- Then we could call listUArray at any type 'e' that had a suitable
-- MArray instance.  But sadly we can't, because we don't have quantified 
-- constraints.  Hence the mass of rules below.

-- I would like also to write a rule for listUArrayST (or listArray or
-- whatever) applied to unpackCString#. Unfortunately unpackCString#
-- calls seem to be floated out, then floated back into the middle
-- of listUArrayST, so I was not able to do this.










































{-# INLINE (!) #-}
-- | Returns the element of an immutable array at the specified index.
(!) :: (IArray a e, Ix i) => a i e -> i -> e
arr ! i = case bounds arr of (l,u) -> unsafeAt arr (index (l,u) i)

{-# INLINE indices #-}
-- | Returns a list of all the valid indices in an array.
indices :: (IArray a e, Ix i) => a i e -> [i]
indices arr = case bounds arr of (l,u) -> range (l,u)

{-# INLINE elems #-}
-- | Returns a list of all the elements of an array, in the same order
-- as their indices.
elems :: (IArray a e, Ix i) => a i e -> [e]
elems arr = case bounds arr of
    (l,u) -> [unsafeAt arr i | i <- [0 .. rangeSize (l,u) - 1]]

{-# INLINE assocs #-}
-- | Returns the contents of an array as a list of associations.
assocs :: (IArray a e, Ix i) => a i e -> [(i, e)]
assocs arr = case bounds arr of
    (l,u) -> [(i, unsafeAt arr (unsafeIndex (l,u) i)) | i <- range (l,u)]

{-# INLINE accumArray #-}

{-| 
Constructs an immutable array from a list of associations.  Unlike
'array', the same index is allowed to occur multiple times in the list
of associations; an /accumulating function/ is used to combine the
values of elements with the same index.

For example, given a list of values of some index type, hist produces
a histogram of the number of occurrences of each index within a
specified range:

> hist :: (Ix a, Num b) => (a,a) -> [a] -> Array a b
> hist bnds is = accumArray (+) 0 bnds [(i, 1) | i\<-is, inRange bnds i]
-}
accumArray :: (IArray a e, Ix i) 
	=> (e -> e' -> e) 	-- ^ An accumulating function
	-> e			-- ^ A default element
	-> (i,i)		-- ^ The bounds of the array
	-> [(i, e')]		-- ^ List of associations
	-> a i e		-- ^ Returns: the array
accumArray f init (l,u) ies =
    unsafeAccumArray f init (l,u) [(index (l,u) i, e) | (i, e) <- ies]

{-# INLINE (//) #-}
{-|
Takes an array and a list of pairs and returns an array identical to
the left argument except that it has been updated by the associations
in the right argument.  For example, if m is a 1-origin, n by n matrix,
then @m\/\/[((i,i), 0) | i \<- [1..n]]@ is the same matrix, except with
the diagonal zeroed.

As with the 'array' function, if any two associations in the list have
the same index, the value at that index is implementation-dependent.
(In GHC, the last value specified for that index is used.
Other implementations will also do this for unboxed arrays, but Haskell
98 requires that for 'Array' the value at such indices is bottom.)

For most array types, this operation is O(/n/) where /n/ is the size
of the array.  However, the 'Data.Array.Diff.DiffArray' type provides
this operation with complexity linear in the number of updates.
-}
(//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
arr // ies = case bounds arr of
    (l,u) -> unsafeReplace arr [(index (l,u) i, e) | (i, e) <- ies]

{-# INLINE accum #-}
{-|
@accum f@ takes an array and an association list and accumulates pairs
from the list into the array with the accumulating function @f@. Thus
'accumArray' can be defined using 'accum':

> accumArray f z b = accum f (array b [(i, z) | i \<- range b])
-}
accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
accum f arr ies = case bounds arr of
    (l,u) -> unsafeAccum f arr [(index (l,u) i, e) | (i, e) <- ies]

{-# INLINE amap #-}
-- | Returns a new array derived from the original array by applying a
-- function to each of the elements.
amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
amap f arr = case bounds arr of
    (l,u) -> unsafeArray (l,u) [(i, f (unsafeAt arr i)) |
				i <- [0 .. rangeSize (l,u) - 1]]
{-# INLINE ixmap #-}
-- | Returns a new array derived from the original array by applying a
-- function to each of the indices.
ixmap :: (IArray a e, Ix i, Ix j) => (i,i) -> (i -> j) -> a j e -> a i e
ixmap (l,u) f arr =
    unsafeArray (l,u) [(unsafeIndex (l,u) i, arr ! f i) | i <- range (l,u)]

-----------------------------------------------------------------------------
-- Normal polymorphic arrays

instance IArray Arr.Array e where
    {-# INLINE bounds #-}
    bounds = Arr.bounds
    {-# INLINE unsafeArray #-}
    unsafeArray      = Arr.unsafeArray
    {-# INLINE unsafeAt #-}
    unsafeAt         = Arr.unsafeAt
    {-# INLINE unsafeReplace #-}
    unsafeReplace    = Arr.unsafeReplace
    {-# INLINE unsafeAccum #-}
    unsafeAccum      = Arr.unsafeAccum
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray = Arr.unsafeAccumArray

-----------------------------------------------------------------------------
-- Flat unboxed arrays

-- | Arrays with unboxed elements.  Instances of 'IArray' are provided
-- for 'UArray' with certain element types ('Int', 'Float', 'Char',
-- etc.; see the 'UArray' class for a full list).
--
-- A 'UArray' will generally be more efficient (in terms of both time
-- and space) than the equivalent 'Data.Array.Array' with the same
-- element type.  However, 'UArray' is strict in its elements - so
-- don\'t use 'UArray' if you require the non-strictness that
-- 'Data.Array.Array' provides.
--
-- Because the @IArray@ interface provides operations overloaded on
-- the type of the array, it should be possible to just change the
-- array type being used by a program from say @Array@ to @UArray@ to
-- get the benefits of unboxed arrays (don\'t forget to import
-- "Data.Array.Unboxed" instead of "Data.Array").
--




data UArray i e = UArray !i !i !ByteArray


uArrayTc = mkTyCon "UArray"; instance Typeable2 UArray where { typeOf2 _ = mkTyConApp uArrayTc [] }; instance Typeable a => Typeable1 (UArray a) where {   typeOf1 = typeOf1Default }; instance (Typeable a, Typeable b) => Typeable (UArray a b) where {   typeOf = typeOfDefault }

{-# INLINE unsafeArrayUArray #-}
unsafeArrayUArray :: (MArray (STUArray s) e (ST s), Ix i)
                  => (i,i) -> [(Int, e)] -> e -> ST s (UArray i e)
unsafeArrayUArray (l,u) ies default_elem = do
    marr <- newArray (l,u) default_elem
    sequence_ [unsafeWrite marr i e | (i, e) <- ies]
    unsafeFreezeSTUArray marr










unsafeFreezeSTUArray :: STUArray s i e -> ST s (UArray i e)
unsafeFreezeSTUArray (STUArray l u marr) = do
    arr <- unsafeFreezeMutableByteArray marr
    return (UArray l u arr)


{-# INLINE unsafeReplaceUArray #-}
unsafeReplaceUArray :: (MArray (STUArray s) e (ST s), Ix i)
                    => UArray i e -> [(Int, e)] -> ST s (UArray i e)
unsafeReplaceUArray arr ies = do
    marr <- thawSTUArray arr
    sequence_ [unsafeWrite marr i e | (i, e) <- ies]
    unsafeFreezeSTUArray marr

{-# INLINE unsafeAccumUArray #-}
unsafeAccumUArray :: (MArray (STUArray s) e (ST s), Ix i)
                  => (e -> e' -> e) -> UArray i e -> [(Int, e')] -> ST s (UArray i e)
unsafeAccumUArray f arr ies = do
    marr <- thawSTUArray arr
    sequence_ [do
        old <- unsafeRead marr i
        unsafeWrite marr i (f old new)
        | (i, new) <- ies]
    unsafeFreezeSTUArray marr

{-# INLINE unsafeAccumArrayUArray #-}
unsafeAccumArrayUArray :: (MArray (STUArray s) e (ST s), Ix i)
                       => (e -> e' -> e) -> e -> (i,i) -> [(Int, e')] -> ST s (UArray i e)
unsafeAccumArrayUArray f init (l,u) ies = do
    marr <- newArray (l,u) init
    sequence_ [do
        old <- unsafeRead marr i
        unsafeWrite marr i (f old new)
        | (i, new) <- ies]
    unsafeFreezeSTUArray marr

{-# INLINE eqUArray #-}
eqUArray :: (IArray UArray e, Ix i, Eq e) => UArray i e -> UArray i e -> Bool
eqUArray arr1@(UArray l1 u1 _) arr2@(UArray l2 u2 _) =
    if rangeSize (l1,u1) == 0 then rangeSize (l2,u2) == 0 else
    l1 == l2 && u1 == u2 &&
    and [unsafeAt arr1 i == unsafeAt arr2 i | i <- [0 .. rangeSize (l1,u1) - 1]]

{-# INLINE cmpUArray #-}
cmpUArray :: (IArray UArray e, Ix i, Ord e) => UArray i e -> UArray i e -> Ordering
cmpUArray arr1 arr2 = compare (assocs arr1) (assocs arr2)

{-# INLINE cmpIntUArray #-}
cmpIntUArray :: (IArray UArray e, Ord e) => UArray Int e -> UArray Int e -> Ordering
cmpIntUArray arr1@(UArray l1 u1 _) arr2@(UArray l2 u2 _) =
    if rangeSize (l1,u1) == 0 then if rangeSize (l2,u2) == 0 then EQ else LT else
    if rangeSize (l2,u2) == 0 then GT else
    case compare l1 l2 of
        EQ    -> foldr cmp (compare u1 u2) [0 .. rangeSize (l1, min u1 u2) - 1]
        other -> other
    where
    cmp i rest = case compare (unsafeAt arr1 i) (unsafeAt arr2 i) of
        EQ    -> rest
        other -> other

{-# RULES "cmpUArray/Int" cmpUArray = cmpIntUArray #-}

-----------------------------------------------------------------------------
-- Showing IArrays

{-# SPECIALISE 
    showsIArray :: (IArray UArray e, Ix i, Show i, Show e) => 
		   Int -> UArray i e -> ShowS
  #-}

showsIArray :: (IArray a e, Ix i, Show i, Show e) => Int -> a i e -> ShowS
showsIArray p a =
    showParen (p > 9) $
    showString "array " .
    shows (bounds a) .
    showChar ' ' .
    shows (assocs a)

-----------------------------------------------------------------------------
-- Flat unboxed arrays: instances


unsafeAtBArray :: Storable e => UArray i e -> Int -> e
unsafeAtBArray (UArray _ _ arr) = readByteArray arr


instance IArray UArray Bool where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies False)







    unsafeAt (UArray _ _ arr) i =
	testBit (readByteArray arr (bOOL_INDEX i)::BitSet) (bOOL_SUBINDEX i)

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray Char where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies '\0')
    {-# INLINE unsafeAt #-}




    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray Int where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)





    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray Word where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)





    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray (Ptr a) where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies nullPtr)
    {-# INLINE unsafeAt #-}




    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray (FunPtr a) where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies nullFunPtr)





    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray Float where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)





    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray Double where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)





    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray (StablePtr a) where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies nullStablePtr)





    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

-- bogus StablePtr value for initialising a UArray of StablePtr.




nullStablePtr = castPtrToStablePtr nullPtr


instance IArray UArray Int8 where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)





    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray Int16 where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)





    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray Int32 where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)





    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray Int64 where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)





    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray Word8 where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)





    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray Word16 where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)





    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray Word32 where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)





    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance IArray UArray Word64 where
    {-# INLINE bounds #-}
    bounds (UArray l u _) = (l,u)
    {-# INLINE unsafeArray #-}
    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)





    unsafeAt = unsafeAtBArray

    {-# INLINE unsafeReplace #-}
    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)
    {-# INLINE unsafeAccum #-}
    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)
    {-# INLINE unsafeAccumArray #-}
    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)

instance (Ix ix, Eq e, IArray UArray e) => Eq (UArray ix e) where
    (==) = eqUArray

instance (Ix ix, Ord e, IArray UArray e) => Ord (UArray ix e) where
    compare = cmpUArray

instance (Ix ix, Show ix, Show e, IArray UArray e) => Show (UArray ix e) where
    showsPrec = showsIArray

-----------------------------------------------------------------------------
-- Mutable arrays

{-# NOINLINE arrEleBottom #-}
arrEleBottom :: a
arrEleBottom = error "MArray: undefined array element"

{-| Class of mutable array types.

An array type has the form @(a i e)@ where @a@ is the array type
constructor (kind @* -> * -> *@), @i@ is the index type (a member of
the class 'Ix'), and @e@ is the element type.

The @MArray@ class is parameterised over both @a@ and @e@ (so that
instances specialised to certain element types can be defined, in the
same way as for 'IArray'), and also over the type of the monad, @m@,
in which the mutable array will be manipulated.
-}
class (Monad m) => MArray a e m where

    -- | Returns the bounds of the array
    getBounds   :: Ix i => a i e -> m (i,i)

    -- | Builds a new array, with every element initialised to the supplied 
    -- value.
    newArray    :: Ix i => (i,i) -> e -> m (a i e)

    -- | Builds a new array, with every element initialised to undefined.
    newArray_   :: Ix i => (i,i) -> m (a i e)

    unsafeRead  :: Ix i => a i e -> Int -> m e
    unsafeWrite :: Ix i => a i e -> Int -> e -> m ()

    {-# INLINE newArray #-}
	-- The INLINE is crucial, because until we know at least which monad 	
	-- we are in, the code below allocates like crazy.  So inline it,
	-- in the hope that the context will know the monad.
    newArray (l,u) init = do
        marr <- newArray_ (l,u)
        sequence_ [unsafeWrite marr i init | i <- [0 .. rangeSize (l,u) - 1]]
        return marr

    newArray_ (l,u) = newArray (l,u) arrEleBottom

    -- newArray takes an initialiser which all elements of
    -- the newly created array are initialised to.  newArray_ takes
    -- no initialiser, it is assumed that the array is initialised with
    -- "undefined" values.

    -- why not omit newArray_?  Because in the unboxed array case we would
    -- like to omit the initialisation altogether if possible.  We can't do
    -- this for boxed arrays, because the elements must all have valid values
    -- at all times in case of garbage collection.

    -- why not omit newArray?  Because in the boxed case, we can omit the
    -- default initialisation with undefined values if we *do* know the
    -- initial value and it is constant for all elements.

{-# INLINE newListArray #-}
-- | Constructs a mutable array from a list of initial elements.
-- The list gives the elements of the array in ascending order
-- beginning with the lowest index.
newListArray :: (MArray a e m, Ix i) => (i,i) -> [e] -> m (a i e)
newListArray (l,u) es = do
    marr <- newArray_ (l,u)
    let n = rangeSize (l,u)
    let fillFromList i xs | i == n    = return ()
                          | otherwise = case xs of
            []   -> return ()
            y:ys -> unsafeWrite marr i y >> fillFromList (i+1) ys
    fillFromList 0 es
    return marr

{-# INLINE readArray #-}
-- | Read an element from a mutable array
readArray :: (MArray a e m, Ix i) => a i e -> i -> m e
readArray marr i = do
  (l,u) <- getBounds marr
  unsafeRead marr (index (l,u) i)

{-# INLINE writeArray #-}
-- | Write an element in a mutable array
writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
writeArray marr i e = do
  (l,u) <- getBounds marr
  unsafeWrite marr (index (l,u) i) e

{-# INLINE getElems #-}
-- | Return a list of all the elements of a mutable array
getElems :: (MArray a e m, Ix i) => a i e -> m [e]
getElems marr = do 
  (l,u) <- getBounds marr
  sequence [unsafeRead marr i | i <- [0 .. rangeSize (l,u) - 1]]

{-# INLINE getAssocs #-}
-- | Return a list of all the associations of a mutable array, in
-- index order.
getAssocs :: (MArray a e m, Ix i) => a i e -> m [(i, e)]
getAssocs marr = do 
  (l,u) <- getBounds marr
  sequence [ do e <- unsafeRead marr (index (l,u) i); return (i,e)
           | i <- range (l,u)]

{-# INLINE mapArray #-}
-- | Constructs a new array derived from the original array by applying a
-- function to each of the elements.
mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
mapArray f marr = do 
  (l,u) <- getBounds marr
  marr' <- newArray_ (l,u)
  sequence_ [do
        e <- unsafeRead marr i
        unsafeWrite marr' i (f e)
        | i <- [0 .. rangeSize (l,u) - 1]]
  return marr'

{-# INLINE mapIndices #-}
-- | Constructs a new array derived from the original array by applying a
-- function to each of the indices.
mapIndices :: (MArray a e m, Ix i, Ix j) => (i,i) -> (i -> j) -> a j e -> m (a i e)
mapIndices (l,u) f marr = do
    marr' <- newArray_ (l,u)
    sequence_ [do
        e <- readArray marr (f i)
        unsafeWrite marr' (unsafeIndex (l,u) i) e
        | i <- range (l,u)]
    return marr'

-----------------------------------------------------------------------------
-- Polymorphic non-strict mutable arrays (ST monad)

instance MArray (STArray s) e (ST s) where
    {-# INLINE getBounds #-}
    getBounds arr = return $! ArrST.boundsSTArray arr
    {-# INLINE newArray #-}
    newArray    = ArrST.newSTArray
    {-# INLINE unsafeRead #-}
    unsafeRead  = ArrST.unsafeReadSTArray
    {-# INLINE unsafeWrite #-}
    unsafeWrite = ArrST.unsafeWriteSTArray

instance MArray (STArray s) e (Lazy.ST s) where
    {-# INLINE getBounds #-}
    getBounds arr = strictToLazyST (return $! ArrST.boundsSTArray arr)
    {-# INLINE newArray #-}
    newArray (l,u) e    = strictToLazyST (ArrST.newSTArray (l,u) e)
    {-# INLINE unsafeRead #-}
    unsafeRead arr i    = strictToLazyST (ArrST.unsafeReadSTArray arr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite arr i e = strictToLazyST (ArrST.unsafeWriteSTArray arr i e)


sTArrayTc = mkTyCon "STArray"; instance Typeable3 STArray where { typeOf3 _ = mkTyConApp sTArrayTc [] }; instance Typeable a => Typeable2 (STArray a) where {   typeOf2 = typeOf2Default }; instance (Typeable a, Typeable b) => Typeable1 (STArray a b) where {   typeOf1 = typeOf1Default }; instance (Typeable a, Typeable b, Typeable c) => Typeable (STArray a b c) where {   typeOf = typeOfDefault }


-----------------------------------------------------------------------------
-- Flat unboxed mutable arrays (ST monad)

-- | A mutable array with unboxed elements, that can be manipulated in
-- the 'ST' monad.  The type arguments are as follows:
--
--  * @s@: the state variable argument for the 'ST' type
--
--  * @i@: the index type of the array (should be an instance of @Ix@)
--
--  * @e@: the element type of the array.  Only certain element types
--    are supported.
--
-- An 'STUArray' will generally be more efficient (in terms of both time
-- and space) than the equivalent boxed version ('STArray') with the same
-- element type.  However, 'STUArray' is strict in its elements - so
-- don\'t use 'STUArray' if you require the non-strictness that
-- 'STArray' provides.




data STUArray s i a = STUArray !i !i !(MutableByteArray s)


stUArrayTc = mkTyCon "STUArray"; instance Typeable3 STUArray where { typeOf3 _ = mkTyConApp stUArrayTc [] }; instance Typeable a => Typeable2 (STUArray a) where {   typeOf2 = typeOf2Default }; instance (Typeable a, Typeable b) => Typeable1 (STUArray a b) where {   typeOf1 = typeOf1Default }; instance (Typeable a, Typeable b, Typeable c) => Typeable (STUArray a b c) where {   typeOf = typeOfDefault }















































































































































































































































































































































newMBArray_ :: (Ix i, Storable e) => (i,i) -> ST s (STUArray s i e)
newMBArray_ = makeArray undefined
  where
    makeArray :: (Ix i, Storable e) => e -> (i,i) -> ST s (STUArray s i e)
    makeArray dummy (l,u) = do
	marr <- newMutableByteArray (rangeSize (l,u) * sizeOf dummy)
	return (STUArray l u marr)

unsafeReadMBArray :: Storable e => STUArray s i e -> Int -> ST s e
unsafeReadMBArray (STUArray _ _ marr) = readMutableByteArray marr

unsafeWriteMBArray :: Storable e => STUArray s i e -> Int -> e -> ST s ()
unsafeWriteMBArray (STUArray _ _ marr) = writeMutableByteArray marr

getBoundsMBArray (STUArray l u _) = return (l,u)

instance MArray (STUArray s) Bool (ST s) where
    getBounds = getBoundsMBArray
    newArray_ (l,u) = do
        marr <- newMutableByteArray (bOOL_SCALE (rangeSize (l,u)))
        return (STUArray l u marr)
    unsafeRead (STUArray _ _ marr) i = do
	let ix = bOOL_INDEX i
	    bit = bOOL_SUBINDEX i
	w <- readMutableByteArray marr ix
	return (testBit (w::BitSet) bit)
    unsafeWrite (STUArray _ _ marr) i e = do
	let ix = bOOL_INDEX i
	    bit = bOOL_SUBINDEX i
	w <- readMutableByteArray marr ix
	writeMutableByteArray marr ix
	    (if e then setBit (w::BitSet) bit else clearBit w bit)

instance MArray (STUArray s) Char (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) Int (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) Word (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) (Ptr a) (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) (FunPtr a) (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) Float (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) Double (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) (StablePtr a) (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) Int8 (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) Int16 (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) Int32 (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) Int64 (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) Word8 (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) Word16 (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) Word32 (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

instance MArray (STUArray s) Word64 (ST s) where
    getBounds = getBoundsMBArray
    newArray_ = newMBArray_
    unsafeRead = unsafeReadMBArray
    unsafeWrite = unsafeWriteMBArray

type BitSet = Word8

bitSetSize = bitSize (0::BitSet)

bOOL_SCALE :: Int -> Int
bOOL_SCALE n = (n + bitSetSize - 1) `div` bitSetSize
 
bOOL_INDEX :: Int -> Int
bOOL_INDEX i = i `div` bitSetSize

bOOL_SUBINDEX :: Int -> Int
bOOL_SUBINDEX i = i `mod` bitSetSize


-----------------------------------------------------------------------------
-- Freezing

-- | Converts a mutable array (any instance of 'MArray') to an
-- immutable array (any instance of 'IArray') by taking a complete
-- copy of it.
freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
freeze marr = do
  (l,u) <- getBounds marr
  ies <- sequence [do e <- unsafeRead marr i; return (i,e)
                   | i <- [0 .. rangeSize (l,u) - 1]]
  return (unsafeArray (l,u) ies)
















-- In-place conversion of mutable arrays to immutable ones places
-- a proof obligation on the user: no other parts of your code can
-- have a reference to the array at the point where you unsafely
-- freeze it (and, subsequently mutate it, I suspect).

{- |
   Converts an mutable array into an immutable array.  The 
   implementation may either simply cast the array from
   one type to the other without copying the array, or it
   may take a full copy of the array.

   Note that because the array is possibly not copied, any subsequent
   modifications made to the mutable version of the array may be
   shared with the immutable version.  It is safe to use, therefore, if
   the mutable version is never modified after the freeze operation.

   The non-copying implementation is supported between certain pairs
   of array types only; one constraint is that the array types must
   have identical representations.  In GHC, The following pairs of
   array types have a non-copying O(1) implementation of
   'unsafeFreeze'.  Because the optimised versions are enabled by
   specialisations, you will need to compile with optimisation (-O) to
   get them.

     * 'Data.Array.IO.IOUArray' -> 'Data.Array.Unboxed.UArray'

     * 'Data.Array.ST.STUArray' -> 'Data.Array.Unboxed.UArray'

     * 'Data.Array.IO.IOArray' -> 'Data.Array.Array'

     * 'Data.Array.ST.STArray' -> 'Data.Array.Array'
-}
{-# INLINE unsafeFreeze #-}
unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
unsafeFreeze = freeze

{-# RULES
"unsafeFreeze/STArray"  unsafeFreeze = ArrST.unsafeFreezeSTArray
"unsafeFreeze/STUArray" unsafeFreeze = unsafeFreezeSTUArray
    #-}

-----------------------------------------------------------------------------
-- Thawing

-- | Converts an immutable array (any instance of 'IArray') into a
-- mutable array (any instance of 'MArray') by taking a complete copy
-- of it.
thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
thaw arr = case bounds arr of
  (l,u) -> do
    marr <- newArray_ (l,u)
    sequence_ [unsafeWrite marr i (unsafeAt arr i)
               | i <- [0 .. rangeSize (l,u) - 1]]
    return marr



















thawSTUArray :: Ix i => UArray i e -> ST s (STUArray s i e)
thawSTUArray (UArray l u arr) = do
    marr <- thawByteArray arr
    return (STUArray l u marr)


-- In-place conversion of immutable arrays to mutable ones places
-- a proof obligation on the user: no other parts of your code can
-- have a reference to the array at the point where you unsafely
-- thaw it (and, subsequently mutate it, I suspect).

{- |
   Converts an immutable array into a mutable array.  The 
   implementation may either simply cast the array from
   one type to the other without copying the array, or it
   may take a full copy of the array.  

   Note that because the array is possibly not copied, any subsequent
   modifications made to the mutable version of the array may be
   shared with the immutable version.  It is only safe to use,
   therefore, if the immutable array is never referenced again in this
   thread, and there is no possibility that it can be also referenced
   in another thread.  If you use an unsafeThaw/write/unsafeFreeze
   sequence in a multi-threaded setting, then you must ensure that
   this sequence is atomic with respect to other threads, or a garbage
   collector crash may result (because the write may be writing to a
   frozen array).

   The non-copying implementation is supported between certain pairs
   of array types only; one constraint is that the array types must
   have identical representations.  In GHC, The following pairs of
   array types have a non-copying O(1) implementation of
   'unsafeThaw'.  Because the optimised versions are enabled by
   specialisations, you will need to compile with optimisation (-O) to
   get them.

     * 'Data.Array.Unboxed.UArray' -> 'Data.Array.IO.IOUArray'

     * 'Data.Array.Unboxed.UArray' -> 'Data.Array.ST.STUArray'

     * 'Data.Array.Array'  -> 'Data.Array.IO.IOArray'

     * 'Data.Array.Array'  -> 'Data.Array.ST.STArray'
-}
{-# INLINE unsafeThaw #-}
unsafeThaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
unsafeThaw = thaw













-- | Casts an 'STUArray' with one element type into one with a
-- different element type.  All the elements of the resulting array
-- are undefined (unless you know what you\'re doing...).







castSTUArray :: STUArray s ix a -> ST s (STUArray s ix b)
castSTUArray (STUArray l u marr) = return (STUArray l u marr)

-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Array.Diff
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (uses Data.Array.IArray)
--
-- Functional arrays with constant-time update.
--
-----------------------------------------------------------------------------

module Data.Array.Diff (

    -- * Diff array types

    -- | Diff arrays have an immutable interface, but rely on internal
    -- updates in place to provide fast functional update operator
    -- '//'.
    --
    -- When the '//' operator is applied to a diff array, its contents
    -- are physically updated in place. The old array silently changes
    -- its representation without changing the visible behavior:
    -- it stores a link to the new current array along with the
    -- difference to be applied to get the old contents.
    --
    -- So if a diff array is used in a single-threaded style,
    -- i.e. after '//' application the old version is no longer used,
    -- @a'!'i@ takes O(1) time and @a '//' d@ takes O(@length d@).
    -- Accessing elements of older versions gradually becomes slower.
    --
    -- Updating an array which is not current makes a physical copy.
    -- The resulting array is unlinked from the old family. So you
    -- can obtain a version which is guaranteed to be current and
    -- thus have fast element access by @a '//' []@.

    -- Possible improvement for the future (not implemented now):
    -- make it possible to say "I will make an update now, but when
    -- I later return to the old version, I want it to mutate back
    -- instead of being copied".

    IOToDiffArray, -- data IOToDiffArray
                   --     (a :: * -> * -> *) -- internal mutable array
                   --     (i :: *)           -- indices
                   --     (e :: *)           -- elements

    -- | Type synonyms for the two most important IO array types.

    -- Two most important diff array types are fully polymorphic
    -- lazy boxed DiffArray:
    DiffArray,     -- = IOToDiffArray IOArray
    -- ...and strict unboxed DiffUArray, working only for elements
    -- of primitive types but more compact and usually faster:
    DiffUArray,    -- = IOToDiffArray IOUArray

    -- * Overloaded immutable array interface
    
    -- | Module "Data.Array.IArray" provides the interface of diff arrays.
    -- They are instances of class 'IArray'.
    module Data.Array.IArray,

    -- * Low-level interface

    -- | These are really internal functions, but you will need them
    -- to make further 'IArray' instances of various diff array types
    -- (for either more 'MArray' types or more unboxed element types).
    newDiffArray, readDiffArray, replaceDiffArray
    )
    where

------------------------------------------------------------------------
-- Imports.

import Prelude

import Data.Ix
import Data.Array.Base
import Data.Array.IArray
import Data.Array.IO

import Foreign.Ptr        ( Ptr, FunPtr )
import Foreign.StablePtr  ( StablePtr )
import Data.Int           ( Int8,  Int16,  Int32,  Int64 )
import Data.Word          ( Word, Word8, Word16, Word32, Word64 )

import System.IO.Unsafe	  ( unsafePerformIO )
import Control.Exception  ( evaluate )
import Control.Concurrent.MVar ( MVar, newMVar, takeMVar, putMVar, readMVar )

------------------------------------------------------------------------
-- Diff array types.

-- | An arbitrary 'MArray' type living in the 'IO' monad can be converted
-- to a diff array.

newtype IOToDiffArray a i e =
    DiffArray {varDiffArray :: MVar (DiffArrayData a i e)}

-- Internal representation: either a mutable array, or a link to
-- another diff array patched with a list of index+element pairs.
data DiffArrayData a i e = Current (a i e)
                         | Diff (IOToDiffArray a i e) [(Int, e)]

-- | Fully polymorphic lazy boxed diff array.
type DiffArray  = IOToDiffArray IOArray

-- | Strict unboxed diff array, working only for elements
-- of primitive types but more compact and usually faster than 'DiffArray'.
type DiffUArray = IOToDiffArray IOUArray

-- Having 'MArray a e IO' in instance context would require
-- -fallow-undecidable-instances, so each instance is separate here.

------------------------------------------------------------------------
-- Showing DiffArrays

instance (Ix ix, Show ix, Show e) => Show (DiffArray ix e) where
  showsPrec = showsIArray

instance (Ix ix, Show ix) => Show (DiffUArray ix Char) where
  showsPrec = showsIArray

instance (Ix ix, Show ix) => Show (DiffUArray ix Int) where
  showsPrec = showsIArray

instance (Ix ix, Show ix) => Show (DiffUArray ix Word) where
  showsPrec = showsIArray

instance (Ix ix, Show ix) => Show (DiffUArray ix Float) where
  showsPrec = showsIArray

instance (Ix ix, Show ix) => Show (DiffUArray ix Double) where
  showsPrec = showsIArray

instance (Ix ix, Show ix) => Show (DiffUArray ix Int8) where
  showsPrec = showsIArray

instance (Ix ix, Show ix) => Show (DiffUArray ix Int16) where
  showsPrec = showsIArray

instance (Ix ix, Show ix) => Show (DiffUArray ix Int32) where
  showsPrec = showsIArray

instance (Ix ix, Show ix) => Show (DiffUArray ix Int64) where
  showsPrec = showsIArray

instance (Ix ix, Show ix) => Show (DiffUArray ix Word8) where
  showsPrec = showsIArray

instance (Ix ix, Show ix) => Show (DiffUArray ix Word16) where
  showsPrec = showsIArray

instance (Ix ix, Show ix) => Show (DiffUArray ix Word32) where
  showsPrec = showsIArray

instance (Ix ix, Show ix) => Show (DiffUArray ix Word64) where
  showsPrec = showsIArray

------------------------------------------------------------------------
-- Boring instances.

instance IArray (IOToDiffArray IOArray) e where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray1` ies

instance IArray (IOToDiffArray IOUArray) Char where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) Int where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) Word where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) (Ptr a) where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) (FunPtr a) where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) Float where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) Double where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) (StablePtr a) where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) Int8 where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) Int16 where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) Int32 where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) Int64 where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) Word8 where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) Word16 where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) Word32 where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies

instance IArray (IOToDiffArray IOUArray) Word64 where
    bounds        a      = unsafePerformIO $ boundsDiffArray a
    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies
    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i
    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray2` ies



------------------------------------------------------------------------
-- The important stuff.

newDiffArray :: (MArray a e IO, Ix i)
             => (i,i)
             -> [(Int, e)]
             -> IO (IOToDiffArray a i e)
newDiffArray (l,u) ies = do
    a <- newArray_ (l,u)
    sequence_ [unsafeWrite a i e | (i, e) <- ies]
    var <- newMVar (Current a)
    return (DiffArray var)

readDiffArray :: (MArray a e IO, Ix i)
              => IOToDiffArray a i e
              -> Int
              -> IO e
a `readDiffArray` i = do
    d <- readMVar (varDiffArray a)
    case d of
        Current a'  -> unsafeRead a' i
        Diff a' ies -> maybe (readDiffArray a' i) return (lookup i ies)

replaceDiffArray :: (MArray a e IO, Ix i)
                => IOToDiffArray a i e
                -> [(Int, e)]
                -> IO (IOToDiffArray a i e)
a `replaceDiffArray` ies = do
    d <- takeMVar (varDiffArray a)
    case d of
        Current a' -> case ies of
            [] -> do
                -- We don't do the copy when there is nothing to change
                -- and this is the current version. But see below.
                putMVar (varDiffArray a) d
                return a
            _:_ -> do
                diff <- sequence [do e <- unsafeRead a' i; return (i, e)
                                  | (i, _) <- ies]
                sequence_ [unsafeWrite a' i e | (i, e) <- ies]
                var' <- newMVar (Current a')
                putMVar (varDiffArray a) (Diff (DiffArray var') diff)
                return (DiffArray var')
        Diff _ _ -> do
            -- We still do the copy when there is nothing to change
            -- but this is not the current version. So you can use
            -- 'a // []' to make sure that the resulting array has
            -- fast element access.
            putMVar (varDiffArray a) d
            a' <- thawDiffArray a
                -- thawDiffArray gives a fresh array which we can
                -- safely mutate.
            sequence_ [unsafeWrite a' i e | (i, e) <- ies]
            var' <- newMVar (Current a')
            return (DiffArray var')

-- The elements of the diff list might recursively reference the
-- array, so we must seq them before taking the MVar to avoid
-- deadlock.
replaceDiffArray1 :: (MArray a e IO, Ix i)
                => IOToDiffArray a i e
                -> [(Int, e)]
                -> IO (IOToDiffArray a i e)
a `replaceDiffArray1` ies = do
    mapM_ (evaluate . fst) ies
    a `replaceDiffArray` ies

-- If the array contains unboxed elements, then the elements of the
-- diff list may also recursively reference the array from inside
-- replaceDiffArray, so we must seq them too.
replaceDiffArray2 :: (MArray a e IO, Ix i)
                => IOToDiffArray a i e
                -> [(Int, e)]
                -> IO (IOToDiffArray a i e)
a `replaceDiffArray2` ies = do
    mapM_ (\(a,b) -> do evaluate a; evaluate b) ies
    a `replaceDiffArray` ies


boundsDiffArray :: (MArray a e IO, Ix ix)
                => IOToDiffArray a ix e
                -> IO (ix,ix)
boundsDiffArray a = do
    d <- readMVar (varDiffArray a)
    case d of
        Current a' -> getBounds a'
        Diff a' _  -> boundsDiffArray a'

freezeDiffArray :: (MArray a e IO, Ix ix)
                => a ix e
                -> IO (IOToDiffArray a ix e)
freezeDiffArray a = do
  (l,u) <- getBounds a
  a' <- newArray_ (l,u)
  sequence_ [unsafeRead a i >>= unsafeWrite a' i | i <- [0 .. rangeSize (l,u) - 1]]
  var <- newMVar (Current a')
  return (DiffArray var)

{-# RULES
"freeze/DiffArray" freeze = freezeDiffArray
    #-}

-- unsafeFreezeDiffArray is really unsafe. Better don't use the old
-- array at all after freezing. The contents of the source array will
-- be changed when '//' is applied to the resulting array.

unsafeFreezeDiffArray :: (MArray a e IO, Ix ix)
                      => a ix e
                      -> IO (IOToDiffArray a ix e)
unsafeFreezeDiffArray a = do
    var <- newMVar (Current a)
    return (DiffArray var)

{-# RULES
"unsafeFreeze/DiffArray" unsafeFreeze = unsafeFreezeDiffArray
    #-}

thawDiffArray :: (MArray a e IO, Ix ix)
              => IOToDiffArray a ix e
              -> IO (a ix e)
thawDiffArray a = do
    d <- readMVar (varDiffArray a)
    case d of
        Current a' -> do
	    (l,u) <- getBounds a'
            a'' <- newArray_ (l,u)
            sequence_ [unsafeRead a' i >>= unsafeWrite a'' i | i <- [0 .. rangeSize (l,u) - 1]]
            return a''
        Diff a' ies -> do
            a'' <- thawDiffArray a'
            sequence_ [unsafeWrite a'' i e | (i, e) <- ies]
            return a''

{-# RULES
"thaw/DiffArray" thaw = thawDiffArray
    #-}

-- unsafeThawDiffArray is really unsafe. Better don't use the old
-- array at all after thawing. The contents of the resulting array
-- will be changed when '//' is applied to the source array.

unsafeThawDiffArray :: (MArray a e IO, Ix ix)
                    => IOToDiffArray a ix e
                    -> IO (a ix e)
unsafeThawDiffArray a = do
    d <- readMVar (varDiffArray a)
    case d of
        Current a'  -> return a'
        Diff a' ies -> do
            a'' <- unsafeThawDiffArray a'
            sequence_ [unsafeWrite a'' i e | (i, e) <- ies]
            return a''

{-# RULES
"unsafeThaw/DiffArray" unsafeThaw = unsafeThawDiffArray
    #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Array.IArray
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (uses Data.Array.Base)
--
-- Immutable arrays, with an overloaded interface.  For array types which
-- can be used with this interface, see the 'Array' type exported by this
-- module, and the "Data.Array.Unboxed" and "Data.Array.Diff" modules.
--
-----------------------------------------------------------------------------

module Data.Array.IArray ( 
    -- * Array classes
    IArray,     -- :: (* -> * -> *) -> * -> class

    module Data.Ix,

    -- * Immutable non-strict (boxed) arrays
    Array,    

    -- * Array construction
    array,      -- :: (IArray a e, Ix i) => (i,i) -> [(i, e)] -> a i e
    listArray,  -- :: (IArray a e, Ix i) => (i,i) -> [e] -> a i e
    accumArray, -- :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i,i) -> [(i, e')] -> a i e

    -- * Accessing arrays
    (!),        -- :: (IArray a e, Ix i) => a i e -> i -> e
    bounds,     -- :: (HasBounds a, Ix i) => a i e -> (i,i)
    indices,    -- :: (HasBounds a, Ix i) => a i e -> [i]
    elems,      -- :: (IArray a e, Ix i) => a i e -> [e]
    assocs,     -- :: (IArray a e, Ix i) => a i e -> [(i, e)]

    -- * Incremental array updates
    (//),       -- :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
    accum,      -- :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e

    -- * Derived arrays
    amap,       -- :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
    ixmap,      -- :: (IArray a e, Ix i, Ix j) => (i,i) -> (i -> j) -> a j e -> a i e
 )  where

import Prelude

import Data.Ix
import Data.Array (Array)
import Data.Array.Base
{-# OPTIONS_GHC -#include "HsBase.h" #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Array.IO
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (uses Data.Array.MArray)
--
-- Mutable boxed and unboxed arrays in the IO monad.
--
-----------------------------------------------------------------------------

module Data.Array.IO (
   -- * @IO@ arrays with boxed elements
   IOArray,		-- instance of: Eq, Typeable

   -- * @IO@ arrays with unboxed elements
   IOUArray,		-- instance of: Eq, Typeable
   castIOUArray,	-- :: IOUArray i a -> IO (IOUArray i b)

   -- * Overloaded mutable array interface
   module Data.Array.MArray,

   -- * Doing I\/O with @IOUArray@s
   hGetArray,		-- :: Handle -> IOUArray Int Word8 -> Int -> IO Int
   hPutArray,		-- :: Handle -> IOUArray Int Word8 -> Int -> IO ()
 ) where

import Prelude

import Data.Array.Base
import Data.Array.IO.Internals
import Data.Array		( Array )
import Data.Array.MArray
import Data.Int
import Data.Word









import Data.Char
import System.IO
import System.IO.Error
















































































































































































hGetArray :: Handle -> IOUArray Int Word8 -> Int -> IO Int
hGetArray handle arr count = do
	bds <- getBounds arr
	if count < 0 || count > rangeSize bds
	   then illegalBufferSize handle "hGetArray" count
	   else get 0
 where
  get i | i == count = return i
	| otherwise = do
		error_or_c <- try (hGetChar handle)
		case error_or_c of
		    Left ex
			| isEOFError ex -> return i
			| otherwise -> ioError ex
		    Right c -> do
			unsafeWrite arr i (fromIntegral (ord c))
			get (i+1)

hPutArray :: Handle -> IOUArray Int Word8 -> Int -> IO ()
hPutArray handle arr count = do
	bds <- getBounds arr
	if count < 0 || count > rangeSize bds
	   then illegalBufferSize handle "hPutArray" count
	   else put 0
 where
  put i | i == count = return ()
	| otherwise = do
		w <- unsafeRead arr i
		hPutChar handle (chr (fromIntegral w))
		put (i+1)

illegalBufferSize :: Handle -> String -> Int -> IO a
illegalBufferSize _ fn sz = ioError $
	userError (fn ++ ": illegal buffer size " ++ showsPrec 9 (sz::Int) [])

-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Array.MArray
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (uses Data.Array.Base)
--
-- An overloaded interface to mutable arrays.  For array types which can be
-- used with this interface, see "Data.Array.IO", "Data.Array.ST", 
-- and "Data.Array.Storable".
--
-----------------------------------------------------------------------------

module Data.Array.MArray ( 
    -- * Class of mutable array types
    MArray,       -- :: (* -> * -> *) -> * -> (* -> *) -> class

    -- * The @Ix@ class and operations
    module Data.Ix,

    -- * Constructing mutable arrays
    newArray,     -- :: (MArray a e m, Ix i) => (i,i) -> e -> m (a i e)
    newArray_,    -- :: (MArray a e m, Ix i) => (i,i) -> m (a i e)
    newListArray, -- :: (MArray a e m, Ix i) => (i,i) -> [e] -> m (a i e)

    -- * Reading and writing mutable arrays
    readArray,    -- :: (MArray a e m, Ix i) => a i e -> i -> m e
    writeArray,   -- :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()

    -- * Derived arrays
    mapArray,     -- :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
    mapIndices,   -- :: (MArray a e m, Ix i, Ix j) => (i,i) -> (i -> j) -> a j e -> m (a i e)

    -- * Deconstructing mutable arrays
    getBounds,    -- :: (MArray a e m, Ix i) => a i e -> m (i,i)
    getElems,     -- :: (MArray a e m, Ix i) => a i e -> m [e]
    getAssocs,    -- :: (MArray a e m, Ix i) => a i e -> m [(i, e)]

    -- * Conversions between mutable and immutable arrays
    freeze,       -- :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
    unsafeFreeze, -- :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
    thaw,         -- :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
    unsafeThaw,   -- :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
  ) where

import Prelude

import Data.Ix



import Data.Array.Base
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Array.ST
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (uses Data.Array.MArray)
--
-- Mutable boxed and unboxed arrays in the 'Control.Monad.ST.ST' monad.
--
-----------------------------------------------------------------------------

module Data.Array.ST (

   -- * Boxed arrays
   STArray,		-- instance of: Eq, MArray
   runSTArray,

   -- * Unboxed arrays
   STUArray,		-- instance of: Eq, MArray
   runSTUArray,
   castSTUArray,	-- :: STUArray s i a -> ST s (STUArray s i b)

   -- * Overloaded mutable array interface
   module Data.Array.MArray,
 ) where

import Prelude

import Data.Array.MArray
import Data.Array.Base	( STUArray, castSTUArray, UArray, unsafeFreezeSTUArray )
import Control.Monad.ST	( ST, runST )


import Hugs.Array	( Array )
import Hugs.ST		( STArray, unsafeFreezeSTArray )






-- | A safe way to create and work with a mutable array before returning an
-- immutable array for later perusal.  This function avoids copying
-- the array before returning it - it uses 'unsafeFreeze' internally, but
-- this wrapper is a safe interface to that function.
--
runSTArray :: (Ix i)
	   => (forall s . ST s (STArray s i e))
	   -> Array i e
runSTArray st = runST (st >>= unsafeFreezeSTArray)

-- | A safe way to create and work with an unboxed mutable array before
-- returning an immutable array for later perusal.  This function
-- avoids copying the array before returning it - it uses
-- 'unsafeFreeze' internally, but this wrapper is a safe interface to
-- that function.
--
runSTUArray :: (Ix i)
	   => (forall s . ST s (STUArray s i e))
	   -> UArray i e
runSTUArray st = runST (st >>= unsafeFreezeSTUArray)


-- INTERESTING... this is the type we'd like to give to runSTUArray:
--
-- runSTUArray :: (Ix i, IArray UArray e, 
--	        forall s. MArray (STUArray s) e (ST s))
-- 	   => (forall s . ST s (STUArray s i e))
--	   -> UArray i e
--
-- Note the quantified constraint.  We dodged the problem by using
-- unsafeFreezeSTUArray directly in the defn of runSTUArray above, but
-- this essentially constrains us to a single unsafeFreeze for all STUArrays
-- (in theory we might have a different one for certain element types).
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Array.Storable
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (uses Data.Array.MArray)
--
-- A storable array is an IO-mutable array which stores its
-- contents in a contiguous memory block living in the C
-- heap. Elements are stored according to the class 'Storable'.
-- You can obtain the pointer to the array contents to manipulate
-- elements from languages like C.
--
-- It is similar to 'Data.Array.IO.IOUArray' but slower.
-- Its advantage is that it's compatible with C.
--
-----------------------------------------------------------------------------

module Data.Array.Storable (
    
    -- * Arrays of 'Storable' things.
    StorableArray, -- data StorableArray index element
                   --     -- index type must be in class Ix
                   --     -- element type must be in class Storable
    
    -- * Overloaded mutable array interface
    -- | Module "Data.Array.MArray" provides the interface of storable arrays.
    -- They are instances of class 'MArray' (with the 'IO' monad).
    module Data.Array.MArray,
    
    -- * Accessing the pointer to the array contents
    withStorableArray, -- :: StorableArray i e -> (Ptr e -> IO a) -> IO a
    
    touchStorableArray, -- :: StorableArray i e -> IO ()

    unsafeForeignPtrToStorableArray
    )
    where

import Prelude

import Data.Array.Base
import Data.Array.MArray
import Foreign hiding (newArray)

-- |The array type
data StorableArray i e = StorableArray !i !i !(ForeignPtr e)

instance Storable e => MArray StorableArray e IO where
    getBounds (StorableArray l u _) = return (l,u)

    newArray (l,u) init = do
        fp <- mallocForeignPtrArray size
        withForeignPtr fp $ \a ->
            sequence_ [pokeElemOff a i init | i <- [0..size-1]]
        return (StorableArray l u fp)
        where
        size = rangeSize (l,u)

    newArray_ (l,u) = do
        fp <- mallocForeignPtrArray (rangeSize (l,u))
        return (StorableArray l u fp)

    unsafeRead (StorableArray _ _ fp) i =
        withForeignPtr fp $ \a -> peekElemOff a i

    unsafeWrite (StorableArray _ _ fp) i e =
        withForeignPtr fp $ \a -> pokeElemOff a i e

-- |The pointer to the array contents is obtained by 'withStorableArray'.
-- The idea is similar to 'ForeignPtr' (used internally here).
-- The pointer should be used only during execution of the 'IO' action
-- retured by the function passed as argument to 'withStorableArray'.
withStorableArray :: StorableArray i e -> (Ptr e -> IO a) -> IO a
withStorableArray (StorableArray _ _ fp) f = withForeignPtr fp f

-- |If you want to use it afterwards, ensure that you
-- 'touchStorableArray' after the last use of the pointer,
-- so the array is not freed too early.
touchStorableArray :: StorableArray i e -> IO ()
touchStorableArray (StorableArray _ _ fp) = touchForeignPtr fp

-- |Construct a 'StorableArray' from an arbitrary 'ForeignPtr'.  It is
-- the caller's responsibility to ensure that the 'ForeignPtr' points to
-- an area of memory sufficient for the specified bounds.
unsafeForeignPtrToStorableArray 
   :: ForeignPtr e -> (i,i) -> IO (StorableArray i e)
unsafeForeignPtrToStorableArray p (l,u) =
   return (StorableArray l u p)
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Array.Unboxed
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (uses Data.Array.IArray)
--
-- Unboxed immutable arrays.
--
-----------------------------------------------------------------------------

module Data.Array.Unboxed (
   -- * Arrays with unboxed elements
   UArray,

   -- * The overloaded immutable array interface
   module Data.Array.IArray,
 ) where

import Prelude

import Data.Array.IArray
import Data.Array.Base
{-# OPTIONS_GHC -#include "HsBase.h" #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Array.IO.Internal
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (uses Data.Array.Base)
--
-- Mutable boxed and unboxed arrays in the IO monad.
--
-----------------------------------------------------------------------------

-- #hide
module Data.Array.IO.Internals (
   IOArray(..),		-- instance of: Eq, Typeable
   IOUArray(..),	-- instance of: Eq, Typeable
   castIOUArray,	-- :: IOUArray ix a -> IO (IOUArray ix b)
 ) where

import Prelude

import Data.Array.MArray
import Data.Int
import Data.Word
import Data.Typeable


import Hugs.IOArray


import Control.Monad.ST		( RealWorld, stToIO )
import Foreign.Ptr		( Ptr, FunPtr )
import Foreign.StablePtr	( StablePtr )
import Data.Array.Base






                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
























































iOArrayTc = mkTyCon "IOArray"; instance Typeable2 IOArray where { typeOf2 _ = mkTyConApp iOArrayTc [] }; instance Typeable a => Typeable1 (IOArray a) where {   typeOf1 = typeOf1Default }; instance (Typeable a, Typeable b) => Typeable (IOArray a b) where {   typeOf = typeOfDefault }

-----------------------------------------------------------------------------
-- | Instance declarations for 'IOArray's

instance MArray IOArray e IO where

    getBounds   = return . boundsIOArray




    newArray    = newIOArray
    unsafeRead  = unsafeReadIOArray
    unsafeWrite = unsafeWriteIOArray

-----------------------------------------------------------------------------
-- Flat unboxed mutable arrays (IO monad)

-- | Mutable, unboxed, strict arrays in the 'IO' monad.  The type
-- arguments are as follows:
--
--  * @i@: the index type of the array (should be an instance of 'Ix')
--
--  * @e@: the element type of the array.  Only certain element types
--    are supported: see "Data.Array.MArray" for a list of instances.
--
newtype IOUArray i e = IOUArray (STUArray RealWorld i e)

iOUArrayTc = mkTyCon "IOUArray"; instance Typeable2 IOUArray where { typeOf2 _ = mkTyConApp iOUArrayTc [] }; instance Typeable a => Typeable1 (IOUArray a) where {   typeOf1 = typeOf1Default }; instance (Typeable a, Typeable b) => Typeable (IOUArray a b) where {   typeOf = typeOfDefault }

instance MArray IOUArray Bool IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray Char IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray Int IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray Word IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray (Ptr a) IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray (FunPtr a) IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray Float IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray Double IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray (StablePtr a) IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray Int8 IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray Int16 IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray Int32 IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray Int64 IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray Word8 IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray Word16 IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray Word32 IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

instance MArray IOUArray Word64 IO where
    {-# INLINE getBounds #-}
    getBounds (IOUArray arr) = stToIO $ getBounds arr
    {-# INLINE newArray #-}
    newArray lu init = stToIO $ do
        marr <- newArray lu init; return (IOUArray marr)
    {-# INLINE newArray_ #-}
    newArray_ lu = stToIO $ do
        marr <- newArray_ lu; return (IOUArray marr)
    {-# INLINE unsafeRead #-}
    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)
    {-# INLINE unsafeWrite #-}
    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)

-- | Casts an 'IOUArray' with one element type into one with a
-- different element type.  All the elements of the resulting array
-- are undefined (unless you know what you\'re doing...).
castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
castIOUArray (IOUArray marr) = stToIO $ do
    marr' <- castSTUArray marr
    return (IOUArray marr')

/* Machine generated file, do not modify */
#include <stdlib.h>
#include "HsFFI.h"
#include "HsBase.h"

static HugsAPI5 *hugs = 0;
#include "fpstring.h"

#ifndef ENABLE_MACRO_INTERFACE
#undef fps_count
#endif

static void hugsprim_fps_count_13(HugsStackPtr);
static void hugsprim_fps_count_13(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord64 arg2;
    HsWord8 arg3;
    HsWord64 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getWord64();
    arg3 = hugs->getWord8();
    res1 = fps_count(arg1, arg2, arg3);
    hugs->putWord64(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef fps_minimum
#endif

static void hugsprim_fps_minimum_12(HugsStackPtr);
static void hugsprim_fps_minimum_12(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord64 arg2;
    HsWord8 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getWord64();
    res1 = fps_minimum(arg1, arg2);
    hugs->putWord8(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef fps_maximum
#endif

static void hugsprim_fps_maximum_11(HugsStackPtr);
static void hugsprim_fps_maximum_11(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord64 arg2;
    HsWord8 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getWord64();
    res1 = fps_maximum(arg1, arg2);
    hugs->putWord8(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef fps_intersperse
#endif

static void hugsprim_fps_intersperse_10(HugsStackPtr);
static void hugsprim_fps_intersperse_10(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr arg2;
    HsWord64 arg3;
    HsWord8 arg4;
    arg1 = hugs->getPtr();
    arg2 = hugs->getPtr();
    arg3 = hugs->getWord64();
    arg4 = hugs->getWord8();
    fps_intersperse(arg1, arg2, arg3, arg4);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef fps_reverse
#endif

static void hugsprim_fps_reverse_9(HugsStackPtr);
static void hugsprim_fps_reverse_9(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr arg2;
    HsWord64 arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getPtr();
    arg3 = hugs->getWord64();
    fps_reverse(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}
#include "string.h"

#ifndef ENABLE_MACRO_INTERFACE
#undef memset
#endif

static void hugsprim_memset_8(HugsStackPtr);
static void hugsprim_memset_8(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord8 arg2;
    HsWord64 arg3;
    HsPtr res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getWord8();
    arg3 = hugs->getWord64();
    res1 = memset(arg1, arg2, arg3);
    hugs->putPtr(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef memmove
#endif

static void hugsprim_memmove_7(HugsStackPtr);
static void hugsprim_memmove_7(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr arg2;
    HsWord64 arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getPtr();
    arg3 = hugs->getWord64();
    memmove(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef memcpy
#endif

static void hugsprim_memcpy_6(HugsStackPtr);
static void hugsprim_memcpy_6(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr arg2;
    HsWord64 arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getPtr();
    arg3 = hugs->getWord64();
    memcpy(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef memcmp
#endif

static void hugsprim_memcmp_5(HugsStackPtr);
static void hugsprim_memcmp_5(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr arg2;
    HsWord64 arg3;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getPtr();
    arg3 = hugs->getWord64();
    res1 = memcmp(arg1, arg2, arg3);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef memchr
#endif

static void hugsprim_memchr_4(HugsStackPtr);
static void hugsprim_memchr_4(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord8 arg2;
    HsWord64 arg3;
    HsPtr res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getWord8();
    arg3 = hugs->getWord64();
    res1 = memchr(arg1, arg2, arg3);
    hugs->putPtr(res1);
    hugs->returnIO(hugs_root,1);
}
#include "stdlib.h"

#ifndef ENABLE_MACRO_INTERFACE
#undef free
#endif

static void hugsprim_free_3(HugsStackPtr);
static void hugsprim_free_3(HugsStackPtr hugs_root)
{
    hugs->putFunPtr((HsFunPtr)&free);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef free
#endif

static void hugsprim_free_2(HugsStackPtr);
static void hugsprim_free_2(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    arg1 = hugs->getPtr();
    free(arg1);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef malloc
#endif

static void hugsprim_malloc_1(HugsStackPtr);
static void hugsprim_malloc_1(HugsStackPtr hugs_root)
{
    HsWord64 arg1;
    HsPtr res1;
    arg1 = hugs->getWord64();
    res1 = malloc(arg1);
    hugs->putPtr(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef strlen
#endif

static void hugsprim_strlen_0(HugsStackPtr);
static void hugsprim_strlen_0(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord64 res1;
    arg1 = hugs->getPtr();
    res1 = strlen(arg1);
    hugs->putWord64(res1);
    hugs->returnIO(hugs_root,1);
}

static struct hugs_primitive hugs_primTable[] = {
    {"c_count", 4, hugsprim_fps_count_13},
    {"c_minimum", 3, hugsprim_fps_minimum_12},
    {"c_maximum", 3, hugsprim_fps_maximum_11},
    {"c_intersperse", 5, hugsprim_fps_intersperse_10},
    {"c_reverse", 4, hugsprim_fps_reverse_9},
    {"memset", 4, hugsprim_memset_8},
    {"memmove", 4, hugsprim_memmove_7},
    {"memcpy", 4, hugsprim_memcpy_6},
    {"memcmp", 4, hugsprim_memcmp_5},
    {"memchr", 4, hugsprim_memchr_4},
    {"c_free_finalizer", 0, hugsprim_free_3},
    {"c_free", 2, hugsprim_free_2},
    {"c_malloc", 2, hugsprim_malloc_1},
    {"c_strlen", 2, hugsprim_strlen_0},
};

static void hugs_primControl(int);
static void hugs_primControl(what)
int what; {
}

#ifdef STATIC_LINKAGE
#define initModule initDBBase
#endif

static struct hugs_primInfo hugs_prims = { hugs_primControl, hugs_primTable, 0 };

#ifdef __cplusplus
extern "C" {
#endif
#ifndef __cplusplus
DLLEXPORT(int)  HugsAPIVersion(void);
#endif
DLLEXPORT(int)  HugsAPIVersion() {return (5);}
DLLEXPORT(void) initModule(HugsAPI5 *);
DLLEXPORT(void) initModule(HugsAPI5 *hugsAPI) {
    hugs = hugsAPI;
    hugs->registerPrims(&hugs_prims);
}
#ifdef __cplusplus
}
#endif

{-# OPTIONS_GHC -cpp -fglasgow-exts #-}
--
-- Module      : ByteString.Base
-- License     : BSD-style
-- Maintainer  : dons@cse.unsw.edu.au
-- Stability   : experimental
-- Portability : portable, requires ffi and cpp
-- Tested with : GHC 6.4.1 and Hugs March 2005
-- 

-- | A module containing semi-public ByteString internals. This exposes
-- the ByteString representation and low level construction functions.
-- Modules which extend the ByteString system will need to use this module
-- while ideally most users will be able to make do with the public interface
-- modules.
--
module Data.ByteString.Base (

        -- * The @ByteString@ type and representation
        ByteString(..),         -- instances: Eq, Ord, Show, Read, Data, Typeable
        LazyByteString(..),     -- instances: Eq, Ord, Show, Read, Data, Typeable      

        -- * Unchecked access
        unsafeHead,             -- :: ByteString -> Word8
        unsafeTail,             -- :: ByteString -> ByteString
        unsafeIndex,            -- :: ByteString -> Int -> Word8
        unsafeTake,             -- :: Int -> ByteString -> ByteString
        unsafeDrop,             -- :: Int -> ByteString -> ByteString

        -- * Low level introduction and elimination
        empty,                  -- :: ByteString
        create,                 -- :: Int -> (Ptr Word8 -> IO ()) -> IO ByteString
        createAndTrim,          -- :: Int -> (Ptr Word8 -> IO Int) -> IO  ByteString
        createAndTrim',         -- :: Int -> (Ptr Word8 -> IO (Int, Int, a)) -> IO (ByteString, a)
        mallocByteString,       -- :: Int -> IO (ForeignPtr a)

        unsafeCreate,           -- :: Int -> (Ptr Word8 -> IO ()) ->  ByteString
        unsafeUseAsCString,     -- :: ByteString -> (CString -> IO a) -> IO a
        unsafeUseAsCStringLen,  -- :: ByteString -> (CStringLen -> IO a) -> IO a

        fromForeignPtr,         -- :: ForeignPtr Word8 -> Int -> ByteString
        toForeignPtr,           -- :: ByteString -> (ForeignPtr Word8, Int, Int)








        -- * Utilities
        inlinePerformIO,            -- :: IO a -> a
        nullForeignPtr,             -- :: ForeignPtr Word8

        countOccurrences,           -- :: (Storable a, Num a) => Ptr a -> Ptr Word8 -> Int -> IO ()

        -- * Standard C Functions
        c_strlen,                   -- :: CString -> IO CInt
        c_malloc,                   -- :: CInt -> IO (Ptr Word8)
        c_free,                     -- :: Ptr Word8 -> IO ()
        c_free_finalizer,           -- :: FunPtr (Ptr Word8 -> IO ())

        memchr,                     -- :: Ptr Word8 -> Word8 -> CSize -> IO Ptr Word8
        memcmp,                     -- :: Ptr Word8 -> Ptr Word8 -> CSize -> IO CInt
        memcpy,                     -- :: Ptr Word8 -> Ptr Word8 -> CSize -> IO ()
        memmove,                    -- :: Ptr Word8 -> Ptr Word8 -> CSize -> IO ()
        memset,                     -- :: Ptr Word8 -> Word8 -> CSize -> IO (Ptr Word8)

        -- * cbits functions
        c_reverse,                  -- :: Ptr Word8 -> Ptr Word8 -> CInt -> IO ()
        c_intersperse,              -- :: Ptr Word8 -> Ptr Word8 -> CInt -> Word8 -> IO ()
        c_maximum,                  -- :: Ptr Word8 -> CInt -> IO Word8
        c_minimum,                  -- :: Ptr Word8 -> CInt -> IO Word8
        c_count,                    -- :: Ptr Word8 -> CInt -> Word8 -> IO CInt

        -- * Internal GHC magic




        -- * Chars
        w2c, c2w, isSpaceWord8

  ) where

import Foreign.ForeignPtr       (ForeignPtr, newForeignPtr_, withForeignPtr)
import Foreign.Ptr              (Ptr, FunPtr, plusPtr, castPtr)
import Foreign.Storable         (Storable(..))
import Foreign.C.Types          (CInt, CSize, CULong)
import Foreign.C.String         (CString, CStringLen)

import Control.Exception        (assert)

import Data.Char                (ord)
import Data.Word                (Word8)











import Data.Char                (chr)
import System.IO.Unsafe         (unsafePerformIO)





import Foreign.ForeignPtr       (mallocForeignPtrBytes)






import Foreign.Ptr              (nullPtr)


-- CFILES stuff is Hugs only
{-# CFILES cbits/fpstring.c #-}

-- -----------------------------------------------------------------------------
--
-- Useful macros, until we have bang patterns
--







-- -----------------------------------------------------------------------------

-- | A space-efficient representation of a Word8 vector, supporting many
-- efficient operations.  A 'ByteString' contains 8-bit characters only.
--
-- Instances of Eq, Ord, Read, Show, Data, Typeable
--
data ByteString = PS {-# UNPACK #-} !(ForeignPtr Word8)
                     {-# UNPACK #-} !Int                -- offset
                     {-# UNPACK #-} !Int                -- length





instance Show ByteString where
    showsPrec p ps r = showsPrec p (unpackWith w2c ps) r

instance Read ByteString where
    readsPrec p str = [ (packWith c2w x, y) | (x, y) <- readsPrec p str ]

-- | /O(n)/ Converts a 'ByteString' to a '[a]', using a conversion function.
unpackWith :: (Word8 -> a) -> ByteString -> [a]
unpackWith _ (PS _  _ 0) = []
unpackWith k (PS ps s l) = inlinePerformIO $ withForeignPtr ps $ \p ->
        go (p `plusPtr` s) (l - 1) []
    where
        go a b c | a `seq` b `seq` c `seq` False = undefined
        go p 0 acc = peek p          >>= \e -> return (k e : acc)
        go p n acc = peekByteOff p n >>= \e -> go p (n-1) (k e : acc)
{-# INLINE unpackWith #-}
{-# SPECIALIZE unpackWith :: (Word8 -> Char) -> ByteString -> [Char] #-}

-- | /O(n)/ Convert a '[a]' into a 'ByteString' using some
-- conversion function
packWith :: (a -> Word8) -> [a] -> ByteString
packWith k str = unsafeCreate (length str) $ \p -> go p str
    where
        go a b | a `seq` b `seq` False = undefined
        go _ []     = return ()
        go p (x:xs) = poke p (k x) >> go (p `plusPtr` 1) xs -- less space than pokeElemOff
{-# INLINE packWith #-}
{-# SPECIALIZE packWith :: (Char -> Word8) -> [Char] -> ByteString #-}

------------------------------------------------------------------------

-- | A space-efficient representation of a Word8 vector, supporting many
-- efficient operations.  A 'ByteString' contains 8-bit characters only.
--
-- Instances of Eq, Ord, Read, Show, Data, Typeable
--
newtype LazyByteString = LPS [ByteString] -- LPS for lazy packed string
    deriving (Show,Read



             )

------------------------------------------------------------------------

-- | /O(1)/ The empty 'ByteString'
empty :: ByteString
empty = PS nullForeignPtr 0 0

nullForeignPtr :: ForeignPtr Word8



nullForeignPtr = unsafePerformIO $ newForeignPtr_ nullPtr
{-# NOINLINE nullForeignPtr #-}


-- ---------------------------------------------------------------------
--
-- Extensions to the basic interface
--

-- | A variety of 'head' for non-empty ByteStrings. 'unsafeHead' omits the
-- check for the empty case, so there is an obligation on the programmer
-- to provide a proof that the ByteString is non-empty.
unsafeHead :: ByteString -> Word8
unsafeHead (PS x s l) = assert (l > 0) $
    inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p s
{-# INLINE unsafeHead #-}

-- | A variety of 'tail' for non-empty ByteStrings. 'unsafeTail' omits the
-- check for the empty case. As with 'unsafeHead', the programmer must
-- provide a separate proof that the ByteString is non-empty.
unsafeTail :: ByteString -> ByteString
unsafeTail (PS ps s l) = assert (l > 0) $ PS ps (s+1) (l-1)
{-# INLINE unsafeTail #-}

-- | Unsafe 'ByteString' index (subscript) operator, starting from 0, returning a 'Word8'
-- This omits the bounds check, which means there is an accompanying
-- obligation on the programmer to ensure the bounds are checked in some
-- other way.
unsafeIndex :: ByteString -> Int -> Word8
unsafeIndex (PS x s l) i = assert (i >= 0 && i < l) $
    inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p (s+i)
{-# INLINE unsafeIndex #-}

-- | A variety of 'take' which omits the checks on @n@ so there is an
-- obligation on the programmer to provide a proof that @0 <= n <= 'length' xs@.
unsafeTake :: Int -> ByteString -> ByteString
unsafeTake n (PS x s l) = assert (0 <= n && n <= l) $ PS x s n
{-# INLINE unsafeTake #-}

-- | A variety of 'drop' which omits the checks on @n@ so there is an
-- obligation on the programmer to provide a proof that @0 <= n <= 'length' xs@.
unsafeDrop  :: Int -> ByteString -> ByteString
unsafeDrop n (PS x s l) = assert (0 <= n && n <= l) $ PS x (s+n) (l-n)
{-# INLINE unsafeDrop #-}

-- ---------------------------------------------------------------------
-- Low level constructors

-- | /O(1)/ Build a ByteString from a ForeignPtr
fromForeignPtr :: ForeignPtr Word8 -> Int -> ByteString
fromForeignPtr fp l = PS fp 0 l

-- | /O(1)/ Deconstruct a ForeignPtr from a ByteString
toForeignPtr :: ByteString -> (ForeignPtr Word8, Int, Int)
toForeignPtr (PS ps s l) = (ps, s, l)

-- | A way of creating ByteStrings outside the IO monad. The @Int@
-- argument gives the final size of the ByteString. Unlike
-- 'createAndTrim' the ByteString is not reallocated if the final size
-- is less than the estimated size.
unsafeCreate :: Int -> (Ptr Word8 -> IO ()) -> ByteString
unsafeCreate l f = unsafePerformIO (create l f)
{-# INLINE unsafeCreate #-}

-- | Create ByteString of size @l@ and use action @f@ to fill it's contents.
create :: Int -> (Ptr Word8 -> IO ()) -> IO ByteString
create l f = do
    fp <- mallocByteString l
    withForeignPtr fp $ \p -> f p
    return $! PS fp 0 l

-- | Given the maximum size needed and a function to make the contents
-- of a ByteString, createAndTrim makes the 'ByteString'. The generating
-- function is required to return the actual final size (<= the maximum
-- size), and the resulting byte array is realloced to this size.
--
-- createAndTrim is the main mechanism for creating custom, efficient
-- ByteString functions, using Haskell or C functions to fill the space.
--
createAndTrim :: Int -> (Ptr Word8 -> IO Int) -> IO ByteString
createAndTrim l f = do
    fp <- mallocByteString l
    withForeignPtr fp $ \p -> do
        l' <- f p
        if assert (l' <= l) $ l' >= l
            then return $! PS fp 0 l
            else create l' $ \p' -> memcpy p' p (fromIntegral l')

createAndTrim' :: Int -> (Ptr Word8 -> IO (Int, Int, a)) -> IO (ByteString, a)
createAndTrim' l f = do
    fp <- mallocByteString l
    withForeignPtr fp $ \p -> do
        (off, l', res) <- f p
        if assert (l' <= l) $ l' >= l
            then return $! (PS fp 0 l, res)
            else do ps <- create l' $ \p' ->
                            memcpy p' (p `plusPtr` off) (fromIntegral l')
                    return $! (ps, res)

-- | Wrapper of mallocForeignPtrBytes with faster implementation
-- for GHC 6.5 builds newer than 06/06/06
mallocByteString :: Int -> IO (ForeignPtr a)
mallocByteString l = do



    mallocForeignPtrBytes l


























































------------------------------------------------------------------------

-- | Conversion between 'Word8' and 'Char'. Should compile to a no-op.
w2c :: Word8 -> Char

w2c = chr . fromIntegral



{-# INLINE w2c #-}

-- | Unsafe conversion between 'Char' and 'Word8'. This is a no-op and
-- silently truncates to 8 bits Chars > '\255'. It is provided as
-- convenience for ByteString construction.
c2w :: Char -> Word8
c2w = fromIntegral . ord
{-# INLINE c2w #-}

-- Selects white-space characters in the Latin-1 range
-- ordered by frequency
-- Idea from Ketil
isSpaceWord8 :: Word8 -> Bool
isSpaceWord8 w = case w of
    0x20 -> True -- SPACE
    0x0A -> True -- LF, \n
    0x09 -> True -- HT, \t
    0x0C -> True -- FF, \f
    0x0D -> True -- CR, \r
    0x0B -> True -- VT, \v
    0xA0 -> True -- spotted by QC..
    _    -> False
{-# INLINE isSpaceWord8 #-}

------------------------------------------------------------------------
-- | Just like unsafePerformIO, but we inline it. Big performance gains as
-- it exposes lots of things to further inlining
--
{-# INLINE inlinePerformIO #-}
inlinePerformIO :: IO a -> a



inlinePerformIO = unsafePerformIO


-- | Count the number of occurrences of each byte.
--
{-# SPECIALIZE countOccurrences :: Ptr CSize -> Ptr Word8 -> Int -> IO () #-}
countOccurrences :: (Storable a, Num a) => Ptr a -> Ptr Word8 -> Int -> IO ()
countOccurrences a b c | a `seq` b `seq` c `seq` False = undefined
countOccurrences counts str l = go 0
 where
    go a | a `seq` False = undefined
    go i | i == l    = return ()
         | otherwise = do k <- fromIntegral `fmap` peekElemOff str i
                          x <- peekElemOff counts k
                          pokeElemOff counts k (x + 1)
                          go (i + 1)

-- | /O(1) construction/ Use a @ByteString@ with a function requiring a
-- @CString@.  Warning: modifying the @CString@ will affect the
-- @ByteString@.  Why is this function unsafe? It relies on the null
-- byte at the end of the ByteString to be there. Unless you can
-- guarantee the null byte, you should use the safe version, which will
-- copy the string first.
unsafeUseAsCString :: ByteString -> (CString -> IO a) -> IO a
unsafeUseAsCString (PS ps s _) ac = withForeignPtr ps $ \p -> ac (castPtr p `plusPtr` s)

-- | /O(1) construction/ Use a @ByteString@ with a function requiring a
-- @CStringLen@.
unsafeUseAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
unsafeUseAsCStringLen (PS ps s l) f = withForeignPtr ps $ \p -> f (castPtr p `plusPtr` s,l)

-- ---------------------------------------------------------------------
-- 
-- Standard C functions
--

foreign import ccall unsafe "string.h strlen" c_strlen
    :: CString -> IO CSize

foreign import ccall unsafe "stdlib.h malloc" c_malloc
    :: CSize -> IO (Ptr Word8)

foreign import ccall unsafe "static stdlib.h free" c_free
    :: Ptr Word8 -> IO ()

foreign import ccall unsafe "static stdlib.h &free" c_free_finalizer
    :: FunPtr (Ptr Word8 -> IO ())

foreign import ccall unsafe "string.h memchr" memchr
    :: Ptr Word8 -> Word8 -> CSize -> IO (Ptr Word8)

foreign import ccall unsafe "string.h memcmp" memcmp
    :: Ptr Word8 -> Ptr Word8 -> CSize -> IO CInt

foreign import ccall unsafe "string.h memcpy" memcpy
    :: Ptr Word8 -> Ptr Word8 -> CSize -> IO ()

foreign import ccall unsafe "string.h memmove" memmove
    :: Ptr Word8 -> Ptr Word8 -> CSize -> IO ()

foreign import ccall unsafe "string.h memset" memset
    :: Ptr Word8 -> Word8 -> CSize -> IO (Ptr Word8)


-- ---------------------------------------------------------------------
--
-- Uses our C code
--

foreign import ccall unsafe "static fpstring.h fps_reverse" c_reverse
    :: Ptr Word8 -> Ptr Word8 -> CULong -> IO ()

foreign import ccall unsafe "static fpstring.h fps_intersperse" c_intersperse
    :: Ptr Word8 -> Ptr Word8 -> CULong -> Word8 -> IO ()

foreign import ccall unsafe "static fpstring.h fps_maximum" c_maximum
    :: Ptr Word8 -> CULong -> IO Word8

foreign import ccall unsafe "static fpstring.h fps_minimum" c_minimum
    :: Ptr Word8 -> CULong -> IO Word8

foreign import ccall unsafe "static fpstring.h fps_count" c_count
    :: Ptr Word8 -> CULong -> Word8 -> IO CULong

-- ---------------------------------------------------------------------
-- MMap

{-
foreign import ccall unsafe "static fpstring.h my_mmap" my_mmap
    :: Int -> Int -> IO (Ptr Word8)

foreign import ccall unsafe "static unistd.h close" c_close
    :: Int -> IO Int

#  if !defined(__OpenBSD__)
foreign import ccall unsafe "static sys/mman.h munmap" c_munmap
    :: Ptr Word8 -> Int -> IO Int
#  endif
-}

-- ---------------------------------------------------------------------
-- Internal GHC Haskell magic





 asm    dylink–Ç¿ 4
` ` ` ``` ` ``  ` |Œenv
memoryBase env	tableBase envabort  envgetTempRet0 env_free  env_malloc env_memchr env_memcmp env_memcpy env_memmove env_memset env_strlen envmemory Äenvtablep                  	A A Á_HugsAPIVersion 
__post_instantiate !
_fps_count _fps_intersperse _fps_maximum _fps_minimum _fps_reverse _hugs_primControl _hugsprim_fps_count_13 _hugsprim_fps_intersperse_10 _hugsprim_fps_maximum_11 _hugsprim_fps_minimum_12 _hugsprim_fps_reverse_9 _hugsprim_free_2 _hugsprim_free_3 _hugsprim_malloc_1 _hugsprim_memchr_4 _hugsprim_memcmp_5 _hugsprim_memcpy_6 _hugsprim_memmove_7 _hugsprim_memset_8 _hugsprim_strlen_0 _initModule runPostSets  	& # """"""""""""""""
Ä A # A¿Ç¿j  6 #   (∞   n# A¿Ç¿j( (D !# A¿Ç¿j( (@ !  # A¿Ç¿j( (4 A # A¿Ç¿j( (å   A# A¿Ç¿j( († [# A¿Ç¿j( (D !# A¿Ç¿j( (@ !  # A¿Ç¿j( (Ä    A# A¿Ç¿j( († [# A¿Ç¿j( (D !# A¿Ç¿j( (@ !  # A¿Ç¿j( (Ä    A# A¿Ç¿j( († o# A¿Ç¿j( (D !# A¿Ç¿j( (D !# A¿Ç¿j( (@ !   # A¿Ç¿j( (4   A # A¿Ç¿j( († ^# A¿Ç¿j( (D !# A¿Ç¿j( (D !# A¿Ç¿j( (@ !     A # A¿Ç¿j( († s# A¿Ç¿j( (D !# A¿Ç¿j( (4 !# A¿Ç¿j( (@ !    # A¿Ç¿j( (ê    A# A¿Ç¿j( († _# A¿Ç¿j( (D !# A¿Ç¿j( (D !# A¿Ç¿j( (@ !     A # A¿Ç¿j( († _# A¿Ç¿j( (D !# A¿Ç¿j( (D !# A¿Ç¿j( (@ !     A # A¿Ç¿j( († o# A¿Ç¿j( (D !# A¿Ç¿j( (D !# A¿Ç¿j( (@ !   # A¿Ç¿j( (x    A# A¿Ç¿j( († t# A¿Ç¿j( (D !# A¿Ç¿j( (4 !# A¿Ç¿j( (@ !  Aˇq # A¿Ç¿j( (ê    A# A¿Ç¿j( (†  #Aj# A¿Ç¿j( (î  + # A¿Ç¿j( (D   A # A¿Ç¿j( († F# A¿Ç¿j( (@ ! # A¿Ç¿j( (ê    A# A¿Ç¿j( († ? # A¿Ç¿j( (D 	A # A¿Ç¿j( (å   A# A¿Ç¿j( († D E@  Ajj!@ Aj!  Aj!   ,  :   Aj"@ ! ! Ä AK@ Aj! AtA~j!  ! !@ Aj!  ,  :   Aj!  :  Aj"AK@ ! !   j!   j! AG@   ,  :  Y  ,  ! AH@    j! !  Aj!@ ,  " Aˇq AˇqL@ !  Aj" I@  !  Y  ,  ! AH@    j! !  Aj!@ ,  " Aˇq AˇqN@ !  Aj" I@  !  7 @A !A @  -   AˇqF j!  Aj!  Aj"  £ # #Aj6 # # (# Ajj6# # (# A¥jj6# #Aj6# # (# Aºjj6# #Aj6 # # ($# A∆jj6$# #Aj6,# # (0# A–jj60# #Aj68# # (<# Aﬁjj6<# #Aj6D# # (H# AËjj6H# #Aj6P# # (T# AÔjj6T# #Aj6\# # (`# A˜jj6`# #A	j6h# # (l# A˛jj6l# #A
j6t# # (x# AÖjj6x# #Aj6Ä# # (Ñ# Aåjj6Ñ# #Aj6å# # (ê# Aùjj6ê# #Aj6ò# # (ú# A§jj6ú# #Aj6§# # (®# A≠jj6®# #Aj6∞ # A¿j$#AÄÄ¿j$  A  D        º # µ                                                                                                                                                                       c_count c_minimum c_maximum c_intersperse c_reverse memset memmove memcpy memcmp memchr c_free_finalizer c_free c_malloc c_strlen{-# OPTIONS_GHC -cpp -fglasgow-exts #-}
--
-- Module      : Data.ByteString.Char8
-- Copyright   : (c) Don Stewart 2006
-- License     : BSD-style
--
-- Maintainer  : dons@cse.unsw.edu.au
-- Stability   : experimental
-- Portability : portable (tested with GHC>=6.4.1 and Hugs 2005)
-- 

--
-- | Manipulate 'ByteString's using 'Char' operations. All Chars will be
-- truncated to 8 bits. It can be expected that these functions will run
-- at identical speeds to their 'Word8' equivalents in "Data.ByteString".
--
-- More specifically these byte strings are taken to be in the
-- subset of Unicode covered by code points 0-255. This covers
-- Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls.
-- 
-- See: 
--
--  * <http://www.unicode.org/charts/>
--
--  * <http://www.unicode.org/charts/PDF/U0000.pdf>
--
--  * <http://www.unicode.org/charts/PDF/U0080.pdf>
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.
--
-- > import qualified Data.ByteString.Char8 as B
--

module Data.ByteString.Char8 (

        -- * The @ByteString@ type
        ByteString,             -- abstract, instances: Eq, Ord, Show, Read, Data, Typeable, Monoid

        -- * Introducing and eliminating 'ByteString's
        empty,                  -- :: ByteString
        singleton,              -- :: Char   -> ByteString
        pack,                   -- :: String -> ByteString
        unpack,                 -- :: ByteString -> String

        -- * Basic interface
        cons,                   -- :: Char -> ByteString -> ByteString
        snoc,                   -- :: ByteString -> Char -> ByteString
        append,                 -- :: ByteString -> ByteString -> ByteString
        head,                   -- :: ByteString -> Char
        last,                   -- :: ByteString -> Char
        tail,                   -- :: ByteString -> ByteString
        init,                   -- :: ByteString -> ByteString
        null,                   -- :: ByteString -> Bool
        length,                 -- :: ByteString -> Int

        -- * Transformating ByteStrings
        map,                    -- :: (Char -> Char) -> ByteString -> ByteString
        reverse,                -- :: ByteString -> ByteString
        intersperse,            -- :: Char -> ByteString -> ByteString
        transpose,              -- :: [ByteString] -> [ByteString]

        -- * Reducing 'ByteString's (folds)
        foldl,                  -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl',                 -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl1,                 -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldl1',                -- :: (Char -> Char -> Char) -> ByteString -> Char

        foldr,                  -- :: (Char -> a -> a) -> a -> ByteString -> a
        foldr',                 -- :: (Char -> a -> a) -> a -> ByteString -> a
        foldr1,                 -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldr1',                -- :: (Char -> Char -> Char) -> ByteString -> Char

        -- ** Special folds
        concat,                 -- :: [ByteString] -> ByteString
        concatMap,              -- :: (Char -> ByteString) -> ByteString -> ByteString
        any,                    -- :: (Char -> Bool) -> ByteString -> Bool
        all,                    -- :: (Char -> Bool) -> ByteString -> Bool
        maximum,                -- :: ByteString -> Char
        minimum,                -- :: ByteString -> Char

        -- * Building ByteStrings
        -- ** Scans
        scanl,                  -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
        scanl1,                 -- :: (Char -> Char -> Char) -> ByteString -> ByteString
        scanr,                  -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
        scanr1,                 -- :: (Char -> Char -> Char) -> ByteString -> ByteString

        -- ** Accumulating maps
        mapAccumL,              -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumR,              -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
        mapIndexed,             -- :: (Int -> Char -> Char) -> ByteString -> ByteString

        -- * Generating and unfolding ByteStrings
        replicate,              -- :: Int -> Char -> ByteString
        unfoldr,                -- :: (a -> Maybe (Char, a)) -> a -> ByteString
        unfoldrN,               -- :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)

        -- * Substrings

        -- ** Breaking strings
        take,                   -- :: Int -> ByteString -> ByteString
        drop,                   -- :: Int -> ByteString -> ByteString
        splitAt,                -- :: Int -> ByteString -> (ByteString, ByteString)
        takeWhile,              -- :: (Char -> Bool) -> ByteString -> ByteString
        dropWhile,              -- :: (Char -> Bool) -> ByteString -> ByteString
        span,                   -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        spanEnd,                -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        break,                  -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        breakEnd,               -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        group,                  -- :: ByteString -> [ByteString]
        groupBy,                -- :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
        inits,                  -- :: ByteString -> [ByteString]
        tails,                  -- :: ByteString -> [ByteString]

        -- ** Breaking into many substrings
        split,                  -- :: Char -> ByteString -> [ByteString]
        splitWith,              -- :: (Char -> Bool) -> ByteString -> [ByteString]

        -- ** Breaking into lines and words
        lines,                  -- :: ByteString -> [ByteString]
        words,                  -- :: ByteString -> [ByteString]
        unlines,                -- :: [ByteString] -> ByteString
        unwords,                -- :: ByteString -> [ByteString]

        -- ** Joining strings
        join,                   -- :: ByteString -> [ByteString] -> ByteString

        -- ** Searching for substrings
        isPrefixOf,             -- :: ByteString -> ByteString -> Bool
        isSuffixOf,             -- :: ByteString -> ByteString -> Bool
        isSubstringOf,          -- :: ByteString -> ByteString -> Bool
        findSubstring,          -- :: ByteString -> ByteString -> Maybe Int
        findSubstrings,         -- :: ByteString -> ByteString -> [Int]

        -- * Searching ByteStrings

        -- ** Searching by equality
        elem,                   -- :: Char -> ByteString -> Bool
        notElem,                -- :: Char -> ByteString -> Bool

        -- ** Searching with a predicate
        find,                   -- :: (Char -> Bool) -> ByteString -> Maybe Char
        filter,                 -- :: (Char -> Bool) -> ByteString -> ByteString
--      partition               -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)

        -- * Indexing ByteStrings
        index,                  -- :: ByteString -> Int -> Char
        elemIndex,              -- :: Char -> ByteString -> Maybe Int
        elemIndices,            -- :: Char -> ByteString -> [Int]
        elemIndexEnd,           -- :: Char -> ByteString -> Maybe Int
        findIndex,              -- :: (Char -> Bool) -> ByteString -> Maybe Int
        findIndices,            -- :: (Char -> Bool) -> ByteString -> [Int]
        count,                  -- :: Char -> ByteString -> Int

        -- * Zipping and unzipping ByteStrings
        zip,                    -- :: ByteString -> ByteString -> [(Char,Char)]
        zipWith,                -- :: (Char -> Char -> c) -> ByteString -> ByteString -> [c]
        unzip,                  -- :: [(Char,Char)] -> (ByteString,ByteString)

        -- * Ordered ByteStrings
        sort,                   -- :: ByteString -> ByteString

        -- * Reading from ByteStrings
        readInt,                -- :: ByteString -> Maybe (Int, ByteString)
        readInteger,            -- :: ByteString -> Maybe (Integer, ByteString)

        -- * Low level CString conversions

        -- ** Packing CStrings and pointers
        packCString,            -- :: CString -> ByteString
        packCStringLen,         -- :: CString -> ByteString
        packMallocCString,      -- :: CString -> ByteString

        -- ** Using ByteStrings as CStrings
        useAsCString,           -- :: ByteString -> (CString -> IO a) -> IO a
        useAsCStringLen,        -- :: ByteString -> (CStringLen -> IO a) -> IO a

        -- * Copying ByteStrings
        copy,                   -- :: ByteString -> ByteString
        copyCString,            -- :: CString -> IO ByteString
        copyCStringLen,         -- :: CStringLen -> IO ByteString

        -- * I\/O with @ByteString@s

        -- ** Standard input and output
        getLine,                -- :: IO ByteString
        getContents,            -- :: IO ByteString
        putStr,                 -- :: ByteString -> IO ()
        putStrLn,               -- :: ByteString -> IO ()
        interact,               -- :: (ByteString -> ByteString) -> IO ()

        -- ** Files
        readFile,               -- :: FilePath -> IO ByteString
        writeFile,              -- :: FilePath -> ByteString -> IO ()
        appendFile,             -- :: FilePath -> ByteString -> IO ()
--      mmapFile,               -- :: FilePath -> IO ByteString

        -- ** I\/O with Handles
        hGetLine,               -- :: Handle -> IO ByteString
        hGetNonBlocking,        -- :: Handle -> Int -> IO ByteString
        hGetContents,           -- :: Handle -> IO ByteString
        hGet,                   -- :: Handle -> Int -> IO ByteString
        hPut,                   -- :: Handle -> ByteString -> IO ()
        hPutStr,                -- :: Handle -> ByteString -> IO ()
        hPutStrLn,              -- :: Handle -> ByteString -> IO ()








        -- * Utilities (needed for array fusion)




    ) where

import qualified Prelude as P
import Prelude hiding           (reverse,head,tail,last,init,null
                                ,length,map,lines,foldl,foldr,unlines
                                ,concat,any,take,drop,splitAt,takeWhile
                                ,dropWhile,span,break,elem,filter,unwords
                                ,words,maximum,minimum,all,concatMap
                                ,scanl,scanl1,scanr,scanr1
                                ,appendFile,readFile,writeFile
                                ,foldl1,foldr1,replicate
                                ,getContents,getLine,putStr,putStrLn,interact
                                ,zip,zipWith,unzip,notElem)

import qualified Data.ByteString as B
import qualified Data.ByteString.Base as B

-- Listy functions transparently exported
import Data.ByteString (empty,null,length,tail,init,append
                       ,inits,tails,reverse,transpose
                       ,concat,take,drop,splitAt,join
                       ,sort,isPrefixOf,isSuffixOf,isSubstringOf,findSubstring
                       ,findSubstrings,copy,group

                       ,getLine, getContents, putStr, putStrLn, interact
                       ,hGetContents, hGet, hPut, hPutStr, hPutStrLn
                       ,hGetLine, hGetNonBlocking
                       ,packCString,packCStringLen, packMallocCString
                       ,useAsCString,useAsCStringLen, copyCString,copyCStringLen



                       )

import Data.ByteString.Base (
                        ByteString(..)



                       ,c2w, w2c, unsafeTail, isSpaceWord8, inlinePerformIO
                       )

import Data.Char    ( isSpace )
import qualified Data.List as List (intersperse)

import System.IO                (openFile,hClose,hFileSize,IOMode(..))
import Control.Exception        (bracket)
import Foreign














------------------------------------------------------------------------

-- | /O(1)/ Convert a 'Char' into a 'ByteString'
singleton :: Char -> ByteString
singleton = B.singleton . c2w
{-# INLINE singleton #-}

-- | /O(n)/ Convert a 'String' into a 'ByteString'
--
-- For applications with large numbers of string literals, pack can be a
-- bottleneck. In such cases, consider using packAddress (GHC only).
pack :: String -> ByteString


pack str = B.unsafeCreate (P.length str) $ \p -> go p str
    where go _ []     = return ()
          go p (x:xs) = poke p (c2w x) >> go (p `plusPtr` 1) xs





















-- | /O(n)/ Converts a 'ByteString' to a 'String'.
unpack :: ByteString -> [Char]
unpack = P.map w2c . B.unpack
{-# INLINE unpack #-}

-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
-- complexity, as it requires a memcpy.
cons :: Char -> ByteString -> ByteString
cons = B.cons . c2w
{-# INLINE cons #-}

-- | /O(n)/ Append a Char to the end of a 'ByteString'. Similar to
-- 'cons', this function performs a memcpy.
snoc :: ByteString -> Char -> ByteString
snoc p = B.snoc p . c2w
{-# INLINE snoc #-}

-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
head :: ByteString -> Char
head = w2c . B.head
{-# INLINE head #-}

-- | /O(1)/ Extract the last element of a packed string, which must be non-empty.
last :: ByteString -> Char
last = w2c . B.last
{-# INLINE last #-}

-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each element of @xs@
map :: (Char -> Char) -> ByteString -> ByteString
map f = B.map (c2w . f . w2c)
{-# INLINE map #-}

-- | /O(n)/ The 'intersperse' function takes a Char and a 'ByteString'
-- and \`intersperses\' that Char between the elements of the
-- 'ByteString'.  It is analogous to the intersperse function on Lists.
intersperse :: Char -> ByteString -> ByteString
intersperse = B.intersperse . c2w
{-# INLINE intersperse #-}

-- | 'foldl', applied to a binary operator, a starting value (typically
-- the left-identity of the operator), and a ByteString, reduces the
-- ByteString using the binary operator, from left to right.
foldl :: (a -> Char -> a) -> a -> ByteString -> a
foldl f = B.foldl (\a c -> f a (w2c c))
{-# INLINE foldl #-}

-- | 'foldl\'' is like foldl, but strict in the accumulator.
foldl' :: (a -> Char -> a) -> a -> ByteString -> a
foldl' f = B.foldl' (\a c -> f a (w2c c))
{-# INLINE foldl' #-}

-- | 'foldr', applied to a binary operator, a starting value
-- (typically the right-identity of the operator), and a packed string,
-- reduces the packed string using the binary operator, from right to left.
foldr :: (Char -> a -> a) -> a -> ByteString -> a
foldr f = B.foldr (\c a -> f (w2c c) a)
{-# INLINE foldr #-}

-- | 'foldr\'' is a strict variant of foldr
foldr' :: (Char -> a -> a) -> a -> ByteString -> a
foldr' f = B.foldr' (\c a -> f (w2c c) a)
{-# INLINE foldr' #-}

-- | 'foldl1' is a variant of 'foldl' that has no starting value
-- argument, and thus must be applied to non-empty 'ByteStrings'.
foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
foldl1 f ps = w2c (B.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldl1 #-}

-- | A strict version of 'foldl1'
foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
foldl1' f ps = w2c (B.foldl1' (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldl1' #-}

-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
-- and thus must be applied to non-empty 'ByteString's
foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
foldr1 f ps = w2c (B.foldr1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldr1 #-}

-- | A strict variant of foldr1
foldr1' :: (Char -> Char -> Char) -> ByteString -> Char
foldr1' f ps = w2c (B.foldr1' (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldr1' #-}

-- | Map a function over a 'ByteString' and concatenate the results
concatMap :: (Char -> ByteString) -> ByteString -> ByteString
concatMap f = B.concatMap (f . w2c)
{-# INLINE concatMap #-}

-- | Applied to a predicate and a ByteString, 'any' determines if
-- any element of the 'ByteString' satisfies the predicate.
any :: (Char -> Bool) -> ByteString -> Bool
any f = B.any (f . w2c)
{-# INLINE any #-}

-- | Applied to a predicate and a 'ByteString', 'all' determines if
-- all elements of the 'ByteString' satisfy the predicate.
all :: (Char -> Bool) -> ByteString -> Bool
all f = B.all (f . w2c)
{-# INLINE all #-}

-- | 'maximum' returns the maximum value from a 'ByteString'
maximum :: ByteString -> Char
maximum = w2c . B.maximum
{-# INLINE maximum #-}

-- | 'minimum' returns the minimum value from a 'ByteString'
minimum :: ByteString -> Char
minimum = w2c . B.minimum
{-# INLINE minimum #-}

-- | /O(n)/ map Char functions, provided with the index at each position
mapIndexed :: (Int -> Char -> Char) -> ByteString -> ByteString
mapIndexed f = B.mapIndexed (\i c -> c2w (f i (w2c c)))
{-# INLINE mapIndexed #-}

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new list.
mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
mapAccumL f = B.mapAccumL (\acc w -> case f acc (w2c w) of (acc', c) -> (acc', c2w c))

-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from right to left, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumR :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
mapAccumR f = B.mapAccumR (\acc w -> case f acc (w2c w) of (acc', c) -> (acc', c2w c))

-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left:
--
-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that
--
-- > last (scanl f z xs) == foldl f z xs.
scanl :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanl f z = B.scanl (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)

-- | 'scanl1' is a variant of 'scanl' that has no starting value argument:
--
-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
scanl1 :: (Char -> Char -> Char) -> ByteString -> ByteString
scanl1 f = B.scanl1 (\a b -> c2w (f (w2c a) (w2c b)))

-- | scanr is the right-to-left dual of scanl.
scanr :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanr f z = B.scanr (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)

-- | 'scanr1' is a variant of 'scanr' that has no starting value argument.
scanr1 :: (Char -> Char -> Char) -> ByteString -> ByteString
scanr1 f = B.scanr1 (\a b -> c2w (f (w2c a) (w2c b)))

-- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@
-- the value of every element. The following holds:
--
-- > replicate w c = unfoldr w (\u -> Just (u,u)) c
--
-- This implemenation uses @memset(3)@
replicate :: Int -> Char -> ByteString
replicate w = B.replicate w . c2w
{-# INLINE replicate #-}

-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr' 
-- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a 
-- ByteString from a seed value.  The function takes the element and 
-- returns 'Nothing' if it is done producing the ByteString or returns 
-- 'Just' @(a,b)@, in which case, @a@ is the next character in the string, 
-- and @b@ is the seed value for further production.
--
-- Examples:
--
-- > unfoldr (\x -> if x <= '9' then Just (x, succ x) else Nothing) '0' == "0123456789"
unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
unfoldr f x0 = B.unfoldr (fmap k . f) x0
    where k (i, j) = (c2w i, j)

-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seed
-- value.  However, the length of the result is limited by the first
-- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
-- when the maximum length of the result is known.
--
-- The following equation relates 'unfoldrN' and 'unfoldr':
--
-- > unfoldrN n f s == take n (unfoldr f s)
unfoldrN :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
unfoldrN n f w = B.unfoldrN n ((k `fmap`) . f) w
    where k (i,j) = (c2w i, j)
{-# INLINE unfoldrN #-}

-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.
takeWhile :: (Char -> Bool) -> ByteString -> ByteString
takeWhile f = B.takeWhile (f . w2c)
{-# INLINE takeWhile #-}

-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
dropWhile :: (Char -> Bool) -> ByteString -> ByteString
dropWhile f = B.dropWhile (f . w2c)




-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
break f = B.break (f . w2c)




-- | 'span' @p xs@ breaks the ByteString into two segments. It is
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
span f = B.span (f . w2c)
{-# INLINE span #-}

-- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
-- We have
--
-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
--
-- and
--
-- > spanEnd (not . isSpace) ps
-- >    == 
-- > let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x) 
--
spanEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
spanEnd f = B.spanEnd (f . w2c)
{-# INLINE spanEnd #-}

-- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'
-- 
-- breakEnd p == spanEnd (not.p)
breakEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
breakEnd f = B.breakEnd (f . w2c)
{-# INLINE breakEnd #-}

{-
-- | 'breakChar' breaks its ByteString argument at the first occurence
-- of the specified Char. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
-- 
-- > break (=='c') "abcd" == breakChar 'c' "abcd"
--
breakChar :: Char -> ByteString -> (ByteString, ByteString)
breakChar = B.breakByte . c2w
{-# INLINE breakChar #-}

-- | 'spanChar' breaks its ByteString argument at the first
-- occurence of a Char other than its argument. It is more efficient
-- than 'span (==)'
--
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
--
spanChar :: Char -> ByteString -> (ByteString, ByteString)
spanChar = B.spanByte . c2w
{-# INLINE spanChar #-}
-}

-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.
--
-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split 'a'  "aXaXaXa"    == ["","X","X","X"]
-- > split 'x'  "x"          == ["",""]
-- 
-- and
--
-- > join [c] . split c == id
-- > split == splitWith . (==)
-- 
-- As for all splitting functions in this library, this function does
-- not copy the substrings, it just constructs new 'ByteStrings' that
-- are slices of the original.
--
split :: Char -> ByteString -> [ByteString]
split = B.split . c2w
{-# INLINE split #-}

-- | /O(n)/ Splits a 'ByteString' into components delimited by
-- separators, where the predicate returns True for a separator element.
-- The resulting components do not contain the separators.  Two adjacent
-- separators result in an empty component in the output.  eg.
--
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
--
splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
splitWith f = B.splitWith (f . w2c)
{-# INLINE splitWith #-}
-- the inline makes a big difference here.

{-
-- | Like 'splitWith', except that sequences of adjacent separators are
-- treated as a single separator. eg.
-- 
-- > tokens (=='a') "aabbaca" == ["bb","c"]
--
tokens :: (Char -> Bool) -> ByteString -> [ByteString]
tokens f = B.tokens (f . w2c)
{-# INLINE tokens #-}
-}

-- | The 'groupBy' function is the non-overloaded version of 'group'.
groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
groupBy k = B.groupBy (\a b -> k (w2c a) (w2c b))

{-
-- | /O(n)/ joinWithChar. An efficient way to join to two ByteStrings with a
-- char. Around 4 times faster than the generalised join.
--
joinWithChar :: Char -> ByteString -> ByteString -> ByteString
joinWithChar = B.joinWithByte . c2w
{-# INLINE joinWithChar #-}
-}

-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.
index :: ByteString -> Int -> Char
index = (w2c .) . B.index
{-# INLINE index #-}

-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element in the given 'ByteString' which is equal (by memchr) to the
-- query element, or 'Nothing' if there is no such element.
elemIndex :: Char -> ByteString -> Maybe Int
elemIndex = B.elemIndex . c2w
{-# INLINE elemIndex #-}

-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element. The following
-- holds:
--
-- > elemIndexEnd c xs == 
-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--
elemIndexEnd :: Char -> ByteString -> Maybe Int
elemIndexEnd = B.elemIndexEnd . c2w
{-# INLINE elemIndexEnd #-}

-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- the indices of all elements equal to the query element, in ascending order.
elemIndices :: Char -> ByteString -> [Int]
elemIndices = B.elemIndices . c2w
{-# INLINE elemIndices #-}

-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- returns the index of the first element in the ByteString satisfying the predicate.
findIndex :: (Char -> Bool) -> ByteString -> Maybe Int
findIndex f = B.findIndex (f . w2c)
{-# INLINE findIndex #-}

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices :: (Char -> Bool) -> ByteString -> [Int]
findIndices f = B.findIndices (f . w2c)

-- | count returns the number of times its argument appears in the ByteString
--
-- > count = length . elemIndices
-- 
-- Also
--  
-- > count '\n' == length . lines
--
-- But more efficiently than using length on the intermediate list.
count :: Char -> ByteString -> Int
count c = B.count (c2w c)

-- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This
-- implementation uses @memchr(3)@.
elem :: Char -> ByteString -> Bool
elem    c = B.elem (c2w c)
{-# INLINE elem #-}

-- | /O(n)/ 'notElem' is the inverse of 'elem'
notElem :: Char -> ByteString -> Bool
notElem c = B.notElem (c2w c)
{-# INLINE notElem #-}

-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
-- returns a ByteString containing those characters that satisfy the
-- predicate.
filter :: (Char -> Bool) -> ByteString -> ByteString
filter f = B.filter (f . w2c)
{-# INLINE filter #-}

-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.
find :: (Char -> Bool) -> ByteString -> Maybe Char
find f ps = w2c `fmap` B.find (f . w2c) ps
{-# INLINE find #-}

{-
-- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
-- case of filtering a single Char. It is more efficient to use
-- filterChar in this case.
--
-- > filterChar == filter . (==)
--
-- filterChar is around 10x faster, and uses much less space, than its
-- filter equivalent
--
filterChar :: Char -> ByteString -> ByteString
filterChar c = B.filterByte (c2w c)
{-# INLINE filterChar #-}

-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
-- case of filtering a single Char out of a list. It is more efficient
-- to use /filterNotChar/ in this case.
--
-- > filterNotChar == filter . (/=)
--
-- filterNotChar is around 3x faster, and uses much less space, than its
-- filter equivalent
--
filterNotChar :: Char -> ByteString -> ByteString
filterNotChar c = B.filterNotByte (c2w c)
{-# INLINE filterNotChar #-}
-}

-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- corresponding pairs of Chars. If one input ByteString is short,
-- excess elements of the longer ByteString are discarded. This is
-- equivalent to a pair of 'unpack' operations, and so space
-- usage may be large for multi-megabyte ByteStrings
zip :: ByteString -> ByteString -> [(Char,Char)]
zip ps qs
    | B.null ps || B.null qs = []
    | otherwise = (unsafeHead ps, unsafeHead qs) : zip (B.unsafeTail ps) (B.unsafeTail qs)

-- | 'zipWith' generalises 'zip' by zipping with the function given as
-- the first argument, instead of a tupling function.  For example,
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list
-- of corresponding sums.
zipWith :: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
zipWith f = B.zipWith ((. w2c) . f . w2c)

-- | 'unzip' transforms a list of pairs of Chars into a pair of
-- ByteStrings. Note that this performs two 'pack' operations.
unzip :: [(Char,Char)] -> (ByteString,ByteString)
unzip ls = (pack (P.map fst ls), pack (P.map snd ls))
{-# INLINE unzip #-}

-- | A variety of 'head' for non-empty ByteStrings. 'unsafeHead' omits
-- the check for the empty case, which is good for performance, but
-- there is an obligation on the programmer to provide a proof that the
-- ByteString is non-empty.
unsafeHead :: ByteString -> Char
unsafeHead  = w2c . B.unsafeHead
{-# INLINE unsafeHead #-}

-- ---------------------------------------------------------------------
-- Things that depend on the encoding

{-# RULES
    "FPS specialise break -> breakSpace"
        break isSpace = breakSpace
  #-}

-- | 'breakSpace' returns the pair of ByteStrings when the argument is
-- broken at the first whitespace byte. I.e.
-- 
-- > break isSpace == breakSpace
--
breakSpace :: ByteString -> (ByteString,ByteString)
breakSpace (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
    i <- firstspace (p `plusPtr` s) 0 l
    return $! case () of {_
        | i == 0    -> (empty, PS x s l)
        | i == l    -> (PS x s l, empty)
        | otherwise -> (PS x s i, PS x (s+i) (l-i))
    }
{-# INLINE breakSpace #-}

firstspace :: Ptr Word8 -> Int -> Int -> IO Int
firstspace a b c | a `seq` b `seq` c `seq` False = undefined
firstspace ptr n m
    | n >= m    = return n
    | otherwise = do w <- peekByteOff ptr n
                     if (not . isSpaceWord8) w then firstspace ptr (n+1) m else return n

{-# RULES
    "FPS specialise dropWhile isSpace -> dropSpace"
        dropWhile isSpace = dropSpace
  #-}

-- | 'dropSpace' efficiently returns the 'ByteString' argument with
-- white space Chars removed from the front. It is more efficient than
-- calling dropWhile for removing whitespace. I.e.
-- 
-- > dropWhile isSpace == dropSpace
--
dropSpace :: ByteString -> ByteString
dropSpace (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
    i <- firstnonspace (p `plusPtr` s) 0 l
    return $! if i == l then empty else PS x (s+i) (l-i)
{-# INLINE dropSpace #-}

firstnonspace :: Ptr Word8 -> Int -> Int -> IO Int
firstnonspace a b c | a `seq` b `seq` c `seq` False = undefined
firstnonspace ptr n m
    | n >= m    = return n
    | otherwise = do w <- peekElemOff ptr n
                     if isSpaceWord8 w then firstnonspace ptr (n+1) m else return n

{-
-- | 'dropSpaceEnd' efficiently returns the 'ByteString' argument with
-- white space removed from the end. I.e.
-- 
-- > reverse . (dropWhile isSpace) . reverse == dropSpaceEnd
--
-- but it is more efficient than using multiple reverses.
--
dropSpaceEnd :: ByteString -> ByteString
dropSpaceEnd (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
    i <- lastnonspace (p `plusPtr` s) (l-1)
    return $! if i == (-1) then empty else PS x s (i+1)
{-# INLINE dropSpaceEnd #-}

lastnonspace :: Ptr Word8 -> Int -> IO Int
STRICT2(lastnonspace)
lastnonspace ptr n
    | n < 0     = return n
    | otherwise = do w <- peekElemOff ptr n
                     if isSpaceWord8 w then lastnonspace ptr (n-1) else return n
-}

-- | 'lines' breaks a ByteString up into a list of ByteStrings at
-- newline Chars. The resulting strings do not contain newlines.
--
lines :: ByteString -> [ByteString]
lines ps
    | null ps = []
    | otherwise = case search ps of
             Nothing -> [ps]
             Just n  -> take n ps : lines (drop (n+1) ps)
    where search = elemIndex '\n'
{-# INLINE lines #-}

{-
-- Just as fast, but more complex. Should be much faster, I thought.
lines :: ByteString -> [ByteString]
lines (PS _ _ 0) = []
lines (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
        let ptr = p `plusPtr` s

            STRICT1(loop)
            loop n = do
                let q = memchr (ptr `plusPtr` n) 0x0a (fromIntegral (l-n))
                if q == nullPtr
                    then return [PS x (s+n) (l-n)]
                    else do let i = q `minusPtr` ptr
                            ls <- loop (i+1)
                            return $! PS x (s+n) (i-n) : ls
        loop 0
-}

-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,
-- after appending a terminating newline to each.
unlines :: [ByteString] -> ByteString
unlines [] = empty
unlines ss = (concat $ List.intersperse nl ss) `append` nl -- half as much space
    where nl = singleton '\n'

-- | 'words' breaks a ByteString up into a list of words, which
-- were delimited by Chars representing white space. And
--
-- > tokens isSpace = words
--
words :: ByteString -> [ByteString]
words = P.filter (not . B.null) . B.splitWith isSpaceWord8
{-# INLINE words #-}

-- | The 'unwords' function is analogous to the 'unlines' function, on words.
unwords :: [ByteString] -> ByteString
unwords = join (singleton ' ')
{-# INLINE unwords #-}

-- ---------------------------------------------------------------------
-- Reading from ByteStrings

-- | readInt reads an Int from the beginning of the ByteString.  If there is no
-- integer at the beginning of the string, it returns Nothing, otherwise
-- it just returns the int read, and the rest of the string.
readInt :: ByteString -> Maybe (Int, ByteString)
readInt as
    | null as   = Nothing
    | otherwise =
        case unsafeHead as of
            '-' -> loop True  0 0 (unsafeTail as)
            '+' -> loop False 0 0 (unsafeTail as)
            _   -> loop False 0 0 as

    where loop :: Bool -> Int -> Int -> ByteString -> Maybe (Int, ByteString)
          loop a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
          loop neg i n ps
              | null ps   = end neg i n ps
              | otherwise =
                  case B.unsafeHead ps of
                    w | w >= 0x30
                     && w <= 0x39 -> loop neg (i+1)
                                          (n * 10 + (fromIntegral w - 0x30))
                                          (unsafeTail ps)
                      | otherwise -> end neg i n ps

          end _    0 _ _  = Nothing
          end True _ n ps = Just (negate n, ps)
          end _    _ n ps = Just (n, ps)

-- | readInteger reads an Integer from the beginning of the ByteString.  If
-- there is no integer at the beginning of the string, it returns Nothing,
-- otherwise it just returns the int read, and the rest of the string.
readInteger :: ByteString -> Maybe (Integer, ByteString)
readInteger as
    | null as   = Nothing
    | otherwise =
        case unsafeHead as of
            '-' -> first (unsafeTail as) >>= \(n, bs) -> return (-n, bs)
            '+' -> first (unsafeTail as)
            _   -> first as

    where first ps | null ps   = Nothing
                   | otherwise =
                       case B.unsafeHead ps of
                        w | w >= 0x30 && w <= 0x39 -> Just $
                            loop 1 (fromIntegral w - 0x30) [] (unsafeTail ps)
                          | otherwise              -> Nothing

          loop :: Int -> Int -> [Integer]
               -> ByteString -> (Integer, ByteString)
          loop a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
          loop d acc ns ps
              | null ps   = combine d acc ns empty
              | otherwise =
                  case B.unsafeHead ps of
                   w | w >= 0x30 && w <= 0x39 ->
                       if d == 9 then loop 1 (fromIntegral w - 0x30)
                                           (toInteger acc : ns)
                                           (unsafeTail ps)
                                 else loop (d+1)
                                           (10*acc + (fromIntegral w - 0x30))
                                           ns (unsafeTail ps)
                     | otherwise -> combine d acc ns ps

          combine _ acc [] ps = (toInteger acc, ps)
          combine d acc ns ps =
              ((10^d * combine1 1000000000 ns + toInteger acc), ps)

          combine1 _ [n] = n
          combine1 b ns  = combine1 (b*b) $ combine2 b ns

          combine2 b (n:m:ns) = let t = m*b + n in t `seq` (t : combine2 b ns)
          combine2 _ ns       = ns

-- | Read an entire file strictly into a 'ByteString'.  This is far more
-- efficient than reading the characters into a 'String' and then using
-- 'pack'.  It also may be more efficient than opening the file and
-- reading it using hGet.
readFile :: FilePath -> IO ByteString
readFile f = bracket (openFile f ReadMode) hClose
    (\h -> hFileSize h >>= hGet h . fromIntegral)

-- | Write a 'ByteString' to a file.
writeFile :: FilePath -> ByteString -> IO ()
writeFile f txt = bracket (openFile f WriteMode) hClose
    (\h -> hPut h txt)

-- | Append a 'ByteString' to a file.
appendFile :: FilePath -> ByteString -> IO ()
appendFile f txt = bracket (openFile f AppendMode) hClose
    (\h -> hPut h txt)

{-# OPTIONS_GHC -cpp -fglasgow-exts -fno-warn-orphans #-}
--
-- Module      : Data.ByteString.Fusion
-- License     : BSD-style
-- Maintainer  : dons@cse.unsw.edu.au
-- Stability   : experimental
-- Portability : portable, requires ffi and cpp
-- Tested with : GHC 6.4.1 and Hugs March 2005
-- 

-- #hide

-- | Functional array fusion for ByteStrings. 
--
-- Originally based on code from the Data Parallel Haskell project, 
--      <http://www.cse.unsw.edu.au/~chak/project/dph>
--
module Data.ByteString.Fusion (

    -- * Fusion utilities
    loopU, loopL, fuseEFL,
    NoAcc(NoAcc), loopArr, loopAcc, loopSndAcc, unSP,
    mapEFL, filterEFL, foldEFL, foldEFL', scanEFL, mapAccumEFL, mapIndexEFL,

    -- ** Alternative Fusion stuff
    -- | This replaces 'loopU' with 'loopUp'
    -- and adds several further special cases of loops.
    loopUp, loopDown, loopNoAcc, loopMap, loopFilter,
    loopWrapper, sequenceLoops,
    doUpLoop, doDownLoop, doNoAccLoop, doMapLoop, doFilterLoop,

    -- | These are the special fusion cases for combining each loop form perfectly. 
    fuseAccAccEFL, fuseAccNoAccEFL, fuseNoAccAccEFL, fuseNoAccNoAccEFL,
    fuseMapAccEFL, fuseAccMapEFL, fuseMapNoAccEFL, fuseNoAccMapEFL,
    fuseMapMapEFL, fuseAccFilterEFL, fuseFilterAccEFL, fuseNoAccFilterEFL,
    fuseFilterNoAccEFL, fuseFilterFilterEFL, fuseMapFilterEFL, fuseFilterMapEFL,

    -- * Strict pairs and sums
    PairS(..), MaybeS(..)

  ) where

import Data.ByteString.Base

import Foreign.ForeignPtr
import Foreign.Ptr
import Foreign.Storable         (Storable(..))

import Data.Word                (Word8)
import System.IO.Unsafe         (unsafePerformIO)

-- -----------------------------------------------------------------------------
--
-- Useful macros, until we have bang patterns
--







infixl 2 :*:

-- |Strict pair
data PairS a b = !a :*: !b deriving (Eq,Ord,Show)

-- |Strict Maybe
data MaybeS a = NothingS | JustS !a deriving (Eq,Ord,Show)

-- |Data type for accumulators which can be ignored. The rewrite rules rely on
-- the fact that no bottoms of this type are ever constructed; hence, we can
-- assume @(_ :: NoAcc) `seq` x = x@.
--
data NoAcc = NoAcc

-- |Type of loop functions
type AccEFL acc = acc -> Word8 -> (PairS acc (MaybeS Word8))
type NoAccEFL   =        Word8 ->             MaybeS Word8
type MapEFL     =        Word8 ->                    Word8
type FilterEFL  =        Word8 ->             Bool

infixr 9 `fuseEFL`

-- |Fuse to flat loop functions
fuseEFL :: AccEFL acc1 -> AccEFL acc2 -> AccEFL (PairS acc1 acc2)
fuseEFL f g (acc1 :*: acc2) e1 =
    case f acc1 e1 of
        acc1' :*: NothingS -> (acc1' :*: acc2) :*: NothingS
        acc1' :*: JustS e2 ->
            case g acc2 e2 of
                acc2' :*: res -> (acc1' :*: acc2') :*: res




-- | Special forms of loop arguments
--
-- * These are common special cases for the three function arguments of gen
--   and loop; we give them special names to make it easier to trigger RULES
--   applying in the special cases represented by these arguments.  The
--   "INLINE [1]" makes sure that these functions are only inlined in the last
--   two simplifier phases.
--
-- * In the case where the accumulator is not needed, it is better to always
--   explicitly return a value `()', rather than just copy the input to the
--   output, as the former gives GHC better local information.
-- 

-- | Element function expressing a mapping only

mapEFL :: (Word8 -> Word8) -> AccEFL NoAcc
mapEFL f = \_ e -> (NoAcc :*: (JustS $ f e))








-- | Element function implementing a filter function only

filterEFL :: (Word8 -> Bool) -> AccEFL NoAcc
filterEFL p = \_ e -> if p e then (NoAcc :*: JustS e) else (NoAcc :*: NothingS)









-- |Element function expressing a reduction only
foldEFL :: (acc -> Word8 -> acc) -> AccEFL acc
foldEFL f = \a e -> (f a e :*: NothingS)




-- | A strict foldEFL.
foldEFL' :: (acc -> Word8 -> acc) -> AccEFL acc
foldEFL' f = \a e -> let a' = f a e in a' `seq` (a' :*: NothingS)




-- | Element function expressing a prefix reduction only
--
scanEFL :: (Word8 -> Word8 -> Word8) -> AccEFL Word8
scanEFL f = \a e -> (f a e :*: JustS a)




-- | Element function implementing a map and fold
--
mapAccumEFL :: (acc -> Word8 -> (acc, Word8)) -> AccEFL acc
mapAccumEFL f = \a e -> case f a e of (a', e') -> (a' :*: JustS e')




-- | Element function implementing a map with index
--
mapIndexEFL :: (Int -> Word8 -> Word8) -> AccEFL Int
mapIndexEFL f = \i e -> let i' = i+1 in i' `seq` (i' :*: JustS (f i e))




-- | Projection functions that are fusion friendly (as in, we determine when
-- they are inlined)
loopArr :: (PairS acc arr) -> arr
loopArr (_ :*: arr) = arr




loopAcc :: (PairS acc arr) -> acc
loopAcc (acc :*: _) = acc




loopSndAcc :: (PairS (PairS acc1 acc2) arr) -> (PairS acc2 arr)
loopSndAcc ((_ :*: acc) :*: arr) = (acc :*: arr)




unSP :: (PairS acc arr) -> (acc, arr)
unSP (acc :*: arr) = (acc, arr)




------------------------------------------------------------------------
--
-- Loop combinator and fusion rules for flat arrays
-- |Iteration over over ByteStrings

-- | Iteration over over ByteStrings
loopU :: AccEFL acc                 -- ^ mapping & folding, once per elem
      -> acc                        -- ^ initial acc value
      -> ByteString                 -- ^ input ByteString
      -> (PairS acc ByteString)

loopU f start (PS z s i) = unsafePerformIO $ withForeignPtr z $ \a -> do
    (ps, acc) <- createAndTrim' i $ \p -> do
      (acc' :*: i') <- go (a `plusPtr` s) p start
      return (0, i', acc')
    return (acc :*: ps)

  where
    go p ma = trans 0 0
        where
            trans a b c | a `seq` b `seq` c `seq` False = undefined
            trans a_off ma_off acc
                | a_off >= i = return (acc :*: ma_off)
                | otherwise  = do
                    x <- peekByteOff p a_off
                    let (acc' :*: oe) = f acc x
                    ma_off' <- case oe of
                        NothingS -> return ma_off
                        JustS e  -> do pokeByteOff ma ma_off e
                                       return $ ma_off + 1
                    trans (a_off+1) ma_off' acc'





{-# RULES

"FPS loop/loop fusion!" forall em1 em2 start1 start2 arr.
  loopU em2 start2 (loopArr (loopU em1 start1 arr)) =
    loopSndAcc (loopU (em1 `fuseEFL` em2) (start1 :*: start2) arr)

  #-}

--
-- Functional list/array fusion for lazy ByteStrings.
--
loopL :: AccEFL acc          -- ^ mapping & folding, once per elem
      -> acc                 -- ^ initial acc value
      -> [ByteString]        -- ^ input ByteString
      -> PairS acc [ByteString]
loopL f = loop
  where loop s []     = (s :*: [])
        loop s (x:xs)
          | l == 0    = (s'' :*: ys)
          | otherwise = (s'' :*: y:ys)
          where (s'  :*: y@(PS _ _ l)) = loopU f s x -- avoid circular dep on P.null
                (s'' :*: ys)           = loop s' xs





{-# RULES

"FPS lazy loop/loop fusion!" forall em1 em2 start1 start2 arr.
  loopL em2 start2 (loopArr (loopL em1 start1 arr)) =
    loopSndAcc (loopL (em1 `fuseEFL` em2) (start1 :*: start2) arr)

  #-}


{-

Alternate experimental formulation of loopU which partitions it into
an allocating wrapper and an imperitive array-mutating loop.

The point in doing this split is that we might be able to fuse multiple
loops into a single wrapper. This would save reallocating another buffer.
It should also give better cache locality by reusing the buffer.

Note that this stuff needs ghc-6.5 from May 26 or later for the RULES to
really work reliably.

-}

loopUp :: AccEFL acc -> acc -> ByteString -> PairS acc ByteString
loopUp f a arr = loopWrapper (doUpLoop f a) arr
{-# INLINE loopUp #-}

loopDown :: AccEFL acc -> acc -> ByteString -> PairS acc ByteString
loopDown f a arr = loopWrapper (doDownLoop f a) arr
{-# INLINE loopDown #-}

loopNoAcc :: NoAccEFL -> ByteString -> PairS NoAcc ByteString
loopNoAcc f arr = loopWrapper (doNoAccLoop f NoAcc) arr
{-# INLINE loopNoAcc #-}

loopMap :: MapEFL -> ByteString -> PairS NoAcc ByteString
loopMap f arr = loopWrapper (doMapLoop f NoAcc) arr
{-# INLINE loopMap #-}

loopFilter :: FilterEFL -> ByteString -> PairS NoAcc ByteString
loopFilter f arr = loopWrapper (doFilterLoop f NoAcc) arr
{-# INLINE loopFilter #-}

-- The type of imperitive loops that fill in a destination array by
-- reading a source array. They may not fill in the whole of the dest
-- array if the loop is behaving as a filter, this is why we return
-- the length that was filled in. The loop may also accumulate some
-- value as it loops over the source array.
--
type ImperativeLoop acc =
    Ptr Word8          -- pointer to the start of the source byte array
 -> Ptr Word8          -- pointer to ther start of the destination byte array
 -> Int                -- length of the source byte array
 -> IO (PairS (PairS acc Int) Int) -- result and offset, length of dest that was filled

loopWrapper :: ImperativeLoop acc -> ByteString -> PairS acc ByteString
loopWrapper body (PS srcFPtr srcOffset srcLen) = unsafePerformIO $
    withForeignPtr srcFPtr $ \srcPtr -> do
    (ps, acc) <- createAndTrim' srcLen $ \destPtr -> do
        (acc :*: destOffset :*: destLen) <-
          body (srcPtr `plusPtr` srcOffset) destPtr srcLen
        return (destOffset, destLen, acc)
    return (acc :*: ps)

doUpLoop :: AccEFL acc -> acc -> ImperativeLoop acc
doUpLoop f acc0 src dest len = loop 0 0 acc0
  where loop a b c | a `seq` b `seq` c `seq` False = undefined
        loop src_off dest_off acc
            | src_off >= len = return (acc :*: 0 :*: dest_off)
            | otherwise      = do
                x <- peekByteOff src src_off
                case f acc x of
                  (acc' :*: NothingS) -> loop (src_off+1) dest_off acc'
                  (acc' :*: JustS x') -> pokeByteOff dest dest_off x'
                                      >> loop (src_off+1) (dest_off+1) acc'

doDownLoop :: AccEFL acc -> acc -> ImperativeLoop acc
doDownLoop f acc0 src dest len = loop (len-1) (len-1) acc0
  where loop a b c | a `seq` b `seq` c `seq` False = undefined
        loop src_off dest_off acc
            | src_off < 0 = return (acc :*: dest_off + 1 :*: len - (dest_off + 1))
            | otherwise   = do
                x <- peekByteOff src src_off
                case f acc x of
                  (acc' :*: NothingS) -> loop (src_off-1) dest_off acc'
                  (acc' :*: JustS x') -> pokeByteOff dest dest_off x'
                                      >> loop (src_off-1) (dest_off-1) acc'

doNoAccLoop :: NoAccEFL -> noAcc -> ImperativeLoop noAcc
doNoAccLoop f noAcc src dest len = loop 0 0
  where loop a b | a `seq` b `seq` False = undefined
        loop src_off dest_off
            | src_off >= len = return (noAcc :*: 0 :*: dest_off)
            | otherwise      = do
                x <- peekByteOff src src_off
                case f x of
                  NothingS -> loop (src_off+1) dest_off
                  JustS x' -> pokeByteOff dest dest_off x'
                           >> loop (src_off+1) (dest_off+1)

doMapLoop :: MapEFL -> noAcc -> ImperativeLoop noAcc
doMapLoop f noAcc src dest len = loop 0
  where loop a | a `seq` False = undefined
        loop n
            | n >= len = return (noAcc :*: 0 :*: len)
            | otherwise      = do
                x <- peekByteOff src n
                pokeByteOff dest n (f x)
                loop (n+1) -- offset always the same, only pass 1 arg

doFilterLoop :: FilterEFL -> noAcc -> ImperativeLoop noAcc
doFilterLoop f noAcc src dest len = loop 0 0
  where loop a b | a `seq` b `seq` False = undefined
        loop src_off dest_off
            | src_off >= len = return (noAcc :*: 0 :*: dest_off)
            | otherwise      = do
                x <- peekByteOff src src_off
                if f x
                  then pokeByteOff dest dest_off x
                    >> loop (src_off+1) (dest_off+1)
                  else loop (src_off+1) dest_off

-- run two loops in sequence,
-- think of it as: loop1 >> loop2
sequenceLoops :: ImperativeLoop acc1
              -> ImperativeLoop acc2
              -> ImperativeLoop (PairS acc1 acc2)
sequenceLoops loop1 loop2 src dest len0 = do
  (acc1 :*: off1 :*: len1) <- loop1 src dest len0
  (acc2 :*: off2 :*: len2) <-
    let src'  = dest `plusPtr` off1
        dest' = src' -- note that we are using dest == src
                     -- for the second loop as we are
                     -- mutating the dest array in-place!
     in loop2 src' dest' len1
  return ((acc1  :*: acc2) :*: off1 + off2 :*: len2)

  -- TODO: prove that this is associative! (I think it is)
  -- since we can't be sure how the RULES will combine loops.































{-# RULES

"FPS loopArr/loopSndAcc" forall x.
  loopArr (loopSndAcc x) = loopArr x

"FPS seq/NoAcc" forall (u::NoAcc) e.
  u `seq` e = e

"FPS loop/loop wrapper elimination" forall loop1 loop2 arr.
  loopWrapper loop2 (loopArr (loopWrapper loop1 arr)) =
    loopSndAcc (loopWrapper (sequenceLoops loop1 loop2) arr)

--
-- n.b in the following, when reading n/m fusion, recall sequenceLoops
-- is monadic, so its really n >> m fusion (i.e. m.n), not n . m fusion.
--

"FPS up/up loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doUpLoop f1 acc1) (doUpLoop f2 acc2) =
    doUpLoop (f1 `fuseAccAccEFL` f2) (acc1 :*: acc2)

"FPS map/map loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doMapLoop f1 acc1) (doMapLoop f2 acc2) =
    doMapLoop (f1 `fuseMapMapEFL` f2) (acc1 :*: acc2)

"FPS filter/filter loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doFilterLoop f1 acc1) (doFilterLoop f2 acc2) =
    doFilterLoop (f1 `fuseFilterFilterEFL` f2) (acc1 :*: acc2)

"FPS map/filter loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doMapLoop f1 acc1) (doFilterLoop f2 acc2) =
    doNoAccLoop (f1 `fuseMapFilterEFL` f2) (acc1 :*: acc2)

"FPS filter/map loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doFilterLoop f1 acc1) (doMapLoop f2 acc2) =
    doNoAccLoop (f1 `fuseFilterMapEFL` f2) (acc1 :*: acc2)

"FPS map/up loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doMapLoop f1 acc1) (doUpLoop f2 acc2) =
    doUpLoop (f1 `fuseMapAccEFL` f2) (acc1 :*: acc2)

"FPS up/map loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doUpLoop f1 acc1) (doMapLoop f2 acc2) =
    doUpLoop (f1 `fuseAccMapEFL` f2) (acc1 :*: acc2)

"FPS filter/up loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doFilterLoop f1 acc1) (doUpLoop f2 acc2) =
    doUpLoop (f1 `fuseFilterAccEFL` f2) (acc1 :*: acc2)

"FPS up/filter loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doUpLoop f1 acc1) (doFilterLoop f2 acc2) =
    doUpLoop (f1 `fuseAccFilterEFL` f2) (acc1 :*: acc2)

"FPS down/down loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doDownLoop f1 acc1) (doDownLoop f2 acc2) =
    doDownLoop (f1 `fuseAccAccEFL` f2) (acc1 :*: acc2)

"FPS map/down fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doMapLoop f1 acc1) (doDownLoop f2 acc2) =
    doDownLoop (f1 `fuseMapAccEFL` f2) (acc1 :*: acc2)

"FPS down/map loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doDownLoop f1 acc1) (doMapLoop f2 acc2) =
    doDownLoop (f1 `fuseAccMapEFL` f2) (acc1 :*: acc2)

"FPS filter/down fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doFilterLoop f1 acc1) (doDownLoop f2 acc2) =
    doDownLoop (f1 `fuseFilterAccEFL` f2) (acc1 :*: acc2)

"FPS down/filter loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doDownLoop f1 acc1) (doFilterLoop f2 acc2) =
    doDownLoop (f1 `fuseAccFilterEFL` f2) (acc1 :*: acc2)

"FPS noAcc/noAcc loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doNoAccLoop f1 acc1) (doNoAccLoop f2 acc2) =
    doNoAccLoop (f1 `fuseNoAccNoAccEFL` f2) (acc1 :*: acc2)

"FPS noAcc/up loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doNoAccLoop f1 acc1) (doUpLoop f2 acc2) =
    doUpLoop (f1 `fuseNoAccAccEFL` f2) (acc1 :*: acc2)

"FPS up/noAcc loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doUpLoop f1 acc1) (doNoAccLoop f2 acc2) =
    doUpLoop (f1 `fuseAccNoAccEFL` f2) (acc1 :*: acc2)

"FPS map/noAcc loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doMapLoop f1 acc1) (doNoAccLoop f2 acc2) =
    doNoAccLoop (f1 `fuseMapNoAccEFL` f2) (acc1 :*: acc2)

"FPS noAcc/map loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doNoAccLoop f1 acc1) (doMapLoop f2 acc2) =
    doNoAccLoop (f1 `fuseNoAccMapEFL` f2) (acc1 :*: acc2)

"FPS filter/noAcc loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doFilterLoop f1 acc1) (doNoAccLoop f2 acc2) =
    doNoAccLoop (f1 `fuseFilterNoAccEFL` f2) (acc1 :*: acc2)

"FPS noAcc/filter loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doNoAccLoop f1 acc1) (doFilterLoop f2 acc2) =
    doNoAccLoop (f1 `fuseNoAccFilterEFL` f2) (acc1 :*: acc2)

"FPS noAcc/down loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doNoAccLoop f1 acc1) (doDownLoop f2 acc2) =
    doDownLoop (f1 `fuseNoAccAccEFL` f2) (acc1 :*: acc2)

"FPS down/noAcc loop fusion" forall f1 f2 acc1 acc2.
  sequenceLoops (doDownLoop f1 acc1) (doNoAccLoop f2 acc2) =
    doDownLoop (f1 `fuseAccNoAccEFL` f2) (acc1 :*: acc2)

  #-}

{-

up      = up loop
down    = down loop
map     = map special case
filter  = filter special case
noAcc   = noAcc undirectional loop (unused)

heirarchy:
  up     down
   ^     ^
    \   /
    noAcc
     ^ ^
    /   \
 map     filter

each is a special case of the things above

so we get rules that combine things on the same level
and rules that combine things on different levels
to get something on the higher level

so all the cases:
up/up         --> up     fuseAccAccEFL
down/down     --> down   fuseAccAccEFL
noAcc/noAcc   --> noAcc  fuseNoAccNoAccEFL

noAcc/up      --> up     fuseNoAccAccEFL
up/noAcc      --> up     fuseAccNoAccEFL
noAcc/down    --> down   fuseNoAccAccEFL
down/noAcc    --> down   fuseAccNoAccEFL

and if we do the map, filter special cases then it adds a load more:

map/map       --> map    fuseMapMapEFL
filter/filter --> filter fuseFilterFilterEFL

map/filter    --> noAcc  fuseMapFilterEFL
filter/map    --> noAcc  fuseFilterMapEFL

map/noAcc     --> noAcc  fuseMapNoAccEFL
noAcc/map     --> noAcc  fuseNoAccMapEFL

map/up        --> up     fuseMapAccEFL
up/map        --> up     fuseAccMapEFL

map/down      --> down   fuseMapAccEFL
down/map      --> down   fuseAccMapEFL

filter/noAcc  --> noAcc  fuseNoAccFilterEFL
noAcc/filter  --> noAcc  fuseFilterNoAccEFL

filter/up     --> up     fuseFilterAccEFL
up/filter     --> up     fuseAccFilterEFL

filter/down   --> down   fuseFilterAccEFL
down/filter   --> down   fuseAccFilterEFL
-}

fuseAccAccEFL :: AccEFL acc1 -> AccEFL acc2 -> AccEFL (PairS acc1 acc2)
fuseAccAccEFL f g (acc1 :*: acc2) e1 =
    case f acc1 e1 of
        acc1' :*: NothingS -> (acc1' :*: acc2) :*: NothingS
        acc1' :*: JustS e2 ->
            case g acc2 e2 of
                acc2' :*: res -> (acc1' :*: acc2') :*: res

fuseAccNoAccEFL :: AccEFL acc -> NoAccEFL -> AccEFL (PairS acc noAcc)
fuseAccNoAccEFL f g (acc :*: noAcc) e1 =
    case f acc e1 of
        acc' :*: NothingS -> (acc' :*: noAcc) :*: NothingS
        acc' :*: JustS e2 -> (acc' :*: noAcc) :*: g e2

fuseNoAccAccEFL :: NoAccEFL -> AccEFL acc -> AccEFL (PairS noAcc acc)
fuseNoAccAccEFL f g (noAcc :*: acc) e1 =
    case f e1 of
        NothingS -> (noAcc :*: acc) :*: NothingS
        JustS e2 ->
            case g acc e2 of
                acc' :*: res -> (noAcc :*: acc') :*: res

fuseNoAccNoAccEFL :: NoAccEFL -> NoAccEFL -> NoAccEFL
fuseNoAccNoAccEFL f g e1 =
    case f e1 of
        NothingS -> NothingS
        JustS e2 -> g e2

fuseMapAccEFL :: MapEFL -> AccEFL acc -> AccEFL (PairS noAcc acc)
fuseMapAccEFL f g (noAcc :*: acc) e1 =
    case g acc (f e1) of
        (acc' :*: res) -> (noAcc :*: acc') :*: res

fuseAccMapEFL :: AccEFL acc -> MapEFL -> AccEFL (PairS acc noAcc)
fuseAccMapEFL f g (acc :*: noAcc) e1 =
    case f acc e1 of
        (acc' :*: NothingS) -> (acc' :*: noAcc) :*: NothingS
        (acc' :*: JustS e2) -> (acc' :*: noAcc) :*: JustS (g e2)

fuseMapMapEFL :: MapEFL -> MapEFL -> MapEFL
fuseMapMapEFL   f g e1 = g (f e1)     -- n.b. perfect fusion

fuseMapNoAccEFL :: MapEFL -> NoAccEFL -> NoAccEFL
fuseMapNoAccEFL f g e1 = g (f e1)

fuseNoAccMapEFL :: NoAccEFL -> MapEFL -> NoAccEFL
fuseNoAccMapEFL f g e1 =
    case f e1 of
        NothingS -> NothingS
        JustS e2 -> JustS (g e2)

fuseAccFilterEFL :: AccEFL acc -> FilterEFL -> AccEFL (PairS acc noAcc)
fuseAccFilterEFL f g (acc :*: noAcc) e1 =
    case f acc e1 of
        acc' :*: NothingS -> (acc' :*: noAcc) :*: NothingS
        acc' :*: JustS e2 ->
            case g e2 of
                False -> (acc' :*: noAcc) :*: NothingS
                True  -> (acc' :*: noAcc) :*: JustS e2

fuseFilterAccEFL :: FilterEFL -> AccEFL acc -> AccEFL (PairS noAcc acc)
fuseFilterAccEFL f g (noAcc :*: acc) e1 =
    case f e1 of
        False -> (noAcc :*: acc) :*: NothingS
        True  ->
            case g acc e1 of
                acc' :*: res -> (noAcc :*: acc') :*: res

fuseNoAccFilterEFL :: NoAccEFL -> FilterEFL -> NoAccEFL
fuseNoAccFilterEFL f g e1 =
    case f e1 of
        NothingS -> NothingS
        JustS e2 ->
            case g e2 of
                False -> NothingS
                True  -> JustS e2

fuseFilterNoAccEFL :: FilterEFL -> NoAccEFL -> NoAccEFL
fuseFilterNoAccEFL f g e1 =
    case f e1 of
        False -> NothingS
        True  -> g e1

fuseFilterFilterEFL :: FilterEFL -> FilterEFL -> FilterEFL
fuseFilterFilterEFL f g e1 = f e1 && g e1

fuseMapFilterEFL :: MapEFL -> FilterEFL -> NoAccEFL
fuseMapFilterEFL f g e1 =
    case f e1 of
        e2 -> case g e2 of
            False -> NothingS
            True  -> JustS e2

fuseFilterMapEFL :: FilterEFL -> MapEFL -> NoAccEFL
fuseFilterMapEFL f g e1 =
    case f e1 of
        False -> NothingS
        True  -> JustS (g e1)

{-# OPTIONS_GHC -cpp -fglasgow-exts -fno-warn-orphans -fno-warn-incomplete-patterns #-}
--
-- Module      : ByteString.Lazy
-- Copyright   : (c) Don Stewart 2006
--               (c) Duncan Coutts 2006
-- License     : BSD-style
--
-- Maintainer  : dons@cse.unsw.edu.au
-- Stability   : experimental
-- Portability : portable, requires ffi and cpp
-- Tested with : GHC 6.4.1 and Hugs March 2005
-- 

--
-- | A time and space-efficient implementation of lazy byte vectors
-- using lists of packed 'Word8' arrays, suitable for high performance
-- use, both in terms of large data quantities, or high speed
-- requirements. Byte vectors are encoded as lazy lists of strict 'Word8'
-- arrays of bytes. They provide a means to manipulate large byte vectors
-- without requiring the entire vector be resident in memory.
--
-- Some operations, such as concat, append, reverse and cons, have
-- better complexity than their "Data.ByteString" equivalents, due to
-- optimisations resulting from the list spine structure. And for other
-- operations Lazy ByteStrings are usually within a few percent of
-- strict ones, but with better heap usage. For data larger than the
-- available memory, or if you have tight memory constraints, this
-- module will be the only option. The default chunk size is 64k, which
-- should be good in most circumstances. For people with large L2
-- caches, you may want to increase this to fit your cache.
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.
--
-- > import qualified Data.ByteString.Lazy as B
--
-- Original GHC implementation by Bryan O\'Sullivan. Rewritten to use
-- UArray by Simon Marlow. Rewritten to support slices and use
-- ForeignPtr by David Roundy. Polished and extended by Don Stewart.
-- Lazy variant by Duncan Coutts and Don Stewart.
--

module Data.ByteString.Lazy (

        -- * The @ByteString@ type
        ByteString,             -- instances: Eq, Ord, Show, Read, Data, Typeable

        -- * Introducing and eliminating 'ByteString's
        empty,                  -- :: ByteString
        singleton,              -- :: Word8   -> ByteString
        pack,                   -- :: [Word8] -> ByteString
        unpack,                 -- :: ByteString -> [Word8]
        fromChunks,             -- :: [Strict.ByteString] -> ByteString
        toChunks,               -- :: ByteString -> [Strict.ByteString]

        -- * Basic interface
        cons,                   -- :: Word8 -> ByteString -> ByteString
        snoc,                   -- :: ByteString -> Word8 -> ByteString
        append,                 -- :: ByteString -> ByteString -> ByteString
        head,                   -- :: ByteString -> Word8
        last,                   -- :: ByteString -> Word8
        tail,                   -- :: ByteString -> ByteString
        init,                   -- :: ByteString -> ByteString
        null,                   -- :: ByteString -> Bool
        length,                 -- :: ByteString -> Int64

        -- * Transformating ByteStrings
        map,                    -- :: (Word8 -> Word8) -> ByteString -> ByteString
        reverse,                -- :: ByteString -> ByteString
--      intersperse,            -- :: Word8 -> ByteString -> ByteString
        transpose,              -- :: [ByteString] -> [ByteString]

        -- * Reducing 'ByteString's (folds)
        foldl,                  -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldl',                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldl1',                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldr,                  -- :: (Word8 -> a -> a) -> a -> ByteString -> a
        foldr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8

        -- ** Special folds
        concat,                 -- :: [ByteString] -> ByteString
        concatMap,              -- :: (Word8 -> ByteString) -> ByteString -> ByteString
        any,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
        all,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
        maximum,                -- :: ByteString -> Word8
        minimum,                -- :: ByteString -> Word8

        -- * Building ByteStrings
        -- ** Scans
        scanl,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
--      scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
--      scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
--      scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString

        -- ** Accumulating maps
        mapAccumL,  -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
        mapIndexed, -- :: (Int64 -> Word8 -> Word8) -> ByteString -> ByteString

        -- ** Infinite ByteStrings
        repeat,                 -- :: Word8 -> ByteString
        replicate,              -- :: Int64 -> Word8 -> ByteString
        cycle,                  -- :: ByteString -> ByteString
        iterate,                -- :: (Word8 -> Word8) -> Word8 -> ByteString

        -- ** Unfolding
        unfoldr,                -- :: (a -> Maybe (Word8, a)) -> a -> ByteString

        -- * Substrings

        -- ** Breaking strings
        take,                   -- :: Int64 -> ByteString -> ByteString
        drop,                   -- :: Int64 -> ByteString -> ByteString
        splitAt,                -- :: Int64 -> ByteString -> (ByteString, ByteString)
        takeWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
        dropWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
        span,                   -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        break,                  -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        group,                  -- :: ByteString -> [ByteString]
        groupBy,                -- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
        inits,                  -- :: ByteString -> [ByteString]
        tails,                  -- :: ByteString -> [ByteString]

        -- ** Breaking into many substrings
        split,                  -- :: Word8 -> ByteString -> [ByteString]
        splitWith,              -- :: (Word8 -> Bool) -> ByteString -> [ByteString]

        -- ** Joining strings
        join,                   -- :: ByteString -> [ByteString] -> ByteString

        -- * Predicates
        isPrefixOf,             -- :: ByteString -> ByteString -> Bool
--      isSuffixOf,             -- :: ByteString -> ByteString -> Bool

        -- * Searching ByteStrings

        -- ** Searching by equality
        elem,                   -- :: Word8 -> ByteString -> Bool
        notElem,                -- :: Word8 -> ByteString -> Bool

        -- ** Searching with a predicate
        find,                   -- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
        filter,                 -- :: (Word8 -> Bool) -> ByteString -> ByteString
--      partition               -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)

        -- * Indexing ByteStrings
        index,                  -- :: ByteString -> Int64 -> Word8
        elemIndex,              -- :: Word8 -> ByteString -> Maybe Int64
        elemIndices,            -- :: Word8 -> ByteString -> [Int64]
        findIndex,              -- :: (Word8 -> Bool) -> ByteString -> Maybe Int64
        findIndices,            -- :: (Word8 -> Bool) -> ByteString -> [Int64]
        count,                  -- :: Word8 -> ByteString -> Int64

        -- * Zipping and unzipping ByteStrings
        zip,                    -- :: ByteString -> ByteString -> [(Word8,Word8)]
        zipWith,                -- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
--      unzip,                  -- :: [(Word8,Word8)] -> (ByteString,ByteString)

        -- * Ordered ByteStrings
--        sort,                   -- :: ByteString -> ByteString

        copy,                   -- :: ByteString -> ByteString

        -- * I\/O with 'ByteString's

        -- ** Standard input and output
        getContents,            -- :: IO ByteString
        putStr,                 -- :: ByteString -> IO ()
        putStrLn,               -- :: ByteString -> IO ()
        interact,               -- :: (ByteString -> ByteString) -> IO ()

        -- ** Files
        readFile,               -- :: FilePath -> IO ByteString
        writeFile,              -- :: FilePath -> ByteString -> IO ()
        appendFile,             -- :: FilePath -> ByteString -> IO ()

        -- ** I\/O with Handles
        hGetContents,           -- :: Handle -> IO ByteString
        hGet,                   -- :: Handle -> Int -> IO ByteString
        hPut,                   -- :: Handle -> ByteString -> IO ()
        hGetNonBlocking,        -- :: Handle -> IO ByteString

--      hGetN,                  -- :: Int -> Handle -> Int -> IO ByteString
--      hGetContentsN,          -- :: Int -> Handle -> IO ByteString
--      hGetNonBlockingN,       -- :: Int -> Handle -> IO ByteString

  ) where

import qualified Prelude
import Prelude hiding
    (reverse,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
    ,concat,any,take,drop,splitAt,takeWhile,dropWhile,span,break,elem,filter,maximum
    ,minimum,all,concatMap,foldl1,foldr1,scanl, scanl1, scanr, scanr1
    ,repeat, cycle, interact, iterate,readFile,writeFile,appendFile,replicate
    ,getContents,getLine,putStr,putStrLn ,zip,zipWith,unzip,notElem)

import qualified Data.List              as L  -- L for list/lazy
import qualified Data.ByteString        as P  -- P for packed
import qualified Data.ByteString.Base   as P
import Data.ByteString.Base (LazyByteString(..))
import qualified Data.ByteString.Fusion as P
import Data.ByteString.Fusion (PairS(..),loopL)

import Data.Monoid              (Monoid(..))

import Data.Word                (Word8)
import Data.Int                 (Int64)
import System.IO                (Handle,stdin,stdout,openBinaryFile,IOMode(..)
                                ,hClose,hWaitForInput,hIsEOF)
import System.IO.Unsafe
import Control.Exception        (bracket)

import Foreign.ForeignPtr       (withForeignPtr)
import Foreign.Ptr
import Foreign.Storable

-- -----------------------------------------------------------------------------
--
-- Useful macros, until we have bang patterns
--







-- -----------------------------------------------------------------------------

type ByteString = LazyByteString

--
-- hmm, what about getting the PS constructor unpacked into the cons cell?
--
-- data List = Nil | Cons {-# UNPACK #-} !P.ByteString List
--
-- Would avoid one indirection per chunk.
--

unLPS :: ByteString -> [P.ByteString]
unLPS (LPS xs) = xs
{-# INLINE unLPS #-}

instance Eq  ByteString
    where (==)    = eq

instance Ord ByteString
    where compare = compareBytes

instance Monoid ByteString where
    mempty  = empty
    mappend = append
    mconcat = concat

------------------------------------------------------------------------

-- XXX
-- The data type invariant:
-- Every ByteString is either empty or consists of non-null ByteStrings.
-- All functions must preserve this, and the QC properties must check this.
--
_invariant :: ByteString -> Bool
_invariant (LPS []) = True
_invariant (LPS xs) = L.all (not . P.null) xs

-- In a form useful for QC testing
_checkInvariant :: ByteString -> ByteString
_checkInvariant lps
    | _invariant lps = lps
    | otherwise      = moduleError "invariant" ("violation: " ++ show lps)

-- The Data abstraction function
--
_abstr :: ByteString -> P.ByteString
_abstr (LPS []) = P.empty
_abstr (LPS xs) = P.concat xs

-- The representation uses lists of packed chunks. When we have to convert from
-- a lazy list to the chunked representation, then by default we'll use this
-- chunk size. Some functions give you more control over the chunk size.
--
-- Measurements here:
--  http://www.cse.unsw.edu.au/~dons/tmp/chunksize_v_cache.png
--
-- indicate that a value around 0.5 to 1 x your L2 cache is best.
-- The following value assumes people have something greater than 128k,
-- and need to share the cache with other programs.
--
defaultChunkSize :: Int
defaultChunkSize = 32 * k - overhead
   where k = 1024
         overhead = 2 * sizeOf (undefined :: Int)

smallChunkSize :: Int
smallChunkSize = 4 * k - overhead
   where k = 1024
         overhead = 2 * sizeOf (undefined :: Int)

-- defaultChunkSize = 1

------------------------------------------------------------------------

eq :: ByteString -> ByteString -> Bool
eq (LPS xs) (LPS ys) = eq' xs ys
  where eq' [] [] = True
        eq' [] _  = False
        eq' _  [] = False
        eq' (a:as) (b:bs) =
          case compare (P.length a) (P.length b) of
            LT -> a == (P.take (P.length a) b) && eq' as (P.drop (P.length a) b : bs)
            EQ -> a == b                       && eq' as bs
            GT -> (P.take (P.length b) a) == b && eq' (P.drop (P.length b) a : as) bs

compareBytes :: ByteString -> ByteString -> Ordering
compareBytes (LPS xs) (LPS ys) = cmp xs ys
  where cmp [] [] = EQ
        cmp [] _  = LT
        cmp _  [] = GT
        cmp (a:as) (b:bs) =
          case compare (P.length a) (P.length b) of
            LT -> case compare a (P.take (P.length a) b) of
                    EQ     -> cmp as (P.drop (P.length a) b : bs)
                    result -> result
            EQ -> case compare a b of
                    EQ     -> cmp as bs
                    result -> result
            GT -> case compare (P.take (P.length b) a) b of
                    EQ     -> cmp (P.drop (P.length b) a : as) bs
                    result -> result

-- -----------------------------------------------------------------------------
-- Introducing and eliminating 'ByteString's

-- | /O(1)/ The empty 'ByteString'
empty :: ByteString
empty = LPS []
{-# NOINLINE empty #-}

-- | /O(1)/ Convert a 'Word8' into a 'ByteString'
singleton :: Word8 -> ByteString
singleton c = LPS [P.singleton c]
{-# NOINLINE singleton #-}

-- | /O(n)/ Convert a '[Word8]' into a 'ByteString'. 
pack :: [Word8] -> ByteString
pack str = LPS $ L.map P.pack (chunk defaultChunkSize str)

-- ?
chunk :: Int -> [a] -> [[a]]
chunk _    [] = []
chunk size xs = case L.splitAt size xs of (xs', xs'') -> xs' : chunk size xs''

-- | /O(n)/ Converts a 'ByteString' to a '[Word8]'.
unpack :: ByteString -> [Word8]
unpack (LPS ss) = L.concatMap P.unpack ss
{-# INLINE unpack #-}

-- | /O(c)/ Convert a list of strict 'ByteString' into a lazy 'ByteString'
fromChunks :: [P.ByteString] -> ByteString
fromChunks ls = LPS $ L.filter (not . P.null) ls

-- | /O(n)/ Convert a lazy 'ByteString' into a list of strict 'ByteString'
toChunks :: ByteString -> [P.ByteString]
toChunks (LPS s) = s

------------------------------------------------------------------------

{-
-- | /O(n)/ Convert a '[a]' into a 'ByteString' using some
-- conversion function
packWith :: (a -> Word8) -> [a] -> ByteString
packWith k str = LPS $ L.map (P.packWith k) (chunk defaultChunkSize str)
{-# INLINE packWith #-}
{-# SPECIALIZE packWith :: (Char -> Word8) -> [Char] -> ByteString #-}

-- | /O(n)/ Converts a 'ByteString' to a '[a]', using a conversion function.
unpackWith :: (Word8 -> a) -> ByteString -> [a]
unpackWith k (LPS ss) = L.concatMap (P.unpackWith k) ss
{-# INLINE unpackWith #-}
{-# SPECIALIZE unpackWith :: (Word8 -> Char) -> ByteString -> [Char] #-}
-}

-- ---------------------------------------------------------------------
-- Basic interface

-- | /O(1)/ Test whether a ByteString is empty.
null :: ByteString -> Bool
null (LPS []) = True
null (_)      = False
{-# INLINE null #-}

-- | /O(n\/c)/ 'length' returns the length of a ByteString as an 'Int64'
length :: ByteString -> Int64
length (LPS ss) = L.foldl' (\n ps -> n + fromIntegral (P.length ps)) 0 ss

-- avoid the intermediate list?
-- length (LPS ss) = L.foldl lengthF 0 ss
--     where lengthF n s = let m = n + fromIntegral (P.length s) in m `seq` m
{-# INLINE length #-}

-- | /O(1)/ 'cons' is analogous to '(:)' for lists. Unlike '(:)' however it is
-- strict in the ByteString that we are consing onto. More precisely, it forces
-- the head and the first chunk. It does this because, for space efficiency, it
-- may coalesce the new byte onto the first \'chunk\' rather than starting a
-- new \'chunk\'.
--
-- So that means you can't use a lazy recursive contruction like this:
--
-- > let xs = cons c xs in xs
--
-- You can however use 'repeat' and 'cycle' to build infinite lazy ByteStrings.
--
cons :: Word8 -> ByteString -> ByteString
cons c (LPS (s:ss)) | P.length s <= 16 = LPS (P.cons c s : ss)
cons c (LPS ss)                        = LPS (P.singleton c : ss)
{-# INLINE cons #-}

-- | /O(n\/c)/ Append a byte to the end of a 'ByteString'
snoc :: ByteString -> Word8 -> ByteString
snoc (LPS ss) c = LPS (ss ++ [P.singleton c])
{-# INLINE snoc #-}

-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
head :: ByteString -> Word8
head (LPS [])    = errorEmptyList "head"
head (LPS (x:_)) = P.unsafeHead x
{-# INLINE head #-}

-- | /O(1)/ Extract the elements after the head of a ByteString, which must be non-empty.
tail :: ByteString -> ByteString
tail (LPS [])     = errorEmptyList "tail"
tail (LPS (x:xs))
  | P.length x == 1 = LPS xs
  | otherwise       = LPS (P.unsafeTail x : xs)
{-# INLINE tail #-}

-- | /O(n\/c)/ Extract the last element of a ByteString, which must be finite and non-empty.
last :: ByteString -> Word8
last (LPS []) = errorEmptyList "last"
last (LPS xs) = P.last (L.last xs)
{-# INLINE last #-}

-- | /O(n\/c)/ Return all the elements of a 'ByteString' except the last one.
init :: ByteString -> ByteString
init (LPS []) = errorEmptyList "init"
init (LPS xs)
    | P.length y == 1 = LPS ys
    | otherwise       = LPS (ys ++ [P.init y])
    where (y,ys) = (L.last xs, L.init xs)
{-# INLINE init #-}

-- | /O(n)/ Append two ByteStrings
append :: ByteString -> ByteString -> ByteString
append (LPS []) (LPS ys) = LPS ys
append (LPS xs) (LPS []) = LPS xs
append (LPS xs) (LPS ys) = LPS (xs ++ ys)
{-# INLINE append #-}

-- ---------------------------------------------------------------------
-- Transformations

-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each
-- element of @xs@.
map :: (Word8 -> Word8) -> ByteString -> ByteString
--map f (LPS xs) = LPS (L.map (P.map' f) xs)
map f = LPS . P.loopArr . loopL (P.mapEFL f) P.NoAcc . unLPS
{-# INLINE map #-}

-- | /O(n)/ 'reverse' @xs@ efficiently returns the elements of @xs@ in reverse order.
reverse :: ByteString -> ByteString
reverse (LPS ps) = LPS (rev [] ps)
  where rev a []     = a
        rev a (x:xs) = rev (P.reverse x:a) xs
-- note, here is one example where the extra element lazyness is an advantage.
-- we can reerse the list of chunks strictly but reverse each chunk lazily
-- so while we may force the whole lot into memory we do not need to copy
-- each chunk until it is used.
{-# INLINE reverse #-}

-- The 'intersperse' function takes a 'Word8' and a 'ByteString' and
-- \`intersperses\' that byte between the elements of the 'ByteString'.
-- It is analogous to the intersperse function on Lists.
-- intersperse :: Word8 -> ByteString -> ByteString
-- intersperse = error "FIXME: not yet implemented"

{-
intersperse c (LPS [])     = LPS []
intersperse c (LPS (x:xs)) = LPS (P.intersperse c x : L.map intersperse')
  where intersperse' c ps@(PS x s l) =
          P.create (2*l) $ \p -> withForeignPtr x $ \f ->
                poke p c
                c_intersperse (p `plusPtr` 1) (f `plusPtr` s) l c
-}

-- | The 'transpose' function transposes the rows and columns of its
-- 'ByteString' argument.
transpose :: [ByteString] -> [ByteString]
transpose s = L.map (\ss -> LPS [P.pack ss]) (L.transpose (L.map unpack s))

-- ---------------------------------------------------------------------
-- Reducing 'ByteString's

-- | 'foldl', applied to a binary operator, a starting value (typically
-- the left-identity of the operator), and a ByteString, reduces the
-- ByteString using the binary operator, from left to right.
foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
--foldl f z (LPS xs) = L.foldl (P.foldl f) z xs
foldl f z = P.loopAcc . loopL (P.foldEFL f) z . unLPS
{-# INLINE foldl #-}

-- | 'foldl\'' is like 'foldl', but strict in the accumulator.
foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
--foldl' f z (LPS xs) = L.foldl' (P.foldl' f) z xs
foldl' f z = P.loopAcc . loopL (P.foldEFL' f) z . unLPS
{-# INLINE foldl' #-}

-- | 'foldr', applied to a binary operator, a starting value
-- (typically the right-identity of the operator), and a ByteString,
-- reduces the ByteString using the binary operator, from right to left.
foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
foldr k z (LPS xs) = L.foldr (flip (P.foldr k)) z xs
{-# INLINE foldr #-}

-- | 'foldl1' is a variant of 'foldl' that has no starting value
-- argument, and thus must be applied to non-empty 'ByteStrings'.
-- This function is subject to array fusion.
foldl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1 _ (LPS []) = errorEmptyList "foldl1"
foldl1 f (LPS (x:xs)) = foldl f (P.unsafeHead x) (LPS (P.unsafeTail x : xs))

-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1' _ (LPS []) = errorEmptyList "foldl1'"
foldl1' f (LPS (x:xs)) = foldl' f (P.unsafeHead x) (LPS (P.unsafeTail x : xs))

-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
-- and thus must be applied to non-empty 'ByteString's
foldr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldr1 _ (LPS []) = errorEmptyList "foldr1"
foldr1 f (LPS ps) = foldr1' ps
  where foldr1' (x:[]) = P.foldr1 f x
        foldr1' (x:xs) = P.foldr  f (foldr1' xs) x

-- ---------------------------------------------------------------------
-- Special folds

-- | /O(n)/ Concatenate a list of ByteStrings.
concat :: [ByteString] -> ByteString
concat lpss = LPS (L.concatMap (\(LPS xs) -> xs) lpss)

-- | Map a function over a 'ByteString' and concatenate the results
concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
concatMap f (LPS lps) = LPS (filterMap (P.concatMap k) lps)
    where
      k w = case f w of LPS xs -> P.concat xs

-- | /O(n)/ Applied to a predicate and a ByteString, 'any' determines if
-- any element of the 'ByteString' satisfies the predicate.
any :: (Word8 -> Bool) -> ByteString -> Bool
any f (LPS xs) = L.or (L.map (P.any f) xs)
-- todo fuse

-- | /O(n)/ Applied to a predicate and a 'ByteString', 'all' determines
-- if all elements of the 'ByteString' satisfy the predicate.
all :: (Word8 -> Bool) -> ByteString -> Bool
all f (LPS xs) = L.and (L.map (P.all f) xs)
-- todo fuse

-- | /O(n)/ 'maximum' returns the maximum value from a 'ByteString'
maximum :: ByteString -> Word8
maximum (LPS [])     = errorEmptyList "maximum"
maximum (LPS (x:xs)) = L.foldl' (\n ps -> n `max` P.maximum ps) (P.maximum x) xs
{-# INLINE maximum #-}

-- | /O(n)/ 'minimum' returns the minimum value from a 'ByteString'
minimum :: ByteString -> Word8
minimum (LPS [])     = errorEmptyList "minimum"
minimum (LPS (x:xs)) = L.foldl' (\n ps -> n `min` P.minimum ps) (P.minimum x) xs
{-# INLINE minimum #-}

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapAccumL f z = (\(a :*: ps) -> (a, LPS ps)) . loopL (P.mapAccumEFL f) z . unLPS

-- | /O(n)/ map Word8 functions, provided with the index at each position
mapIndexed :: (Int -> Word8 -> Word8) -> ByteString -> ByteString
mapIndexed f = LPS . P.loopArr . loopL (P.mapIndexEFL f) 0 . unLPS

-- ---------------------------------------------------------------------
-- Building ByteStrings

-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left. This function will fuse.
--
-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that
--
-- > last (scanl f z xs) == foldl f z xs.
scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
scanl f z ps = LPS . P.loopArr . loopL (P.scanEFL f) z . unLPS $ (ps `snoc` 0)
{-# INLINE scanl #-}

-- ---------------------------------------------------------------------
-- Unfolds and replicates

-- | @'iterate' f x@ returns an infinite ByteString of repeated applications
-- of @f@ to @x@:
--
-- > iterate f x == [x, f x, f (f x), ...]
--
iterate :: (Word8 -> Word8) -> Word8 -> ByteString
iterate f = unfoldr (\x -> case f x of x' -> x' `seq` Just (x', x'))

-- | @'repeat' x@ is an infinite ByteString, with @x@ the value of every
-- element.
--
repeat :: Word8 -> ByteString
repeat c = LPS (L.repeat block)
    where block =  P.replicate smallChunkSize c

-- | /O(n)/ @'replicate' n x@ is a ByteString of length @n@ with @x@
-- the value of every element.
--
replicate :: Int64 -> Word8 -> ByteString
replicate w c
    | w <= 0             = empty
    | w < fromIntegral smallChunkSize = LPS [P.replicate (fromIntegral w) c]
    | r == 0             = LPS (L.genericReplicate q s) -- preserve invariant
    | otherwise          = LPS (P.unsafeTake (fromIntegral r) s : L.genericReplicate q s)
 where
    s      = P.replicate smallChunkSize c
    (q, r) = quotRem w (fromIntegral smallChunkSize)

-- | 'cycle' ties a finite ByteString into a circular one, or equivalently,
-- the infinite repetition of the original ByteString.
--
cycle :: ByteString -> ByteString
cycle (LPS []) = errorEmptyList "cycle"
cycle (LPS xs) = LPS (L.cycle xs)

-- | /O(n)/ The 'unfoldr' function is analogous to the List \'unfoldr\'.
-- 'unfoldr' builds a ByteString from a seed value.  The function takes
-- the element and returns 'Nothing' if it is done producing the
-- ByteString or returns 'Just' @(a,b)@, in which case, @a@ is a
-- prepending to the ByteString and @b@ is used as the next element in a
-- recursive call.
unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
unfoldr f = LPS . unfoldChunk 32
  where unfoldChunk n x =
          case P.unfoldrN n f x of
            (s, Nothing)
              | P.null s  -> []
              | otherwise -> s : []
            (s, Just x')  -> s : unfoldChunk ((n*2) `min` smallChunkSize) x'

-- ---------------------------------------------------------------------
-- Substrings

-- | /O(n\/c)/ 'take' @n@, applied to a ByteString @xs@, returns the prefix
-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.
take :: Int64 -> ByteString -> ByteString
take n _ | n < 0 = empty
take i (LPS ps)  = LPS (take' i ps)
  where take' _ []     = []
        take' 0 _      = []
        take' n (x:xs) =
          if n < fromIntegral (P.length x)
            then P.take (fromIntegral n) x : []
            else x : take' (n - fromIntegral (P.length x)) xs

-- | /O(n\/c)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
-- elements, or @[]@ if @n > 'length' xs@.
drop  :: Int64 -> ByteString -> ByteString
drop i p | i <= 0 = p
drop i (LPS ps) = LPS (drop' i ps)
  where drop' _ []     = []
        drop' 0 xs     = xs
        drop' n (x:xs) =
          if n < fromIntegral (P.length x)
            then P.drop (fromIntegral n) x : xs
            else drop' (n - fromIntegral (P.length x)) xs

-- | /O(n\/c)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.
splitAt :: Int64 -> ByteString -> (ByteString, ByteString)
splitAt i p        | i <= 0 = (empty, p)
splitAt i (LPS ps) = case splitAt' i ps of (a,b) -> (LPS a, LPS b)
  where splitAt' _ []     = ([], [])
        splitAt' 0 xs     = ([], xs)
        splitAt' n (x:xs) =
          if n < fromIntegral (P.length x)
            then (P.take (fromIntegral n) x : [], 
                  P.drop (fromIntegral n) x : xs)
            else let (xs', xs'') = splitAt' (n - fromIntegral (P.length x)) xs
                   in (x:xs', xs'')


-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.
takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
takeWhile f (LPS ps) = LPS (takeWhile' ps)
  where takeWhile' []     = []
        takeWhile' (x:xs) =
          case findIndexOrEnd (not . f) x of
            0                  -> []
            n | n < P.length x -> P.take n x : []
              | otherwise      -> x : takeWhile' xs

-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
dropWhile f (LPS ps) = LPS (dropWhile' ps)
  where dropWhile' []     = []
        dropWhile' (x:xs) =
          case findIndexOrEnd (not . f) x of
            n | n < P.length x -> P.drop n x : xs
              | otherwise      -> dropWhile' xs

-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
break f (LPS ps) = case (break' ps) of (a,b) -> (LPS a, LPS b)
  where break' []     = ([], [])
        break' (x:xs) =
          case findIndexOrEnd f x of
            0                  -> ([], x : xs)
            n | n < P.length x -> (P.take n x : [], P.drop n x : xs)
              | otherwise      -> let (xs', xs'') = break' xs
                                   in (x : xs', xs'')

--
-- TODO
--
-- Add rules
--

{-
-- | 'breakByte' breaks its ByteString argument at the first occurence
-- of the specified byte. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
-- 
-- > break (=='c') "abcd" == breakByte 'c' "abcd"
--
breakByte :: Word8 -> ByteString -> (ByteString, ByteString)
breakByte c (LPS ps) = case (breakByte' ps) of (a,b) -> (LPS a, LPS b)
  where breakByte' []     = ([], [])
        breakByte' (x:xs) =
          case P.elemIndex c x of
            Just 0  -> ([], x : xs)
            Just n  -> (P.take n x : [], P.drop n x : xs)
            Nothing -> let (xs', xs'') = breakByte' xs
                        in (x : xs', xs'')

-- | 'spanByte' breaks its ByteString argument at the first
-- occurence of a byte other than its argument. It is more efficient
-- than 'span (==)'
--
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
--
spanByte :: Word8 -> ByteString -> (ByteString, ByteString)
spanByte c (LPS ps) = case (spanByte' ps) of (a,b) -> (LPS a, LPS b)
  where spanByte' []     = ([], [])
        spanByte' (x:xs) =
          case P.spanByte c x of
            (x', x'') | P.null x'  -> ([], x : xs)
                      | P.null x'' -> let (xs', xs'') = spanByte' xs
                                       in (x : xs', xs'')
                      | otherwise  -> (x' : [], x'' : xs)
-}

-- | 'span' @p xs@ breaks the ByteString into two segments. It is
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
span p = break (not . p)

-- | /O(n)/ Splits a 'ByteString' into components delimited by
-- separators, where the predicate returns True for a separator element.
-- The resulting components do not contain the separators.  Two adjacent
-- separators result in an empty component in the output.  eg.
--
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
-- > splitWith (=='a') []        == []
--
splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
splitWith _ (LPS [])     = []
splitWith p (LPS (a:as)) = comb [] (P.splitWith p a) as

  where comb :: [P.ByteString] -> [P.ByteString] -> [P.ByteString] -> [ByteString]
        comb acc (s:[]) []     = LPS (L.reverse (cons' s acc)) : []
        comb acc (s:[]) (x:xs) = comb (cons' s acc) (P.splitWith p x) xs
        comb acc (s:ss) xs     = LPS (L.reverse (cons' s acc)) : comb [] ss xs

        cons' x xs | P.null x  = xs
                   | otherwise = x:xs
        {-# INLINE cons' #-}
{-# INLINE splitWith #-}

-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.
--
-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split 'a'  "aXaXaXa"    == ["","X","X","X"]
-- > split 'x'  "x"          == ["",""]
-- 
-- and
--
-- > join [c] . split c == id
-- > split == splitWith . (==)
-- 
-- As for all splitting functions in this library, this function does
-- not copy the substrings, it just constructs new 'ByteStrings' that
-- are slices of the original.
--
split :: Word8 -> ByteString -> [ByteString]
split _ (LPS [])     = []
split c (LPS (a:as)) = comb [] (P.split c a) as

  where comb :: [P.ByteString] -> [P.ByteString] -> [P.ByteString] -> [ByteString]
        comb acc (s:[]) []     = LPS (L.reverse (cons' s acc)) : []
        comb acc (s:[]) (x:xs) = comb (cons' s acc) (P.split c x) xs
        comb acc (s:ss) xs     = LPS (L.reverse (cons' s acc)) : comb [] ss xs

        cons' x xs | P.null x  = xs
                   | otherwise = x:xs
        {-# INLINE cons' #-}
{-# INLINE split #-}

{-
-- | Like 'splitWith', except that sequences of adjacent separators are
-- treated as a single separator. eg.
-- 
-- > tokens (=='a') "aabbaca" == ["bb","c"]
--
tokens :: (Word8 -> Bool) -> ByteString -> [ByteString]
tokens f = L.filter (not.null) . splitWith f
-}

-- | The 'group' function takes a ByteString and returns a list of
-- ByteStrings such that the concatenation of the result is equal to the
-- argument.  Moreover, each sublist in the result contains only equal
-- elements.  For example,
--
-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--
-- It is a special case of 'groupBy', which allows the programmer to
-- supply their own equality test.
group :: ByteString -> [ByteString]
group (LPS [])     = []
group (LPS (a:as)) = group' [] (P.group a) as
  where group' :: [P.ByteString] -> [P.ByteString] -> [P.ByteString] -> [ByteString]
        group' acc@(s':_) ss@(s:_) xs
          | P.unsafeHead s'
         /= P.unsafeHead s       = LPS (L.reverse acc) : group' [] ss xs
        group' acc (s:[]) []     = LPS (L.reverse (s : acc)) : []
        group' acc (s:[]) (x:xs) = group' (s:acc) (P.group x) xs
        group' acc (s:ss) xs     = LPS (L.reverse (s : acc)) : group' [] ss xs

{-
TODO: check if something like this might be faster

group :: ByteString -> [ByteString]
group xs
    | null xs   = []
    | otherwise = ys : group zs
    where
        (ys, zs) = spanByte (unsafeHead xs) xs
-}

-- | The 'groupBy' function is the non-overloaded version of 'group'.
--
groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
groupBy = error "Data.ByteString.Lazy.groupBy: unimplemented"
{-
groupBy _ (LPS [])     = []
groupBy k (LPS (a:as)) = groupBy' [] 0 (P.groupBy k a) as
  where groupBy' :: [P.ByteString] -> Word8 -> [P.ByteString] -> [P.ByteString] -> [ByteString]
        groupBy' acc@(_:_) c ss@(s:_) xs
          | not (c `k` P.unsafeHead s) = LPS (L.reverse acc) : groupBy' [] 0 ss xs
        groupBy' acc _ (s:[]) []       = LPS (L.reverse (s : acc)) : []
        groupBy' []  _ (s:[]) (x:xs)   = groupBy' (s:[]) (P.unsafeHead s) (P.groupBy k x) xs
        groupBy' acc c (s:[]) (x:xs)   = groupBy' (s:acc) c (P.groupBy k x) xs
        groupBy' acc _ (s:ss) xs       = LPS (L.reverse (s : acc)) : groupBy' [] 0 ss xs
-}

{-
TODO: check if something like this might be faster

groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
groupBy k xs
    | null xs   = []
    | otherwise = take n xs : groupBy k (drop n xs)
    where
        n = 1 + findIndexOrEnd (not . k (head xs)) (tail xs)
-}

-- | /O(n)/ The 'join' function takes a 'ByteString' and a list of
-- 'ByteString's and concatenates the list after interspersing the first
-- argument between each element of the list.
join :: ByteString -> [ByteString] -> ByteString
join s = concat . (L.intersperse s)

-- ---------------------------------------------------------------------
-- Indexing ByteStrings

-- | /O(c)/ 'ByteString' index (subscript) operator, starting from 0.
index :: ByteString -> Int64 -> Word8
index _        i | i < 0 = moduleError "index" ("negative index: " ++ show i)
index (LPS ps) i         = index' ps i
  where index' []     n = moduleError "index" ("index too large: " ++ show n)
        index' (x:xs) n
          | n >= fromIntegral (P.length x) = 
              index' xs (n - fromIntegral (P.length x))
          | otherwise       = P.unsafeIndex x (fromIntegral n)

-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element. 
-- This implementation uses memchr(3).
elemIndex :: Word8 -> ByteString -> Maybe Int64
elemIndex c (LPS ps) = elemIndex' 0 ps
  where elemIndex' _ []     = Nothing
        elemIndex' n (x:xs) =
          case P.elemIndex c x of
            Nothing -> elemIndex' (n + fromIntegral (P.length x)) xs
            Just i  -> Just (n + fromIntegral i)

{-
-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element. The following
-- holds:
--
-- > elemIndexEnd c xs == 
-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--
elemIndexEnd :: Word8 -> ByteString -> Maybe Int
elemIndexEnd ch (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
    go (p `plusPtr` s) (l-1)
  where
    STRICT2(go)
    go p i | i < 0     = return Nothing
           | otherwise = do ch' <- peekByteOff p i
                            if ch == ch'
                                then return $ Just i
                                else go p (i-1)
-}
-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- the indices of all elements equal to the query element, in ascending order.
-- This implementation uses memchr(3).
elemIndices :: Word8 -> ByteString -> [Int64]
elemIndices c (LPS ps) = elemIndices' 0 ps
  where elemIndices' _ []     = []
        elemIndices' n (x:xs) = L.map ((+n).fromIntegral) (P.elemIndices c x)
                             ++ elemIndices' (n + fromIntegral (P.length x)) xs

-- | count returns the number of times its argument appears in the ByteString
--
-- > count = length . elemIndices
--
-- But more efficiently than using length on the intermediate list.
count :: Word8 -> ByteString -> Int64
count w (LPS xs) = L.foldl' (\n ps -> n + fromIntegral (P.count w ps)) 0 xs

-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- returns the index of the first element in the ByteString
-- satisfying the predicate.
findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int64
findIndex k (LPS ps) = findIndex' 0 ps
  where findIndex' _ []     = Nothing
        findIndex' n (x:xs) =
          case P.findIndex k x of
            Nothing -> findIndex' (n + fromIntegral (P.length x)) xs
            Just i  -> Just (n + fromIntegral i)
{-# INLINE findIndex #-}

-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.
--
-- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
--
find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
find f (LPS ps) = find' ps
  where find' []     = Nothing
        find' (x:xs) = case P.find f x of
            Nothing -> find' xs
            Just w  -> Just w
{-# INLINE find #-}

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices :: (Word8 -> Bool) -> ByteString -> [Int64]
findIndices k (LPS ps) = findIndices' 0 ps
  where findIndices' _ []     = []
        findIndices' n (x:xs) = L.map ((+n).fromIntegral) (P.findIndices k x)
                             ++ findIndices' (n + fromIntegral (P.length x)) xs

-- ---------------------------------------------------------------------
-- Searching ByteStrings

-- | /O(n)/ 'elem' is the 'ByteString' membership predicate.
elem :: Word8 -> ByteString -> Bool
elem c ps = case elemIndex c ps of Nothing -> False ; _ -> True

-- | /O(n)/ 'notElem' is the inverse of 'elem'
notElem :: Word8 -> ByteString -> Bool
notElem c ps = not (elem c ps)

-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
-- returns a ByteString containing those characters that satisfy the
-- predicate.
filter :: (Word8 -> Bool) -> ByteString -> ByteString
--filter f (LPS xs) = LPS (filterMap (P.filter' f) xs)
filter p = LPS . P.loopArr . loopL (P.filterEFL p) P.NoAcc . unLPS
{-# INLINE filter #-}

{-
-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
-- (==)/, for the common case of filtering a single byte. It is more
-- efficient to use /filterByte/ in this case.
--
-- > filterByte == filter . (==)
--
-- filterByte is around 10x faster, and uses much less space, than its
-- filter equivalent
filterByte :: Word8 -> ByteString -> ByteString
filterByte w ps = replicate (count w ps) w
-- filterByte w (LPS xs) = LPS (filterMap (P.filterByte w) xs)

-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
-- case of filtering a single byte out of a list. It is more efficient
-- to use /filterNotByte/ in this case.
--
-- > filterNotByte == filter . (/=)
--
-- filterNotByte is around 2x faster than its filter equivalent.
filterNotByte :: Word8 -> ByteString -> ByteString
filterNotByte w (LPS xs) = LPS (filterMap (P.filterNotByte w) xs)
-}

-- ---------------------------------------------------------------------
-- Searching for substrings

-- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True'
-- iff the first is a prefix of the second.
isPrefixOf :: ByteString -> ByteString -> Bool
isPrefixOf (LPS as) (LPS bs) = isPrefixL as bs
  where isPrefixL [] _  = True
        isPrefixL _ []  = False
        isPrefixL (x:xs) (y:ys) | P.length x == P.length y = x == y  && isPrefixL xs ys
                                | P.length x <  P.length y = x == yh && isPrefixL xs (yt:ys)
                                | otherwise                = xh == y && isPrefixL (xt:xs) ys
          where (xh,xt) = P.splitAt (P.length y) x
                (yh,yt) = P.splitAt (P.length x) y

-- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'
-- iff the first is a suffix of the second.
-- 
-- The following holds:
--
-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
--
-- However, the real implemenation uses memcmp to compare the end of the
-- string only, with no reverse required..
--
--isSuffixOf :: ByteString -> ByteString -> Bool
--isSuffixOf = error "not yet implemented"

-- ---------------------------------------------------------------------
-- Zipping

-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- corresponding pairs of bytes. If one input ByteString is short,
-- excess elements of the longer ByteString are discarded. This is
-- equivalent to a pair of 'unpack' operations.
zip :: ByteString -> ByteString -> [(Word8,Word8)]
zip = zipWith (,)

-- | 'zipWith' generalises 'zip' by zipping with the function given as
-- the first argument, instead of a tupling function.  For example,
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of
-- corresponding sums.
zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
zipWith _ (LPS [])     (LPS _)  = []
zipWith _ (LPS _)      (LPS []) = []
zipWith f (LPS (a:as)) (LPS (b:bs)) = zipWith' a as b bs
  where zipWith' x xs y ys =
          (f (P.unsafeHead x) (P.unsafeHead y) : zipWith'' (P.unsafeTail x) xs (P.unsafeTail y) ys)

        zipWith'' x []      _ _       | P.null x       = []
        zipWith'' _ _       y []      | P.null y       = []
        zipWith'' x xs      y ys      | not (P.null x)
                                     && not (P.null y) = zipWith' x  xs y  ys
        zipWith'' x xs      _ (y':ys) | not (P.null x) = zipWith' x  xs y' ys
        zipWith'' _ (x':xs) y ys      | not (P.null y) = zipWith' x' xs y  ys
        zipWith'' _ (x':xs) _ (y':ys)                  = zipWith' x' xs y' ys

-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
-- ByteStrings. Note that this performs two 'pack' operations.
{-
unzip :: [(Word8,Word8)] -> (ByteString,ByteString)
unzip _ls = error "not yet implemented"
{-# INLINE unzip #-}
-}

-- ---------------------------------------------------------------------
-- Special lists

-- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.
inits :: ByteString -> [ByteString]
inits = (LPS [] :) . inits' . unLPS
  where inits' []     = []
        inits' (x:xs) = L.map (\x' -> LPS [x']) (L.tail (P.inits x))
                     ++ L.map (\(LPS xs') -> LPS (x:xs')) (inits' xs)

-- | /O(n)/ Return all final segments of the given 'ByteString', longest first.
tails :: ByteString -> [ByteString]
tails = tails' . unLPS
  where tails' []           = LPS [] : []
        tails' xs@(x:xs')
          | P.length x == 1 = LPS xs : tails' xs'
          | otherwise       = LPS xs : tails' (P.unsafeTail x : xs')

-- ---------------------------------------------------------------------
-- Low level constructors

-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
--   This is mainly useful to allow the rest of the data pointed
--   to by the 'ByteString' to be garbage collected, for example
--   if a large string has been read in, and only a small part of it
--   is needed in the rest of the program.
copy :: ByteString -> ByteString
copy (LPS lps) = LPS (L.map P.copy lps)
--TODO, we could coalese small blocks here
--FIXME: probably not strict enough, if we're doing this to avoid retaining
-- the parent blocks then we'd better copy strictly.

-- ---------------------------------------------------------------------

-- TODO defrag func that concatenates block together that are below a threshold
-- defrag :: Int -> ByteString -> ByteString

-- ---------------------------------------------------------------------
-- Lazy ByteString IO

-- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
-- are read on demand, in at most @k@-sized chunks. It does not block
-- waiting for a whole @k@-sized chunk, so if less than @k@ bytes are
-- available then they will be returned immediately as a smaller chunk.
hGetContentsN :: Int -> Handle -> IO ByteString
hGetContentsN k h = lazyRead >>= return . LPS
  where
    lazyRead = unsafeInterleaveIO loop

    loop = do
        ps <- P.hGetNonBlocking h k
        --TODO: I think this should distinguish EOF from no data available
        -- the otherlying POSIX call makes this distincion, returning either
        -- 0 or EAGAIN
        if P.null ps
          then do eof <- hIsEOF h
                  if eof then return []
                         else hWaitForInput h (-1)
                           >> loop
          else do pss <- lazyRead
                  return (ps : pss)

-- | Read @n@ bytes into a 'ByteString', directly from the
-- specified 'Handle', in chunks of size @k@.
hGetN :: Int -> Handle -> Int -> IO ByteString
hGetN _ _ 0 = return empty
hGetN k h n = readChunks n >>= return . LPS
  where
    readChunks a | a `seq` False = undefined
    readChunks i = do
        ps <- P.hGet h (min k i)
        case P.length ps of
            0 -> return []
            m -> do pss <- readChunks (i - m)
                    return (ps : pss)

-- | hGetNonBlockingN is similar to 'hGetContentsN', except that it will never block
-- waiting for data to become available, instead it returns only whatever data
-- is available. Chunks are read on demand, in @k@-sized chunks.
hGetNonBlockingN :: Int -> Handle -> Int -> IO ByteString












hGetNonBlockingN = hGetN


-- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
-- are read on demand, using the default chunk size.
hGetContents :: Handle -> IO ByteString
hGetContents = hGetContentsN defaultChunkSize

-- | Read @n@ bytes into a 'ByteString', directly from the specified 'Handle'.
hGet :: Handle -> Int -> IO ByteString
hGet = hGetN defaultChunkSize

-- | hGetNonBlocking is similar to 'hGet', except that it will never block
-- waiting for data to become available, instead it returns only whatever data
-- is available.




hGetNonBlocking = hGet


-- | Read an entire file /lazily/ into a 'ByteString'.
readFile :: FilePath -> IO ByteString
readFile f = openBinaryFile f ReadMode >>= hGetContents

-- | Write a 'ByteString' to a file.
writeFile :: FilePath -> ByteString -> IO ()
writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
    (\hdl -> hPut hdl txt)

-- | Append a 'ByteString' to a file.
appendFile :: FilePath -> ByteString -> IO ()
appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
    (\hdl -> hPut hdl txt)

-- | getContents. Equivalent to hGetContents stdin. Will read /lazily/
getContents :: IO ByteString
getContents = hGetContents stdin

-- | Outputs a 'ByteString' to the specified 'Handle'.
hPut :: Handle -> ByteString -> IO ()
hPut h (LPS xs) = mapM_ (P.hPut h) xs

-- | Write a ByteString to stdout
putStr :: ByteString -> IO ()
putStr = hPut stdout

-- | Write a ByteString to stdout, appending a newline byte
putStrLn :: ByteString -> IO ()
putStrLn ps = hPut stdout ps >> hPut stdout (singleton 0x0a)

-- | The interact function takes a function of type @ByteString -> ByteString@
-- as its argument. The entire input from the standard input device is passed
-- to this function as its argument, and the resulting string is output on the
-- standard output device. It's great for writing one line programs!
interact :: (ByteString -> ByteString) -> IO ()
interact transformer = putStr . transformer =<< getContents

-- ---------------------------------------------------------------------
-- Internal utilities

-- Common up near identical calls to `error' to reduce the number
-- constant strings created when compiled:
errorEmptyList :: String -> a
errorEmptyList fun = moduleError fun "empty ByteString"

moduleError :: String -> String -> a
moduleError fun msg = error ("Data.ByteString.Lazy." ++ fun ++ ':':' ':msg)

-- A manually fused version of "filter (not.null) . map f", since they
-- don't seem to fuse themselves. Really helps out filter*, concatMap.
--
-- TODO fuse.
--
filterMap :: (P.ByteString -> P.ByteString) -> [P.ByteString] -> [P.ByteString]
filterMap _ []     = []
filterMap f (x:xs) = case f x of
                    y | P.null y  ->     filterMap f xs      -- manually fuse the invariant filter
                      | otherwise -> y : filterMap f xs
{-# INLINE filterMap #-}


-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length
-- of the string if no element is found, rather than Nothing.
findIndexOrEnd :: (Word8 -> Bool) -> P.ByteString -> Int
findIndexOrEnd k (P.PS x s l) = P.inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
  where
    go a b | a `seq` b `seq` False = undefined
    go ptr n | n >= l    = return l
             | otherwise = do w <- peek ptr
                              if k w
                                then return n
                                else go (ptr `plusPtr` 1) (n+1)
{-# INLINE findIndexOrEnd #-}
{-# OPTIONS_GHC -cpp -fno-warn-orphans #-}
--
-- Module      : Data.ByteString.Lazy.Char8
-- Copyright   : (c) Don Stewart 2006
-- License     : BSD-style
--
-- Maintainer  : dons@cse.unsw.edu.au
-- Stability   : experimental
-- Portability : portable (tested with GHC>=6.4.1 and Hugs 2005)
-- 

--
-- | Manipulate /lazy/ 'ByteString's using 'Char' operations. All Chars will
-- be truncated to 8 bits. It can be expected that these functions will
-- run at identical speeds to their Word8 equivalents in
-- "Data.ByteString.Lazy".
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.
--
-- > import qualified Data.ByteString.Lazy.Char8 as C
--

module Data.ByteString.Lazy.Char8 (

        -- * The @ByteString@ type
        ByteString,            -- instances: Eq, Ord, Show, Read, Data, Typeable

        -- * Introducing and eliminating 'ByteString's
        empty,                  -- :: ByteString
        singleton,               -- :: Char   -> ByteString
        pack,                   -- :: String -> ByteString
        unpack,                 -- :: ByteString -> String
        fromChunks,             -- :: [Strict.ByteString] -> ByteString
        toChunks,               -- :: ByteString -> [Strict.ByteString]

        -- * Basic interface
        cons,                   -- :: Char -> ByteString -> ByteString
        snoc,                   -- :: ByteString -> Char -> ByteString
        append,                 -- :: ByteString -> ByteString -> ByteString
        head,                   -- :: ByteString -> Char
        last,                   -- :: ByteString -> Char
        tail,                   -- :: ByteString -> ByteString
        init,                   -- :: ByteString -> ByteString
        null,                   -- :: ByteString -> Bool
        length,                 -- :: ByteString -> Int64

        -- * Transformating ByteStrings
        map,                    -- :: (Char -> Char) -> ByteString -> ByteString
        reverse,                -- :: ByteString -> ByteString
--      intersperse,            -- :: Char -> ByteString -> ByteString
        transpose,              -- :: [ByteString] -> [ByteString]

        -- * Reducing 'ByteString's (folds)
        foldl,                  -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl',                 -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl1,                 -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldl1',                -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldr,                  -- :: (Char -> a -> a) -> a -> ByteString -> a
        foldr1,                 -- :: (Char -> Char -> Char) -> ByteString -> Char

        -- ** Special folds
        concat,                 -- :: [ByteString] -> ByteString
        concatMap,              -- :: (Char -> ByteString) -> ByteString -> ByteString
        any,                    -- :: (Char -> Bool) -> ByteString -> Bool
        all,                    -- :: (Char -> Bool) -> ByteString -> Bool
        maximum,                -- :: ByteString -> Char
        minimum,                -- :: ByteString -> Char

        -- * Building ByteStrings
        -- ** Scans
        scanl,                  -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
--      scanl1,                 -- :: (Char -> Char -> Char) -> ByteString -> ByteString
--      scanr,                  -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
--      scanr1,                 -- :: (Char -> Char -> Char) -> ByteString -> ByteString

        -- ** Accumulating maps
        mapAccumL,   -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
        mapIndexed,  -- :: (Int64 -> Char -> Char) -> ByteString -> ByteString

        -- ** Infinite ByteStrings
        repeat,                 -- :: Char -> ByteString
        replicate,              -- :: Int64 -> Char -> ByteString
        cycle,                  -- :: ByteString -> ByteString
        iterate,                -- :: (Char -> Char) -> Char -> ByteString

        -- ** Unfolding
        unfoldr,                -- :: (a -> Maybe (Char, a)) -> a -> ByteString

        -- * Substrings

        -- ** Breaking strings
        take,                   -- :: Int64 -> ByteString -> ByteString
        drop,                   -- :: Int64 -> ByteString -> ByteString
        splitAt,                -- :: Int64 -> ByteString -> (ByteString, ByteString)
        takeWhile,              -- :: (Char -> Bool) -> ByteString -> ByteString
        dropWhile,              -- :: (Char -> Bool) -> ByteString -> ByteString
        span,                   -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        break,                  -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        group,                  -- :: ByteString -> [ByteString]
        groupBy,                -- :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
        inits,                  -- :: ByteString -> [ByteString]
        tails,                  -- :: ByteString -> [ByteString]

        -- ** Breaking into many substrings
        split,                  -- :: Char -> ByteString -> [ByteString]
        splitWith,              -- :: (Char -> Bool) -> ByteString -> [ByteString]

        -- ** Breaking into lines and words
        lines,                  -- :: ByteString -> [ByteString]
        words,                  -- :: ByteString -> [ByteString]
        unlines,                -- :: [ByteString] -> ByteString
        unwords,                -- :: ByteString -> [ByteString]

        -- ** Joining strings
        join,                   -- :: ByteString -> [ByteString] -> ByteString

        -- * Predicates
        isPrefixOf,             -- :: ByteString -> ByteString -> Bool
--      isSuffixOf,             -- :: ByteString -> ByteString -> Bool

        -- * Searching ByteStrings

        -- ** Searching by equality
        elem,                   -- :: Char -> ByteString -> Bool
        notElem,                -- :: Char -> ByteString -> Bool

        -- ** Searching with a predicate
        find,                   -- :: (Char -> Bool) -> ByteString -> Maybe Char
        filter,                 -- :: (Char -> Bool) -> ByteString -> ByteString
--      partition               -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)

        -- * Indexing ByteStrings
        index,                  -- :: ByteString -> Int64 -> Char
        elemIndex,              -- :: Char -> ByteString -> Maybe Int64
        elemIndices,            -- :: Char -> ByteString -> [Int64]
        findIndex,              -- :: (Char -> Bool) -> ByteString -> Maybe Int64
        findIndices,            -- :: (Char -> Bool) -> ByteString -> [Int64]
        count,                  -- :: Char -> ByteString -> Int64

        -- * Zipping and unzipping ByteStrings
        zip,                    -- :: ByteString -> ByteString -> [(Char,Char)]
        zipWith,                -- :: (Char -> Char -> c) -> ByteString -> ByteString -> [c]
--      unzip,                  -- :: [(Char,Char)] -> (ByteString,ByteString)

        -- * Ordered ByteStrings
--        sort,                   -- :: ByteString -> ByteString

        copy,                   -- :: ByteString -> ByteString

        -- * Reading from ByteStrings
        readInt,
        readInteger,

        -- * I\/O with 'ByteString's

        -- ** Standard input and output
        getContents,            -- :: IO ByteString
        putStr,                 -- :: ByteString -> IO ()
        putStrLn,               -- :: ByteString -> IO ()
        interact,               -- :: (ByteString -> ByteString) -> IO ()

        -- ** Files
        readFile,               -- :: FilePath -> IO ByteString
        writeFile,              -- :: FilePath -> ByteString -> IO ()
        appendFile,             -- :: FilePath -> ByteString -> IO ()

        -- ** I\/O with Handles
        hGetContents,           -- :: Handle -> IO ByteString
        hGet,                   -- :: Handle -> Int64 -> IO ByteString
        hPut,                   -- :: Handle -> ByteString -> IO ()
        hGetNonBlocking,        -- :: Handle -> IO ByteString

--      hGetN,                  -- :: Int -> Handle -> Int64 -> IO ByteString
--      hGetContentsN,          -- :: Int -> Handle -> IO ByteString
--      hGetNonBlockingN,       -- :: Int -> Handle -> IO ByteString
  ) where

-- Functions transparently exported
import Data.ByteString.Lazy 
        (ByteString, fromChunks, toChunks
        ,empty,null,length,tail,init,append,reverse,transpose
        ,concat,take,drop,splitAt,join,isPrefixOf,group,inits,tails,copy
        ,hGetContents, hGet, hPut, getContents
        ,hGetNonBlocking
        ,putStr, putStrLn, interact)

-- Functions we need to wrap.
import qualified Data.ByteString.Lazy as L
import qualified Data.ByteString as B
import qualified Data.ByteString.Base as B
import Data.ByteString.Base (LazyByteString(LPS))

import Data.ByteString.Base (w2c, c2w, isSpaceWord8)

import Data.Int (Int64)
import qualified Data.List as List (intersperse)

import qualified Prelude as P
import Prelude hiding           
        (reverse,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
        ,concat,any,take,drop,splitAt,takeWhile,dropWhile,span,break,elem,filter
        ,unwords,words,maximum,minimum,all,concatMap,scanl,scanl1,foldl1,foldr1
        ,readFile,writeFile,appendFile,replicate,getContents,getLine,putStr,putStrLn
        ,zip,zipWith,unzip,notElem,repeat,iterate,interact)

import System.IO            (hClose,openFile,IOMode(..))
import Control.Exception    (bracket)







------------------------------------------------------------------------

-- | /O(1)/ Convert a 'Char' into a 'ByteString'
singleton :: Char -> ByteString
singleton = L.singleton . c2w
{-# INLINE singleton #-}

-- | /O(n)/ Convert a 'String' into a 'ByteString'. 
pack :: [Char] -> ByteString
pack = L.pack. P.map c2w

-- | /O(n)/ Converts a 'ByteString' to a 'String'.
unpack :: ByteString -> [Char]
unpack = P.map w2c . L.unpack
{-# INLINE unpack #-}

-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
-- complexity, as it requires a memcpy.
cons :: Char -> ByteString -> ByteString
cons = L.cons . c2w
{-# INLINE cons #-}

-- | /O(n)/ Append a Char to the end of a 'ByteString'. Similar to
-- 'cons', this function performs a memcpy.
snoc :: ByteString -> Char -> ByteString
snoc p = L.snoc p . c2w
{-# INLINE snoc #-}

-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
head :: ByteString -> Char
head = w2c . L.head
{-# INLINE head #-}

-- | /O(1)/ Extract the last element of a packed string, which must be non-empty.
last :: ByteString -> Char
last = w2c . L.last
{-# INLINE last #-}

-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each element of @xs@
map :: (Char -> Char) -> ByteString -> ByteString
map f = L.map (c2w . f . w2c)
{-# INLINE map #-}

-- | 'foldl', applied to a binary operator, a starting value (typically
-- the left-identity of the operator), and a ByteString, reduces the
-- ByteString using the binary operator, from left to right.
foldl :: (a -> Char -> a) -> a -> ByteString -> a
foldl f = L.foldl (\a c -> f a (w2c c))
{-# INLINE foldl #-}

-- | 'foldl\'' is like foldl, but strict in the accumulator.
foldl' :: (a -> Char -> a) -> a -> ByteString -> a
foldl' f = L.foldl' (\a c -> f a (w2c c))
{-# INLINE foldl' #-}

-- | 'foldr', applied to a binary operator, a starting value
-- (typically the right-identity of the operator), and a packed string,
-- reduces the packed string using the binary operator, from right to left.
foldr :: (Char -> a -> a) -> a -> ByteString -> a
foldr f = L.foldr (\c a -> f (w2c c) a)
{-# INLINE foldr #-}

-- | 'foldl1' is a variant of 'foldl' that has no starting value
-- argument, and thus must be applied to non-empty 'ByteStrings'.
foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
foldl1 f ps = w2c (L.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldl1 #-}

-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
foldl1' f ps = w2c (L.foldl1' (\x y -> c2w (f (w2c x) (w2c y))) ps)

-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
-- and thus must be applied to non-empty 'ByteString's
foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
foldr1 f ps = w2c (L.foldr1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldr1 #-}

-- | Map a function over a 'ByteString' and concatenate the results
concatMap :: (Char -> ByteString) -> ByteString -> ByteString
concatMap f = L.concatMap (f . w2c)
{-# INLINE concatMap #-}

-- | Applied to a predicate and a ByteString, 'any' determines if
-- any element of the 'ByteString' satisfies the predicate.
any :: (Char -> Bool) -> ByteString -> Bool
any f = L.any (f . w2c)
{-# INLINE any #-}

-- | Applied to a predicate and a 'ByteString', 'all' determines if
-- all elements of the 'ByteString' satisfy the predicate.
all :: (Char -> Bool) -> ByteString -> Bool
all f = L.all (f . w2c)
{-# INLINE all #-}

-- | 'maximum' returns the maximum value from a 'ByteString'
maximum :: ByteString -> Char
maximum = w2c . L.maximum
{-# INLINE maximum #-}

-- | 'minimum' returns the minimum value from a 'ByteString'
minimum :: ByteString -> Char
minimum = w2c . L.minimum
{-# INLINE minimum #-}

-- ---------------------------------------------------------------------
-- Building ByteStrings

-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left. This function will fuse.
--
-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that
--
-- > last (scanl f z xs) == foldl f z xs.
scanl :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanl f z = L.scanl (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
mapAccumL f = L.mapAccumL (\a w -> case f a (w2c w) of (a',c) -> (a', c2w c))

-- | /O(n)/ map Char functions, provided with the index at each position
mapIndexed :: (Int -> Char -> Char) -> ByteString -> ByteString
mapIndexed f = L.mapIndexed (\i w -> c2w (f i (w2c w)))

------------------------------------------------------------------------
-- Generating and unfolding ByteStrings

-- | @'iterate' f x@ returns an infinite ByteString of repeated applications
-- of @f@ to @x@:
--
-- > iterate f x == [x, f x, f (f x), ...]
--
iterate :: (Char -> Char) -> Char -> ByteString
iterate f = L.iterate (c2w . f . w2c) . c2w

-- | @'repeat' x@ is an infinite ByteString, with @x@ the value of every
-- element.
--
repeat :: Char -> ByteString
repeat = L.repeat . c2w

-- | /O(n)/ @'replicate' n x@ is a ByteString of length @n@ with @x@
-- the value of every element.
--
replicate :: Int64 -> Char -> ByteString
replicate w c = L.replicate w (c2w c)

-- | /O(n)/ The 'unfoldr' function is analogous to the List \'unfoldr\'.
-- 'unfoldr' builds a ByteString from a seed value.  The function takes
-- the element and returns 'Nothing' if it is done producing the
-- ByteString or returns 'Just' @(a,b)@, in which case, @a@ is a
-- prepending to the ByteString and @b@ is used as the next element in a
-- recursive call.
unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
unfoldr f = L.unfoldr $ \a -> case f a of
                                    Nothing      -> Nothing
                                    Just (c, a') -> Just (c2w c, a')

------------------------------------------------------------------------

-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.
takeWhile :: (Char -> Bool) -> ByteString -> ByteString
takeWhile f = L.takeWhile (f . w2c)
{-# INLINE takeWhile #-}

-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
dropWhile :: (Char -> Bool) -> ByteString -> ByteString
dropWhile f = L.dropWhile (f . w2c)
{-# INLINE dropWhile #-}

-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
break f = L.break (f . w2c)
{-# INLINE break #-}

-- | 'span' @p xs@ breaks the ByteString into two segments. It is
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
span f = L.span (f . w2c)
{-# INLINE span #-}

{-
-- | 'breakChar' breaks its ByteString argument at the first occurence
-- of the specified Char. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
-- 
-- > break (=='c') "abcd" == breakChar 'c' "abcd"
--
breakChar :: Char -> ByteString -> (ByteString, ByteString)
breakChar = L.breakByte . c2w
{-# INLINE breakChar #-}

-- | 'spanChar' breaks its ByteString argument at the first
-- occurence of a Char other than its argument. It is more efficient
-- than 'span (==)'
--
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
--
spanChar :: Char -> ByteString -> (ByteString, ByteString)
spanChar = L.spanByte . c2w
{-# INLINE spanChar #-}
-}

--
-- TODO, more rules for breakChar*
--

-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.
--
-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split 'a'  "aXaXaXa"    == ["","X","X","X"]
-- > split 'x'  "x"          == ["",""]
-- 
-- and
--
-- > join [c] . split c == id
-- > split == splitWith . (==)
-- 
-- As for all splitting functions in this library, this function does
-- not copy the substrings, it just constructs new 'ByteStrings' that
-- are slices of the original.
--
split :: Char -> ByteString -> [ByteString]
split = L.split . c2w
{-# INLINE split #-}

-- | /O(n)/ Splits a 'ByteString' into components delimited by
-- separators, where the predicate returns True for a separator element.
-- The resulting components do not contain the separators.  Two adjacent
-- separators result in an empty component in the output.  eg.
--
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
--
splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
splitWith f = L.splitWith (f . w2c)
{-# INLINE splitWith #-}

-- | The 'groupBy' function is the non-overloaded version of 'group'.
groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
groupBy k = L.groupBy (\a b -> k (w2c a) (w2c b))

-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.
index :: ByteString -> Int64 -> Char
index = (w2c .) . L.index
{-# INLINE index #-}

-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element in the given 'ByteString' which is equal (by memchr) to the
-- query element, or 'Nothing' if there is no such element.
elemIndex :: Char -> ByteString -> Maybe Int64
elemIndex = L.elemIndex . c2w
{-# INLINE elemIndex #-}

-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- the indices of all elements equal to the query element, in ascending order.
elemIndices :: Char -> ByteString -> [Int64]
elemIndices = L.elemIndices . c2w
{-# INLINE elemIndices #-}

-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- returns the index of the first element in the ByteString satisfying the predicate.
findIndex :: (Char -> Bool) -> ByteString -> Maybe Int64
findIndex f = L.findIndex (f . w2c)
{-# INLINE findIndex #-}

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices :: (Char -> Bool) -> ByteString -> [Int64]
findIndices f = L.findIndices (f . w2c)

-- | count returns the number of times its argument appears in the ByteString
--
-- > count      == length . elemIndices
-- > count '\n' == length . lines
--
-- But more efficiently than using length on the intermediate list.
count :: Char -> ByteString -> Int64
count c = L.count (c2w c)

-- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This
-- implementation uses @memchr(3)@.
elem :: Char -> ByteString -> Bool
elem c = L.elem (c2w c)
{-# INLINE elem #-}

-- | /O(n)/ 'notElem' is the inverse of 'elem'
notElem :: Char -> ByteString -> Bool
notElem c = L.notElem (c2w c)
{-# INLINE notElem #-}

-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
-- returns a ByteString containing those characters that satisfy the
-- predicate.
filter :: (Char -> Bool) -> ByteString -> ByteString
filter f = L.filter (f . w2c)
{-# INLINE filter #-}

-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.
find :: (Char -> Bool) -> ByteString -> Maybe Char
find f ps = w2c `fmap` L.find (f . w2c) ps
{-# INLINE find #-}

{-
-- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
-- case of filtering a single Char. It is more efficient to use
-- filterChar in this case.
--
-- > filterChar == filter . (==)
--
-- filterChar is around 10x faster, and uses much less space, than its
-- filter equivalent
--
filterChar :: Char -> ByteString -> ByteString
filterChar c = L.filterByte (c2w c)
{-# INLINE filterChar #-}

-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
-- case of filtering a single Char out of a list. It is more efficient
-- to use /filterNotChar/ in this case.
--
-- > filterNotChar == filter . (/=)
--
-- filterNotChar is around 3x faster, and uses much less space, than its
-- filter equivalent
--
filterNotChar :: Char -> ByteString -> ByteString
filterNotChar c = L.filterNotByte (c2w c)
{-# INLINE filterNotChar #-}
-}

-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- corresponding pairs of Chars. If one input ByteString is short,
-- excess elements of the longer ByteString are discarded. This is
-- equivalent to a pair of 'unpack' operations, and so space
-- usage may be large for multi-megabyte ByteStrings
zip :: ByteString -> ByteString -> [(Char,Char)]
zip ps qs
    | L.null ps || L.null qs = []
    | otherwise = (head ps, head qs) : zip (L.tail ps) (L.tail qs)

-- | 'zipWith' generalises 'zip' by zipping with the function given as
-- the first argument, instead of a tupling function.  For example,
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list
-- of corresponding sums.
zipWith :: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
zipWith f = L.zipWith ((. w2c) . f . w2c)

-- | 'lines' breaks a ByteString up into a list of ByteStrings at
-- newline Chars. The resulting strings do not contain newlines.
--
lines :: ByteString -> [ByteString]
lines (LPS [])     = []
lines (LPS (x:xs)) = loop0 x xs
    where
    -- this is a really performance sensitive function but the
    -- chunked representation makes the general case a bit expensive
    -- however assuming a large chunk size and normalish line lengths
    -- we will find line endings much more frequently than chunk
    -- endings so it makes sense to optimise for that common case.
    -- So we partition into two special cases depending on whether we
    -- are keeping back a list of chunks that will eventually be output
    -- once we get to the end of the current line.

    -- the common special case where we have no existing chunks of
    -- the current line
    loop0 :: B.ByteString -> [B.ByteString] -> [ByteString]
    loop0 a b | a `seq` b `seq` False = undefined
    loop0 ps pss =
        case B.elemIndex (c2w '\n') ps of
            Nothing -> case pss of
                           []  | B.null ps ->            []
                               | otherwise -> LPS [ps] : []
                           (ps':pss')
                               | B.null ps -> loop0 ps'      pss'
                               | otherwise -> loop  ps' [ps] pss'

            Just n | n /= 0    -> LPS [B.unsafeTake n ps]
                                : loop0 (B.unsafeDrop (n+1) ps) pss
                   | otherwise -> loop0 (B.unsafeTail ps) pss

    -- the general case when we are building a list of chunks that are
    -- part of the same line
    loop :: B.ByteString -> [B.ByteString] -> [B.ByteString] -> [ByteString]
    loop a b c | a `seq` b `seq` c `seq` False = undefined
    loop ps line pss =
        case B.elemIndex (c2w '\n') ps of
            Nothing ->
                case pss of
                    [] -> let ps' | B.null ps = P.reverse line
                                  | otherwise = P.reverse (ps : line)
                           in ps' `seq` (LPS ps' : [])

                    (ps':pss')
                        | B.null ps -> loop ps'       line  pss'
                        | otherwise -> loop ps' (ps : line) pss'

            Just n ->
                let ps' | n == 0    = P.reverse line
                        | otherwise = P.reverse (B.unsafeTake n ps : line)
                 in ps' `seq` (LPS ps' : loop0 (B.unsafeDrop (n+1) ps) pss)

-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,
-- after appending a terminating newline to each.
unlines :: [ByteString] -> ByteString
unlines [] = empty
unlines ss = (concat $ List.intersperse nl ss) `append` nl -- half as much space
    where nl = singleton '\n'

-- | 'words' breaks a ByteString up into a list of words, which
-- were delimited by Chars representing white space. And
--
-- > tokens isSpace = words
--
words :: ByteString -> [ByteString]
words = P.filter (not . L.null) . L.splitWith isSpaceWord8
{-# INLINE words #-}

-- | The 'unwords' function is analogous to the 'unlines' function, on words.
unwords :: [ByteString] -> ByteString
unwords = join (singleton ' ')
{-# INLINE unwords #-}

-- | readInt reads an Int from the beginning of the ByteString.  If
-- there is no integer at the beginning of the string, it returns
-- Nothing, otherwise it just returns the int read, and the rest of the
-- string.
readInt :: ByteString -> Maybe (Int, ByteString)
readInt (LPS [])     = Nothing
readInt (LPS (x:xs)) =
        case w2c (B.unsafeHead x) of
            '-' -> loop True  0 0 (B.unsafeTail x) xs
            '+' -> loop False 0 0 (B.unsafeTail x) xs
            _   -> loop False 0 0 x xs

    where loop :: Bool -> Int -> Int -> B.ByteString -> [B.ByteString] -> Maybe (Int, ByteString)
          loop a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined
          loop neg i n ps pss
              | B.null ps = case pss of
                                []         -> end  neg i n ps  pss
                                (ps':pss') -> loop neg i n ps' pss'
              | otherwise =
                  case B.unsafeHead ps of
                    w | w >= 0x30
                     && w <= 0x39 -> loop neg (i+1)
                                          (n * 10 + (fromIntegral w - 0x30))
                                          (B.unsafeTail ps) pss
                      | otherwise -> end neg i n ps pss

          end _   0 _ _  _   = Nothing
          end neg _ n ps pss = let n'  | neg       = negate n
                                       | otherwise = n
                                   ps' | B.null ps =    pss
                                       | otherwise = ps:pss
                                in n' `seq` ps' `seq` Just $! (n', LPS ps')


-- | readInteger reads an Integer from the beginning of the ByteString.  If
-- there is no integer at the beginning of the string, it returns Nothing,
-- otherwise it just returns the int read, and the rest of the string.
readInteger :: ByteString -> Maybe (Integer, ByteString)
readInteger (LPS []) = Nothing
readInteger (LPS (x:xs)) =
        case w2c (B.unsafeHead x) of
            '-' -> first (B.unsafeTail x) xs >>= \(n, bs) -> return (-n, bs)
            '+' -> first (B.unsafeTail x) xs
            _   -> first x xs

    where first ps pss
              | B.null ps = case pss of
                  []         -> Nothing
                  (ps':pss') -> first' ps' pss'
              | otherwise = first' ps pss

          first' ps pss = case B.unsafeHead ps of
              w | w >= 0x30 && w <= 0x39 -> Just $
                  loop 1 (fromIntegral w - 0x30) [] (B.unsafeTail ps) pss
                | otherwise              -> Nothing

          loop :: Int -> Int -> [Integer]
               -> B.ByteString -> [B.ByteString] -> (Integer, ByteString)
          loop a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined
          loop d acc ns ps pss
              | B.null ps = case pss of
                                []         -> combine d acc ns ps pss
                                (ps':pss') -> loop d acc ns ps' pss'
              | otherwise =
                  case B.unsafeHead ps of
                   w | w >= 0x30 && w <= 0x39 ->
                       if d < 9 then loop (d+1)
                                          (10*acc + (fromIntegral w - 0x30))
                                          ns (B.unsafeTail ps) pss
                                else loop 1 (fromIntegral w - 0x30)
                                          (fromIntegral acc : ns)
                                          (B.unsafeTail ps) pss
                     | otherwise -> combine d acc ns ps pss

          combine _ acc [] ps pss = end (fromIntegral acc) ps pss
          combine d acc ns ps pss =
              end (10^d * combine1 1000000000 ns + fromIntegral acc) ps pss

          combine1 _ [n] = n
          combine1 b ns  = combine1 (b*b) $ combine2 b ns

          combine2 b (n:m:ns) = let t = n+m*b in t `seq` (t : combine2 b ns)
          combine2 _ ns       = ns

          end n ps pss = let ps' | B.null ps =    pss
                                 | otherwise = ps:pss
                          in ps' `seq` (n, LPS ps')

-- | Read an entire file /lazily/ into a 'ByteString'. Use 'text mode'
-- on Windows to interpret newlines
readFile :: FilePath -> IO ByteString
readFile f = openFile f ReadMode >>= hGetContents

-- | Write a 'ByteString' to a file.
writeFile :: FilePath -> ByteString -> IO ()
writeFile f txt = bracket (openFile f WriteMode) hClose
    (\hdl -> hPut hdl txt)

-- | Append a 'ByteString' to a file.
appendFile :: FilePath -> ByteString -> IO ()
appendFile f txt = bracket (openFile f AppendMode) hClose
    (\hdl -> hPut hdl txt)
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.STRef.Lazy
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable (uses Control.Monad.ST.Lazy)
--
-- Mutable references in the lazy ST monad.
--
-----------------------------------------------------------------------------
module Data.STRef.Lazy (
	-- * STRefs
	ST.STRef,	-- abstract, instance Eq
	newSTRef,	-- :: a -> ST s (STRef s a)
	readSTRef,	-- :: STRef s a -> ST s a
	writeSTRef,	-- :: STRef s a -> a -> ST s ()
	modifySTRef	-- :: STRef s a -> (a -> a) -> ST s ()
 ) where

import Control.Monad.ST.Lazy
import qualified Data.STRef as ST

newSTRef    :: a -> ST s (ST.STRef s a)
readSTRef   :: ST.STRef s a -> ST s a
writeSTRef  :: ST.STRef s a -> a -> ST s ()
modifySTRef :: ST.STRef s a -> (a -> a) -> ST s ()

newSTRef   = strictToLazyST . ST.newSTRef
readSTRef  = strictToLazyST . ST.readSTRef
writeSTRef r a = strictToLazyST (ST.writeSTRef r a)
modifySTRef r f = strictToLazyST (ST.modifySTRef r f)
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.STRef.Strict
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  non-portable (uses Control.Monad.ST.Strict)
--
-- Mutable references in the (strict) ST monad (re-export of "Data.STRef")
--
-----------------------------------------------------------------------------

module Data.STRef.Strict (
 	module Data.STRef
  ) where

import Prelude
import Data.STRef
-----------------------------------------------------------------------------
-- |
-- Module      :  Debug.Trace
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- The 'trace' function.
--
-----------------------------------------------------------------------------

module Debug.Trace (
	-- * Tracing
	putTraceMsg,      -- :: String -> IO ()
	trace             -- :: String -> a -> a
  ) where

import Prelude
import System.IO.Unsafe




import System.IO (hPutStrLn,stderr)


-- | 'putTraceMsg' function outputs the trace message from IO monad.
-- Usually the output stream is 'System.IO.stderr' but if the function is called
-- from Windows GUI application then the output will be directed to the Windows
-- debug console.
putTraceMsg :: String -> IO ()
putTraceMsg msg = do

    hPutStrLn stderr msg









{-# NOINLINE trace #-}
{-|
When called, 'trace' outputs the string in its first argument, before 
returning the second argument as its result. The 'trace' function is not 
referentially transparent, and should only be used for debugging, or for 
monitoring execution. Some implementations of 'trace' may decorate the string 
that\'s output to indicate that you\'re tracing. The function is implemented on
top of 'putTraceMsg'.
-}
trace :: String -> a -> a
trace string expr = unsafePerformIO $ do
    putTraceMsg string
    return expr

{-|
Like 'trace', but uses 'show' on the argument to convert it to a 'String'.

> traceShow = trace . show
-}
traceShow :: (Show a) => a -> b -> b
traceShow = trace . show
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Foreign.C
-- Copyright   :  (c) The FFI task force 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  ffi@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Bundles the C specific FFI library functionality
--
-----------------------------------------------------------------------------

module Foreign.C
        ( module Foreign.C.Types
	, module Foreign.C.String
	, module Foreign.C.Error
        ) where

import Foreign.C.Types
import Foreign.C.String
import Foreign.C.Error
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Foreign.ForeignPtr
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  ffi@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- The 'ForeignPtr' type and operations.  This module is part of the
-- Foreign Function Interface (FFI) and will usually be imported via
-- the "Foreign" module.
--
-----------------------------------------------------------------------------

module Foreign.ForeignPtr
        ( 
	-- * Finalised data pointers
	  ForeignPtr
	, FinalizerPtr

	, FinalizerEnvPtr

	-- ** Basic operations
        , newForeignPtr
        , newForeignPtr_
        , addForeignPtrFinalizer

	, newForeignPtrEnv
	, addForeignPtrFinalizerEnv

	, withForeignPtr





	-- ** Low-level operations
	, unsafeForeignPtrToPtr
	, touchForeignPtr
	, castForeignPtr

	-- ** Allocating managed memory
	, mallocForeignPtr
	, mallocForeignPtrBytes
	, mallocForeignPtrArray
	, mallocForeignPtrArray0
        ) 
	where

import Foreign.Ptr


















import Hugs.ForeignPtr



import Foreign.Storable	( Storable(sizeOf) )











import Foreign.Marshal.Alloc	( malloc, mallocBytes, finalizerFree )

instance Eq (ForeignPtr a) where 
    p == q  =  unsafeForeignPtrToPtr p == unsafeForeignPtrToPtr q

instance Ord (ForeignPtr a) where 
    compare p q  =  compare (unsafeForeignPtrToPtr p) (unsafeForeignPtrToPtr q)

instance Show (ForeignPtr a) where
    showsPrec p f = showsPrec p (unsafeForeignPtrToPtr f)




newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)
-- ^Turns a plain memory reference into a foreign pointer, and
-- associates a finaliser with the reference.  The finaliser will be executed
-- after the last reference to the foreign object is dropped.  Note that there
-- is no guarantee on how soon the finaliser is executed after the last
-- reference was dropped; this depends on the details of the Haskell storage
-- manager. The only guarantee is that the finaliser runs before the program
-- terminates.
newForeignPtr finalizer p
  = do fObj <- newForeignPtr_ p
       addForeignPtrFinalizer finalizer fObj
       return fObj

withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
-- ^This is a way to look at the pointer living inside a
-- foreign object.  This function takes a function which is
-- applied to that pointer. The resulting 'IO' action is then
-- executed. The foreign object is kept alive at least during
-- the whole action, even if it is not used directly
-- inside. Note that it is not safe to return the pointer from
-- the action and use it after the action completes. All uses
-- of the pointer should be inside the
-- 'withForeignPtr' bracket.  The reason for
-- this unsafeness is the same as for
-- 'unsafeForeignPtrToPtr' below: the finalizer
-- may run earlier than expected, because the compiler can only
-- track usage of the 'ForeignPtr' object, not
-- a 'Ptr' object made from it.
--
-- This function is normally used for marshalling data to
-- or from the object pointed to by the
-- 'ForeignPtr', using the operations from the
-- 'Storable' class.
withForeignPtr fo io
  = do r <- io (unsafeForeignPtrToPtr fo)
       touchForeignPtr fo
       return r



-- | This variant of 'newForeignPtr' adds a finalizer that expects an
-- environment in addition to the finalized pointer.  The environment
-- that will be passed to the finalizer is fixed by the second argument to
-- 'newForeignPtrEnv'.
newForeignPtrEnv ::
    FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)
newForeignPtrEnv finalizer env p
  = do fObj <- newForeignPtr_ p
       addForeignPtrFinalizerEnv finalizer env fObj
       return fObj





















mallocForeignPtr :: Storable a => IO (ForeignPtr a)
mallocForeignPtr = do
  r <- malloc
  newForeignPtr finalizerFree r

mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)
mallocForeignPtrBytes n = do
  r <- mallocBytes n
  newForeignPtr finalizerFree r


-- | This function is similar to 'Foreign.Marshal.Array.mallocArray',
-- but yields a memory area that has a finalizer attached that releases
-- the memory area.  As with 'mallocForeignPtr', it is not guaranteed that
-- the block of memory was allocated by 'Foreign.Marshal.Alloc.malloc'.
mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
mallocForeignPtrArray  = doMalloc undefined
  where
    doMalloc            :: Storable b => b -> Int -> IO (ForeignPtr b)
    doMalloc dummy size  = mallocForeignPtrBytes (size * sizeOf dummy)

-- | This function is similar to 'Foreign.Marshal.Array.mallocArray0',
-- but yields a memory area that has a finalizer attached that releases
-- the memory area.  As with 'mallocForeignPtr', it is not guaranteed that
-- the block of memory was allocated by 'Foreign.Marshal.Alloc.malloc'.
mallocForeignPtrArray0      :: Storable a => Int -> IO (ForeignPtr a)
mallocForeignPtrArray0 size  = mallocForeignPtrArray (size + 1)
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Foreign.Marshal
-- Copyright   :  (c) The FFI task force 2003
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  ffi@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Marshalling support
--
-----------------------------------------------------------------------------

module Foreign.Marshal
        ( module Foreign.Marshal.Alloc
        , module Foreign.Marshal.Array
        , module Foreign.Marshal.Error
        , module Foreign.Marshal.Pool
        , module Foreign.Marshal.Utils
        ) where

import Foreign.Marshal.Alloc
import Foreign.Marshal.Array
import Foreign.Marshal.Error
import Foreign.Marshal.Pool
import Foreign.Marshal.Utils
/* Machine generated file, do not modify */
#include <stdlib.h>
#include "HsFFI.h"
#include "HsBase.h"

static HugsAPI5 *hugs = 0;

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_from_intptr
#endif

static void hugsprim___hscore_from_intptr_3(HugsStackPtr);
static void hugsprim___hscore_from_intptr_3(HugsStackPtr hugs_root)
{
    HsInt64 arg1;
    HsPtr res1;
    arg1 = hugs->getInt64();
    res1 = __hscore_from_intptr(arg1);
    hugs->putPtr(res1);
    hugs->returnId(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_to_intptr
#endif

static void hugsprim___hscore_to_intptr_2(HugsStackPtr);
static void hugsprim___hscore_to_intptr_2(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt64 res1;
    arg1 = hugs->getPtr();
    res1 = __hscore_to_intptr(arg1);
    hugs->putInt64(res1);
    hugs->returnId(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_from_uintptr
#endif

static void hugsprim___hscore_from_uintptr_1(HugsStackPtr);
static void hugsprim___hscore_from_uintptr_1(HugsStackPtr hugs_root)
{
    HsWord64 arg1;
    HsPtr res1;
    arg1 = hugs->getWord64();
    res1 = __hscore_from_uintptr(arg1);
    hugs->putPtr(res1);
    hugs->returnId(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_to_uintptr
#endif

static void hugsprim___hscore_to_uintptr_0(HugsStackPtr);
static void hugsprim___hscore_to_uintptr_0(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord64 res1;
    arg1 = hugs->getPtr();
    res1 = __hscore_to_uintptr(arg1);
    hugs->putWord64(res1);
    hugs->returnId(hugs_root,1);
}

static struct hugs_primitive hugs_primTable[] = {
    {"intPtrToPtr", 1, hugsprim___hscore_from_intptr_3},
    {"ptrToIntPtr", 1, hugsprim___hscore_to_intptr_2},
    {"wordPtrToPtr", 1, hugsprim___hscore_from_uintptr_1},
    {"ptrToWordPtr", 1, hugsprim___hscore_to_uintptr_0},
};

static void hugs_primControl(int);
static void hugs_primControl(what)
int what; {
}

#ifdef STATIC_LINKAGE
#define initModule initFPtr
#endif

static struct hugs_primInfo hugs_prims = { hugs_primControl, hugs_primTable, 0 };

#ifdef __cplusplus
extern "C" {
#endif
#ifndef __cplusplus
DLLEXPORT(int)  HugsAPIVersion(void);
#endif
DLLEXPORT(int)  HugsAPIVersion() {return (5);}
DLLEXPORT(void) initModule(HugsAPI5 *);
DLLEXPORT(void) initModule(HugsAPI5 *hugsAPI) {
    hugs = hugsAPI;
    hugs->registerPrims(&hugs_prims);
}
#ifdef __cplusplus
}
#endif

{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Foreign.Ptr
-- Copyright   :  (c) The FFI task force 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  ffi@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- This module provides typed pointers to foreign data.  It is part
-- of the Foreign Function Interface (FFI) and will normally be
-- imported via the "Foreign" module.
--
-----------------------------------------------------------------------------

module Foreign.Ptr (

    -- * Data pointers
    
    Ptr,      -- data Ptr a
    nullPtr,      -- :: Ptr a
    castPtr,      -- :: Ptr a -> Ptr b
    plusPtr,      -- :: Ptr a -> Int -> Ptr b
    alignPtr,     -- :: Ptr a -> Int -> Ptr a
    minusPtr,     -- :: Ptr a -> Ptr b -> Int
    
    -- * Function pointers
    
    FunPtr,      -- data FunPtr a
    nullFunPtr,      -- :: FunPtr a
    castFunPtr,      -- :: FunPtr a -> FunPtr b
    castFunPtrToPtr, -- :: FunPtr a -> Ptr b
    castPtrToFunPtr, -- :: Ptr a -> FunPtr b
    
    freeHaskellFunPtr, -- :: FunPtr a -> IO ()
    -- Free the function pointer created by foreign export dynamic.


    -- * Integral types with lossless conversion to and from pointers
    IntPtr,
    ptrToIntPtr,
    intPtrToPtr,
    WordPtr,
    ptrToWordPtr,
    wordPtrToPtr

 ) where















import Foreign.C.Types


import Control.Monad	( liftM )
import Data.Bits
import Data.Typeable 	( Typeable(..), mkTyCon, mkTyConApp )
import Foreign.Storable ( Storable(..) )



















import Hugs.Ptr












                                                                              
                                                                             

                         


                          


                              


                                 


                        


                                


                          


                            


                         


                           


                           


                         


                          


                         


                                


                                


                              


                           


                                


                          


                        


                          


                          


                          


                         


                          


                             


                                


                         


                          


                               


                         


                          


                       


                           


                          


                         


                          


                          


                            


                             


                                


                            


                             


                               


                          


                           


                            


                           


                          


                          


                           


                          


                           


                          


                          


                          


                               


                          


                         


                          


                          


                           


                            


                           


                             


                            


                          


                         


                              


                         


                                


                         


                            


                                


                                 


                                


                          


                                   


                              


                          


                           


                           


                         


                                


                            


                             


                                   


                          


                         


                          


                          


                         


                             


                                


                           


                          


                               


                         


                            


                           


                           


                          


                           


                           


                          


                          


                          


                          


                           


                           


                           


                           


                           


                           


                           


                          


                           


                           


                           


                           


                           


                          


                           


                           


                             


                           


                           


                             


                           


                           


                           


                               


                               


                                                        


                                                                                     


                                                                                    
                             

                                                         


                                                        


                                                        


                                                  


                                                   


                                                       


                                                      
                          

                                                       


                                                          


                                                      


                                                           


                                                      


                                                         


                                                         


                                                         


                                                   


                                                         


                                                       


                                                       


                                                         


                                                         


                                                         


                                                          


                                                         


                                                          


                                                               


                                                             


                                                           


                                                              


                                                            


                                                             
                              

                                                            


                                                           


                                                            


                                                              


                                                           


                                                          


                                                   


                                                       


                                                                                                         


                                                                                         
                        

                                                         


                                                        


                                                   


                                                        
                         

                                                         


                                                          
                           

                                                          
                           

                                  


                                   


                                                     
                         

                                     


                                     


                                        


                                      


                                       


                                      


                                      


                                      


                                    


                                         


                                         


                                     


                                          


                                       


                                        


                                      


                                      


                                          


                                       


                                      


                                            


                                             


                                       


                                        


                                        


                                         


                                       


                                      


                                          


                                          


                                              


                                             


                                              


                                                   


                                               


                                        


                                       
                         

                                                                              


                                              


                                                          


                                                          


                                               


                                            


                                           


                                                      


                                                                           


                                                            
                           

                                                   




                                                                       
                              

                                                 
                         

                                                            
                  

                                                       
                  

                                                
                  


                                                                                                                                                                                                                                              




                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
























































                                                                                                                                                                                                                                        

                                                                


































































































































































































































newtype WordPtr = WordPtr CUIntPtr deriving (Eq, Ord) ; instance Num WordPtr where {    (WordPtr i) + (WordPtr j) = WordPtr (i + j) ;    (WordPtr i) - (WordPtr j) = WordPtr (i - j) ;    (WordPtr i) * (WordPtr j) = WordPtr (i * j) ;    negate  (WordPtr i) = WordPtr (negate i) ;    abs     (WordPtr i) = WordPtr (abs    i) ;    signum  (WordPtr i) = WordPtr (signum i) ;    fromInteger x = WordPtr (fromInteger x) } ; instance Real WordPtr where {    toRational (WordPtr i) = toRational i } ; instance Read WordPtr where {    readsPrec p s = map (\(x, t) -> (WordPtr x, t)) (readsPrec p s) } ; instance Show WordPtr where {    showsPrec p (WordPtr x) = showsPrec p x } ; instance Enum WordPtr where {    succ           (WordPtr i)             = WordPtr (succ i) ;    pred           (WordPtr i)             = WordPtr (pred i) ;    toEnum               x           = WordPtr (toEnum x) ;    fromEnum       (WordPtr i)             = fromEnum i ;    enumFrom       (WordPtr i)             = map WordPtr (enumFrom i) ;    enumFromThen   (WordPtr i) (WordPtr j)       = map WordPtr (enumFromThen i j) ;    enumFromTo     (WordPtr i) (WordPtr j)       = map WordPtr (enumFromTo i j) ;    enumFromThenTo (WordPtr i) (WordPtr j) (WordPtr k) = map WordPtr (enumFromThenTo i j k) } ; instance Storable WordPtr where {    sizeOf    (WordPtr x)       = sizeOf x ;    alignment (WordPtr x)       = alignment x ;    peekElemOff a i       = liftM WordPtr (peekElemOff (castPtr a) i) ;    pokeElemOff a i (WordPtr x) = pokeElemOff (castPtr a) i x } ; tyConWordPtr = mkTyCon "WordPtr"; instance Typeable WordPtr where { typeOf _ = mkTyConApp tyConWordPtr [] } ; ; instance Bounded WordPtr where {    minBound = WordPtr minBound ;    maxBound = WordPtr maxBound } ; instance Integral WordPtr where {    (WordPtr i) `quot`    (WordPtr j) = WordPtr (i `quot` j) ;    (WordPtr i) `rem`     (WordPtr j) = WordPtr (i `rem`  j) ;    (WordPtr i) `div`     (WordPtr j) = WordPtr (i `div`  j) ;    (WordPtr i) `mod`     (WordPtr j) = WordPtr (i `mod`  j) ;    (WordPtr i) `quotRem` (WordPtr j) = let (q,r) = i `quotRem` j in (WordPtr q, WordPtr r) ;    (WordPtr i) `divMod`  (WordPtr j) = let (d,m) = i `divMod`  j in (WordPtr d, WordPtr m) ;    toInteger (WordPtr i)       = toInteger i } ; instance Bits WordPtr where {   (WordPtr x) .&.     (WordPtr y)   = WordPtr (x .&.   y) ;   (WordPtr x) .|.     (WordPtr y)   = WordPtr (x .|.   y) ;   (WordPtr x) `xor`   (WordPtr y)   = WordPtr (x `xor` y) ;   complement    (WordPtr x)   = WordPtr (complement x) ;   shift         (WordPtr x) n = WordPtr (shift x n) ;   rotate        (WordPtr x) n = WordPtr (rotate x n) ;   bit                 n = WordPtr (bit n) ;   setBit        (WordPtr x) n = WordPtr (setBit x n) ;   clearBit      (WordPtr x) n = WordPtr (clearBit x n) ;   complementBit (WordPtr x) n = WordPtr (complementBit x n) ;   testBit       (WordPtr x) n = testBit x n ;   bitSize       (WordPtr x)   = bitSize x ;   isSigned      (WordPtr x)   = isSigned x }
newtype IntPtr = IntPtr CIntPtr deriving (Eq, Ord) ; instance Num IntPtr where {    (IntPtr i) + (IntPtr j) = IntPtr (i + j) ;    (IntPtr i) - (IntPtr j) = IntPtr (i - j) ;    (IntPtr i) * (IntPtr j) = IntPtr (i * j) ;    negate  (IntPtr i) = IntPtr (negate i) ;    abs     (IntPtr i) = IntPtr (abs    i) ;    signum  (IntPtr i) = IntPtr (signum i) ;    fromInteger x = IntPtr (fromInteger x) } ; instance Real IntPtr where {    toRational (IntPtr i) = toRational i } ; instance Read IntPtr where {    readsPrec p s = map (\(x, t) -> (IntPtr x, t)) (readsPrec p s) } ; instance Show IntPtr where {    showsPrec p (IntPtr x) = showsPrec p x } ; instance Enum IntPtr where {    succ           (IntPtr i)             = IntPtr (succ i) ;    pred           (IntPtr i)             = IntPtr (pred i) ;    toEnum               x           = IntPtr (toEnum x) ;    fromEnum       (IntPtr i)             = fromEnum i ;    enumFrom       (IntPtr i)             = map IntPtr (enumFrom i) ;    enumFromThen   (IntPtr i) (IntPtr j)       = map IntPtr (enumFromThen i j) ;    enumFromTo     (IntPtr i) (IntPtr j)       = map IntPtr (enumFromTo i j) ;    enumFromThenTo (IntPtr i) (IntPtr j) (IntPtr k) = map IntPtr (enumFromThenTo i j k) } ; instance Storable IntPtr where {    sizeOf    (IntPtr x)       = sizeOf x ;    alignment (IntPtr x)       = alignment x ;    peekElemOff a i       = liftM IntPtr (peekElemOff (castPtr a) i) ;    pokeElemOff a i (IntPtr x) = pokeElemOff (castPtr a) i x } ; tyConIntPtr = mkTyCon "IntPtr"; instance Typeable IntPtr where { typeOf _ = mkTyConApp tyConIntPtr [] } ; ; instance Bounded IntPtr where {    minBound = IntPtr minBound ;    maxBound = IntPtr maxBound } ; instance Integral IntPtr where {    (IntPtr i) `quot`    (IntPtr j) = IntPtr (i `quot` j) ;    (IntPtr i) `rem`     (IntPtr j) = IntPtr (i `rem`  j) ;    (IntPtr i) `div`     (IntPtr j) = IntPtr (i `div`  j) ;    (IntPtr i) `mod`     (IntPtr j) = IntPtr (i `mod`  j) ;    (IntPtr i) `quotRem` (IntPtr j) = let (q,r) = i `quotRem` j in (IntPtr q, IntPtr r) ;    (IntPtr i) `divMod`  (IntPtr j) = let (d,m) = i `divMod`  j in (IntPtr d, IntPtr m) ;    toInteger (IntPtr i)       = toInteger i } ; instance Bits IntPtr where {   (IntPtr x) .&.     (IntPtr y)   = IntPtr (x .&.   y) ;   (IntPtr x) .|.     (IntPtr y)   = IntPtr (x .|.   y) ;   (IntPtr x) `xor`   (IntPtr y)   = IntPtr (x `xor` y) ;   complement    (IntPtr x)   = IntPtr (complement x) ;   shift         (IntPtr x) n = IntPtr (shift x n) ;   rotate        (IntPtr x) n = IntPtr (rotate x n) ;   bit                 n = IntPtr (bit n) ;   setBit        (IntPtr x) n = IntPtr (setBit x n) ;   clearBit      (IntPtr x) n = IntPtr (clearBit x n) ;   complementBit (IntPtr x) n = IntPtr (complementBit x n) ;   testBit       (IntPtr x) n = testBit x n ;   bitSize       (IntPtr x)   = bitSize x ;   isSigned      (IntPtr x)   = isSigned x }

{-# CFILES cbits/PrelIOUtils.c #-}

foreign import ccall unsafe "__hscore_to_uintptr"
    ptrToWordPtr :: Ptr a -> WordPtr

foreign import ccall unsafe "__hscore_from_uintptr"
    wordPtrToPtr :: WordPtr -> Ptr a

foreign import ccall unsafe "__hscore_to_intptr"
    ptrToIntPtr :: Ptr a -> IntPtr

foreign import ccall unsafe "__hscore_from_intptr"
    intPtrToPtr :: IntPtr -> Ptr a



 asm    dylinkÄÅ¿` ` ` ``  ` |Õ
env
memoryBase env	tableBase envabort  envgetTempRet0 env___hscore_from_intptr env___hscore_from_uintptr env___hscore_to_intptr env___hscore_to_uintptr envmemory Äenvtablep 
      A A ‚	_HugsAPIVersion __post_instantiate _hugs_primControl  _hugsprim___hscore_from_intptr_3 	!_hugsprim___hscore_from_uintptr_1 _hugsprim___hscore_to_intptr_2 
_hugsprim___hscore_to_uintptr_0 _initModule runPostSets 	 #	

Ô
 A # AÄ¿j  6 #   (∞   F# AÄ¿j( (0 ! # AÄ¿j( (ê    A# AÄ¿j( (® K# AÄ¿j( (D " A HAtAu# AÄ¿j( (|   A# AÄ¿j( (® F# AÄ¿j( (@ ! # AÄ¿j( (ê    A# AÄ¿j( (® ? # AÄ¿j( (D A # AÄ¿j( (å   A# AÄ¿j( (® á # #Aj6 # # (# Ajj6# # (# A<jj6# #Aj6# # (# A» jj6# #Aj6 # # ($# A‘ jj6$# #Aj6,# # (0# A· jj60# #Aj68 # A j$#AÄÄ¿j$ A  D        s # m                                                        intPtrToPtr ptrToIntPtr wordPtrToPtr ptrToWordPtr{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Foreign.StablePtr
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  ffi@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- This module is part of the Foreign Function Interface (FFI) and will usually
-- be imported via the module "Foreign".
--
-----------------------------------------------------------------------------


module Foreign.StablePtr
        ( -- * Stable references to Haskell values
	  StablePtr          -- abstract
        , newStablePtr       -- :: a -> IO (StablePtr a)
        , deRefStablePtr     -- :: StablePtr a -> IO a
        , freeStablePtr      -- :: StablePtr a -> IO ()
        , castStablePtrToPtr -- :: StablePtr a -> Ptr ()
        , castPtrToStablePtr -- :: Ptr () -> StablePtr a
	, -- ** The C-side interface

	  -- $cinterface
        ) where







import Hugs.StablePtr













-- $cinterface
--
-- The following definition is available to C programs inter-operating with
-- Haskell code when including the header @HsFFI.h@.
--
-- > typedef void *HsStablePtr;  /* C representation of a StablePtr */
--
-- Note that no assumptions may be made about the values representing stable
-- pointers.  In fact, they need not even be valid memory addresses.  The only
-- guarantee provided is that if they are passed back to Haskell land, the
-- function 'deRefStablePtr' will be able to reconstruct the
-- Haskell value referred to by the stable pointer.
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Foreign.Storable
-- Copyright   :  (c) The FFI task force 2001
-- License     :  see libraries/base/LICENSE
-- 
-- Maintainer  :  ffi@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- The module "Foreign.Storable" provides most elementary support for
-- marshalling and is part of the language-independent portion of the
-- Foreign Function Interface (FFI), and will normally be imported via
-- the "Foreign" module.
--
-----------------------------------------------------------------------------

module Foreign.Storable
	( Storable(
	     sizeOf,         -- :: a -> Int
	     alignment,      -- :: a -> Int
	     peekElemOff,    -- :: Ptr a -> Int      -> IO a
	     pokeElemOff,    -- :: Ptr a -> Int -> a -> IO ()
	     peekByteOff,    -- :: Ptr b -> Int      -> IO a
	     pokeByteOff,    -- :: Ptr b -> Int -> a -> IO ()
	     peek,           -- :: Ptr a             -> IO a
	     poke)           -- :: Ptr a        -> a -> IO ()
        ) where







import Control.Monad		( liftM )

                                                                                                                                                                                                        

                                                                        
                                                                          

                               
                                                                                                            







                                                      












                                                         












                                


                                  


                                 


                               


                                


                                     


                                 


                                         


                                        


                                         


                                              


                                          


                                  


                                                           


                                                         


                                                         


                                                         


                                                         


                                                          


                                                         


                                                           


                                                            


                                                         


                                                                              


                                              


                                                          


                                                          


                                               


                                            


                                                


                                                  


                                                 


                                               


                                                


                                                     


                                                 


                                                         


                                                        


                                                         


                                                              


                                                          


                                                  


                                                      



















































                                                                              
                                                                             

                         


                          


                              


                                 


                        


                                


                          


                            


                         


                           


                           


                         


                          


                         


                                


                                


                              


                           


                                


                          


                        


                          


                          


                          


                         


                          


                             


                                


                         


                          


                               


                         


                          


                       


                           


                          


                         


                          


                          


                            


                             


                                


                            


                             


                               


                          


                           


                            


                           


                          


                          


                           


                          


                           


                          


                          


                          


                               


                          


                         


                          


                          


                           


                            


                           


                             


                            


                          


                         


                              


                         


                                


                         


                            


                                


                                 


                                


                          


                                   


                              


                          


                           


                           


                         


                                


                            


                             


                                   


                          


                         


                          


                          


                         


                             


                                


                           


                          


                               


                         


                            


                           


                           


                          


                           


                           


                          


                          


                          


                          


                           


                           


                           


                           


                           


                           


                           


                          


                           


                           


                           


                           


                           


                          


                           


                           


                             


                           


                           


                             


                           


                           


                           


                               


                               


                                                        


                                                                                     


                                                                                    
                             

                                                         


                                                        


                                                        


                                                  


                                                   


                                                       


                                                      
                          

                                                       


                                                          


                                                      


                                                           


                                                      


                                                         


                                                         


                                                         


                                                   


                                                         


                                                       


                                                       


                                                         


                                                         


                                                         


                                                          


                                                         


                                                          


                                                               


                                                             


                                                           


                                                              


                                                            


                                                             
                              

                                                            


                                                           


                                                            


                                                              


                                                           


                                                          


                                                   


                                                       


                                                                                                         


                                                                                         
                        

                                                         


                                                        


                                                   


                                                        
                         

                                                         


                                                          
                           

                                                          
                           

                                  


                                   


                                                     
                         

                                     


                                     


                                        


                                      


                                       


                                      


                                      


                                      


                                    


                                         


                                         


                                     


                                          


                                       


                                        


                                      


                                      


                                          


                                       


                                      


                                            


                                             


                                       


                                        


                                        


                                         


                                       


                                      


                                          


                                          


                                              


                                             


                                              


                                                   


                                               


                                        


                                       
                         

                                                                              


                                              


                                                          


                                                          


                                               


                                            


                                           


                                                      


                                                                           


                                                            
                           

                                                   




                                                                       
                              

                                                 
                         

                                                            
                  

                                                       
                  

                                                
                  
















import Data.Int
import Data.Word
import Foreign.StablePtr



import Hugs.Prelude
import Hugs.Ptr
import Hugs.Storable


{- |
The member functions of this class facilitate writing values of
primitive types to raw memory (which may have been allocated with the
above mentioned routines) and reading values from blocks of raw
memory.  The class, furthermore, includes support for computing the
storage requirements and alignment restrictions of storable types.

Memory addresses are represented as values of type @'Ptr' a@, for some
@a@ which is an instance of class 'Storable'.  The type argument to
'Ptr' helps provide some valuable type safety in FFI code (you can\'t
mix pointers of different types without an explicit cast), while
helping the Haskell type system figure out which marshalling method is
needed for a given pointer.

All marshalling between Haskell and a foreign language ultimately
boils down to translating Haskell data structures into the binary
representation of a corresponding data structure of the foreign
language and vice versa.  To code this marshalling in Haskell, it is
necessary to manipulate primitive data types stored in unstructured
memory blocks.  The class 'Storable' facilitates this manipulation on
all types for which it is instantiated, which are the standard basic
types of Haskell, the fixed size @Int@ types ('Int8', 'Int16',
'Int32', 'Int64'), the fixed size @Word@ types ('Word8', 'Word16',
'Word32', 'Word64'), 'StablePtr', all types from "Foreign.C.Types",
as well as 'Ptr'.

Minimal complete definition: 'sizeOf', 'alignment', one of 'peek',
'peekElemOff' and 'peekByteOff', and one of 'poke', 'pokeElemOff' and
'pokeByteOff'.
-}

class Storable a where

   sizeOf      :: a -> Int
   -- ^ Computes the storage requirements (in bytes) of the argument.
   -- The value of the argument is not used.

   alignment   :: a -> Int
   -- ^ Computes the alignment constraint of the argument.  An
   -- alignment constraint @x@ is fulfilled by any address divisible
   -- by @x@.  The value of the argument is not used.

   peekElemOff :: Ptr a -> Int      -> IO a
   -- ^       Read a value from a memory area regarded as an array
   --         of values of the same kind.  The first argument specifies
   --         the start address of the array and the second the index into
   --         the array (the first element of the array has index
   --         @0@).  The following equality holds,
   -- 
   -- > peekElemOff addr idx = IOExts.fixIO $ \result ->
   -- >   peek (addr `plusPtr` (idx * sizeOf result))
   --
   --         Note that this is only a specification, not
   --         necessarily the concrete implementation of the
   --         function.

   pokeElemOff :: Ptr a -> Int -> a -> IO ()
   -- ^       Write a value to a memory area regarded as an array of
   --         values of the same kind.  The following equality holds:
   -- 
   -- > pokeElemOff addr idx x = 
   -- >   poke (addr `plusPtr` (idx * sizeOf x)) x

   peekByteOff :: Ptr b -> Int      -> IO a
   -- ^       Read a value from a memory location given by a base
   --         address and offset.  The following equality holds:
   --
   -- > peekByteOff addr off = peek (addr `plusPtr` off)

   pokeByteOff :: Ptr b -> Int -> a -> IO ()
   -- ^       Write a value to a memory location given by a base
   --         address and offset.  The following equality holds:
   --
   -- > pokeByteOff addr off x = poke (addr `plusPtr` off) x
  
   peek        :: Ptr a      -> IO a
   -- ^ Read a value from the given memory location.
   --
   --  Note that the peek and poke functions might require properly
   --  aligned addresses to function correctly.  This is architecture
   --  dependent; thus, portable code should ensure that when peeking or
   --  poking values of some type @a@, the alignment
   --  constraint for @a@, as given by the function
   --  'alignment' is fulfilled.

   poke        :: Ptr a -> a -> IO ()
   -- ^ Write the given value to the given memory location.  Alignment
   -- restrictions might apply; see 'peek'.
 
   -- circular default instances





   peekElemOff ptr off = peekByteOff ptr (off * sizeOfPtr ptr undefined)

   pokeElemOff ptr off val = pokeByteOff ptr (off * sizeOf val) val

   peekByteOff ptr off = peek (ptr `plusPtr` off)
   pokeByteOff ptr off = poke (ptr `plusPtr` off)

   peek ptr = peekElemOff ptr 0
   poke ptr = pokeElemOff ptr 0


sizeOfPtr :: Storable a => Ptr a -> a -> Int
sizeOfPtr px x = sizeOf x


-- System-dependent, but rather obvious instances

instance Storable Bool where
   sizeOf _          = sizeOf (undefined::Int32)
   alignment _       = alignment (undefined::Int32)
   peekElemOff p i   = liftM (/= (0::Int32)) $ peekElemOff (castPtr p) i
   pokeElemOff p i x = pokeElemOff (castPtr p) i (if x then 1 else 0::Int32)












instance Storable (Char) where {			    sizeOf    _ = 4;				    alignment _ = 4;			    peekElemOff = readCharOffPtr;				    pokeElemOff = writeCharOffPtr }


instance Storable (Int) where {			    sizeOf    _ = 4;				    alignment _ = 4;			    peekElemOff = readIntOffPtr;				    pokeElemOff = writeIntOffPtr }


instance Storable (Word) where {			    sizeOf    _ = 4;				    alignment _ = 4;			    peekElemOff = readWordOffPtr;				    pokeElemOff = writeWordOffPtr }


instance Storable ((Ptr a)) where {			    sizeOf    _ = 8;				    alignment _ = 8;			    peekElemOff = readPtrOffPtr;				    pokeElemOff = writePtrOffPtr }

instance Storable ((FunPtr a)) where {			    sizeOf    _ = 8;				    alignment _ = 8;			    peekElemOff = readFunPtrOffPtr;				    pokeElemOff = writeFunPtrOffPtr }

instance Storable ((StablePtr a)) where {			    sizeOf    _ = 8;				    alignment _ = 8;			    peekElemOff = readStablePtrOffPtr;				    pokeElemOff = writeStablePtrOffPtr }

instance Storable (Float) where {			    sizeOf    _ = 4;				    alignment _ = 4;			    peekElemOff = readFloatOffPtr;				    pokeElemOff = writeFloatOffPtr }

instance Storable (Double) where {			    sizeOf    _ = 8;				    alignment _ = 8;			    peekElemOff = readDoubleOffPtr;				    pokeElemOff = writeDoubleOffPtr }

instance Storable (Word8) where {			    sizeOf    _ = 1;				    alignment _ = 1;			    peekElemOff = readWord8OffPtr;				    pokeElemOff = writeWord8OffPtr }

instance Storable (Word16) where {			    sizeOf    _ = 2;				    alignment _ = 2;			    peekElemOff = readWord16OffPtr;				    pokeElemOff = writeWord16OffPtr }

instance Storable (Word32) where {			    sizeOf    _ = 4;				    alignment _ = 4;			    peekElemOff = readWord32OffPtr;				    pokeElemOff = writeWord32OffPtr }

instance Storable (Word64) where {			    sizeOf    _ = 8;				    alignment _ = 8;			    peekElemOff = readWord64OffPtr;				    pokeElemOff = writeWord64OffPtr }

instance Storable (Int8) where {			    sizeOf    _ = 1;				    alignment _ = 1;			    peekElemOff = readInt8OffPtr;				    pokeElemOff = writeInt8OffPtr }

instance Storable (Int16) where {			    sizeOf    _ = 2;				    alignment _ = 2;			    peekElemOff = readInt16OffPtr;				    pokeElemOff = writeInt16OffPtr }

instance Storable (Int32) where {			    sizeOf    _ = 4;				    alignment _ = 4;			    peekElemOff = readInt32OffPtr;				    pokeElemOff = writeInt32OffPtr }

instance Storable (Int64) where {			    sizeOf    _ = 8;				    alignment _ = 8;			    peekElemOff = readInt64OffPtr;				    pokeElemOff = writeInt64OffPtr }


/* Machine generated file, do not modify */
#include <stdlib.h>
#include "HsFFI.h"
#include "HsBase.h"

static HugsAPI5 *hugs = 0;
#include "string.h"

#ifndef ENABLE_MACRO_INTERFACE
#undef strerror
#endif

static void hugsprim_strerror_2(HugsStackPtr);
static void hugsprim_strerror_2(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsPtr res1;
    arg1 = hugs->getInt32();
    res1 = strerror(arg1);
    hugs->putPtr(res1);
    hugs->returnIO(hugs_root,1);
}
#include "HsBase.h"

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_set_errno
#endif

static void hugsprim___hscore_set_errno_1(HugsStackPtr);
static void hugsprim___hscore_set_errno_1(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    arg1 = hugs->getInt32();
    __hscore_set_errno(arg1);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_get_errno
#endif

static void hugsprim___hscore_get_errno_0(HugsStackPtr);
static void hugsprim___hscore_get_errno_0(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_get_errno();
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

static struct hugs_primitive hugs_primTable[] = {
    {"strerror", 2, hugsprim_strerror_2},
    {"set_errno", 2, hugsprim___hscore_set_errno_1},
    {"get_errno", 1, hugsprim___hscore_get_errno_0},
};

static void hugs_primControl(int);
static void hugs_primControl(what)
int what; {
}

#ifdef STATIC_LINKAGE
#define initModule initFCError
#endif

static struct hugs_primInfo hugs_prims = { hugs_primControl, hugs_primTable, 0 };

#ifdef __cplusplus
extern "C" {
#endif
#ifndef __cplusplus
DLLEXPORT(int)  HugsAPIVersion(void);
#endif
DLLEXPORT(int)  HugsAPIVersion() {return (5);}
DLLEXPORT(void) initModule(HugsAPI5 *);
DLLEXPORT(void) initModule(HugsAPI5 *hugsAPI) {
    hugs = hugsAPI;
    hugs->registerPrims(&hugs_prims);
}
#ifdef __cplusplus
}
#endif

{-# OPTIONS_GHC -fno-implicit-prelude -#include "HsBase.h" #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Foreign.C.Error
-- Copyright   :  (c) The FFI task force 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  ffi@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- C-specific Marshalling support: Handling of C \"errno\" error codes.
--
-----------------------------------------------------------------------------

module Foreign.C.Error (

  -- * Haskell representations of @errno@ values

  Errno(..),		-- instance: Eq

  -- ** Common @errno@ symbols
  -- | Different operating systems and\/or C libraries often support
  -- different values of @errno@.  This module defines the common values,
  -- but due to the open definition of 'Errno' users may add definitions
  -- which are not predefined.
  eOK, e2BIG, eACCES, eADDRINUSE, eADDRNOTAVAIL, eADV, eAFNOSUPPORT, eAGAIN, 
  eALREADY, eBADF, eBADMSG, eBADRPC, eBUSY, eCHILD, eCOMM, eCONNABORTED, 
  eCONNREFUSED, eCONNRESET, eDEADLK, eDESTADDRREQ, eDIRTY, eDOM, eDQUOT, 
  eEXIST, eFAULT, eFBIG, eFTYPE, eHOSTDOWN, eHOSTUNREACH, eIDRM, eILSEQ, 
  eINPROGRESS, eINTR, eINVAL, eIO, eISCONN, eISDIR, eLOOP, eMFILE, eMLINK, 
  eMSGSIZE, eMULTIHOP, eNAMETOOLONG, eNETDOWN, eNETRESET, eNETUNREACH, 
  eNFILE, eNOBUFS, eNODATA, eNODEV, eNOENT, eNOEXEC, eNOLCK, eNOLINK, 
  eNOMEM, eNOMSG, eNONET, eNOPROTOOPT, eNOSPC, eNOSR, eNOSTR, eNOSYS, 
  eNOTBLK, eNOTCONN, eNOTDIR, eNOTEMPTY, eNOTSOCK, eNOTTY, eNXIO, 
  eOPNOTSUPP, ePERM, ePFNOSUPPORT, ePIPE, ePROCLIM, ePROCUNAVAIL, 
  ePROGMISMATCH, ePROGUNAVAIL, ePROTO, ePROTONOSUPPORT, ePROTOTYPE, 
  eRANGE, eREMCHG, eREMOTE, eROFS, eRPCMISMATCH, eRREMOTE, eSHUTDOWN, 
  eSOCKTNOSUPPORT, eSPIPE, eSRCH, eSRMNT, eSTALE, eTIME, eTIMEDOUT, 
  eTOOMANYREFS, eTXTBSY, eUSERS, eWOULDBLOCK, eXDEV,

  -- ** 'Errno' functions
                        -- :: Errno
  isValidErrno,		-- :: Errno -> Bool

  -- access to the current thread's "errno" value
  --
  getErrno,             -- :: IO Errno
  resetErrno,           -- :: IO ()

  -- conversion of an "errno" value into IO error
  --
  errnoToIOError,       -- :: String       -- location
                        -- -> Errno        -- errno
                        -- -> Maybe Handle -- handle
                        -- -> Maybe String -- filename
                        -- -> IOError

  -- throw current "errno" value
  --
  throwErrno,           -- ::                String               -> IO a

  -- ** Guards for IO operations that may fail

  throwErrnoIf,         -- :: (a -> Bool) -> String -> IO a       -> IO a
  throwErrnoIf_,        -- :: (a -> Bool) -> String -> IO a       -> IO ()
  throwErrnoIfRetry,    -- :: (a -> Bool) -> String -> IO a       -> IO a
  throwErrnoIfRetry_,   -- :: (a -> Bool) -> String -> IO a       -> IO ()
  throwErrnoIfMinus1,   -- :: Num a 
			-- =>                String -> IO a       -> IO a
  throwErrnoIfMinus1_,  -- :: Num a 
			-- =>                String -> IO a       -> IO ()
  throwErrnoIfMinus1Retry,  
			-- :: Num a 
			-- =>                String -> IO a       -> IO a
  throwErrnoIfMinus1Retry_,  
			-- :: Num a 
			-- =>                String -> IO a       -> IO ()
  throwErrnoIfNull,	-- ::                String -> IO (Ptr a) -> IO (Ptr a)
  throwErrnoIfNullRetry,-- ::                String -> IO (Ptr a) -> IO (Ptr a)

  throwErrnoIfRetryMayBlock, 
  throwErrnoIfRetryMayBlock_,
  throwErrnoIfMinus1RetryMayBlock,
  throwErrnoIfMinus1RetryMayBlock_,  
  throwErrnoIfNullRetryMayBlock
) where


-- this is were we get the CONST_XXX definitions from that configure
-- calculated for us
--

                                                                              
                                                                             

                         


                          


                              


                                 


                        


                                


                          


                            


                         


                           


                           


                         


                          


                         


                                


                                


                              


                           


                                


                          


                        


                          


                          


                          


                         


                          


                             


                                


                         


                          


                               


                         


                          


                       


                           


                          


                         


                          


                          


                            


                             


                                


                            


                             


                               


                          


                           


                            


                           


                          


                          


                           


                          


                           


                          


                          


                          


                               


                          


                         


                          


                          


                           


                            


                           


                             


                            


                          


                         


                              


                         


                                


                         


                            


                                


                                 


                                


                          


                                   


                              


                          


                           


                           


                         


                                


                            


                             


                                   


                          


                         


                          


                          


                         


                             


                                


                           


                          


                               


                         


                            


                           


                           


                          


                           


                           


                          


                          


                          


                          


                           


                           


                           


                           


                           


                           


                           


                          


                           


                           


                           


                           


                           


                          


                           


                           


                             


                           


                           


                             


                           


                           


                           


                               


                               


                                                        


                                                                                     


                                                                                    
                             

                                                         


                                                        


                                                        


                                                  


                                                   


                                                       


                                                      
                          

                                                       


                                                          


                                                      


                                                           


                                                      


                                                         


                                                         


                                                         


                                                   


                                                         


                                                       


                                                       


                                                         


                                                         


                                                         


                                                          


                                                         


                                                          


                                                               


                                                             


                                                           


                                                              


                                                            


                                                             
                              

                                                            


                                                           


                                                            


                                                              


                                                           


                                                          


                                                   


                                                       


                                                                                                         


                                                                                         
                        

                                                         


                                                        


                                                   


                                                        
                         

                                                         


                                                          
                           

                                                          
                           

                                  


                                   


                                                     
                         

                                     


                                     


                                        


                                      


                                       


                                      


                                      


                                      


                                    


                                         


                                         


                                     


                                          


                                       


                                        


                                      


                                      


                                          


                                       


                                      


                                            


                                             


                                       


                                        


                                        


                                         


                                       


                                      


                                          


                                          


                                              


                                             


                                              


                                                   


                                               


                                        


                                       
                         

                                                                              


                                              


                                                          


                                                          


                                               


                                            


                                           


                                                      


                                                                           


                                                            
                           

                                                   




                                                                       
                              

                                                 
                         

                                                            
                  

                                                       
                  

                                                
                  




-- system dependent imports
-- ------------------------

-- GHC allows us to get at the guts inside IO errors/exceptions
--





-- regular imports
-- ---------------

import Foreign.Storable
import Foreign.Ptr
import Foreign.C.Types
import Foreign.C.String
import Foreign.Marshal.Error 	( void )
import Data.Maybe






import System.IO		( Handle )
import System.IO.Error		( IOError, ioError )
import System.IO.Unsafe		( unsafePerformIO )



{-# CFILES cbits/PrelIOUtils.c #-}



-- "errno" type
-- ------------

-- | Haskell representation for @errno@ values.
-- The implementation is deliberately exposed, to allow users to add
-- their own definitions of 'Errno' values.

newtype Errno = Errno CInt

instance Eq Errno where
  errno1@(Errno no1) == errno2@(Errno no2) 
    | isValidErrno errno1 && isValidErrno errno2 = no1 == no2
    | otherwise					 = False

-- common "errno" symbols
--
eOK, e2BIG, eACCES, eADDRINUSE, eADDRNOTAVAIL, eADV, eAFNOSUPPORT, eAGAIN, 
  eALREADY, eBADF, eBADMSG, eBADRPC, eBUSY, eCHILD, eCOMM, eCONNABORTED, 
  eCONNREFUSED, eCONNRESET, eDEADLK, eDESTADDRREQ, eDIRTY, eDOM, eDQUOT, 
  eEXIST, eFAULT, eFBIG, eFTYPE, eHOSTDOWN, eHOSTUNREACH, eIDRM, eILSEQ, 
  eINPROGRESS, eINTR, eINVAL, eIO, eISCONN, eISDIR, eLOOP, eMFILE, eMLINK, 
  eMSGSIZE, eMULTIHOP, eNAMETOOLONG, eNETDOWN, eNETRESET, eNETUNREACH, 
  eNFILE, eNOBUFS, eNODATA, eNODEV, eNOENT, eNOEXEC, eNOLCK, eNOLINK, 
  eNOMEM, eNOMSG, eNONET, eNOPROTOOPT, eNOSPC, eNOSR, eNOSTR, eNOSYS, 
  eNOTBLK, eNOTCONN, eNOTDIR, eNOTEMPTY, eNOTSOCK, eNOTTY, eNXIO, 
  eOPNOTSUPP, ePERM, ePFNOSUPPORT, ePIPE, ePROCLIM, ePROCUNAVAIL, 
  ePROGMISMATCH, ePROGUNAVAIL, ePROTO, ePROTONOSUPPORT, ePROTOTYPE, 
  eRANGE, eREMCHG, eREMOTE, eROFS, eRPCMISMATCH, eRREMOTE, eSHUTDOWN, 
  eSOCKTNOSUPPORT, eSPIPE, eSRCH, eSRMNT, eSTALE, eTIME, eTIMEDOUT, 
  eTOOMANYREFS, eTXTBSY, eUSERS, eWOULDBLOCK, eXDEV		       :: Errno
--
-- the cCONST_XXX identifiers are cpp symbols whose value is computed by
-- configure 
--
eOK             = Errno 0



e2BIG           = Errno (7)
eACCES		= Errno (13)
eADDRINUSE	= Errno (98)
eADDRNOTAVAIL	= Errno (99)
eADV		= Errno (68)
eAFNOSUPPORT	= Errno (97)
eAGAIN		= Errno (11)
eALREADY	= Errno (114)
eBADF		= Errno (9)
eBADMSG		= Errno (74)
eBADRPC		= Errno (-1)
eBUSY		= Errno (16)
eCHILD		= Errno (10)
eCOMM		= Errno (70)
eCONNABORTED	= Errno (103)
eCONNREFUSED	= Errno (111)
eCONNRESET	= Errno (104)
eDEADLK		= Errno (35)
eDESTADDRREQ	= Errno (89)
eDIRTY		= Errno (-1)
eDOM		= Errno (33)
eDQUOT		= Errno (122)
eEXIST		= Errno (17)
eFAULT		= Errno (14)
eFBIG		= Errno (27)
eFTYPE		= Errno (-1)
eHOSTDOWN	= Errno (112)
eHOSTUNREACH	= Errno (113)
eIDRM		= Errno (43)
eILSEQ		= Errno (84)
eINPROGRESS	= Errno (115)
eINTR		= Errno (4)
eINVAL		= Errno (22)
eIO		= Errno (5)
eISCONN		= Errno (106)
eISDIR		= Errno (21)
eLOOP		= Errno (40)
eMFILE		= Errno (24)
eMLINK		= Errno (31)
eMSGSIZE	= Errno (90)
eMULTIHOP	= Errno (72)
eNAMETOOLONG	= Errno (36)
eNETDOWN	= Errno (100)
eNETRESET	= Errno (102)
eNETUNREACH	= Errno (101)
eNFILE		= Errno (23)
eNOBUFS		= Errno (105)
eNODATA		= Errno (61)
eNODEV		= Errno (19)
eNOENT		= Errno (2)
eNOEXEC		= Errno (8)
eNOLCK		= Errno (37)
eNOLINK		= Errno (67)
eNOMEM		= Errno (12)
eNOMSG		= Errno (42)
eNONET		= Errno (64)
eNOPROTOOPT	= Errno (92)
eNOSPC		= Errno (28)
eNOSR		= Errno (63)
eNOSTR		= Errno (60)
eNOSYS		= Errno (38)
eNOTBLK		= Errno (15)
eNOTCONN	= Errno (107)
eNOTDIR		= Errno (20)
eNOTEMPTY	= Errno (39)
eNOTSOCK	= Errno (88)
eNOTTY		= Errno (25)
eNXIO		= Errno (6)
eOPNOTSUPP	= Errno (95)
ePERM		= Errno (1)
ePFNOSUPPORT	= Errno (96)
ePIPE		= Errno (32)
ePROCLIM	= Errno (-1)
ePROCUNAVAIL	= Errno (-1)
ePROGMISMATCH	= Errno (-1)
ePROGUNAVAIL	= Errno (-1)
ePROTO		= Errno (71)
ePROTONOSUPPORT = Errno (93)
ePROTOTYPE	= Errno (91)
eRANGE		= Errno (34)
eREMCHG		= Errno (78)
eREMOTE		= Errno (66)
eROFS		= Errno (30)
eRPCMISMATCH	= Errno (-1)
eRREMOTE	= Errno (-1)
eSHUTDOWN	= Errno (108)
eSOCKTNOSUPPORT = Errno (94)
eSPIPE		= Errno (29)
eSRCH		= Errno (3)
eSRMNT		= Errno (69)
eSTALE		= Errno (116)
eTIME		= Errno (62)
eTIMEDOUT	= Errno (110)
eTOOMANYREFS	= Errno (109)
eTXTBSY		= Errno (26)
eUSERS		= Errno (87)
eWOULDBLOCK	= Errno (11)
eXDEV		= Errno (18)


-- | Yield 'True' if the given 'Errno' value is valid on the system.
-- This implies that the 'Eq' instance of 'Errno' is also system dependent
-- as it is only defined for valid values of 'Errno'.
--
isValidErrno               :: Errno -> Bool
--
-- the configure script sets all invalid "errno"s to -1
--
isValidErrno (Errno errno)  = errno /= -1


-- access to the current thread's "errno" value
-- --------------------------------------------

-- | Get the current value of @errno@ in the current thread.
--
getErrno :: IO Errno

-- We must call a C function to get the value of errno in general.  On
-- threaded systems, errno is hidden behind a C macro so that each OS
-- thread gets its own copy.




getErrno = do e <- get_errno; return (Errno e)
foreign import ccall unsafe "HsBase.h __hscore_get_errno" get_errno :: IO CInt


-- | Reset the current thread\'s @errno@ value to 'eOK'.
--
resetErrno :: IO ()

-- Again, setting errno has to be done via a C function.



resetErrno = set_errno 0
foreign import ccall unsafe "HsBase.h __hscore_set_errno" set_errno :: CInt -> IO ()


-- throw current "errno" value
-- ---------------------------

-- | Throw an 'IOError' corresponding to the current value of 'getErrno'.
--
throwErrno     :: String	-- ^ textual description of the error location
	       -> IO a
throwErrno loc  =
  do
    errno <- getErrno
    ioError (errnoToIOError loc errno Nothing Nothing)


-- guards for IO operations that may fail
-- --------------------------------------

-- | Throw an 'IOError' corresponding to the current value of 'getErrno'
-- if the result value of the 'IO' action meets the given predicate.
--
throwErrnoIf    :: (a -> Bool)	-- ^ predicate to apply to the result value
				-- of the 'IO' operation
		-> String	-- ^ textual description of the location
		-> IO a		-- ^ the 'IO' operation to be executed
		-> IO a
throwErrnoIf pred loc f  = 
  do
    res <- f
    if pred res then throwErrno loc else return res

-- | as 'throwErrnoIf', but discards the result of the 'IO' action after
-- error handling.
--
throwErrnoIf_   :: (a -> Bool) -> String -> IO a -> IO ()
throwErrnoIf_ pred loc f  = void $ throwErrnoIf pred loc f

-- | as 'throwErrnoIf', but retry the 'IO' action when it yields the
-- error code 'eINTR' - this amounts to the standard retry loop for
-- interrupted POSIX system calls.
--
throwErrnoIfRetry            :: (a -> Bool) -> String -> IO a -> IO a
throwErrnoIfRetry pred loc f  = 
  do
    res <- f
    if pred res
      then do
	err <- getErrno
	if err == eINTR
	  then throwErrnoIfRetry pred loc f
	  else throwErrno loc
      else return res

-- | as 'throwErrnoIfRetry', but checks for operations that would block and
-- executes an alternative action before retrying in that case.
--
throwErrnoIfRetryMayBlock
		:: (a -> Bool)	-- ^ predicate to apply to the result value
				-- of the 'IO' operation
		-> String	-- ^ textual description of the location
		-> IO a		-- ^ the 'IO' operation to be executed
		-> IO b		-- ^ action to execute before retrying if
				-- an immediate retry would block
		-> IO a
throwErrnoIfRetryMayBlock pred loc f on_block  = 
  do
    res <- f
    if pred res
      then do
	err <- getErrno
	if err == eINTR
	  then throwErrnoIfRetryMayBlock pred loc f on_block
          else if err == eWOULDBLOCK || err == eAGAIN
	         then do on_block; throwErrnoIfRetryMayBlock pred loc f on_block
                 else throwErrno loc
      else return res

-- | as 'throwErrnoIfRetry', but discards the result.
--
throwErrnoIfRetry_            :: (a -> Bool) -> String -> IO a -> IO ()
throwErrnoIfRetry_ pred loc f  = void $ throwErrnoIfRetry pred loc f

-- | as 'throwErrnoIfRetryMayBlock', but discards the result.
--
throwErrnoIfRetryMayBlock_ :: (a -> Bool) -> String -> IO a -> IO b -> IO ()
throwErrnoIfRetryMayBlock_ pred loc f on_block 
  = void $ throwErrnoIfRetryMayBlock pred loc f on_block

-- | Throw an 'IOError' corresponding to the current value of 'getErrno'
-- if the 'IO' action returns a result of @-1@.
--
throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
throwErrnoIfMinus1  = throwErrnoIf (== -1)

-- | as 'throwErrnoIfMinus1', but discards the result.
--
throwErrnoIfMinus1_ :: Num a => String -> IO a -> IO ()
throwErrnoIfMinus1_  = throwErrnoIf_ (== -1)

-- | Throw an 'IOError' corresponding to the current value of 'getErrno'
-- if the 'IO' action returns a result of @-1@, but retries in case of
-- an interrupted operation.
--
throwErrnoIfMinus1Retry :: Num a => String -> IO a -> IO a
throwErrnoIfMinus1Retry  = throwErrnoIfRetry (== -1)

-- | as 'throwErrnoIfMinus1', but discards the result.
--
throwErrnoIfMinus1Retry_ :: Num a => String -> IO a -> IO ()
throwErrnoIfMinus1Retry_  = throwErrnoIfRetry_ (== -1)

-- | as 'throwErrnoIfMinus1Retry', but checks for operations that would block.
--
throwErrnoIfMinus1RetryMayBlock :: Num a => String -> IO a -> IO b -> IO a
throwErrnoIfMinus1RetryMayBlock  = throwErrnoIfRetryMayBlock (== -1)

-- | as 'throwErrnoIfMinus1RetryMayBlock', but discards the result.
--
throwErrnoIfMinus1RetryMayBlock_ :: Num a => String -> IO a -> IO b -> IO ()
throwErrnoIfMinus1RetryMayBlock_  = throwErrnoIfRetryMayBlock_ (== -1)

-- | Throw an 'IOError' corresponding to the current value of 'getErrno'
-- if the 'IO' action returns 'nullPtr'.
--
throwErrnoIfNull :: String -> IO (Ptr a) -> IO (Ptr a)
throwErrnoIfNull  = throwErrnoIf (== nullPtr)

-- | Throw an 'IOError' corresponding to the current value of 'getErrno'
-- if the 'IO' action returns 'nullPtr',
-- but retry in case of an interrupted operation.
--
throwErrnoIfNullRetry :: String -> IO (Ptr a) -> IO (Ptr a)
throwErrnoIfNullRetry  = throwErrnoIfRetry (== nullPtr)

-- | as 'throwErrnoIfNullRetry', but checks for operations that would block.
--
throwErrnoIfNullRetryMayBlock :: String -> IO (Ptr a) -> IO b -> IO (Ptr a)
throwErrnoIfNullRetryMayBlock  = throwErrnoIfRetryMayBlock (== nullPtr)

-- conversion of an "errno" value into IO error
-- --------------------------------------------

-- | Construct a Haskell 98 I\/O error based on the given 'Errno' value.
-- The optional information can be used to improve the accuracy of
-- error messages.
--
errnoToIOError	:: String	-- ^ the location where the error occurred
		-> Errno	-- ^ the error number
		-> Maybe Handle	-- ^ optional handle associated with the error
		-> Maybe String	-- ^ optional filename associated with the error
		-> IOError
errnoToIOError loc errno maybeHdl maybeName = unsafePerformIO $ do
    str <- strerror errno >>= peekCString









































































































    return (userError (loc ++ ": " ++ str ++ maybe "" (": "++) maybeName))


foreign import ccall unsafe "string.h" strerror :: Errno -> IO (Ptr CChar)
 asm    dylink‡Ä¿` ` ` ``  ` |ëenv
memoryBase env	tableBase envabort  env___hscore_get_errno env___hscore_set_errno  env	_strerror envmemory Äenvtablep 
	     A A ±_HugsAPIVersion __post_instantiate _hugs_primControl _hugsprim___hscore_get_errno_0 	_hugsprim___hscore_set_errno_1 _hugsprim_strerror_2 _initModule runPostSets 
	 #	
Œ	 A # A–Ä¿j  6 #   (∞   = # A–Ä¿j( (, # A–Ä¿j( (ê    A# A–Ä¿j( († + # A–Ä¿j( (,   A # A–Ä¿j( († + # A–Ä¿j( (x    A# A–Ä¿j( († k # #Aj6 # # (# Ajj6# # (# A0jj6# #Aj6# # (# A9jj6# #Aj6 # # ($# A√ jj6$# #Aj6, # A– j$#AÄÄ¿j$
 A  D        R # L                                             strerror set_errno get_errno{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Foreign.C.String
-- Copyright   :  (c) The FFI task force 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  ffi@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Utilities for primitive marshalling of C strings.
--
-- The marshalling converts each Haskell character, representing a Unicode
-- code point, to one or more bytes in a manner that, by default, is
-- determined by the current locale.  As a consequence, no guarantees
-- can be made about the relative length of a Haskell string and its
-- corresponding C string, and therefore all the marshalling routines
-- include memory allocation.  The translation between Unicode and the
-- encoding of the current locale may be lossy.
--
-----------------------------------------------------------------------------

module Foreign.C.String (   -- representation of strings in C

  -- * C strings

  CString,           -- = Ptr CChar
  CStringLen,        -- = (Ptr CChar, Int)

  -- ** Using a locale-dependent encoding

  -- | Currently these functions are identical to their @CAString@ counterparts;
  -- eventually they will use an encoding determined by the current locale.

  -- conversion of C strings into Haskell strings
  --
  peekCString,       -- :: CString    -> IO String
  peekCStringLen,    -- :: CStringLen -> IO String

  -- conversion of Haskell strings into C strings
  --
  newCString,        -- :: String -> IO CString
  newCStringLen,     -- :: String -> IO CStringLen

  -- conversion of Haskell strings into C strings using temporary storage
  --
  withCString,       -- :: String -> (CString    -> IO a) -> IO a
  withCStringLen,    -- :: String -> (CStringLen -> IO a) -> IO a

  charIsRepresentable, -- :: Char -> IO Bool

  -- ** Using 8-bit characters

  -- | These variants of the above functions are for use with C libraries
  -- that are ignorant of Unicode.  These functions should be used with
  -- care, as a loss of information can occur.

  castCharToCChar,   -- :: Char -> CChar
  castCCharToChar,   -- :: CChar -> Char

  peekCAString,      -- :: CString    -> IO String
  peekCAStringLen,   -- :: CStringLen -> IO String
  newCAString,       -- :: String -> IO CString
  newCAStringLen,    -- :: String -> IO CStringLen
  withCAString,      -- :: String -> (CString    -> IO a) -> IO a
  withCAStringLen,   -- :: String -> (CStringLen -> IO a) -> IO a

  -- * C wide strings

  -- | These variants of the above functions are for use with C libraries
  -- that encode Unicode using the C @wchar_t@ type in a system-dependent
  -- way.  The only encodings supported are
  --
  -- * UTF-32 (the C compiler defines @__STDC_ISO_10646__@), or
  --
  -- * UTF-16 (as used on Windows systems).

  CWString,          -- = Ptr CWchar
  CWStringLen,       -- = (Ptr CWchar, Int)

  peekCWString,      -- :: CWString    -> IO String
  peekCWStringLen,   -- :: CWStringLen -> IO String
  newCWString,       -- :: String -> IO CWString
  newCWStringLen,    -- :: String -> IO CWStringLen
  withCWString,      -- :: String -> (CWString    -> IO a) -> IO a
  withCWStringLen,   -- :: String -> (CWStringLen -> IO a) -> IO a

  ) where

import Foreign.Marshal.Array
import Foreign.C.Types
import Foreign.Ptr
import Foreign.Storable

import Data.Word








import Data.Char ( chr, ord )



-----------------------------------------------------------------------------
-- Strings

-- representation of strings in C
-- ------------------------------

-- | A C string is a reference to an array of C characters terminated by NUL.
type CString    = Ptr CChar

-- | A string with explicit length information in bytes instead of a
-- terminating NUL (allowing NUL characters in the middle of the string).
type CStringLen = (Ptr CChar, Int)

-- exported functions
-- ------------------
--
-- * the following routines apply the default conversion when converting the
--   C-land character encoding into the Haskell-land character encoding

-- | Marshal a NUL terminated C string into a Haskell string.
--
peekCString    :: CString -> IO String
peekCString = peekCAString

-- | Marshal a C string with explicit length into a Haskell string.
--
peekCStringLen           :: CStringLen -> IO String
peekCStringLen = peekCAStringLen

-- | Marshal a Haskell string into a NUL terminated C string.
--
-- * the Haskell string may /not/ contain any NUL characters
--
-- * new storage is allocated for the C string and must be
--   explicitly freed using 'Foreign.Marshal.Alloc.free' or
--   'Foreign.Marshal.Alloc.finalizerFree'.
--
newCString :: String -> IO CString
newCString = newCAString

-- | Marshal a Haskell string into a C string (ie, character array) with
-- explicit length information.
--
-- * new storage is allocated for the C string and must be
--   explicitly freed using 'Foreign.Marshal.Alloc.free' or
--   'Foreign.Marshal.Alloc.finalizerFree'.
--
newCStringLen     :: String -> IO CStringLen
newCStringLen = newCAStringLen

-- | Marshal a Haskell string into a NUL terminated C string using temporary
-- storage.
--
-- * the Haskell string may /not/ contain any NUL characters
--
-- * the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary
--   storage must /not/ be used after this.
--
withCString :: String -> (CString -> IO a) -> IO a
withCString = withCAString

-- | Marshal a Haskell string into a C string (ie, character array)
-- in temporary storage, with explicit length information.
--
-- * the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary
--   storage must /not/ be used after this.
--
withCStringLen         :: String -> (CStringLen -> IO a) -> IO a
withCStringLen = withCAStringLen

-- | Determines whether a character can be accurately encoded in a 'CString'.
-- Unrepresentable characters are converted to @\'?\'@.
--
-- Currently only Latin-1 characters are representable.
charIsRepresentable :: Char -> IO Bool
charIsRepresentable c = return (ord c < 256)

-- single byte characters
-- ----------------------
--
--   ** NOTE: These routines don't handle conversions! **

-- | Convert a C byte, representing a Latin-1 character, to the corresponding
-- Haskell character.
castCCharToChar :: CChar -> Char
castCCharToChar ch = chr (fromIntegral (fromIntegral ch :: Word8))

-- | Convert a Haskell character to a C character.
-- This function is only safe on the first 256 characters.
castCharToCChar :: Char -> CChar
castCharToCChar ch = fromIntegral (ord ch)

-- | Marshal a NUL terminated C string into a Haskell string.
--
peekCAString    :: CString -> IO String

peekCAString cp  = do
  cs <- peekArray0 nUL cp
  return (cCharsToChars cs)











-- | Marshal a C string with explicit length into a Haskell string.
--
peekCAStringLen           :: CStringLen -> IO String

peekCAStringLen (cp, len)  = do
  cs <- peekArray len cp
  return (cCharsToChars cs)














-- | Marshal a Haskell string into a NUL terminated C string.
--
-- * the Haskell string may /not/ contain any NUL characters
--
-- * new storage is allocated for the C string and must be
--   explicitly freed using 'Foreign.Marshal.Alloc.free' or
--   'Foreign.Marshal.Alloc.finalizerFree'.
--
newCAString :: String -> IO CString

newCAString  = newArray0 nUL . charsToCChars










-- | Marshal a Haskell string into a C string (ie, character array) with
-- explicit length information.
--
-- * new storage is allocated for the C string and must be
--   explicitly freed using 'Foreign.Marshal.Alloc.free' or
--   'Foreign.Marshal.Alloc.finalizerFree'.
--
newCAStringLen     :: String -> IO CStringLen

newCAStringLen str  = do
  a <- newArray (charsToCChars str)
  return (pairLength str a)












-- | Marshal a Haskell string into a NUL terminated C string using temporary
-- storage.
--
-- * the Haskell string may /not/ contain any NUL characters
--
-- * the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary
--   storage must /not/ be used after this.
--
withCAString :: String -> (CString -> IO a) -> IO a

withCAString  = withArray0 nUL . charsToCChars











-- | Marshal a Haskell string into a C string (ie, character array)
-- in temporary storage, with explicit length information.
--
-- * the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary
--   storage must /not/ be used after this.
--
withCAStringLen         :: String -> (CStringLen -> IO a) -> IO a

withCAStringLen str act  = withArray (charsToCChars str) $ act . pairLength str













-- auxiliary definitions
-- ----------------------

-- C's end of string character
--
nUL :: CChar
nUL  = 0

-- pair a C string with the length of the given Haskell string
--
pairLength :: String -> a -> (a, Int)
pairLength  = flip (,) . length


-- cast [CChar] to [Char]
--
cCharsToChars :: [CChar] -> [Char]
cCharsToChars xs  = map castCCharToChar xs

-- cast [Char] to [CChar]
--
charsToCChars :: [Char] -> [CChar]
charsToCChars xs  = map castCharToCChar xs


-----------------------------------------------------------------------------
-- Wide strings

-- representation of wide strings in C
-- -----------------------------------

-- | A C wide string is a reference to an array of C wide characters
-- terminated by NUL.
type CWString    = Ptr CWchar

-- | A wide character string with explicit length information in bytes
-- instead of a terminating NUL (allowing NUL characters in the middle
-- of the string).
type CWStringLen = (Ptr CWchar, Int)

-- | Marshal a NUL terminated C wide string into a Haskell string.
--
peekCWString    :: CWString -> IO String
peekCWString cp  = do
  cs <- peekArray0 wNUL cp
  return (cWcharsToChars cs)

-- | Marshal a C wide string with explicit length into a Haskell string.
--
peekCWStringLen           :: CWStringLen -> IO String
peekCWStringLen (cp, len)  = do
  cs <- peekArray len cp
  return (cWcharsToChars cs)

-- | Marshal a Haskell string into a NUL terminated C wide string.
--
-- * the Haskell string may /not/ contain any NUL characters
--
-- * new storage is allocated for the C wide string and must
--   be explicitly freed using 'Foreign.Marshal.Alloc.free' or
--   'Foreign.Marshal.Alloc.finalizerFree'.
--
newCWString :: String -> IO CWString
newCWString  = newArray0 wNUL . charsToCWchars

-- | Marshal a Haskell string into a C wide string (ie, wide character array)
-- with explicit length information.
--
-- * new storage is allocated for the C wide string and must
--   be explicitly freed using 'Foreign.Marshal.Alloc.free' or
--   'Foreign.Marshal.Alloc.finalizerFree'.
--
newCWStringLen     :: String -> IO CWStringLen
newCWStringLen str  = do
  a <- newArray (charsToCWchars str)
  return (pairLength str a)

-- | Marshal a Haskell string into a NUL terminated C wide string using
-- temporary storage.
--
-- * the Haskell string may /not/ contain any NUL characters
--
-- * the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary
--   storage must /not/ be used after this.
--
withCWString :: String -> (CWString -> IO a) -> IO a
withCWString  = withArray0 wNUL . charsToCWchars

-- | Marshal a Haskell string into a NUL terminated C wide string using
-- temporary storage.
--
-- * the Haskell string may /not/ contain any NUL characters
--
-- * the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary
--   storage must /not/ be used after this.
--
withCWStringLen         :: String -> (CWStringLen -> IO a) -> IO a
withCWStringLen str act  = withArray (charsToCWchars str) $ act . pairLength str

-- auxiliary definitions
-- ----------------------

wNUL :: CWchar
wNUL = 0

cWcharsToChars :: [CWchar] -> [Char]
charsToCWchars :: [Char] -> [CWchar]
























cWcharsToChars xs  = map castCWcharToChar xs
charsToCWchars xs  = map castCharToCWchar xs

-- These conversions only make sense if __STDC_ISO_10646__ is defined
-- (meaning that wchar_t is ISO 10646, aka Unicode)

castCWcharToChar :: CWchar -> Char
castCWcharToChar ch = chr (fromIntegral ch )

castCharToCWchar :: Char -> CWchar
castCharToCWchar ch = fromIntegral (ord ch)


{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Foreign.C.Types
-- Copyright   :  (c) The FFI task force 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  ffi@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Mapping of C types to corresponding Haskell types.
--
-----------------------------------------------------------------------------

module Foreign.C.Types
	( -- * Representations of C types

	  -- $ctypes

	  -- ** Integral types
	  -- | These types are are represented as @newtype@s of
	  -- types in "Data.Int" and "Data.Word", and are instances of
	  -- 'Prelude.Eq', 'Prelude.Ord', 'Prelude.Num', 'Prelude.Read',
	  -- 'Prelude.Show', 'Prelude.Enum', 'Typeable', 'Storable',
	  -- 'Prelude.Bounded', 'Prelude.Real', 'Prelude.Integral' and
	  -- 'Bits'.
	  CChar,  CSChar,  CUChar
	, CShort, CUShort, CInt,   CUInt
	, CLong,  CULong
	, CPtrdiff, CSize, CWchar, CSigAtomic
        , CLLong, CULLong
	, CIntPtr, CUIntPtr
	, CIntMax, CUIntMax

	  -- ** Numeric types
	  -- | These types are are represented as @newtype@s of basic
	  -- foreign types, and are instances of
	  -- 'Prelude.Eq', 'Prelude.Ord', 'Prelude.Num', 'Prelude.Read',
	  -- 'Prelude.Show', 'Prelude.Enum', 'Typeable' and 'Storable'.
	, CClock,   CTime

	  -- ** Floating types
	  -- | These types are are represented as @newtype@s of
	  -- 'Prelude.Float' and 'Prelude.Double', and are instances of
	  -- 'Prelude.Eq', 'Prelude.Ord', 'Prelude.Num', 'Prelude.Read',
	  -- 'Prelude.Show', 'Prelude.Enum', 'Typeable', 'Storable',
	  -- 'Prelude.Real', 'Prelude.Fractional', 'Prelude.Floating',
	  -- 'Prelude.RealFrac' and 'Prelude.RealFloat'.
	, CFloat,  CDouble, CLDouble










	  -- ** Other types

          -- Instances of: Eq and Storable
	, CFile,        CFpos,     CJmpBuf
	) where



import Foreign.Storable
import Data.Bits	( Bits(..) )
import Data.Int		( Int8,  Int16,  Int32,  Int64  )
import Data.Word	( Word8, Word16, Word32, Word64 )
import Data.Typeable










import Control.Monad	( liftM )



import Hugs.Ptr		( castPtr )


                                                                              
                                                                             

                         


                          


                              


                                 


                        


                                


                          


                            


                         


                           


                           


                         


                          


                         


                                


                                


                              


                           


                                


                          


                        


                          


                          


                          


                         


                          


                             


                                


                         


                          


                               


                         


                          


                       


                           


                          


                         


                          


                          


                            


                             


                                


                            


                             


                               


                          


                           


                            


                           


                          


                          


                           


                          


                           


                          


                          


                          


                               


                          


                         


                          


                          


                           


                            


                           


                             


                            


                          


                         


                              


                         


                                


                         


                            


                                


                                 


                                


                          


                                   


                              


                          


                           


                           


                         


                                


                            


                             


                                   


                          


                         


                          


                          


                         


                             


                                


                           


                          


                               


                         


                            


                           


                           


                          


                           


                           


                          


                          


                          


                          


                           


                           


                           


                           


                           


                           


                           


                          


                           


                           


                           


                           


                           


                          


                           


                           


                             


                           


                           


                             


                           


                           


                           


                               


                               


                                                        


                                                                                     


                                                                                    
                             

                                                         


                                                        


                                                        


                                                  


                                                   


                                                       


                                                      
                          

                                                       


                                                          


                                                      


                                                           


                                                      


                                                         


                                                         


                                                         


                                                   


                                                         


                                                       


                                                       


                                                         


                                                         


                                                         


                                                          


                                                         


                                                          


                                                               


                                                             


                                                           


                                                              


                                                            


                                                             
                              

                                                            


                                                           


                                                            


                                                              


                                                           


                                                          


                                                   


                                                       


                                                                                                         


                                                                                         
                        

                                                         


                                                        


                                                   


                                                        
                         

                                                         


                                                          
                           

                                                          
                           

                                  


                                   


                                                     
                         

                                     


                                     


                                        


                                      


                                       


                                      


                                      


                                      


                                    


                                         


                                         


                                     


                                          


                                       


                                        


                                      


                                      


                                          


                                       


                                      


                                            


                                             


                                       


                                        


                                        


                                         


                                       


                                      


                                          


                                          


                                              


                                             


                                              


                                                   


                                               


                                        


                                       
                         

                                                                              


                                              


                                                          


                                                          


                                               


                                            


                                           


                                                      


                                                                           


                                                            
                           

                                                   




                                                                       
                              

                                                 
                         

                                                            
                  

                                                       
                  

                                                
                  


                                                                                                                                                                                                                                              




                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
























































                                                                                                                                                                                                                                        

                                                                





































































































































































































-- | Haskell type representing the C @char@ type.
newtype CChar = CChar Int8 deriving (Eq, Ord) ; instance Num CChar where {    (CChar i) + (CChar j) = CChar (i + j) ;    (CChar i) - (CChar j) = CChar (i - j) ;    (CChar i) * (CChar j) = CChar (i * j) ;    negate  (CChar i) = CChar (negate i) ;    abs     (CChar i) = CChar (abs    i) ;    signum  (CChar i) = CChar (signum i) ;    fromInteger x = CChar (fromInteger x) } ; instance Real CChar where {    toRational (CChar i) = toRational i } ; instance Read CChar where {    readsPrec p s = map (\(x, t) -> (CChar x, t)) (readsPrec p s) } ; instance Show CChar where {    showsPrec p (CChar x) = showsPrec p x } ; instance Enum CChar where {    succ           (CChar i)             = CChar (succ i) ;    pred           (CChar i)             = CChar (pred i) ;    toEnum               x           = CChar (toEnum x) ;    fromEnum       (CChar i)             = fromEnum i ;    enumFrom       (CChar i)             = map CChar (enumFrom i) ;    enumFromThen   (CChar i) (CChar j)       = map CChar (enumFromThen i j) ;    enumFromTo     (CChar i) (CChar j)       = map CChar (enumFromTo i j) ;    enumFromThenTo (CChar i) (CChar j) (CChar k) = map CChar (enumFromThenTo i j k) } ; instance Storable CChar where {    sizeOf    (CChar x)       = sizeOf x ;    alignment (CChar x)       = alignment x ;    peekElemOff a i       = liftM CChar (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CChar x) = pokeElemOff (castPtr a) i x } ; tyConCChar = mkTyCon "CChar"; instance Typeable CChar where { typeOf _ = mkTyConApp tyConCChar [] } ; ; instance Bounded CChar where {    minBound = CChar minBound ;    maxBound = CChar maxBound } ; instance Integral CChar where {    (CChar i) `quot`    (CChar j) = CChar (i `quot` j) ;    (CChar i) `rem`     (CChar j) = CChar (i `rem`  j) ;    (CChar i) `div`     (CChar j) = CChar (i `div`  j) ;    (CChar i) `mod`     (CChar j) = CChar (i `mod`  j) ;    (CChar i) `quotRem` (CChar j) = let (q,r) = i `quotRem` j in (CChar q, CChar r) ;    (CChar i) `divMod`  (CChar j) = let (d,m) = i `divMod`  j in (CChar d, CChar m) ;    toInteger (CChar i)       = toInteger i } ; instance Bits CChar where {   (CChar x) .&.     (CChar y)   = CChar (x .&.   y) ;   (CChar x) .|.     (CChar y)   = CChar (x .|.   y) ;   (CChar x) `xor`   (CChar y)   = CChar (x `xor` y) ;   complement    (CChar x)   = CChar (complement x) ;   shift         (CChar x) n = CChar (shift x n) ;   rotate        (CChar x) n = CChar (rotate x n) ;   bit                 n = CChar (bit n) ;   setBit        (CChar x) n = CChar (setBit x n) ;   clearBit      (CChar x) n = CChar (clearBit x n) ;   complementBit (CChar x) n = CChar (complementBit x n) ;   testBit       (CChar x) n = testBit x n ;   bitSize       (CChar x)   = bitSize x ;   isSigned      (CChar x)   = isSigned x }
-- | Haskell type representing the C @signed char@ type.
newtype CSChar = CSChar Int8 deriving (Eq, Ord) ; instance Num CSChar where {    (CSChar i) + (CSChar j) = CSChar (i + j) ;    (CSChar i) - (CSChar j) = CSChar (i - j) ;    (CSChar i) * (CSChar j) = CSChar (i * j) ;    negate  (CSChar i) = CSChar (negate i) ;    abs     (CSChar i) = CSChar (abs    i) ;    signum  (CSChar i) = CSChar (signum i) ;    fromInteger x = CSChar (fromInteger x) } ; instance Real CSChar where {    toRational (CSChar i) = toRational i } ; instance Read CSChar where {    readsPrec p s = map (\(x, t) -> (CSChar x, t)) (readsPrec p s) } ; instance Show CSChar where {    showsPrec p (CSChar x) = showsPrec p x } ; instance Enum CSChar where {    succ           (CSChar i)             = CSChar (succ i) ;    pred           (CSChar i)             = CSChar (pred i) ;    toEnum               x           = CSChar (toEnum x) ;    fromEnum       (CSChar i)             = fromEnum i ;    enumFrom       (CSChar i)             = map CSChar (enumFrom i) ;    enumFromThen   (CSChar i) (CSChar j)       = map CSChar (enumFromThen i j) ;    enumFromTo     (CSChar i) (CSChar j)       = map CSChar (enumFromTo i j) ;    enumFromThenTo (CSChar i) (CSChar j) (CSChar k) = map CSChar (enumFromThenTo i j k) } ; instance Storable CSChar where {    sizeOf    (CSChar x)       = sizeOf x ;    alignment (CSChar x)       = alignment x ;    peekElemOff a i       = liftM CSChar (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CSChar x) = pokeElemOff (castPtr a) i x } ; tyConCSChar = mkTyCon "CSChar"; instance Typeable CSChar where { typeOf _ = mkTyConApp tyConCSChar [] } ; ; instance Bounded CSChar where {    minBound = CSChar minBound ;    maxBound = CSChar maxBound } ; instance Integral CSChar where {    (CSChar i) `quot`    (CSChar j) = CSChar (i `quot` j) ;    (CSChar i) `rem`     (CSChar j) = CSChar (i `rem`  j) ;    (CSChar i) `div`     (CSChar j) = CSChar (i `div`  j) ;    (CSChar i) `mod`     (CSChar j) = CSChar (i `mod`  j) ;    (CSChar i) `quotRem` (CSChar j) = let (q,r) = i `quotRem` j in (CSChar q, CSChar r) ;    (CSChar i) `divMod`  (CSChar j) = let (d,m) = i `divMod`  j in (CSChar d, CSChar m) ;    toInteger (CSChar i)       = toInteger i } ; instance Bits CSChar where {   (CSChar x) .&.     (CSChar y)   = CSChar (x .&.   y) ;   (CSChar x) .|.     (CSChar y)   = CSChar (x .|.   y) ;   (CSChar x) `xor`   (CSChar y)   = CSChar (x `xor` y) ;   complement    (CSChar x)   = CSChar (complement x) ;   shift         (CSChar x) n = CSChar (shift x n) ;   rotate        (CSChar x) n = CSChar (rotate x n) ;   bit                 n = CSChar (bit n) ;   setBit        (CSChar x) n = CSChar (setBit x n) ;   clearBit      (CSChar x) n = CSChar (clearBit x n) ;   complementBit (CSChar x) n = CSChar (complementBit x n) ;   testBit       (CSChar x) n = testBit x n ;   bitSize       (CSChar x)   = bitSize x ;   isSigned      (CSChar x)   = isSigned x }
-- | Haskell type representing the C @unsigned char@ type.
newtype CUChar = CUChar Word8 deriving (Eq, Ord) ; instance Num CUChar where {    (CUChar i) + (CUChar j) = CUChar (i + j) ;    (CUChar i) - (CUChar j) = CUChar (i - j) ;    (CUChar i) * (CUChar j) = CUChar (i * j) ;    negate  (CUChar i) = CUChar (negate i) ;    abs     (CUChar i) = CUChar (abs    i) ;    signum  (CUChar i) = CUChar (signum i) ;    fromInteger x = CUChar (fromInteger x) } ; instance Real CUChar where {    toRational (CUChar i) = toRational i } ; instance Read CUChar where {    readsPrec p s = map (\(x, t) -> (CUChar x, t)) (readsPrec p s) } ; instance Show CUChar where {    showsPrec p (CUChar x) = showsPrec p x } ; instance Enum CUChar where {    succ           (CUChar i)             = CUChar (succ i) ;    pred           (CUChar i)             = CUChar (pred i) ;    toEnum               x           = CUChar (toEnum x) ;    fromEnum       (CUChar i)             = fromEnum i ;    enumFrom       (CUChar i)             = map CUChar (enumFrom i) ;    enumFromThen   (CUChar i) (CUChar j)       = map CUChar (enumFromThen i j) ;    enumFromTo     (CUChar i) (CUChar j)       = map CUChar (enumFromTo i j) ;    enumFromThenTo (CUChar i) (CUChar j) (CUChar k) = map CUChar (enumFromThenTo i j k) } ; instance Storable CUChar where {    sizeOf    (CUChar x)       = sizeOf x ;    alignment (CUChar x)       = alignment x ;    peekElemOff a i       = liftM CUChar (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CUChar x) = pokeElemOff (castPtr a) i x } ; tyConCUChar = mkTyCon "CUChar"; instance Typeable CUChar where { typeOf _ = mkTyConApp tyConCUChar [] } ; ; instance Bounded CUChar where {    minBound = CUChar minBound ;    maxBound = CUChar maxBound } ; instance Integral CUChar where {    (CUChar i) `quot`    (CUChar j) = CUChar (i `quot` j) ;    (CUChar i) `rem`     (CUChar j) = CUChar (i `rem`  j) ;    (CUChar i) `div`     (CUChar j) = CUChar (i `div`  j) ;    (CUChar i) `mod`     (CUChar j) = CUChar (i `mod`  j) ;    (CUChar i) `quotRem` (CUChar j) = let (q,r) = i `quotRem` j in (CUChar q, CUChar r) ;    (CUChar i) `divMod`  (CUChar j) = let (d,m) = i `divMod`  j in (CUChar d, CUChar m) ;    toInteger (CUChar i)       = toInteger i } ; instance Bits CUChar where {   (CUChar x) .&.     (CUChar y)   = CUChar (x .&.   y) ;   (CUChar x) .|.     (CUChar y)   = CUChar (x .|.   y) ;   (CUChar x) `xor`   (CUChar y)   = CUChar (x `xor` y) ;   complement    (CUChar x)   = CUChar (complement x) ;   shift         (CUChar x) n = CUChar (shift x n) ;   rotate        (CUChar x) n = CUChar (rotate x n) ;   bit                 n = CUChar (bit n) ;   setBit        (CUChar x) n = CUChar (setBit x n) ;   clearBit      (CUChar x) n = CUChar (clearBit x n) ;   complementBit (CUChar x) n = CUChar (complementBit x n) ;   testBit       (CUChar x) n = testBit x n ;   bitSize       (CUChar x)   = bitSize x ;   isSigned      (CUChar x)   = isSigned x }

-- | Haskell type representing the C @short@ type.
newtype CShort = CShort Int16 deriving (Eq, Ord) ; instance Num CShort where {    (CShort i) + (CShort j) = CShort (i + j) ;    (CShort i) - (CShort j) = CShort (i - j) ;    (CShort i) * (CShort j) = CShort (i * j) ;    negate  (CShort i) = CShort (negate i) ;    abs     (CShort i) = CShort (abs    i) ;    signum  (CShort i) = CShort (signum i) ;    fromInteger x = CShort (fromInteger x) } ; instance Real CShort where {    toRational (CShort i) = toRational i } ; instance Read CShort where {    readsPrec p s = map (\(x, t) -> (CShort x, t)) (readsPrec p s) } ; instance Show CShort where {    showsPrec p (CShort x) = showsPrec p x } ; instance Enum CShort where {    succ           (CShort i)             = CShort (succ i) ;    pred           (CShort i)             = CShort (pred i) ;    toEnum               x           = CShort (toEnum x) ;    fromEnum       (CShort i)             = fromEnum i ;    enumFrom       (CShort i)             = map CShort (enumFrom i) ;    enumFromThen   (CShort i) (CShort j)       = map CShort (enumFromThen i j) ;    enumFromTo     (CShort i) (CShort j)       = map CShort (enumFromTo i j) ;    enumFromThenTo (CShort i) (CShort j) (CShort k) = map CShort (enumFromThenTo i j k) } ; instance Storable CShort where {    sizeOf    (CShort x)       = sizeOf x ;    alignment (CShort x)       = alignment x ;    peekElemOff a i       = liftM CShort (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CShort x) = pokeElemOff (castPtr a) i x } ; tyConCShort = mkTyCon "CShort"; instance Typeable CShort where { typeOf _ = mkTyConApp tyConCShort [] } ; ; instance Bounded CShort where {    minBound = CShort minBound ;    maxBound = CShort maxBound } ; instance Integral CShort where {    (CShort i) `quot`    (CShort j) = CShort (i `quot` j) ;    (CShort i) `rem`     (CShort j) = CShort (i `rem`  j) ;    (CShort i) `div`     (CShort j) = CShort (i `div`  j) ;    (CShort i) `mod`     (CShort j) = CShort (i `mod`  j) ;    (CShort i) `quotRem` (CShort j) = let (q,r) = i `quotRem` j in (CShort q, CShort r) ;    (CShort i) `divMod`  (CShort j) = let (d,m) = i `divMod`  j in (CShort d, CShort m) ;    toInteger (CShort i)       = toInteger i } ; instance Bits CShort where {   (CShort x) .&.     (CShort y)   = CShort (x .&.   y) ;   (CShort x) .|.     (CShort y)   = CShort (x .|.   y) ;   (CShort x) `xor`   (CShort y)   = CShort (x `xor` y) ;   complement    (CShort x)   = CShort (complement x) ;   shift         (CShort x) n = CShort (shift x n) ;   rotate        (CShort x) n = CShort (rotate x n) ;   bit                 n = CShort (bit n) ;   setBit        (CShort x) n = CShort (setBit x n) ;   clearBit      (CShort x) n = CShort (clearBit x n) ;   complementBit (CShort x) n = CShort (complementBit x n) ;   testBit       (CShort x) n = testBit x n ;   bitSize       (CShort x)   = bitSize x ;   isSigned      (CShort x)   = isSigned x }
-- | Haskell type representing the C @unsigned short@ type.
newtype CUShort = CUShort Word16 deriving (Eq, Ord) ; instance Num CUShort where {    (CUShort i) + (CUShort j) = CUShort (i + j) ;    (CUShort i) - (CUShort j) = CUShort (i - j) ;    (CUShort i) * (CUShort j) = CUShort (i * j) ;    negate  (CUShort i) = CUShort (negate i) ;    abs     (CUShort i) = CUShort (abs    i) ;    signum  (CUShort i) = CUShort (signum i) ;    fromInteger x = CUShort (fromInteger x) } ; instance Real CUShort where {    toRational (CUShort i) = toRational i } ; instance Read CUShort where {    readsPrec p s = map (\(x, t) -> (CUShort x, t)) (readsPrec p s) } ; instance Show CUShort where {    showsPrec p (CUShort x) = showsPrec p x } ; instance Enum CUShort where {    succ           (CUShort i)             = CUShort (succ i) ;    pred           (CUShort i)             = CUShort (pred i) ;    toEnum               x           = CUShort (toEnum x) ;    fromEnum       (CUShort i)             = fromEnum i ;    enumFrom       (CUShort i)             = map CUShort (enumFrom i) ;    enumFromThen   (CUShort i) (CUShort j)       = map CUShort (enumFromThen i j) ;    enumFromTo     (CUShort i) (CUShort j)       = map CUShort (enumFromTo i j) ;    enumFromThenTo (CUShort i) (CUShort j) (CUShort k) = map CUShort (enumFromThenTo i j k) } ; instance Storable CUShort where {    sizeOf    (CUShort x)       = sizeOf x ;    alignment (CUShort x)       = alignment x ;    peekElemOff a i       = liftM CUShort (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CUShort x) = pokeElemOff (castPtr a) i x } ; tyConCUShort = mkTyCon "CUShort"; instance Typeable CUShort where { typeOf _ = mkTyConApp tyConCUShort [] } ; ; instance Bounded CUShort where {    minBound = CUShort minBound ;    maxBound = CUShort maxBound } ; instance Integral CUShort where {    (CUShort i) `quot`    (CUShort j) = CUShort (i `quot` j) ;    (CUShort i) `rem`     (CUShort j) = CUShort (i `rem`  j) ;    (CUShort i) `div`     (CUShort j) = CUShort (i `div`  j) ;    (CUShort i) `mod`     (CUShort j) = CUShort (i `mod`  j) ;    (CUShort i) `quotRem` (CUShort j) = let (q,r) = i `quotRem` j in (CUShort q, CUShort r) ;    (CUShort i) `divMod`  (CUShort j) = let (d,m) = i `divMod`  j in (CUShort d, CUShort m) ;    toInteger (CUShort i)       = toInteger i } ; instance Bits CUShort where {   (CUShort x) .&.     (CUShort y)   = CUShort (x .&.   y) ;   (CUShort x) .|.     (CUShort y)   = CUShort (x .|.   y) ;   (CUShort x) `xor`   (CUShort y)   = CUShort (x `xor` y) ;   complement    (CUShort x)   = CUShort (complement x) ;   shift         (CUShort x) n = CUShort (shift x n) ;   rotate        (CUShort x) n = CUShort (rotate x n) ;   bit                 n = CUShort (bit n) ;   setBit        (CUShort x) n = CUShort (setBit x n) ;   clearBit      (CUShort x) n = CUShort (clearBit x n) ;   complementBit (CUShort x) n = CUShort (complementBit x n) ;   testBit       (CUShort x) n = testBit x n ;   bitSize       (CUShort x)   = bitSize x ;   isSigned      (CUShort x)   = isSigned x }

-- | Haskell type representing the C @int@ type.
newtype CInt = CInt Int32 deriving (Eq, Ord) ; instance Num CInt where {    (CInt i) + (CInt j) = CInt (i + j) ;    (CInt i) - (CInt j) = CInt (i - j) ;    (CInt i) * (CInt j) = CInt (i * j) ;    negate  (CInt i) = CInt (negate i) ;    abs     (CInt i) = CInt (abs    i) ;    signum  (CInt i) = CInt (signum i) ;    fromInteger x = CInt (fromInteger x) } ; instance Real CInt where {    toRational (CInt i) = toRational i } ; instance Read CInt where {    readsPrec p s = map (\(x, t) -> (CInt x, t)) (readsPrec p s) } ; instance Show CInt where {    showsPrec p (CInt x) = showsPrec p x } ; instance Enum CInt where {    succ           (CInt i)             = CInt (succ i) ;    pred           (CInt i)             = CInt (pred i) ;    toEnum               x           = CInt (toEnum x) ;    fromEnum       (CInt i)             = fromEnum i ;    enumFrom       (CInt i)             = map CInt (enumFrom i) ;    enumFromThen   (CInt i) (CInt j)       = map CInt (enumFromThen i j) ;    enumFromTo     (CInt i) (CInt j)       = map CInt (enumFromTo i j) ;    enumFromThenTo (CInt i) (CInt j) (CInt k) = map CInt (enumFromThenTo i j k) } ; instance Storable CInt where {    sizeOf    (CInt x)       = sizeOf x ;    alignment (CInt x)       = alignment x ;    peekElemOff a i       = liftM CInt (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CInt x) = pokeElemOff (castPtr a) i x } ; tyConCInt = mkTyCon "CInt"; instance Typeable CInt where { typeOf _ = mkTyConApp tyConCInt [] } ; ; instance Bounded CInt where {    minBound = CInt minBound ;    maxBound = CInt maxBound } ; instance Integral CInt where {    (CInt i) `quot`    (CInt j) = CInt (i `quot` j) ;    (CInt i) `rem`     (CInt j) = CInt (i `rem`  j) ;    (CInt i) `div`     (CInt j) = CInt (i `div`  j) ;    (CInt i) `mod`     (CInt j) = CInt (i `mod`  j) ;    (CInt i) `quotRem` (CInt j) = let (q,r) = i `quotRem` j in (CInt q, CInt r) ;    (CInt i) `divMod`  (CInt j) = let (d,m) = i `divMod`  j in (CInt d, CInt m) ;    toInteger (CInt i)       = toInteger i } ; instance Bits CInt where {   (CInt x) .&.     (CInt y)   = CInt (x .&.   y) ;   (CInt x) .|.     (CInt y)   = CInt (x .|.   y) ;   (CInt x) `xor`   (CInt y)   = CInt (x `xor` y) ;   complement    (CInt x)   = CInt (complement x) ;   shift         (CInt x) n = CInt (shift x n) ;   rotate        (CInt x) n = CInt (rotate x n) ;   bit                 n = CInt (bit n) ;   setBit        (CInt x) n = CInt (setBit x n) ;   clearBit      (CInt x) n = CInt (clearBit x n) ;   complementBit (CInt x) n = CInt (complementBit x n) ;   testBit       (CInt x) n = testBit x n ;   bitSize       (CInt x)   = bitSize x ;   isSigned      (CInt x)   = isSigned x }
-- | Haskell type representing the C @unsigned int@ type.
newtype CUInt = CUInt Word32 deriving (Eq, Ord) ; instance Num CUInt where {    (CUInt i) + (CUInt j) = CUInt (i + j) ;    (CUInt i) - (CUInt j) = CUInt (i - j) ;    (CUInt i) * (CUInt j) = CUInt (i * j) ;    negate  (CUInt i) = CUInt (negate i) ;    abs     (CUInt i) = CUInt (abs    i) ;    signum  (CUInt i) = CUInt (signum i) ;    fromInteger x = CUInt (fromInteger x) } ; instance Real CUInt where {    toRational (CUInt i) = toRational i } ; instance Read CUInt where {    readsPrec p s = map (\(x, t) -> (CUInt x, t)) (readsPrec p s) } ; instance Show CUInt where {    showsPrec p (CUInt x) = showsPrec p x } ; instance Enum CUInt where {    succ           (CUInt i)             = CUInt (succ i) ;    pred           (CUInt i)             = CUInt (pred i) ;    toEnum               x           = CUInt (toEnum x) ;    fromEnum       (CUInt i)             = fromEnum i ;    enumFrom       (CUInt i)             = map CUInt (enumFrom i) ;    enumFromThen   (CUInt i) (CUInt j)       = map CUInt (enumFromThen i j) ;    enumFromTo     (CUInt i) (CUInt j)       = map CUInt (enumFromTo i j) ;    enumFromThenTo (CUInt i) (CUInt j) (CUInt k) = map CUInt (enumFromThenTo i j k) } ; instance Storable CUInt where {    sizeOf    (CUInt x)       = sizeOf x ;    alignment (CUInt x)       = alignment x ;    peekElemOff a i       = liftM CUInt (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CUInt x) = pokeElemOff (castPtr a) i x } ; tyConCUInt = mkTyCon "CUInt"; instance Typeable CUInt where { typeOf _ = mkTyConApp tyConCUInt [] } ; ; instance Bounded CUInt where {    minBound = CUInt minBound ;    maxBound = CUInt maxBound } ; instance Integral CUInt where {    (CUInt i) `quot`    (CUInt j) = CUInt (i `quot` j) ;    (CUInt i) `rem`     (CUInt j) = CUInt (i `rem`  j) ;    (CUInt i) `div`     (CUInt j) = CUInt (i `div`  j) ;    (CUInt i) `mod`     (CUInt j) = CUInt (i `mod`  j) ;    (CUInt i) `quotRem` (CUInt j) = let (q,r) = i `quotRem` j in (CUInt q, CUInt r) ;    (CUInt i) `divMod`  (CUInt j) = let (d,m) = i `divMod`  j in (CUInt d, CUInt m) ;    toInteger (CUInt i)       = toInteger i } ; instance Bits CUInt where {   (CUInt x) .&.     (CUInt y)   = CUInt (x .&.   y) ;   (CUInt x) .|.     (CUInt y)   = CUInt (x .|.   y) ;   (CUInt x) `xor`   (CUInt y)   = CUInt (x `xor` y) ;   complement    (CUInt x)   = CUInt (complement x) ;   shift         (CUInt x) n = CUInt (shift x n) ;   rotate        (CUInt x) n = CUInt (rotate x n) ;   bit                 n = CUInt (bit n) ;   setBit        (CUInt x) n = CUInt (setBit x n) ;   clearBit      (CUInt x) n = CUInt (clearBit x n) ;   complementBit (CUInt x) n = CUInt (complementBit x n) ;   testBit       (CUInt x) n = testBit x n ;   bitSize       (CUInt x)   = bitSize x ;   isSigned      (CUInt x)   = isSigned x }

-- | Haskell type representing the C @long@ type.
newtype CLong = CLong Int64 deriving (Eq, Ord) ; instance Num CLong where {    (CLong i) + (CLong j) = CLong (i + j) ;    (CLong i) - (CLong j) = CLong (i - j) ;    (CLong i) * (CLong j) = CLong (i * j) ;    negate  (CLong i) = CLong (negate i) ;    abs     (CLong i) = CLong (abs    i) ;    signum  (CLong i) = CLong (signum i) ;    fromInteger x = CLong (fromInteger x) } ; instance Real CLong where {    toRational (CLong i) = toRational i } ; instance Read CLong where {    readsPrec p s = map (\(x, t) -> (CLong x, t)) (readsPrec p s) } ; instance Show CLong where {    showsPrec p (CLong x) = showsPrec p x } ; instance Enum CLong where {    succ           (CLong i)             = CLong (succ i) ;    pred           (CLong i)             = CLong (pred i) ;    toEnum               x           = CLong (toEnum x) ;    fromEnum       (CLong i)             = fromEnum i ;    enumFrom       (CLong i)             = map CLong (enumFrom i) ;    enumFromThen   (CLong i) (CLong j)       = map CLong (enumFromThen i j) ;    enumFromTo     (CLong i) (CLong j)       = map CLong (enumFromTo i j) ;    enumFromThenTo (CLong i) (CLong j) (CLong k) = map CLong (enumFromThenTo i j k) } ; instance Storable CLong where {    sizeOf    (CLong x)       = sizeOf x ;    alignment (CLong x)       = alignment x ;    peekElemOff a i       = liftM CLong (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CLong x) = pokeElemOff (castPtr a) i x } ; tyConCLong = mkTyCon "CLong"; instance Typeable CLong where { typeOf _ = mkTyConApp tyConCLong [] } ; ; instance Bounded CLong where {    minBound = CLong minBound ;    maxBound = CLong maxBound } ; instance Integral CLong where {    (CLong i) `quot`    (CLong j) = CLong (i `quot` j) ;    (CLong i) `rem`     (CLong j) = CLong (i `rem`  j) ;    (CLong i) `div`     (CLong j) = CLong (i `div`  j) ;    (CLong i) `mod`     (CLong j) = CLong (i `mod`  j) ;    (CLong i) `quotRem` (CLong j) = let (q,r) = i `quotRem` j in (CLong q, CLong r) ;    (CLong i) `divMod`  (CLong j) = let (d,m) = i `divMod`  j in (CLong d, CLong m) ;    toInteger (CLong i)       = toInteger i } ; instance Bits CLong where {   (CLong x) .&.     (CLong y)   = CLong (x .&.   y) ;   (CLong x) .|.     (CLong y)   = CLong (x .|.   y) ;   (CLong x) `xor`   (CLong y)   = CLong (x `xor` y) ;   complement    (CLong x)   = CLong (complement x) ;   shift         (CLong x) n = CLong (shift x n) ;   rotate        (CLong x) n = CLong (rotate x n) ;   bit                 n = CLong (bit n) ;   setBit        (CLong x) n = CLong (setBit x n) ;   clearBit      (CLong x) n = CLong (clearBit x n) ;   complementBit (CLong x) n = CLong (complementBit x n) ;   testBit       (CLong x) n = testBit x n ;   bitSize       (CLong x)   = bitSize x ;   isSigned      (CLong x)   = isSigned x }
-- | Haskell type representing the C @unsigned long@ type.
newtype CULong = CULong Word64 deriving (Eq, Ord) ; instance Num CULong where {    (CULong i) + (CULong j) = CULong (i + j) ;    (CULong i) - (CULong j) = CULong (i - j) ;    (CULong i) * (CULong j) = CULong (i * j) ;    negate  (CULong i) = CULong (negate i) ;    abs     (CULong i) = CULong (abs    i) ;    signum  (CULong i) = CULong (signum i) ;    fromInteger x = CULong (fromInteger x) } ; instance Real CULong where {    toRational (CULong i) = toRational i } ; instance Read CULong where {    readsPrec p s = map (\(x, t) -> (CULong x, t)) (readsPrec p s) } ; instance Show CULong where {    showsPrec p (CULong x) = showsPrec p x } ; instance Enum CULong where {    succ           (CULong i)             = CULong (succ i) ;    pred           (CULong i)             = CULong (pred i) ;    toEnum               x           = CULong (toEnum x) ;    fromEnum       (CULong i)             = fromEnum i ;    enumFrom       (CULong i)             = map CULong (enumFrom i) ;    enumFromThen   (CULong i) (CULong j)       = map CULong (enumFromThen i j) ;    enumFromTo     (CULong i) (CULong j)       = map CULong (enumFromTo i j) ;    enumFromThenTo (CULong i) (CULong j) (CULong k) = map CULong (enumFromThenTo i j k) } ; instance Storable CULong where {    sizeOf    (CULong x)       = sizeOf x ;    alignment (CULong x)       = alignment x ;    peekElemOff a i       = liftM CULong (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CULong x) = pokeElemOff (castPtr a) i x } ; tyConCULong = mkTyCon "CULong"; instance Typeable CULong where { typeOf _ = mkTyConApp tyConCULong [] } ; ; instance Bounded CULong where {    minBound = CULong minBound ;    maxBound = CULong maxBound } ; instance Integral CULong where {    (CULong i) `quot`    (CULong j) = CULong (i `quot` j) ;    (CULong i) `rem`     (CULong j) = CULong (i `rem`  j) ;    (CULong i) `div`     (CULong j) = CULong (i `div`  j) ;    (CULong i) `mod`     (CULong j) = CULong (i `mod`  j) ;    (CULong i) `quotRem` (CULong j) = let (q,r) = i `quotRem` j in (CULong q, CULong r) ;    (CULong i) `divMod`  (CULong j) = let (d,m) = i `divMod`  j in (CULong d, CULong m) ;    toInteger (CULong i)       = toInteger i } ; instance Bits CULong where {   (CULong x) .&.     (CULong y)   = CULong (x .&.   y) ;   (CULong x) .|.     (CULong y)   = CULong (x .|.   y) ;   (CULong x) `xor`   (CULong y)   = CULong (x `xor` y) ;   complement    (CULong x)   = CULong (complement x) ;   shift         (CULong x) n = CULong (shift x n) ;   rotate        (CULong x) n = CULong (rotate x n) ;   bit                 n = CULong (bit n) ;   setBit        (CULong x) n = CULong (setBit x n) ;   clearBit      (CULong x) n = CULong (clearBit x n) ;   complementBit (CULong x) n = CULong (complementBit x n) ;   testBit       (CULong x) n = testBit x n ;   bitSize       (CULong x)   = bitSize x ;   isSigned      (CULong x)   = isSigned x }

-- | Haskell type representing the C @long long@ type.
newtype CLLong = CLLong Int64 deriving (Eq, Ord) ; instance Num CLLong where {    (CLLong i) + (CLLong j) = CLLong (i + j) ;    (CLLong i) - (CLLong j) = CLLong (i - j) ;    (CLLong i) * (CLLong j) = CLLong (i * j) ;    negate  (CLLong i) = CLLong (negate i) ;    abs     (CLLong i) = CLLong (abs    i) ;    signum  (CLLong i) = CLLong (signum i) ;    fromInteger x = CLLong (fromInteger x) } ; instance Real CLLong where {    toRational (CLLong i) = toRational i } ; instance Read CLLong where {    readsPrec p s = map (\(x, t) -> (CLLong x, t)) (readsPrec p s) } ; instance Show CLLong where {    showsPrec p (CLLong x) = showsPrec p x } ; instance Enum CLLong where {    succ           (CLLong i)             = CLLong (succ i) ;    pred           (CLLong i)             = CLLong (pred i) ;    toEnum               x           = CLLong (toEnum x) ;    fromEnum       (CLLong i)             = fromEnum i ;    enumFrom       (CLLong i)             = map CLLong (enumFrom i) ;    enumFromThen   (CLLong i) (CLLong j)       = map CLLong (enumFromThen i j) ;    enumFromTo     (CLLong i) (CLLong j)       = map CLLong (enumFromTo i j) ;    enumFromThenTo (CLLong i) (CLLong j) (CLLong k) = map CLLong (enumFromThenTo i j k) } ; instance Storable CLLong where {    sizeOf    (CLLong x)       = sizeOf x ;    alignment (CLLong x)       = alignment x ;    peekElemOff a i       = liftM CLLong (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CLLong x) = pokeElemOff (castPtr a) i x } ; tyConCLLong = mkTyCon "CLLong"; instance Typeable CLLong where { typeOf _ = mkTyConApp tyConCLLong [] } ; ; instance Bounded CLLong where {    minBound = CLLong minBound ;    maxBound = CLLong maxBound } ; instance Integral CLLong where {    (CLLong i) `quot`    (CLLong j) = CLLong (i `quot` j) ;    (CLLong i) `rem`     (CLLong j) = CLLong (i `rem`  j) ;    (CLLong i) `div`     (CLLong j) = CLLong (i `div`  j) ;    (CLLong i) `mod`     (CLLong j) = CLLong (i `mod`  j) ;    (CLLong i) `quotRem` (CLLong j) = let (q,r) = i `quotRem` j in (CLLong q, CLLong r) ;    (CLLong i) `divMod`  (CLLong j) = let (d,m) = i `divMod`  j in (CLLong d, CLLong m) ;    toInteger (CLLong i)       = toInteger i } ; instance Bits CLLong where {   (CLLong x) .&.     (CLLong y)   = CLLong (x .&.   y) ;   (CLLong x) .|.     (CLLong y)   = CLLong (x .|.   y) ;   (CLLong x) `xor`   (CLLong y)   = CLLong (x `xor` y) ;   complement    (CLLong x)   = CLLong (complement x) ;   shift         (CLLong x) n = CLLong (shift x n) ;   rotate        (CLLong x) n = CLLong (rotate x n) ;   bit                 n = CLLong (bit n) ;   setBit        (CLLong x) n = CLLong (setBit x n) ;   clearBit      (CLLong x) n = CLLong (clearBit x n) ;   complementBit (CLLong x) n = CLLong (complementBit x n) ;   testBit       (CLLong x) n = testBit x n ;   bitSize       (CLLong x)   = bitSize x ;   isSigned      (CLLong x)   = isSigned x }
-- | Haskell type representing the C @unsigned long long@ type.
newtype CULLong = CULLong Word64 deriving (Eq, Ord) ; instance Num CULLong where {    (CULLong i) + (CULLong j) = CULLong (i + j) ;    (CULLong i) - (CULLong j) = CULLong (i - j) ;    (CULLong i) * (CULLong j) = CULLong (i * j) ;    negate  (CULLong i) = CULLong (negate i) ;    abs     (CULLong i) = CULLong (abs    i) ;    signum  (CULLong i) = CULLong (signum i) ;    fromInteger x = CULLong (fromInteger x) } ; instance Real CULLong where {    toRational (CULLong i) = toRational i } ; instance Read CULLong where {    readsPrec p s = map (\(x, t) -> (CULLong x, t)) (readsPrec p s) } ; instance Show CULLong where {    showsPrec p (CULLong x) = showsPrec p x } ; instance Enum CULLong where {    succ           (CULLong i)             = CULLong (succ i) ;    pred           (CULLong i)             = CULLong (pred i) ;    toEnum               x           = CULLong (toEnum x) ;    fromEnum       (CULLong i)             = fromEnum i ;    enumFrom       (CULLong i)             = map CULLong (enumFrom i) ;    enumFromThen   (CULLong i) (CULLong j)       = map CULLong (enumFromThen i j) ;    enumFromTo     (CULLong i) (CULLong j)       = map CULLong (enumFromTo i j) ;    enumFromThenTo (CULLong i) (CULLong j) (CULLong k) = map CULLong (enumFromThenTo i j k) } ; instance Storable CULLong where {    sizeOf    (CULLong x)       = sizeOf x ;    alignment (CULLong x)       = alignment x ;    peekElemOff a i       = liftM CULLong (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CULLong x) = pokeElemOff (castPtr a) i x } ; tyConCULLong = mkTyCon "CULLong"; instance Typeable CULLong where { typeOf _ = mkTyConApp tyConCULLong [] } ; ; instance Bounded CULLong where {    minBound = CULLong minBound ;    maxBound = CULLong maxBound } ; instance Integral CULLong where {    (CULLong i) `quot`    (CULLong j) = CULLong (i `quot` j) ;    (CULLong i) `rem`     (CULLong j) = CULLong (i `rem`  j) ;    (CULLong i) `div`     (CULLong j) = CULLong (i `div`  j) ;    (CULLong i) `mod`     (CULLong j) = CULLong (i `mod`  j) ;    (CULLong i) `quotRem` (CULLong j) = let (q,r) = i `quotRem` j in (CULLong q, CULLong r) ;    (CULLong i) `divMod`  (CULLong j) = let (d,m) = i `divMod`  j in (CULLong d, CULLong m) ;    toInteger (CULLong i)       = toInteger i } ; instance Bits CULLong where {   (CULLong x) .&.     (CULLong y)   = CULLong (x .&.   y) ;   (CULLong x) .|.     (CULLong y)   = CULLong (x .|.   y) ;   (CULLong x) `xor`   (CULLong y)   = CULLong (x `xor` y) ;   complement    (CULLong x)   = CULLong (complement x) ;   shift         (CULLong x) n = CULLong (shift x n) ;   rotate        (CULLong x) n = CULLong (rotate x n) ;   bit                 n = CULLong (bit n) ;   setBit        (CULLong x) n = CULLong (setBit x n) ;   clearBit      (CULLong x) n = CULLong (clearBit x n) ;   complementBit (CULLong x) n = CULLong (complementBit x n) ;   testBit       (CULLong x) n = testBit x n ;   bitSize       (CULLong x)   = bitSize x ;   isSigned      (CULLong x)   = isSigned x }

{-# RULES
"fromIntegral/a->CChar"   fromIntegral = \x -> CChar   (fromIntegral x)
"fromIntegral/a->CSChar"  fromIntegral = \x -> CSChar  (fromIntegral x)
"fromIntegral/a->CUChar"  fromIntegral = \x -> CUChar  (fromIntegral x)
"fromIntegral/a->CShort"  fromIntegral = \x -> CShort  (fromIntegral x)
"fromIntegral/a->CUShort" fromIntegral = \x -> CUShort (fromIntegral x)
"fromIntegral/a->CInt"    fromIntegral = \x -> CInt    (fromIntegral x)
"fromIntegral/a->CUInt"   fromIntegral = \x -> CUInt   (fromIntegral x)
"fromIntegral/a->CLong"   fromIntegral = \x -> CLong   (fromIntegral x)
"fromIntegral/a->CULong"  fromIntegral = \x -> CULong  (fromIntegral x)
"fromIntegral/a->CLLong"  fromIntegral = \x -> CLLong  (fromIntegral x)
"fromIntegral/a->CULLong" fromIntegral = \x -> CULLong (fromIntegral x)

"fromIntegral/CChar->a"   fromIntegral = \(CChar   x) -> fromIntegral x
"fromIntegral/CSChar->a"  fromIntegral = \(CSChar  x) -> fromIntegral x
"fromIntegral/CUChar->a"  fromIntegral = \(CUChar  x) -> fromIntegral x
"fromIntegral/CShort->a"  fromIntegral = \(CShort  x) -> fromIntegral x
"fromIntegral/CUShort->a" fromIntegral = \(CUShort x) -> fromIntegral x
"fromIntegral/CInt->a"    fromIntegral = \(CInt    x) -> fromIntegral x
"fromIntegral/CUInt->a"   fromIntegral = \(CUInt   x) -> fromIntegral x
"fromIntegral/CLong->a"   fromIntegral = \(CLong   x) -> fromIntegral x
"fromIntegral/CULong->a"  fromIntegral = \(CULong  x) -> fromIntegral x
"fromIntegral/CLLong->a"  fromIntegral = \(CLLong  x) -> fromIntegral x
"fromIntegral/CULLong->a" fromIntegral = \(CULLong x) -> fromIntegral x
 #-}

-- | Haskell type representing the C @float@ type.
newtype CFloat = CFloat Float deriving (Eq, Ord) ; instance Num CFloat where {    (CFloat i) + (CFloat j) = CFloat (i + j) ;    (CFloat i) - (CFloat j) = CFloat (i - j) ;    (CFloat i) * (CFloat j) = CFloat (i * j) ;    negate  (CFloat i) = CFloat (negate i) ;    abs     (CFloat i) = CFloat (abs    i) ;    signum  (CFloat i) = CFloat (signum i) ;    fromInteger x = CFloat (fromInteger x) } ; instance Real CFloat where {    toRational (CFloat i) = toRational i } ; instance Read CFloat where {    readsPrec p s = map (\(x, t) -> (CFloat x, t)) (readsPrec p s) } ; instance Show CFloat where {    showsPrec p (CFloat x) = showsPrec p x } ; instance Enum CFloat where {    succ           (CFloat i)             = CFloat (succ i) ;    pred           (CFloat i)             = CFloat (pred i) ;    toEnum               x           = CFloat (toEnum x) ;    fromEnum       (CFloat i)             = fromEnum i ;    enumFrom       (CFloat i)             = map CFloat (enumFrom i) ;    enumFromThen   (CFloat i) (CFloat j)       = map CFloat (enumFromThen i j) ;    enumFromTo     (CFloat i) (CFloat j)       = map CFloat (enumFromTo i j) ;    enumFromThenTo (CFloat i) (CFloat j) (CFloat k) = map CFloat (enumFromThenTo i j k) } ; instance Storable CFloat where {    sizeOf    (CFloat x)       = sizeOf x ;    alignment (CFloat x)       = alignment x ;    peekElemOff a i       = liftM CFloat (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CFloat x) = pokeElemOff (castPtr a) i x } ; tyConCFloat = mkTyCon "CFloat"; instance Typeable CFloat where { typeOf _ = mkTyConApp tyConCFloat [] } ; ; instance Fractional CFloat where {    (CFloat x) / (CFloat y)  = CFloat (x / y) ;    recip   (CFloat x)  = CFloat (recip x) ;    fromRational	r = CFloat (fromRational r) } ; instance Floating CFloat where {    pi                    = pi ;    exp   (CFloat x)           = CFloat (exp   x) ;    log   (CFloat x)           = CFloat (log   x) ;    sqrt  (CFloat x)           = CFloat (sqrt  x) ;    (CFloat x) **        (CFloat y) = CFloat (x ** y) ;    (CFloat x) `logBase` (CFloat y) = CFloat (x `logBase` y) ;    sin   (CFloat x)           = CFloat (sin   x) ;    cos   (CFloat x)           = CFloat (cos   x) ;    tan   (CFloat x)           = CFloat (tan   x) ;    asin  (CFloat x)           = CFloat (asin  x) ;    acos  (CFloat x)           = CFloat (acos  x) ;    atan  (CFloat x)           = CFloat (atan  x) ;    sinh  (CFloat x)           = CFloat (sinh  x) ;    cosh  (CFloat x)           = CFloat (cosh  x) ;    tanh  (CFloat x)           = CFloat (tanh  x) ;    asinh (CFloat x)           = CFloat (asinh x) ;    acosh (CFloat x)           = CFloat (acosh x) ;    atanh (CFloat x)           = CFloat (atanh x) } ; instance RealFrac CFloat where {    properFraction (CFloat x) = let (m,y) = properFraction x in (m, CFloat y) ;    truncate (CFloat x) = truncate x ;    round    (CFloat x) = round x ;    ceiling  (CFloat x) = ceiling x ;    floor    (CFloat x) = floor x } ; instance RealFloat CFloat where {    floatRadix     (CFloat x) = floatRadix x ;    floatDigits    (CFloat x) = floatDigits x ;    floatRange     (CFloat x) = floatRange x ;    decodeFloat    (CFloat x) = decodeFloat x ;    encodeFloat m n      = CFloat (encodeFloat m n) ;    exponent       (CFloat x) = exponent x ;    significand    (CFloat x) = CFloat (significand  x) ;    scaleFloat n   (CFloat x) = CFloat (scaleFloat n x) ;    isNaN          (CFloat x) = isNaN x ;    isInfinite     (CFloat x) = isInfinite x ;    isDenormalized (CFloat x) = isDenormalized x ;    isNegativeZero (CFloat x) = isNegativeZero x ;    isIEEE         (CFloat x) = isIEEE x ;    (CFloat x) `atan2`  (CFloat y) = CFloat (x `atan2` y) }
-- | Haskell type representing the C @double@ type.
newtype CDouble = CDouble Double deriving (Eq, Ord) ; instance Num CDouble where {    (CDouble i) + (CDouble j) = CDouble (i + j) ;    (CDouble i) - (CDouble j) = CDouble (i - j) ;    (CDouble i) * (CDouble j) = CDouble (i * j) ;    negate  (CDouble i) = CDouble (negate i) ;    abs     (CDouble i) = CDouble (abs    i) ;    signum  (CDouble i) = CDouble (signum i) ;    fromInteger x = CDouble (fromInteger x) } ; instance Real CDouble where {    toRational (CDouble i) = toRational i } ; instance Read CDouble where {    readsPrec p s = map (\(x, t) -> (CDouble x, t)) (readsPrec p s) } ; instance Show CDouble where {    showsPrec p (CDouble x) = showsPrec p x } ; instance Enum CDouble where {    succ           (CDouble i)             = CDouble (succ i) ;    pred           (CDouble i)             = CDouble (pred i) ;    toEnum               x           = CDouble (toEnum x) ;    fromEnum       (CDouble i)             = fromEnum i ;    enumFrom       (CDouble i)             = map CDouble (enumFrom i) ;    enumFromThen   (CDouble i) (CDouble j)       = map CDouble (enumFromThen i j) ;    enumFromTo     (CDouble i) (CDouble j)       = map CDouble (enumFromTo i j) ;    enumFromThenTo (CDouble i) (CDouble j) (CDouble k) = map CDouble (enumFromThenTo i j k) } ; instance Storable CDouble where {    sizeOf    (CDouble x)       = sizeOf x ;    alignment (CDouble x)       = alignment x ;    peekElemOff a i       = liftM CDouble (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CDouble x) = pokeElemOff (castPtr a) i x } ; tyConCDouble = mkTyCon "CDouble"; instance Typeable CDouble where { typeOf _ = mkTyConApp tyConCDouble [] } ; ; instance Fractional CDouble where {    (CDouble x) / (CDouble y)  = CDouble (x / y) ;    recip   (CDouble x)  = CDouble (recip x) ;    fromRational	r = CDouble (fromRational r) } ; instance Floating CDouble where {    pi                    = pi ;    exp   (CDouble x)           = CDouble (exp   x) ;    log   (CDouble x)           = CDouble (log   x) ;    sqrt  (CDouble x)           = CDouble (sqrt  x) ;    (CDouble x) **        (CDouble y) = CDouble (x ** y) ;    (CDouble x) `logBase` (CDouble y) = CDouble (x `logBase` y) ;    sin   (CDouble x)           = CDouble (sin   x) ;    cos   (CDouble x)           = CDouble (cos   x) ;    tan   (CDouble x)           = CDouble (tan   x) ;    asin  (CDouble x)           = CDouble (asin  x) ;    acos  (CDouble x)           = CDouble (acos  x) ;    atan  (CDouble x)           = CDouble (atan  x) ;    sinh  (CDouble x)           = CDouble (sinh  x) ;    cosh  (CDouble x)           = CDouble (cosh  x) ;    tanh  (CDouble x)           = CDouble (tanh  x) ;    asinh (CDouble x)           = CDouble (asinh x) ;    acosh (CDouble x)           = CDouble (acosh x) ;    atanh (CDouble x)           = CDouble (atanh x) } ; instance RealFrac CDouble where {    properFraction (CDouble x) = let (m,y) = properFraction x in (m, CDouble y) ;    truncate (CDouble x) = truncate x ;    round    (CDouble x) = round x ;    ceiling  (CDouble x) = ceiling x ;    floor    (CDouble x) = floor x } ; instance RealFloat CDouble where {    floatRadix     (CDouble x) = floatRadix x ;    floatDigits    (CDouble x) = floatDigits x ;    floatRange     (CDouble x) = floatRange x ;    decodeFloat    (CDouble x) = decodeFloat x ;    encodeFloat m n      = CDouble (encodeFloat m n) ;    exponent       (CDouble x) = exponent x ;    significand    (CDouble x) = CDouble (significand  x) ;    scaleFloat n   (CDouble x) = CDouble (scaleFloat n x) ;    isNaN          (CDouble x) = isNaN x ;    isInfinite     (CDouble x) = isInfinite x ;    isDenormalized (CDouble x) = isDenormalized x ;    isNegativeZero (CDouble x) = isNegativeZero x ;    isIEEE         (CDouble x) = isIEEE x ;    (CDouble x) `atan2`  (CDouble y) = CDouble (x `atan2` y) }
-- HACK: Currently no long double in the FFI, so we simply re-use double
-- | Haskell type representing the C @long double@ type.
newtype CLDouble = CLDouble Double deriving (Eq, Ord) ; instance Num CLDouble where {    (CLDouble i) + (CLDouble j) = CLDouble (i + j) ;    (CLDouble i) - (CLDouble j) = CLDouble (i - j) ;    (CLDouble i) * (CLDouble j) = CLDouble (i * j) ;    negate  (CLDouble i) = CLDouble (negate i) ;    abs     (CLDouble i) = CLDouble (abs    i) ;    signum  (CLDouble i) = CLDouble (signum i) ;    fromInteger x = CLDouble (fromInteger x) } ; instance Real CLDouble where {    toRational (CLDouble i) = toRational i } ; instance Read CLDouble where {    readsPrec p s = map (\(x, t) -> (CLDouble x, t)) (readsPrec p s) } ; instance Show CLDouble where {    showsPrec p (CLDouble x) = showsPrec p x } ; instance Enum CLDouble where {    succ           (CLDouble i)             = CLDouble (succ i) ;    pred           (CLDouble i)             = CLDouble (pred i) ;    toEnum               x           = CLDouble (toEnum x) ;    fromEnum       (CLDouble i)             = fromEnum i ;    enumFrom       (CLDouble i)             = map CLDouble (enumFrom i) ;    enumFromThen   (CLDouble i) (CLDouble j)       = map CLDouble (enumFromThen i j) ;    enumFromTo     (CLDouble i) (CLDouble j)       = map CLDouble (enumFromTo i j) ;    enumFromThenTo (CLDouble i) (CLDouble j) (CLDouble k) = map CLDouble (enumFromThenTo i j k) } ; instance Storable CLDouble where {    sizeOf    (CLDouble x)       = sizeOf x ;    alignment (CLDouble x)       = alignment x ;    peekElemOff a i       = liftM CLDouble (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CLDouble x) = pokeElemOff (castPtr a) i x } ; tyConCLDouble = mkTyCon "CLDouble"; instance Typeable CLDouble where { typeOf _ = mkTyConApp tyConCLDouble [] } ; ; instance Fractional CLDouble where {    (CLDouble x) / (CLDouble y)  = CLDouble (x / y) ;    recip   (CLDouble x)  = CLDouble (recip x) ;    fromRational	r = CLDouble (fromRational r) } ; instance Floating CLDouble where {    pi                    = pi ;    exp   (CLDouble x)           = CLDouble (exp   x) ;    log   (CLDouble x)           = CLDouble (log   x) ;    sqrt  (CLDouble x)           = CLDouble (sqrt  x) ;    (CLDouble x) **        (CLDouble y) = CLDouble (x ** y) ;    (CLDouble x) `logBase` (CLDouble y) = CLDouble (x `logBase` y) ;    sin   (CLDouble x)           = CLDouble (sin   x) ;    cos   (CLDouble x)           = CLDouble (cos   x) ;    tan   (CLDouble x)           = CLDouble (tan   x) ;    asin  (CLDouble x)           = CLDouble (asin  x) ;    acos  (CLDouble x)           = CLDouble (acos  x) ;    atan  (CLDouble x)           = CLDouble (atan  x) ;    sinh  (CLDouble x)           = CLDouble (sinh  x) ;    cosh  (CLDouble x)           = CLDouble (cosh  x) ;    tanh  (CLDouble x)           = CLDouble (tanh  x) ;    asinh (CLDouble x)           = CLDouble (asinh x) ;    acosh (CLDouble x)           = CLDouble (acosh x) ;    atanh (CLDouble x)           = CLDouble (atanh x) } ; instance RealFrac CLDouble where {    properFraction (CLDouble x) = let (m,y) = properFraction x in (m, CLDouble y) ;    truncate (CLDouble x) = truncate x ;    round    (CLDouble x) = round x ;    ceiling  (CLDouble x) = ceiling x ;    floor    (CLDouble x) = floor x } ; instance RealFloat CLDouble where {    floatRadix     (CLDouble x) = floatRadix x ;    floatDigits    (CLDouble x) = floatDigits x ;    floatRange     (CLDouble x) = floatRange x ;    decodeFloat    (CLDouble x) = decodeFloat x ;    encodeFloat m n      = CLDouble (encodeFloat m n) ;    exponent       (CLDouble x) = exponent x ;    significand    (CLDouble x) = CLDouble (significand  x) ;    scaleFloat n   (CLDouble x) = CLDouble (scaleFloat n x) ;    isNaN          (CLDouble x) = isNaN x ;    isInfinite     (CLDouble x) = isInfinite x ;    isDenormalized (CLDouble x) = isDenormalized x ;    isNegativeZero (CLDouble x) = isNegativeZero x ;    isIEEE         (CLDouble x) = isIEEE x ;    (CLDouble x) `atan2`  (CLDouble y) = CLDouble (x `atan2` y) }

{-# RULES
"realToFrac/a->CFloat"    realToFrac = \x -> CFloat   (realToFrac x)
"realToFrac/a->CDouble"   realToFrac = \x -> CDouble  (realToFrac x)
"realToFrac/a->CLDouble"  realToFrac = \x -> CLDouble (realToFrac x)

"realToFrac/CFloat->a"    realToFrac = \(CFloat   x) -> realToFrac x
"realToFrac/CDouble->a"   realToFrac = \(CDouble  x) -> realToFrac x
"realToFrac/CLDouble->a"  realToFrac = \(CLDouble x) -> realToFrac x
 #-}

-- | Haskell type representing the C @ptrdiff_t@ type.
newtype CPtrdiff = CPtrdiff Int64 deriving (Eq, Ord) ; instance Num CPtrdiff where {    (CPtrdiff i) + (CPtrdiff j) = CPtrdiff (i + j) ;    (CPtrdiff i) - (CPtrdiff j) = CPtrdiff (i - j) ;    (CPtrdiff i) * (CPtrdiff j) = CPtrdiff (i * j) ;    negate  (CPtrdiff i) = CPtrdiff (negate i) ;    abs     (CPtrdiff i) = CPtrdiff (abs    i) ;    signum  (CPtrdiff i) = CPtrdiff (signum i) ;    fromInteger x = CPtrdiff (fromInteger x) } ; instance Real CPtrdiff where {    toRational (CPtrdiff i) = toRational i } ; instance Read CPtrdiff where {    readsPrec p s = map (\(x, t) -> (CPtrdiff x, t)) (readsPrec p s) } ; instance Show CPtrdiff where {    showsPrec p (CPtrdiff x) = showsPrec p x } ; instance Enum CPtrdiff where {    succ           (CPtrdiff i)             = CPtrdiff (succ i) ;    pred           (CPtrdiff i)             = CPtrdiff (pred i) ;    toEnum               x           = CPtrdiff (toEnum x) ;    fromEnum       (CPtrdiff i)             = fromEnum i ;    enumFrom       (CPtrdiff i)             = map CPtrdiff (enumFrom i) ;    enumFromThen   (CPtrdiff i) (CPtrdiff j)       = map CPtrdiff (enumFromThen i j) ;    enumFromTo     (CPtrdiff i) (CPtrdiff j)       = map CPtrdiff (enumFromTo i j) ;    enumFromThenTo (CPtrdiff i) (CPtrdiff j) (CPtrdiff k) = map CPtrdiff (enumFromThenTo i j k) } ; instance Storable CPtrdiff where {    sizeOf    (CPtrdiff x)       = sizeOf x ;    alignment (CPtrdiff x)       = alignment x ;    peekElemOff a i       = liftM CPtrdiff (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CPtrdiff x) = pokeElemOff (castPtr a) i x } ; tyConCPtrdiff = mkTyCon "CPtrdiff"; instance Typeable CPtrdiff where { typeOf _ = mkTyConApp tyConCPtrdiff [] } ; ; instance Bounded CPtrdiff where {    minBound = CPtrdiff minBound ;    maxBound = CPtrdiff maxBound } ; instance Integral CPtrdiff where {    (CPtrdiff i) `quot`    (CPtrdiff j) = CPtrdiff (i `quot` j) ;    (CPtrdiff i) `rem`     (CPtrdiff j) = CPtrdiff (i `rem`  j) ;    (CPtrdiff i) `div`     (CPtrdiff j) = CPtrdiff (i `div`  j) ;    (CPtrdiff i) `mod`     (CPtrdiff j) = CPtrdiff (i `mod`  j) ;    (CPtrdiff i) `quotRem` (CPtrdiff j) = let (q,r) = i `quotRem` j in (CPtrdiff q, CPtrdiff r) ;    (CPtrdiff i) `divMod`  (CPtrdiff j) = let (d,m) = i `divMod`  j in (CPtrdiff d, CPtrdiff m) ;    toInteger (CPtrdiff i)       = toInteger i } ; instance Bits CPtrdiff where {   (CPtrdiff x) .&.     (CPtrdiff y)   = CPtrdiff (x .&.   y) ;   (CPtrdiff x) .|.     (CPtrdiff y)   = CPtrdiff (x .|.   y) ;   (CPtrdiff x) `xor`   (CPtrdiff y)   = CPtrdiff (x `xor` y) ;   complement    (CPtrdiff x)   = CPtrdiff (complement x) ;   shift         (CPtrdiff x) n = CPtrdiff (shift x n) ;   rotate        (CPtrdiff x) n = CPtrdiff (rotate x n) ;   bit                 n = CPtrdiff (bit n) ;   setBit        (CPtrdiff x) n = CPtrdiff (setBit x n) ;   clearBit      (CPtrdiff x) n = CPtrdiff (clearBit x n) ;   complementBit (CPtrdiff x) n = CPtrdiff (complementBit x n) ;   testBit       (CPtrdiff x) n = testBit x n ;   bitSize       (CPtrdiff x)   = bitSize x ;   isSigned      (CPtrdiff x)   = isSigned x }
-- | Haskell type representing the C @size_t@ type.
newtype CSize = CSize Word64 deriving (Eq, Ord) ; instance Num CSize where {    (CSize i) + (CSize j) = CSize (i + j) ;    (CSize i) - (CSize j) = CSize (i - j) ;    (CSize i) * (CSize j) = CSize (i * j) ;    negate  (CSize i) = CSize (negate i) ;    abs     (CSize i) = CSize (abs    i) ;    signum  (CSize i) = CSize (signum i) ;    fromInteger x = CSize (fromInteger x) } ; instance Real CSize where {    toRational (CSize i) = toRational i } ; instance Read CSize where {    readsPrec p s = map (\(x, t) -> (CSize x, t)) (readsPrec p s) } ; instance Show CSize where {    showsPrec p (CSize x) = showsPrec p x } ; instance Enum CSize where {    succ           (CSize i)             = CSize (succ i) ;    pred           (CSize i)             = CSize (pred i) ;    toEnum               x           = CSize (toEnum x) ;    fromEnum       (CSize i)             = fromEnum i ;    enumFrom       (CSize i)             = map CSize (enumFrom i) ;    enumFromThen   (CSize i) (CSize j)       = map CSize (enumFromThen i j) ;    enumFromTo     (CSize i) (CSize j)       = map CSize (enumFromTo i j) ;    enumFromThenTo (CSize i) (CSize j) (CSize k) = map CSize (enumFromThenTo i j k) } ; instance Storable CSize where {    sizeOf    (CSize x)       = sizeOf x ;    alignment (CSize x)       = alignment x ;    peekElemOff a i       = liftM CSize (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CSize x) = pokeElemOff (castPtr a) i x } ; tyConCSize = mkTyCon "CSize"; instance Typeable CSize where { typeOf _ = mkTyConApp tyConCSize [] } ; ; instance Bounded CSize where {    minBound = CSize minBound ;    maxBound = CSize maxBound } ; instance Integral CSize where {    (CSize i) `quot`    (CSize j) = CSize (i `quot` j) ;    (CSize i) `rem`     (CSize j) = CSize (i `rem`  j) ;    (CSize i) `div`     (CSize j) = CSize (i `div`  j) ;    (CSize i) `mod`     (CSize j) = CSize (i `mod`  j) ;    (CSize i) `quotRem` (CSize j) = let (q,r) = i `quotRem` j in (CSize q, CSize r) ;    (CSize i) `divMod`  (CSize j) = let (d,m) = i `divMod`  j in (CSize d, CSize m) ;    toInteger (CSize i)       = toInteger i } ; instance Bits CSize where {   (CSize x) .&.     (CSize y)   = CSize (x .&.   y) ;   (CSize x) .|.     (CSize y)   = CSize (x .|.   y) ;   (CSize x) `xor`   (CSize y)   = CSize (x `xor` y) ;   complement    (CSize x)   = CSize (complement x) ;   shift         (CSize x) n = CSize (shift x n) ;   rotate        (CSize x) n = CSize (rotate x n) ;   bit                 n = CSize (bit n) ;   setBit        (CSize x) n = CSize (setBit x n) ;   clearBit      (CSize x) n = CSize (clearBit x n) ;   complementBit (CSize x) n = CSize (complementBit x n) ;   testBit       (CSize x) n = testBit x n ;   bitSize       (CSize x)   = bitSize x ;   isSigned      (CSize x)   = isSigned x }
-- | Haskell type representing the C @wchar_t@ type.
newtype CWchar = CWchar Int32 deriving (Eq, Ord) ; instance Num CWchar where {    (CWchar i) + (CWchar j) = CWchar (i + j) ;    (CWchar i) - (CWchar j) = CWchar (i - j) ;    (CWchar i) * (CWchar j) = CWchar (i * j) ;    negate  (CWchar i) = CWchar (negate i) ;    abs     (CWchar i) = CWchar (abs    i) ;    signum  (CWchar i) = CWchar (signum i) ;    fromInteger x = CWchar (fromInteger x) } ; instance Real CWchar where {    toRational (CWchar i) = toRational i } ; instance Read CWchar where {    readsPrec p s = map (\(x, t) -> (CWchar x, t)) (readsPrec p s) } ; instance Show CWchar where {    showsPrec p (CWchar x) = showsPrec p x } ; instance Enum CWchar where {    succ           (CWchar i)             = CWchar (succ i) ;    pred           (CWchar i)             = CWchar (pred i) ;    toEnum               x           = CWchar (toEnum x) ;    fromEnum       (CWchar i)             = fromEnum i ;    enumFrom       (CWchar i)             = map CWchar (enumFrom i) ;    enumFromThen   (CWchar i) (CWchar j)       = map CWchar (enumFromThen i j) ;    enumFromTo     (CWchar i) (CWchar j)       = map CWchar (enumFromTo i j) ;    enumFromThenTo (CWchar i) (CWchar j) (CWchar k) = map CWchar (enumFromThenTo i j k) } ; instance Storable CWchar where {    sizeOf    (CWchar x)       = sizeOf x ;    alignment (CWchar x)       = alignment x ;    peekElemOff a i       = liftM CWchar (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CWchar x) = pokeElemOff (castPtr a) i x } ; tyConCWchar = mkTyCon "CWchar"; instance Typeable CWchar where { typeOf _ = mkTyConApp tyConCWchar [] } ; ; instance Bounded CWchar where {    minBound = CWchar minBound ;    maxBound = CWchar maxBound } ; instance Integral CWchar where {    (CWchar i) `quot`    (CWchar j) = CWchar (i `quot` j) ;    (CWchar i) `rem`     (CWchar j) = CWchar (i `rem`  j) ;    (CWchar i) `div`     (CWchar j) = CWchar (i `div`  j) ;    (CWchar i) `mod`     (CWchar j) = CWchar (i `mod`  j) ;    (CWchar i) `quotRem` (CWchar j) = let (q,r) = i `quotRem` j in (CWchar q, CWchar r) ;    (CWchar i) `divMod`  (CWchar j) = let (d,m) = i `divMod`  j in (CWchar d, CWchar m) ;    toInteger (CWchar i)       = toInteger i } ; instance Bits CWchar where {   (CWchar x) .&.     (CWchar y)   = CWchar (x .&.   y) ;   (CWchar x) .|.     (CWchar y)   = CWchar (x .|.   y) ;   (CWchar x) `xor`   (CWchar y)   = CWchar (x `xor` y) ;   complement    (CWchar x)   = CWchar (complement x) ;   shift         (CWchar x) n = CWchar (shift x n) ;   rotate        (CWchar x) n = CWchar (rotate x n) ;   bit                 n = CWchar (bit n) ;   setBit        (CWchar x) n = CWchar (setBit x n) ;   clearBit      (CWchar x) n = CWchar (clearBit x n) ;   complementBit (CWchar x) n = CWchar (complementBit x n) ;   testBit       (CWchar x) n = testBit x n ;   bitSize       (CWchar x)   = bitSize x ;   isSigned      (CWchar x)   = isSigned x }
-- | Haskell type representing the C @sig_atomic_t@ type.
newtype CSigAtomic = CSigAtomic Int32 deriving (Eq, Ord) ; instance Num CSigAtomic where {    (CSigAtomic i) + (CSigAtomic j) = CSigAtomic (i + j) ;    (CSigAtomic i) - (CSigAtomic j) = CSigAtomic (i - j) ;    (CSigAtomic i) * (CSigAtomic j) = CSigAtomic (i * j) ;    negate  (CSigAtomic i) = CSigAtomic (negate i) ;    abs     (CSigAtomic i) = CSigAtomic (abs    i) ;    signum  (CSigAtomic i) = CSigAtomic (signum i) ;    fromInteger x = CSigAtomic (fromInteger x) } ; instance Real CSigAtomic where {    toRational (CSigAtomic i) = toRational i } ; instance Read CSigAtomic where {    readsPrec p s = map (\(x, t) -> (CSigAtomic x, t)) (readsPrec p s) } ; instance Show CSigAtomic where {    showsPrec p (CSigAtomic x) = showsPrec p x } ; instance Enum CSigAtomic where {    succ           (CSigAtomic i)             = CSigAtomic (succ i) ;    pred           (CSigAtomic i)             = CSigAtomic (pred i) ;    toEnum               x           = CSigAtomic (toEnum x) ;    fromEnum       (CSigAtomic i)             = fromEnum i ;    enumFrom       (CSigAtomic i)             = map CSigAtomic (enumFrom i) ;    enumFromThen   (CSigAtomic i) (CSigAtomic j)       = map CSigAtomic (enumFromThen i j) ;    enumFromTo     (CSigAtomic i) (CSigAtomic j)       = map CSigAtomic (enumFromTo i j) ;    enumFromThenTo (CSigAtomic i) (CSigAtomic j) (CSigAtomic k) = map CSigAtomic (enumFromThenTo i j k) } ; instance Storable CSigAtomic where {    sizeOf    (CSigAtomic x)       = sizeOf x ;    alignment (CSigAtomic x)       = alignment x ;    peekElemOff a i       = liftM CSigAtomic (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CSigAtomic x) = pokeElemOff (castPtr a) i x } ; tyConCSigAtomic = mkTyCon "CSigAtomic"; instance Typeable CSigAtomic where { typeOf _ = mkTyConApp tyConCSigAtomic [] } ; ; instance Bounded CSigAtomic where {    minBound = CSigAtomic minBound ;    maxBound = CSigAtomic maxBound } ; instance Integral CSigAtomic where {    (CSigAtomic i) `quot`    (CSigAtomic j) = CSigAtomic (i `quot` j) ;    (CSigAtomic i) `rem`     (CSigAtomic j) = CSigAtomic (i `rem`  j) ;    (CSigAtomic i) `div`     (CSigAtomic j) = CSigAtomic (i `div`  j) ;    (CSigAtomic i) `mod`     (CSigAtomic j) = CSigAtomic (i `mod`  j) ;    (CSigAtomic i) `quotRem` (CSigAtomic j) = let (q,r) = i `quotRem` j in (CSigAtomic q, CSigAtomic r) ;    (CSigAtomic i) `divMod`  (CSigAtomic j) = let (d,m) = i `divMod`  j in (CSigAtomic d, CSigAtomic m) ;    toInteger (CSigAtomic i)       = toInteger i } ; instance Bits CSigAtomic where {   (CSigAtomic x) .&.     (CSigAtomic y)   = CSigAtomic (x .&.   y) ;   (CSigAtomic x) .|.     (CSigAtomic y)   = CSigAtomic (x .|.   y) ;   (CSigAtomic x) `xor`   (CSigAtomic y)   = CSigAtomic (x `xor` y) ;   complement    (CSigAtomic x)   = CSigAtomic (complement x) ;   shift         (CSigAtomic x) n = CSigAtomic (shift x n) ;   rotate        (CSigAtomic x) n = CSigAtomic (rotate x n) ;   bit                 n = CSigAtomic (bit n) ;   setBit        (CSigAtomic x) n = CSigAtomic (setBit x n) ;   clearBit      (CSigAtomic x) n = CSigAtomic (clearBit x n) ;   complementBit (CSigAtomic x) n = CSigAtomic (complementBit x n) ;   testBit       (CSigAtomic x) n = testBit x n ;   bitSize       (CSigAtomic x)   = bitSize x ;   isSigned      (CSigAtomic x)   = isSigned x }

{-# RULES
"fromIntegral/a->CPtrdiff"   fromIntegral = \x -> CPtrdiff   (fromIntegral x)
"fromIntegral/a->CSize"      fromIntegral = \x -> CSize      (fromIntegral x)
"fromIntegral/a->CWchar"     fromIntegral = \x -> CWchar     (fromIntegral x)
"fromIntegral/a->CSigAtomic" fromIntegral = \x -> CSigAtomic (fromIntegral x)

"fromIntegral/CPtrdiff->a"   fromIntegral = \(CPtrdiff   x) -> fromIntegral x
"fromIntegral/CSize->a"      fromIntegral = \(CSize      x) -> fromIntegral x
"fromIntegral/CWchar->a"     fromIntegral = \(CWchar     x) -> fromIntegral x
"fromIntegral/CSigAtomic->a" fromIntegral = \(CSigAtomic x) -> fromIntegral x
 #-}

-- | Haskell type representing the C @clock_t@ type.
newtype CClock = CClock Int64 deriving (Eq, Ord) ; instance Num CClock where {    (CClock i) + (CClock j) = CClock (i + j) ;    (CClock i) - (CClock j) = CClock (i - j) ;    (CClock i) * (CClock j) = CClock (i * j) ;    negate  (CClock i) = CClock (negate i) ;    abs     (CClock i) = CClock (abs    i) ;    signum  (CClock i) = CClock (signum i) ;    fromInteger x = CClock (fromInteger x) } ; instance Real CClock where {    toRational (CClock i) = toRational i } ; instance Read CClock where {    readsPrec p s = map (\(x, t) -> (CClock x, t)) (readsPrec p s) } ; instance Show CClock where {    showsPrec p (CClock x) = showsPrec p x } ; instance Enum CClock where {    succ           (CClock i)             = CClock (succ i) ;    pred           (CClock i)             = CClock (pred i) ;    toEnum               x           = CClock (toEnum x) ;    fromEnum       (CClock i)             = fromEnum i ;    enumFrom       (CClock i)             = map CClock (enumFrom i) ;    enumFromThen   (CClock i) (CClock j)       = map CClock (enumFromThen i j) ;    enumFromTo     (CClock i) (CClock j)       = map CClock (enumFromTo i j) ;    enumFromThenTo (CClock i) (CClock j) (CClock k) = map CClock (enumFromThenTo i j k) } ; instance Storable CClock where {    sizeOf    (CClock x)       = sizeOf x ;    alignment (CClock x)       = alignment x ;    peekElemOff a i       = liftM CClock (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CClock x) = pokeElemOff (castPtr a) i x } ; tyConCClock = mkTyCon "CClock"; instance Typeable CClock where { typeOf _ = mkTyConApp tyConCClock [] } ;
-- | Haskell type representing the C @time_t@ type.
newtype CTime = CTime Int64 deriving (Eq, Ord) ; instance Num CTime where {    (CTime i) + (CTime j) = CTime (i + j) ;    (CTime i) - (CTime j) = CTime (i - j) ;    (CTime i) * (CTime j) = CTime (i * j) ;    negate  (CTime i) = CTime (negate i) ;    abs     (CTime i) = CTime (abs    i) ;    signum  (CTime i) = CTime (signum i) ;    fromInteger x = CTime (fromInteger x) } ; instance Real CTime where {    toRational (CTime i) = toRational i } ; instance Read CTime where {    readsPrec p s = map (\(x, t) -> (CTime x, t)) (readsPrec p s) } ; instance Show CTime where {    showsPrec p (CTime x) = showsPrec p x } ; instance Enum CTime where {    succ           (CTime i)             = CTime (succ i) ;    pred           (CTime i)             = CTime (pred i) ;    toEnum               x           = CTime (toEnum x) ;    fromEnum       (CTime i)             = fromEnum i ;    enumFrom       (CTime i)             = map CTime (enumFrom i) ;    enumFromThen   (CTime i) (CTime j)       = map CTime (enumFromThen i j) ;    enumFromTo     (CTime i) (CTime j)       = map CTime (enumFromTo i j) ;    enumFromThenTo (CTime i) (CTime j) (CTime k) = map CTime (enumFromThenTo i j k) } ; instance Storable CTime where {    sizeOf    (CTime x)       = sizeOf x ;    alignment (CTime x)       = alignment x ;    peekElemOff a i       = liftM CTime (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CTime x) = pokeElemOff (castPtr a) i x } ; tyConCTime = mkTyCon "CTime"; instance Typeable CTime where { typeOf _ = mkTyConApp tyConCTime [] } ;

-- FIXME: Implement and provide instances for Eq and Storable
-- | Haskell type representing the C @FILE@ type.
data CFile = CFile
-- | Haskell type representing the C @fpos_t@ type.
data CFpos = CFpos
-- | Haskell type representing the C @jmp_buf@ type.
data CJmpBuf = CJmpBuf

newtype CIntPtr = CIntPtr Int64 deriving (Eq, Ord) ; instance Num CIntPtr where {    (CIntPtr i) + (CIntPtr j) = CIntPtr (i + j) ;    (CIntPtr i) - (CIntPtr j) = CIntPtr (i - j) ;    (CIntPtr i) * (CIntPtr j) = CIntPtr (i * j) ;    negate  (CIntPtr i) = CIntPtr (negate i) ;    abs     (CIntPtr i) = CIntPtr (abs    i) ;    signum  (CIntPtr i) = CIntPtr (signum i) ;    fromInteger x = CIntPtr (fromInteger x) } ; instance Real CIntPtr where {    toRational (CIntPtr i) = toRational i } ; instance Read CIntPtr where {    readsPrec p s = map (\(x, t) -> (CIntPtr x, t)) (readsPrec p s) } ; instance Show CIntPtr where {    showsPrec p (CIntPtr x) = showsPrec p x } ; instance Enum CIntPtr where {    succ           (CIntPtr i)             = CIntPtr (succ i) ;    pred           (CIntPtr i)             = CIntPtr (pred i) ;    toEnum               x           = CIntPtr (toEnum x) ;    fromEnum       (CIntPtr i)             = fromEnum i ;    enumFrom       (CIntPtr i)             = map CIntPtr (enumFrom i) ;    enumFromThen   (CIntPtr i) (CIntPtr j)       = map CIntPtr (enumFromThen i j) ;    enumFromTo     (CIntPtr i) (CIntPtr j)       = map CIntPtr (enumFromTo i j) ;    enumFromThenTo (CIntPtr i) (CIntPtr j) (CIntPtr k) = map CIntPtr (enumFromThenTo i j k) } ; instance Storable CIntPtr where {    sizeOf    (CIntPtr x)       = sizeOf x ;    alignment (CIntPtr x)       = alignment x ;    peekElemOff a i       = liftM CIntPtr (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CIntPtr x) = pokeElemOff (castPtr a) i x } ; tyConCIntPtr = mkTyCon "CIntPtr"; instance Typeable CIntPtr where { typeOf _ = mkTyConApp tyConCIntPtr [] } ; ; instance Bounded CIntPtr where {    minBound = CIntPtr minBound ;    maxBound = CIntPtr maxBound } ; instance Integral CIntPtr where {    (CIntPtr i) `quot`    (CIntPtr j) = CIntPtr (i `quot` j) ;    (CIntPtr i) `rem`     (CIntPtr j) = CIntPtr (i `rem`  j) ;    (CIntPtr i) `div`     (CIntPtr j) = CIntPtr (i `div`  j) ;    (CIntPtr i) `mod`     (CIntPtr j) = CIntPtr (i `mod`  j) ;    (CIntPtr i) `quotRem` (CIntPtr j) = let (q,r) = i `quotRem` j in (CIntPtr q, CIntPtr r) ;    (CIntPtr i) `divMod`  (CIntPtr j) = let (d,m) = i `divMod`  j in (CIntPtr d, CIntPtr m) ;    toInteger (CIntPtr i)       = toInteger i } ; instance Bits CIntPtr where {   (CIntPtr x) .&.     (CIntPtr y)   = CIntPtr (x .&.   y) ;   (CIntPtr x) .|.     (CIntPtr y)   = CIntPtr (x .|.   y) ;   (CIntPtr x) `xor`   (CIntPtr y)   = CIntPtr (x `xor` y) ;   complement    (CIntPtr x)   = CIntPtr (complement x) ;   shift         (CIntPtr x) n = CIntPtr (shift x n) ;   rotate        (CIntPtr x) n = CIntPtr (rotate x n) ;   bit                 n = CIntPtr (bit n) ;   setBit        (CIntPtr x) n = CIntPtr (setBit x n) ;   clearBit      (CIntPtr x) n = CIntPtr (clearBit x n) ;   complementBit (CIntPtr x) n = CIntPtr (complementBit x n) ;   testBit       (CIntPtr x) n = testBit x n ;   bitSize       (CIntPtr x)   = bitSize x ;   isSigned      (CIntPtr x)   = isSigned x }
newtype CUIntPtr = CUIntPtr Word64 deriving (Eq, Ord) ; instance Num CUIntPtr where {    (CUIntPtr i) + (CUIntPtr j) = CUIntPtr (i + j) ;    (CUIntPtr i) - (CUIntPtr j) = CUIntPtr (i - j) ;    (CUIntPtr i) * (CUIntPtr j) = CUIntPtr (i * j) ;    negate  (CUIntPtr i) = CUIntPtr (negate i) ;    abs     (CUIntPtr i) = CUIntPtr (abs    i) ;    signum  (CUIntPtr i) = CUIntPtr (signum i) ;    fromInteger x = CUIntPtr (fromInteger x) } ; instance Real CUIntPtr where {    toRational (CUIntPtr i) = toRational i } ; instance Read CUIntPtr where {    readsPrec p s = map (\(x, t) -> (CUIntPtr x, t)) (readsPrec p s) } ; instance Show CUIntPtr where {    showsPrec p (CUIntPtr x) = showsPrec p x } ; instance Enum CUIntPtr where {    succ           (CUIntPtr i)             = CUIntPtr (succ i) ;    pred           (CUIntPtr i)             = CUIntPtr (pred i) ;    toEnum               x           = CUIntPtr (toEnum x) ;    fromEnum       (CUIntPtr i)             = fromEnum i ;    enumFrom       (CUIntPtr i)             = map CUIntPtr (enumFrom i) ;    enumFromThen   (CUIntPtr i) (CUIntPtr j)       = map CUIntPtr (enumFromThen i j) ;    enumFromTo     (CUIntPtr i) (CUIntPtr j)       = map CUIntPtr (enumFromTo i j) ;    enumFromThenTo (CUIntPtr i) (CUIntPtr j) (CUIntPtr k) = map CUIntPtr (enumFromThenTo i j k) } ; instance Storable CUIntPtr where {    sizeOf    (CUIntPtr x)       = sizeOf x ;    alignment (CUIntPtr x)       = alignment x ;    peekElemOff a i       = liftM CUIntPtr (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CUIntPtr x) = pokeElemOff (castPtr a) i x } ; tyConCUIntPtr = mkTyCon "CUIntPtr"; instance Typeable CUIntPtr where { typeOf _ = mkTyConApp tyConCUIntPtr [] } ; ; instance Bounded CUIntPtr where {    minBound = CUIntPtr minBound ;    maxBound = CUIntPtr maxBound } ; instance Integral CUIntPtr where {    (CUIntPtr i) `quot`    (CUIntPtr j) = CUIntPtr (i `quot` j) ;    (CUIntPtr i) `rem`     (CUIntPtr j) = CUIntPtr (i `rem`  j) ;    (CUIntPtr i) `div`     (CUIntPtr j) = CUIntPtr (i `div`  j) ;    (CUIntPtr i) `mod`     (CUIntPtr j) = CUIntPtr (i `mod`  j) ;    (CUIntPtr i) `quotRem` (CUIntPtr j) = let (q,r) = i `quotRem` j in (CUIntPtr q, CUIntPtr r) ;    (CUIntPtr i) `divMod`  (CUIntPtr j) = let (d,m) = i `divMod`  j in (CUIntPtr d, CUIntPtr m) ;    toInteger (CUIntPtr i)       = toInteger i } ; instance Bits CUIntPtr where {   (CUIntPtr x) .&.     (CUIntPtr y)   = CUIntPtr (x .&.   y) ;   (CUIntPtr x) .|.     (CUIntPtr y)   = CUIntPtr (x .|.   y) ;   (CUIntPtr x) `xor`   (CUIntPtr y)   = CUIntPtr (x `xor` y) ;   complement    (CUIntPtr x)   = CUIntPtr (complement x) ;   shift         (CUIntPtr x) n = CUIntPtr (shift x n) ;   rotate        (CUIntPtr x) n = CUIntPtr (rotate x n) ;   bit                 n = CUIntPtr (bit n) ;   setBit        (CUIntPtr x) n = CUIntPtr (setBit x n) ;   clearBit      (CUIntPtr x) n = CUIntPtr (clearBit x n) ;   complementBit (CUIntPtr x) n = CUIntPtr (complementBit x n) ;   testBit       (CUIntPtr x) n = testBit x n ;   bitSize       (CUIntPtr x)   = bitSize x ;   isSigned      (CUIntPtr x)   = isSigned x }
newtype CIntMax = CIntMax Int64 deriving (Eq, Ord) ; instance Num CIntMax where {    (CIntMax i) + (CIntMax j) = CIntMax (i + j) ;    (CIntMax i) - (CIntMax j) = CIntMax (i - j) ;    (CIntMax i) * (CIntMax j) = CIntMax (i * j) ;    negate  (CIntMax i) = CIntMax (negate i) ;    abs     (CIntMax i) = CIntMax (abs    i) ;    signum  (CIntMax i) = CIntMax (signum i) ;    fromInteger x = CIntMax (fromInteger x) } ; instance Real CIntMax where {    toRational (CIntMax i) = toRational i } ; instance Read CIntMax where {    readsPrec p s = map (\(x, t) -> (CIntMax x, t)) (readsPrec p s) } ; instance Show CIntMax where {    showsPrec p (CIntMax x) = showsPrec p x } ; instance Enum CIntMax where {    succ           (CIntMax i)             = CIntMax (succ i) ;    pred           (CIntMax i)             = CIntMax (pred i) ;    toEnum               x           = CIntMax (toEnum x) ;    fromEnum       (CIntMax i)             = fromEnum i ;    enumFrom       (CIntMax i)             = map CIntMax (enumFrom i) ;    enumFromThen   (CIntMax i) (CIntMax j)       = map CIntMax (enumFromThen i j) ;    enumFromTo     (CIntMax i) (CIntMax j)       = map CIntMax (enumFromTo i j) ;    enumFromThenTo (CIntMax i) (CIntMax j) (CIntMax k) = map CIntMax (enumFromThenTo i j k) } ; instance Storable CIntMax where {    sizeOf    (CIntMax x)       = sizeOf x ;    alignment (CIntMax x)       = alignment x ;    peekElemOff a i       = liftM CIntMax (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CIntMax x) = pokeElemOff (castPtr a) i x } ; tyConCIntMax = mkTyCon "CIntMax"; instance Typeable CIntMax where { typeOf _ = mkTyConApp tyConCIntMax [] } ; ; instance Bounded CIntMax where {    minBound = CIntMax minBound ;    maxBound = CIntMax maxBound } ; instance Integral CIntMax where {    (CIntMax i) `quot`    (CIntMax j) = CIntMax (i `quot` j) ;    (CIntMax i) `rem`     (CIntMax j) = CIntMax (i `rem`  j) ;    (CIntMax i) `div`     (CIntMax j) = CIntMax (i `div`  j) ;    (CIntMax i) `mod`     (CIntMax j) = CIntMax (i `mod`  j) ;    (CIntMax i) `quotRem` (CIntMax j) = let (q,r) = i `quotRem` j in (CIntMax q, CIntMax r) ;    (CIntMax i) `divMod`  (CIntMax j) = let (d,m) = i `divMod`  j in (CIntMax d, CIntMax m) ;    toInteger (CIntMax i)       = toInteger i } ; instance Bits CIntMax where {   (CIntMax x) .&.     (CIntMax y)   = CIntMax (x .&.   y) ;   (CIntMax x) .|.     (CIntMax y)   = CIntMax (x .|.   y) ;   (CIntMax x) `xor`   (CIntMax y)   = CIntMax (x `xor` y) ;   complement    (CIntMax x)   = CIntMax (complement x) ;   shift         (CIntMax x) n = CIntMax (shift x n) ;   rotate        (CIntMax x) n = CIntMax (rotate x n) ;   bit                 n = CIntMax (bit n) ;   setBit        (CIntMax x) n = CIntMax (setBit x n) ;   clearBit      (CIntMax x) n = CIntMax (clearBit x n) ;   complementBit (CIntMax x) n = CIntMax (complementBit x n) ;   testBit       (CIntMax x) n = testBit x n ;   bitSize       (CIntMax x)   = bitSize x ;   isSigned      (CIntMax x)   = isSigned x }
newtype CUIntMax = CUIntMax Word64 deriving (Eq, Ord) ; instance Num CUIntMax where {    (CUIntMax i) + (CUIntMax j) = CUIntMax (i + j) ;    (CUIntMax i) - (CUIntMax j) = CUIntMax (i - j) ;    (CUIntMax i) * (CUIntMax j) = CUIntMax (i * j) ;    negate  (CUIntMax i) = CUIntMax (negate i) ;    abs     (CUIntMax i) = CUIntMax (abs    i) ;    signum  (CUIntMax i) = CUIntMax (signum i) ;    fromInteger x = CUIntMax (fromInteger x) } ; instance Real CUIntMax where {    toRational (CUIntMax i) = toRational i } ; instance Read CUIntMax where {    readsPrec p s = map (\(x, t) -> (CUIntMax x, t)) (readsPrec p s) } ; instance Show CUIntMax where {    showsPrec p (CUIntMax x) = showsPrec p x } ; instance Enum CUIntMax where {    succ           (CUIntMax i)             = CUIntMax (succ i) ;    pred           (CUIntMax i)             = CUIntMax (pred i) ;    toEnum               x           = CUIntMax (toEnum x) ;    fromEnum       (CUIntMax i)             = fromEnum i ;    enumFrom       (CUIntMax i)             = map CUIntMax (enumFrom i) ;    enumFromThen   (CUIntMax i) (CUIntMax j)       = map CUIntMax (enumFromThen i j) ;    enumFromTo     (CUIntMax i) (CUIntMax j)       = map CUIntMax (enumFromTo i j) ;    enumFromThenTo (CUIntMax i) (CUIntMax j) (CUIntMax k) = map CUIntMax (enumFromThenTo i j k) } ; instance Storable CUIntMax where {    sizeOf    (CUIntMax x)       = sizeOf x ;    alignment (CUIntMax x)       = alignment x ;    peekElemOff a i       = liftM CUIntMax (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CUIntMax x) = pokeElemOff (castPtr a) i x } ; tyConCUIntMax = mkTyCon "CUIntMax"; instance Typeable CUIntMax where { typeOf _ = mkTyConApp tyConCUIntMax [] } ; ; instance Bounded CUIntMax where {    minBound = CUIntMax minBound ;    maxBound = CUIntMax maxBound } ; instance Integral CUIntMax where {    (CUIntMax i) `quot`    (CUIntMax j) = CUIntMax (i `quot` j) ;    (CUIntMax i) `rem`     (CUIntMax j) = CUIntMax (i `rem`  j) ;    (CUIntMax i) `div`     (CUIntMax j) = CUIntMax (i `div`  j) ;    (CUIntMax i) `mod`     (CUIntMax j) = CUIntMax (i `mod`  j) ;    (CUIntMax i) `quotRem` (CUIntMax j) = let (q,r) = i `quotRem` j in (CUIntMax q, CUIntMax r) ;    (CUIntMax i) `divMod`  (CUIntMax j) = let (d,m) = i `divMod`  j in (CUIntMax d, CUIntMax m) ;    toInteger (CUIntMax i)       = toInteger i } ; instance Bits CUIntMax where {   (CUIntMax x) .&.     (CUIntMax y)   = CUIntMax (x .&.   y) ;   (CUIntMax x) .|.     (CUIntMax y)   = CUIntMax (x .|.   y) ;   (CUIntMax x) `xor`   (CUIntMax y)   = CUIntMax (x `xor` y) ;   complement    (CUIntMax x)   = CUIntMax (complement x) ;   shift         (CUIntMax x) n = CUIntMax (shift x n) ;   rotate        (CUIntMax x) n = CUIntMax (rotate x n) ;   bit                 n = CUIntMax (bit n) ;   setBit        (CUIntMax x) n = CUIntMax (setBit x n) ;   clearBit      (CUIntMax x) n = CUIntMax (clearBit x n) ;   complementBit (CUIntMax x) n = CUIntMax (complementBit x n) ;   testBit       (CUIntMax x) n = testBit x n ;   bitSize       (CUIntMax x)   = bitSize x ;   isSigned      (CUIntMax x)   = isSigned x }

{-# RULES
"fromIntegral/a->CIntPtr"  fromIntegral = \x -> CIntPtr  (fromIntegral x)
"fromIntegral/a->CUIntPtr" fromIntegral = \x -> CUIntPtr (fromIntegral x)
"fromIntegral/a->CIntMax"  fromIntegral = \x -> CIntMax  (fromIntegral x)
"fromIntegral/a->CUIntMax" fromIntegral = \x -> CUIntMax (fromIntegral x)
 #-}

-- C99 types which are still missing include:
-- wint_t, wctrans_t, wctype_t

{- $ctypes

These types are needed to accurately represent C function prototypes,
in order to access C library interfaces in Haskell.  The Haskell system
is not required to represent those types exactly as C does, but the
following guarantees are provided concerning a Haskell type @CT@
representing a C type @t@:

* If a C function prototype has @t@ as an argument or result type, the
  use of @CT@ in the corresponding position in a foreign declaration
  permits the Haskell program to access the full range of values encoded
  by the C type; and conversely, any Haskell value for @CT@ has a valid
  representation in C.

* @'sizeOf' ('Prelude.undefined' :: CT)@ will yield the same value as
  @sizeof (t)@ in C.

* @'alignment' ('Prelude.undefined' :: CT)@ matches the alignment
  constraint enforced by the C implementation for @t@.

* The members 'peek' and 'poke' of the 'Storable' class map all values
  of @CT@ to the corresponding value of @t@ and vice versa.

* When an instance of 'Prelude.Bounded' is defined for @CT@, the values
  of 'Prelude.minBound' and 'Prelude.maxBound' coincide with @t_MIN@
  and @t_MAX@ in C.

* When an instance of 'Prelude.Eq' or 'Prelude.Ord' is defined for @CT@,
  the predicates defined by the type class implement the same relation
  as the corresponding predicate in C on @t@.

* When an instance of 'Prelude.Num', 'Prelude.Read', 'Prelude.Integral',
  'Prelude.Fractional', 'Prelude.Floating', 'Prelude.RealFrac', or
  'Prelude.RealFloat' is defined for @CT@, the arithmetic operations
  defined by the type class implement the same function as the
  corresponding arithmetic operations (if available) in C on @t@.

* When an instance of 'Bits' is defined for @CT@, the bitwise operation
  defined by the type class implement the same function as the
  corresponding bitwise operation in C on @t@.

-}

















































/* Machine generated file, do not modify */
#include <stdlib.h>
#include "HsFFI.h"
#include "HsBase.h"

static HugsAPI5 *hugs = 0;
#include "stdlib.h"

#ifndef ENABLE_MACRO_INTERFACE
#undef free
#endif

static void hugsprim_free_3(HugsStackPtr);
static void hugsprim_free_3(HugsStackPtr hugs_root)
{
    hugs->putFunPtr((HsFunPtr)&free);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef free
#endif

static void hugsprim_free_2(HugsStackPtr);
static void hugsprim_free_2(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    arg1 = hugs->getPtr();
    free(arg1);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef realloc
#endif

static void hugsprim_realloc_1(HugsStackPtr);
static void hugsprim_realloc_1(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord64 arg2;
    HsPtr res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getWord64();
    res1 = realloc(arg1, arg2);
    hugs->putPtr(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef malloc
#endif

static void hugsprim_malloc_0(HugsStackPtr);
static void hugsprim_malloc_0(HugsStackPtr hugs_root)
{
    HsWord64 arg1;
    HsPtr res1;
    arg1 = hugs->getWord64();
    res1 = malloc(arg1);
    hugs->putPtr(res1);
    hugs->returnIO(hugs_root,1);
}

static struct hugs_primitive hugs_primTable[] = {
    {"finalizerFree", 0, hugsprim_free_3},
    {"_free", 2, hugsprim_free_2},
    {"_realloc", 3, hugsprim_realloc_1},
    {"_malloc", 2, hugsprim_malloc_0},
};

static void hugs_primControl(int);
static void hugs_primControl(what)
int what; {
}

#ifdef STATIC_LINKAGE
#define initModule initFMAlloc
#endif

static struct hugs_primInfo hugs_prims = { hugs_primControl, hugs_primTable, 0 };

#ifdef __cplusplus
extern "C" {
#endif
#ifndef __cplusplus
DLLEXPORT(int)  HugsAPIVersion(void);
#endif
DLLEXPORT(int)  HugsAPIVersion() {return (5);}
DLLEXPORT(void) initModule(HugsAPI5 *);
DLLEXPORT(void) initModule(HugsAPI5 *hugsAPI) {
    hugs = hugsAPI;
    hugs->registerPrims(&hugs_prims);
}
#ifdef __cplusplus
}
#endif

{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Foreign.Marshal.Alloc
-- Copyright   :  (c) The FFI task force 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  ffi@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Marshalling support: basic routines for memory allocation
--
-----------------------------------------------------------------------------

module Foreign.Marshal.Alloc (
  -- * Memory allocation
  -- ** Local allocation
  alloca,       -- :: Storable a =>        (Ptr a -> IO b) -> IO b
  allocaBytes,  -- ::               Int -> (Ptr a -> IO b) -> IO b

  -- ** Dynamic allocation
  malloc,       -- :: Storable a =>        IO (Ptr a)
  mallocBytes,  -- ::               Int -> IO (Ptr a)

  realloc,      -- :: Storable b => Ptr a        -> IO (Ptr b)
  reallocBytes, -- ::		    Ptr a -> Int -> IO (Ptr a)

  free,         -- :: Ptr a -> IO ()
  finalizerFree -- :: FinalizerPtr a
) where

import Data.Maybe
import Foreign.Ptr	 	( Ptr, nullPtr, FunPtr )
import Foreign.C.Types	 	( CSize )
import Foreign.Storable  	( Storable(sizeOf) )













import Control.Exception	( bracket )



import Hugs.Prelude		( IOException(IOError),
				  IOErrorType(ResourceExhausted) )
import Hugs.ForeignPtr		( FinalizerPtr )



-- exported functions
-- ------------------

-- |Allocate a block of memory that is sufficient to hold values of type
-- @a@.  The size of the area allocated is determined by the 'sizeOf'
-- method from the instance of 'Storable' for the appropriate type.
--
-- The memory may be deallocated using 'free' or 'finalizerFree' when
-- no longer required.
--
malloc :: Storable a => IO (Ptr a)
malloc  = doMalloc undefined
  where
    doMalloc       :: Storable b => b -> IO (Ptr b)
    doMalloc dummy  = mallocBytes (sizeOf dummy)

-- |Allocate a block of memory of the given number of bytes.
-- The block of memory is sufficiently aligned for any of the basic
-- foreign types that fits into a memory block of the allocated size.
--
-- The memory may be deallocated using 'free' or 'finalizerFree' when
-- no longer required.
--
mallocBytes      :: Int -> IO (Ptr a)
mallocBytes size  = failWhenNULL "malloc" (_malloc (fromIntegral size))

-- |@'alloca' f@ executes the computation @f@, passing as argument
-- a pointer to a temporarily allocated block of memory sufficient to
-- hold values of type @a@.
--
-- The memory is freed when @f@ terminates (either normally or via an
-- exception), so the pointer passed to @f@ must /not/ be used after this.
--
alloca :: Storable a => (Ptr a -> IO b) -> IO b
alloca  = doAlloca undefined
  where
    doAlloca       :: Storable a' => a' -> (Ptr a' -> IO b') -> IO b'
    doAlloca dummy  = allocaBytes (sizeOf dummy)

-- |@'allocaBytes' n f@ executes the computation @f@, passing as argument
-- a pointer to a temporarily allocated block of memory of @n@ bytes.
-- The block of memory is sufficiently aligned for any of the basic
-- foreign types that fits into a memory block of the allocated size.
--
-- The memory is freed when @f@ terminates (either normally or via an
-- exception), so the pointer passed to @f@ must /not/ be used after this.
--












allocaBytes      :: Int -> (Ptr a -> IO b) -> IO b
allocaBytes size  = bracket (mallocBytes size) free


-- |Resize a memory area that was allocated with 'malloc' or 'mallocBytes'
-- to the size needed to store values of type @b@.  The returned pointer
-- may refer to an entirely different memory area, but will be suitably
-- aligned to hold values of type @b@.  The contents of the referenced
-- memory area will be the same as of the original pointer up to the
-- minimum of the original size and the size of values of type @b@.
--
-- If the argument to 'realloc' is 'nullPtr', 'realloc' behaves like
-- 'malloc'.
--
realloc :: Storable b => Ptr a -> IO (Ptr b)
realloc  = doRealloc undefined
  where
    doRealloc           :: Storable b' => b' -> Ptr a' -> IO (Ptr b')
    doRealloc dummy ptr  = let
			     size = fromIntegral (sizeOf dummy)
			   in
			   failWhenNULL "realloc" (_realloc ptr size)

-- |Resize a memory area that was allocated with 'malloc' or 'mallocBytes'
-- to the given size.  The returned pointer may refer to an entirely
-- different memory area, but will be sufficiently aligned for any of the
-- basic foreign types that fits into a memory block of the given size.
-- The contents of the referenced memory area will be the same as of
-- the original pointer up to the minimum of the original size and the
-- given size.
--
-- If the pointer argument to 'reallocBytes' is 'nullPtr', 'reallocBytes'
-- behaves like 'malloc'.  If the requested size is 0, 'reallocBytes'
-- behaves like 'free'.
--
reallocBytes          :: Ptr a -> Int -> IO (Ptr a)
reallocBytes ptr 0     = do free ptr; return nullPtr
reallocBytes ptr size  = 
  failWhenNULL "realloc" (_realloc ptr (fromIntegral size))

-- |Free a block of memory that was allocated with 'malloc',
-- 'mallocBytes', 'realloc', 'reallocBytes', 'Foreign.Marshal.Utils.new'
-- or any of the @new@/X/ functions in "Foreign.Marshal.Array" or
-- "Foreign.C.String".
--
free :: Ptr a -> IO ()
free  = _free


-- auxilliary routines
-- -------------------

-- asserts that the pointer returned from the action in the second argument is
-- non-null
--
failWhenNULL :: String -> IO (Ptr a) -> IO (Ptr a)
failWhenNULL name f = do
   addr <- f
   if addr == nullPtr

      then ioError (IOError Nothing ResourceExhausted name 
					"out of memory" Nothing)



      else return addr

-- basic C routines needed for memory allocation
--
foreign import ccall unsafe "stdlib.h malloc"  _malloc  ::          CSize -> IO (Ptr a)
foreign import ccall unsafe "stdlib.h realloc" _realloc :: Ptr a -> CSize -> IO (Ptr b)
foreign import ccall unsafe "stdlib.h free"    _free    :: Ptr a -> IO ()

-- | A pointer to a foreign function equivalent to 'free', which may be
-- used as a finalizer (cf 'Foreign.ForeignPtr.ForeignPtr') for storage
-- allocated with 'malloc', 'mallocBytes', 'realloc' or 'reallocBytes'.
foreign import ccall unsafe "stdlib.h &free" finalizerFree :: FinalizerPtr a
 asm    dylinkÄÅ¿ ` ` ` ```  ` |à	env
memoryBase env	tableBase envabort  envgetTempRet0 env_free  env_malloc env_realloc envmemory Äenvtablep 
      A A ©	_HugsAPIVersion __post_instantiate _hugs_primControl _hugsprim_free_2 	_hugsprim_free_3 _hugsprim_malloc_0 _hugsprim_realloc_1 
_initModule runPostSets 	 #	

æ
 A # AÄ¿j  6 #   (∞    #Aj# AÄ¿j( (î  + # AÄ¿j( (D   A # AÄ¿j( († [# AÄ¿j( (D !# AÄ¿j( (@ !  # AÄ¿j( (ê    A# AÄ¿j( († F# AÄ¿j( (@ ! # AÄ¿j( (ê    A# AÄ¿j( († á # #Aj6 # # (# Ajj6# # (# A<jj6# #Aj6# # (# A  jj6# #Aj6 # # ($# A– jj6$# #Aj6,# # (0# AŸ jj60# #Aj68 # A j$#AÄÄ¿j$ A  D        f # `                                                         finalizerFree _free _realloc _malloc{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Foreign.Marshal.Array
-- Copyright   :  (c) The FFI task force 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  ffi@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Marshalling support: routines allocating, storing, and retrieving Haskell
-- lists that are represented as arrays in the foreign language
--
-----------------------------------------------------------------------------

module Foreign.Marshal.Array (
  -- * Marshalling arrays

  -- ** Allocation
  --
  mallocArray,    -- :: Storable a => Int -> IO (Ptr a)
  mallocArray0,   -- :: Storable a => Int -> IO (Ptr a)

  allocaArray,    -- :: Storable a => Int -> (Ptr a -> IO b) -> IO b
  allocaArray0,   -- :: Storable a => Int -> (Ptr a -> IO b) -> IO b

  reallocArray,   -- :: Storable a => Ptr a -> Int -> IO (Ptr a)
  reallocArray0,  -- :: Storable a => Ptr a -> Int -> IO (Ptr a)

  -- ** Marshalling
  --
  peekArray,      -- :: Storable a =>         Int -> Ptr a -> IO [a]
  peekArray0,     -- :: (Storable a, Eq a) => a   -> Ptr a -> IO [a]

  pokeArray,      -- :: Storable a =>      Ptr a -> [a] -> IO ()
  pokeArray0,     -- :: Storable a => a -> Ptr a -> [a] -> IO ()

  -- ** Combined allocation and marshalling
  --
  newArray,       -- :: Storable a =>      [a] -> IO (Ptr a)
  newArray0,      -- :: Storable a => a -> [a] -> IO (Ptr a)

  withArray,      -- :: Storable a =>      [a] -> (Ptr a -> IO b) -> IO b
  withArray0,     -- :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b

  withArrayLen,   -- :: Storable a =>      [a] -> (Int -> Ptr a -> IO b) -> IO b
  withArrayLen0,  -- :: Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b

  -- ** Copying

  -- | (argument order: destination, source)
  copyArray,      -- :: Storable a => Ptr a -> Ptr a -> Int -> IO ()
  moveArray,      -- :: Storable a => Ptr a -> Ptr a -> Int -> IO ()

  -- ** Finding the length
  --
  lengthArray0,   -- :: (Storable a, Eq a) => a -> Ptr a -> IO Int

  -- ** Indexing
  --
  advancePtr,     -- :: Storable a => Ptr a -> Int -> Ptr a
) where

import Control.Monad
import Foreign.Ptr	(Ptr, plusPtr)
import Foreign.Storable	(Storable(sizeOf,peekElemOff,pokeElemOff))
import Foreign.Marshal.Alloc (mallocBytes, allocaBytes, reallocBytes)
import Foreign.Marshal.Utils (copyBytes, moveBytes)









-- allocation
-- ----------

-- |Allocate storage for the given number of elements of a storable type
-- (like 'Foreign.Marshal.Alloc.malloc', but for multiple elements).
--
mallocArray :: Storable a => Int -> IO (Ptr a)
mallocArray  = doMalloc undefined
  where
    doMalloc            :: Storable a' => a' -> Int -> IO (Ptr a')
    doMalloc dummy size  = mallocBytes (size * sizeOf dummy)

-- |Like 'mallocArray', but add an extra position to hold a special
-- termination element.
--
mallocArray0      :: Storable a => Int -> IO (Ptr a)
mallocArray0 size  = mallocArray (size + 1)

-- |Temporarily allocate space for the given number of elements
-- (like 'Foreign.Marshal.Alloc.alloca', but for multiple elements).
--
allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
allocaArray  = doAlloca undefined
  where
    doAlloca            :: Storable a' => a' -> Int -> (Ptr a' -> IO b') -> IO b'
    doAlloca dummy size  = allocaBytes (size * sizeOf dummy)

-- |Like 'allocaArray', but add an extra position to hold a special
-- termination element.
--
allocaArray0      :: Storable a => Int -> (Ptr a -> IO b) -> IO b
allocaArray0 size  = allocaArray (size + 1)

-- |Adjust the size of an array
--
reallocArray :: Storable a => Ptr a -> Int -> IO (Ptr a)
reallocArray  = doRealloc undefined
  where
    doRealloc                :: Storable a' => a' -> Ptr a' -> Int -> IO (Ptr a')
    doRealloc dummy ptr size  = reallocBytes ptr (size * sizeOf dummy)

-- |Adjust the size of an array including an extra position for the end marker.
--
reallocArray0          :: Storable a => Ptr a -> Int -> IO (Ptr a)
reallocArray0 ptr size  = reallocArray ptr (size + 1)


-- marshalling
-- -----------

-- |Convert an array of given length into a Haskell list.  This version
-- traverses the array backwards using an accumulating parameter,
-- which uses constant stack space.  The previous version using mapM
-- needed linear stack space.
--
peekArray          :: Storable a => Int -> Ptr a -> IO [a]
peekArray size ptr | size <= 0 = return []
                 | otherwise = f (size-1) []
  where
    f 0 acc = do e <- peekElemOff ptr 0; return (e:acc)
    f n acc = do e <- peekElemOff ptr n; f (n-1) (e:acc)
  
-- |Convert an array terminated by the given end marker into a Haskell list
--
peekArray0            :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
peekArray0 marker ptr  = do
  size <- lengthArray0 marker ptr
  peekArray size ptr

-- |Write the list elements consecutive into memory
--
pokeArray :: Storable a => Ptr a -> [a] -> IO ()

pokeArray ptr vals =  zipWithM_ (pokeElemOff ptr) [0..] vals






-- |Write the list elements consecutive into memory and terminate them with the
-- given marker element
--
pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()

pokeArray0 marker ptr vals  = do
  pokeArray ptr vals
  pokeElemOff ptr (length vals) marker







-- combined allocation and marshalling
-- -----------------------------------

-- |Write a list of storable elements into a newly allocated, consecutive
-- sequence of storable values
-- (like 'Foreign.Marshal.Utils.new', but for multiple elements).
--
newArray      :: Storable a => [a] -> IO (Ptr a)
newArray vals  = do
  ptr <- mallocArray (length vals)
  pokeArray ptr vals
  return ptr

-- |Write a list of storable elements into a newly allocated, consecutive
-- sequence of storable values, where the end is fixed by the given end marker
--
newArray0             :: Storable a => a -> [a] -> IO (Ptr a)
newArray0 marker vals  = do
  ptr <- mallocArray0 (length vals)
  pokeArray0 marker ptr vals
  return ptr

-- |Temporarily store a list of storable values in memory
-- (like 'Foreign.Marshal.Utils.with', but for multiple elements).
--
withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
withArray vals = withArrayLen vals . const

-- |Like 'withArray', but the action gets the number of values
-- as an additional parameter
--
withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
withArrayLen vals f  =
  allocaArray len $ \ptr -> do
      pokeArray ptr vals
      res <- f len ptr
      return res
  where
    len = length vals

-- |Like 'withArray', but a terminator indicates where the array ends
--
withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
withArray0 marker vals = withArrayLen0 marker vals . const

-- |Like 'withArrayLen', but a terminator indicates where the array ends
--
withArrayLen0 :: Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b
withArrayLen0 marker vals f  =
  allocaArray0 len $ \ptr -> do
      pokeArray0 marker ptr vals
      res <- f len ptr
      return res
  where
    len = length vals


-- copying (argument order: destination, source)
-- -------

-- |Copy the given number of elements from the second array (source) into the
-- first array (destination); the copied areas may /not/ overlap
--
copyArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()
copyArray  = doCopy undefined
  where
    doCopy                     :: Storable a' => a' -> Ptr a' -> Ptr a' -> Int -> IO ()
    doCopy dummy dest src size  = copyBytes dest src (size * sizeOf dummy)

-- |Copy the given number of elements from the second array (source) into the
-- first array (destination); the copied areas /may/ overlap
--
moveArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()
moveArray  = doMove undefined
  where
    doMove                     :: Storable a' => a' -> Ptr a' -> Ptr a' -> Int -> IO ()
    doMove dummy dest src size  = moveBytes dest src (size * sizeOf dummy)


-- finding the length
-- ------------------

-- |Return the number of elements in an array, excluding the terminator
--
lengthArray0            :: (Storable a, Eq a) => a -> Ptr a -> IO Int
lengthArray0 marker ptr  = loop 0
  where
    loop i = do
        val <- peekElemOff ptr i
        if val == marker then return i else loop (i+1)


-- indexing
-- --------

-- |Advance a pointer into an array by the given number of elements
--
advancePtr :: Storable a => Ptr a -> Int -> Ptr a
advancePtr  = doAdvance undefined
  where
    doAdvance             :: Storable a' => a' -> Ptr a' -> Int -> Ptr a'
    doAdvance dummy ptr i  = ptr `plusPtr` (i * sizeOf dummy)
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Foreign.Marshal.Error
-- Copyright   :  (c) The FFI task force 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  ffi@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Routines for testing return values and raising a 'userError' exception
-- in case of values indicating an error state.
--
-----------------------------------------------------------------------------

module Foreign.Marshal.Error (
  throwIf,       -- :: (a -> Bool) -> (a -> String) -> IO a       -> IO a
  throwIf_,      -- :: (a -> Bool) -> (a -> String) -> IO a       -> IO ()
  throwIfNeg,    -- :: (Ord a, Num a) 
	         -- =>                (a -> String) -> IO a       -> IO a
  throwIfNeg_,   -- :: (Ord a, Num a)
	         -- =>                (a -> String) -> IO a       -> IO ()
  throwIfNull,   -- ::                String        -> IO (Ptr a) -> IO (Ptr a)

  -- Discard return value
  --
  void           -- IO a -> IO ()
) where

import Foreign.Ptr











-- exported functions
-- ------------------

-- |Execute an 'IO' action, throwing a 'userError' if the predicate yields
-- 'True' when applied to the result returned by the 'IO' action.
-- If no exception is raised, return the result of the computation.
--
throwIf :: (a -> Bool)	-- ^ error condition on the result of the 'IO' action
	-> (a -> String) -- ^ computes an error message from erroneous results
			-- of the 'IO' action
	-> IO a		-- ^ the 'IO' action to be executed
	-> IO a
throwIf pred msgfct act  = 
  do
    res <- act
    (if pred res then ioError . userError . msgfct else return) res

-- |Like 'throwIf', but discarding the result
--
throwIf_                 :: (a -> Bool) -> (a -> String) -> IO a -> IO ()
throwIf_ pred msgfct act  = void $ throwIf pred msgfct act

-- |Guards against negative result values
--
throwIfNeg :: (Ord a, Num a) => (a -> String) -> IO a -> IO a
throwIfNeg  = throwIf (< 0)

-- |Like 'throwIfNeg', but discarding the result
--
throwIfNeg_ :: (Ord a, Num a) => (a -> String) -> IO a -> IO ()
throwIfNeg_  = throwIf_ (< 0)

-- |Guards against null pointers
--
throwIfNull :: String -> IO (Ptr a) -> IO (Ptr a)
throwIfNull  = throwIf (== nullPtr) . const

-- |Discard the return value of an 'IO' action
--
void     :: IO a -> IO ()
void act  = act >> return ()
{-# OPTIONS_GHC -fno-implicit-prelude #-}
--------------------------------------------------------------------------------
-- |
-- Module      :  Foreign.Marshal.Pool
-- Copyright   :  (c) Sven Panne 2002-2004
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  sven.panne@aedion.de
-- Stability   :  provisional
-- Portability :  portable
--
-- This module contains support for pooled memory management. Under this scheme,
-- (re-)allocations belong to a given pool, and everything in a pool is
-- deallocated when the pool itself is deallocated. This is useful when
-- 'Foreign.Marshal.Alloc.alloca' with its implicit allocation and deallocation
-- is not flexible enough, but explicit uses of 'Foreign.Marshal.Alloc.malloc'
-- and 'free' are too awkward.
--
--------------------------------------------------------------------------------

module Foreign.Marshal.Pool (
   -- * Pool management
   Pool,
   newPool,             -- :: IO Pool
   freePool,            -- :: Pool -> IO ()
   withPool,            -- :: (Pool -> IO b) -> IO b

   -- * (Re-)Allocation within a pool
   pooledMalloc,        -- :: Storable a => Pool                 -> IO (Ptr a)
   pooledMallocBytes,   -- ::               Pool          -> Int -> IO (Ptr a)

   pooledRealloc,       -- :: Storable a => Pool -> Ptr a        -> IO (Ptr a)
   pooledReallocBytes,  -- ::               Pool -> Ptr a -> Int -> IO (Ptr a)

   pooledMallocArray,   -- :: Storable a => Pool ->          Int -> IO (Ptr a)
   pooledMallocArray0,  -- :: Storable a => Pool ->          Int -> IO (Ptr a)

   pooledReallocArray,  -- :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)
   pooledReallocArray0, -- :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)

   -- * Combined allocation and marshalling
   pooledNew,           -- :: Storable a => Pool -> a            -> IO (Ptr a)
   pooledNewArray,      -- :: Storable a => Pool ->      [a]     -> IO (Ptr a)
   pooledNewArray0      -- :: Storable a => Pool -> a -> [a]     -> IO (Ptr a)
) where









import Data.IORef            ( IORef, newIORef, readIORef, writeIORef )



import Control.Exception     ( bracket )



import Control.Monad         ( liftM )
import Data.List             ( delete )
import Foreign.Marshal.Alloc ( mallocBytes, reallocBytes, free )
import Foreign.Marshal.Array ( pokeArray, pokeArray0 )
import Foreign.Marshal.Error ( throwIf )
import Foreign.Ptr           ( Ptr, castPtr )
import Foreign.Storable      ( Storable(sizeOf, poke) )

--------------------------------------------------------------------------------

-- To avoid non-H98 stuff like existentially quantified data constructors, we
-- simply use pointers to () below. Not very nice, but...

-- | A memory pool.

newtype Pool = Pool (IORef [Ptr ()])

-- | Allocate a fresh memory pool.

newPool :: IO Pool
newPool = liftM Pool (newIORef [])

-- | Deallocate a memory pool and everything which has been allocated in the
-- pool itself.

freePool :: Pool -> IO ()
freePool (Pool pool) = readIORef pool >>= freeAll
   where freeAll []     = return ()
         freeAll (p:ps) = free p >> freeAll ps

-- | Execute an action with a fresh memory pool, which gets automatically
-- deallocated (including its contents) after the action has finished.

withPool :: (Pool -> IO b) -> IO b










withPool = bracket newPool freePool


--------------------------------------------------------------------------------

-- | Allocate space for storable type in the given pool. The size of the area
-- allocated is determined by the 'sizeOf' method from the instance of
-- 'Storable' for the appropriate type.

pooledMalloc :: Storable a => Pool -> IO (Ptr a)
pooledMalloc = pm undefined
  where
    pm           :: Storable a' => a' -> Pool -> IO (Ptr a')
    pm dummy pool = pooledMallocBytes pool (sizeOf dummy)

-- | Allocate the given number of bytes of storage in the pool.

pooledMallocBytes :: Pool -> Int -> IO (Ptr a)
pooledMallocBytes (Pool pool) size = do
   ptr <- mallocBytes size
   ptrs <- readIORef pool
   writeIORef pool (ptr:ptrs)
   return (castPtr ptr)

-- | Adjust the storage area for an element in the pool to the given size of
-- the required type.

pooledRealloc :: Storable a => Pool -> Ptr a -> IO (Ptr a)
pooledRealloc = pr undefined
  where
    pr               :: Storable a' => a' -> Pool -> Ptr a' -> IO (Ptr a')
    pr dummy pool ptr = pooledReallocBytes pool ptr (sizeOf dummy)

-- | Adjust the storage area for an element in the pool to the given size.

pooledReallocBytes :: Pool -> Ptr a -> Int -> IO (Ptr a)
pooledReallocBytes (Pool pool) ptr size = do
   let cPtr = castPtr ptr
   throwIf (not . (cPtr `elem`)) (\_ -> "pointer not in pool") (readIORef pool)
   newPtr <- reallocBytes cPtr size
   ptrs <- readIORef pool
   writeIORef pool (newPtr : delete cPtr ptrs)
   return (castPtr newPtr)

-- | Allocate storage for the given number of elements of a storable type in the
-- pool.

pooledMallocArray :: Storable a => Pool -> Int -> IO (Ptr a)
pooledMallocArray = pma undefined
  where
    pma                :: Storable a' => a' -> Pool -> Int -> IO (Ptr a')
    pma dummy pool size = pooledMallocBytes pool (size * sizeOf dummy)

-- | Allocate storage for the given number of elements of a storable type in the
-- pool, but leave room for an extra element to signal the end of the array.

pooledMallocArray0 :: Storable a => Pool -> Int -> IO (Ptr a)
pooledMallocArray0 pool size =
   pooledMallocArray pool (size + 1)

-- | Adjust the size of an array in the given pool.

pooledReallocArray :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)
pooledReallocArray = pra undefined
  where
    pra                ::  Storable a' => a' -> Pool -> Ptr a' -> Int -> IO (Ptr a')
    pra dummy pool ptr size  = pooledReallocBytes pool ptr (size * sizeOf dummy)

-- | Adjust the size of an array with an end marker in the given pool.

pooledReallocArray0 :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)
pooledReallocArray0 pool ptr size =
   pooledReallocArray pool ptr (size + 1)

--------------------------------------------------------------------------------

-- | Allocate storage for a value in the given pool and marshal the value into
-- this storage.

pooledNew :: Storable a => Pool -> a -> IO (Ptr a)
pooledNew pool val = do
   ptr <- pooledMalloc pool
   poke ptr val
   return ptr

-- | Allocate consecutive storage for a list of values in the given pool and
-- marshal these values into it.

pooledNewArray :: Storable a => Pool -> [a] -> IO (Ptr a)
pooledNewArray pool vals = do
   ptr <- pooledMallocArray pool (length vals)
   pokeArray ptr vals
   return ptr

-- | Allocate consecutive storage for a list of values in the given pool and
-- marshal these values into it, terminating the end with the given marker.

pooledNewArray0 :: Storable a => Pool -> a -> [a] -> IO (Ptr a)
pooledNewArray0 pool marker vals = do
   ptr <- pooledMallocArray0 pool (length vals)
   pokeArray0 marker ptr vals
   return ptr
/* Machine generated file, do not modify */
#include <stdlib.h>
#include "HsFFI.h"
#include "HsBase.h"

static HugsAPI5 *hugs = 0;
#include "string.h"

#ifndef ENABLE_MACRO_INTERFACE
#undef memmove
#endif

static void hugsprim_memmove_1(HugsStackPtr);
static void hugsprim_memmove_1(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr arg2;
    HsWord64 arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getPtr();
    arg3 = hugs->getWord64();
    memmove(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef memcpy
#endif

static void hugsprim_memcpy_0(HugsStackPtr);
static void hugsprim_memcpy_0(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr arg2;
    HsWord64 arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getPtr();
    arg3 = hugs->getWord64();
    memcpy(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

static struct hugs_primitive hugs_primTable[] = {
    {"memmove", 4, hugsprim_memmove_1},
    {"memcpy", 4, hugsprim_memcpy_0},
};

static void hugs_primControl(int);
static void hugs_primControl(what)
int what; {
}

#ifdef STATIC_LINKAGE
#define initModule initFMUtils
#endif

static struct hugs_primInfo hugs_prims = { hugs_primControl, hugs_primTable, 0 };

#ifdef __cplusplus
extern "C" {
#endif
#ifndef __cplusplus
DLLEXPORT(int)  HugsAPIVersion(void);
#endif
DLLEXPORT(int)  HugsAPIVersion() {return (5);}
DLLEXPORT(void) initModule(HugsAPI5 *);
DLLEXPORT(void) initModule(HugsAPI5 *hugsAPI) {
    hugs = hugsAPI;
    hugs->registerPrims(&hugs_prims);
}
#ifdef __cplusplus
}
#endif

{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Foreign.Marshal.Utils
-- Copyright   :  (c) The FFI task force 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  ffi@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Utilities for primitive marshaling
--
-----------------------------------------------------------------------------

module Foreign.Marshal.Utils (
  -- * General marshalling utilities

  -- ** Combined allocation and marshalling
  --
  with,          -- :: Storable a => a -> (Ptr a -> IO b) -> IO b
  new,           -- :: Storable a => a -> IO (Ptr a)

  -- ** Marshalling of Boolean values (non-zero corresponds to 'True')
  --
  fromBool,      -- :: Num a => Bool -> a
  toBool,	 -- :: Num a => a -> Bool

  -- ** Marshalling of Maybe values
  --
  maybeNew,      -- :: (      a -> IO (Ptr a))
		 -- -> (Maybe a -> IO (Ptr a))
  maybeWith,     -- :: (      a -> (Ptr b -> IO c) -> IO c)
		 -- -> (Maybe a -> (Ptr b -> IO c) -> IO c)
  maybePeek,     -- :: (Ptr a -> IO        b )
		 -- -> (Ptr a -> IO (Maybe b))

  -- ** Marshalling lists of storable objects
  --
  withMany,      -- :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res

  -- ** Haskellish interface to memcpy and memmove
  -- | (argument order: destination, source)
  --
  copyBytes,     -- :: Ptr a -> Ptr a -> Int -> IO ()
  moveBytes,     -- :: Ptr a -> Ptr a -> Int -> IO ()
) where

import Data.Maybe
import Foreign.Ptr	        ( Ptr, nullPtr )
import Foreign.Storable		( Storable(poke) )
import Foreign.C.Types    	( CSize )
import Foreign.Marshal.Alloc 	( malloc, alloca )












-- combined allocation and marshalling
-- -----------------------------------

-- |Allocate a block of memory and marshal a value into it
-- (the combination of 'malloc' and 'poke').
-- The size of the area allocated is determined by the 'Foreign.Storable.sizeOf'
-- method from the instance of 'Storable' for the appropriate type.
--
-- The memory may be deallocated using 'Foreign.Marshal.Alloc.free' or
-- 'Foreign.Marshal.Alloc.finalizerFree' when no longer required.
--
new     :: Storable a => a -> IO (Ptr a)
new val  = 
  do 
    ptr <- malloc
    poke ptr val
    return ptr

-- |@'with' val f@ executes the computation @f@, passing as argument
-- a pointer to a temporarily allocated block of memory into which
-- @val@ has been marshalled (the combination of 'alloca' and 'poke').
--
-- The memory is freed when @f@ terminates (either normally or via an
-- exception), so the pointer passed to @f@ must /not/ be used after this.
--
with       :: Storable a => a -> (Ptr a -> IO b) -> IO b
with val f  =
  alloca $ \ptr -> do
    poke ptr val
    res <- f ptr
    return res


-- marshalling of Boolean values (non-zero corresponds to 'True')
-- -----------------------------

-- |Convert a Haskell 'Bool' to its numeric representation
--
fromBool       :: Num a => Bool -> a
fromBool False  = 0
fromBool True   = 1

-- |Convert a Boolean in numeric representation to a Haskell value
--
toBool :: Num a => a -> Bool
toBool  = (/= 0)


-- marshalling of Maybe values
-- ---------------------------

-- |Allocate storage and marshall a storable value wrapped into a 'Maybe'
--
-- * the 'nullPtr' is used to represent 'Nothing'
--
maybeNew :: (      a -> IO (Ptr a))
	 -> (Maybe a -> IO (Ptr a))
maybeNew  = maybe (return nullPtr)

-- |Converts a @withXXX@ combinator into one marshalling a value wrapped
-- into a 'Maybe', using 'nullPtr' to represent 'Nothing'.
--
maybeWith :: (      a -> (Ptr b -> IO c) -> IO c) 
	  -> (Maybe a -> (Ptr b -> IO c) -> IO c)
maybeWith  = maybe ($ nullPtr)

-- |Convert a peek combinator into a one returning 'Nothing' if applied to a
-- 'nullPtr' 
--
maybePeek                           :: (Ptr a -> IO b) -> Ptr a -> IO (Maybe b)
maybePeek peek ptr | ptr == nullPtr  = return Nothing
		   | otherwise       = do a <- peek ptr; return (Just a)


-- marshalling lists of storable objects
-- -------------------------------------

-- |Replicates a @withXXX@ combinator over a list of objects, yielding a list of
-- marshalled objects
--
withMany :: (a -> (b -> res) -> res)  -- withXXX combinator for one object
	 -> [a]			      -- storable objects
	 -> ([b] -> res)	      -- action on list of marshalled obj.s
	 -> res
withMany _       []     f = f []
withMany withFoo (x:xs) f = withFoo x $ \x' ->
			      withMany withFoo xs (\xs' -> f (x':xs'))


-- Haskellish interface to memcpy and memmove
-- ------------------------------------------

-- |Copies the given number of bytes from the second area (source) into the
-- first (destination); the copied areas may /not/ overlap
--
copyBytes               :: Ptr a -> Ptr a -> Int -> IO ()
copyBytes dest src size  = memcpy dest src (fromIntegral size)

-- |Copies the given number of elements from the second area (source) into the
-- first (destination); the copied areas /may/ overlap
--
moveBytes               :: Ptr a -> Ptr a -> Int -> IO ()
moveBytes dest src size  = memmove dest src (fromIntegral size)


-- auxilliary routines
-- -------------------

-- |Basic C routines needed for memory copying
--
foreign import ccall unsafe "string.h" memcpy  :: Ptr a -> Ptr a -> CSize -> IO ()
foreign import ccall unsafe "string.h" memmove :: Ptr a -> Ptr a -> CSize -> IO ()
 asm    dylink–Ä¿` ` ` ``  ` ||env
memoryBase env	tableBase envabort  envgetTempRet0 env_memcpy env_memmove envmemory Äenvtablep 	    A A É_HugsAPIVersion __post_instantiate 
_hugs_primControl _hugsprim_memcpy_0 _hugsprim_memmove_1 _initModule runPostSets 		
 #
› A # A¿Ä¿j  6 #   (∞   _# A¿Ä¿j( (D !# A¿Ä¿j( (D !# A¿Ä¿j( (@ !     A # A¿Ä¿j( († _# A¿Ä¿j( (D !# A¿Ä¿j( (D !# A¿Ä¿j( (@ !     A # A¿Ä¿j( († P # #Aj6 # # (# Ajj6# # (# A$jj6# #Aj6# # (# A,jj6# #Aj6  # A¿ j$#AÄÄ¿j$	 A  D        8 # 2                                  memmove memcpy{-# OPTIONS_GHC -optc-D__HUGS__ #-}
{-# LINE 1 "System/CPUTime.hsc" #-}
-----------------------------------------------------------------------------
{-# LINE 2 "System/CPUTime.hsc" #-}
-- |
-- Module      :  System.CPUTime
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- The standard CPUTime library.
--
-----------------------------------------------------------------------------

module System.CPUTime 
	(
         getCPUTime,       -- :: IO Integer
	 cpuTimePrecision  -- :: Integer
        ) where

import Prelude

import Data.Ratio


{-# LINE 26 "System/CPUTime.hsc" #-}
import Hugs.Time ( getCPUTime, clockTicks )

{-# LINE 28 "System/CPUTime.hsc" #-}


{-# LINE 32 "System/CPUTime.hsc" #-}


{-# LINE 39 "System/CPUTime.hsc" #-}


{-# LINE 128 "System/CPUTime.hsc" #-}

-- |The 'cpuTimePrecision' constant is the smallest measurable difference
-- in CPU time that the implementation can record, and is given as an
-- integral number of picoseconds.


{-# LINE 134 "System/CPUTime.hsc" #-}
cpuTimePrecision :: Integer
cpuTimePrecision = round ((1000000000000::Integer) % fromIntegral (clockTicks))

{-# LINE 137 "System/CPUTime.hsc" #-}


{-# LINE 148 "System/CPUTime.hsc" #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  System.Cmd
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Executing an external command.
--
-----------------------------------------------------------------------------

module System.Cmd
    ( system,        -- :: String -> IO ExitCode
      rawSystem,     -- :: FilePath -> [String] -> IO ExitCode
    ) where

import Prelude

import System.Exit 	( ExitCode )











import Hugs.System






-- ---------------------------------------------------------------------------
-- system

{-| 
Computation @system cmd@ returns the exit code
produced when the operating system processes the command @cmd@.

This computation may fail with

   * @PermissionDenied@: The process has insufficient privileges to
     perform the operation.

   * @ResourceExhausted@: Insufficient resources are available to
     perform the operation.

   * @UnsupportedOperation@: The implementation does not support
     system calls.

On Windows, 'system' is implemented using Windows's native system
call, which ignores the @SHELL@ environment variable, and always
passes the command to the Windows command interpreter (@CMD.EXE@ or
@COMMAND.COM@), hence Unixy shell tricks will not work.
-}



























{-|
The computation @'rawSystem' cmd args@ runs the operating system command
@cmd@ in such a way that it receives as arguments the @args@ strings
exactly as given, with no funny escaping or shell meta-syntax expansion.
It will therefore behave more portably between operating systems than 'system'.

The return codes and possible failures are the same as for 'system'.
-}
rawSystem :: String -> [String] -> IO ExitCode



















-- crude fallback implementation: could do much better than this under Unix
rawSystem cmd args = system (unwords (map translate (cmd:args)))

translate :: String -> String
translate str = '\'' : foldr escape "'" str
  where	escape '\'' = showString "'\\''"
	escape c    = showChar c















-----------------------------------------------------------------------------
-- |
-- Module      :  System.Directory
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  stable
-- Portability :  portable
--
-- System-independent interface to directory manipulation.
--
-----------------------------------------------------------------------------

module System.Directory 
   ( 
    -- $intro

    -- * Actions on directories
      createDirectory		-- :: FilePath -> IO ()
    , createDirectoryIfMissing  -- :: Bool -> FilePath -> IO ()
    , removeDirectory		-- :: FilePath -> IO ()
    , removeDirectoryRecursive  -- :: FilePath -> IO ()
    , renameDirectory		-- :: FilePath -> FilePath -> IO ()

    , getDirectoryContents      -- :: FilePath -> IO [FilePath]
    , getCurrentDirectory       -- :: IO FilePath
    , setCurrentDirectory       -- :: FilePath -> IO ()

    -- * Pre-defined directories
    , getHomeDirectory
    , getAppUserDataDirectory
    , getUserDocumentsDirectory
    , getTemporaryDirectory

    -- * Actions on files
    , removeFile		-- :: FilePath -> IO ()
    , renameFile                -- :: FilePath -> FilePath -> IO ()
    , copyFile                  -- :: FilePath -> FilePath -> IO ()
    
    , canonicalizePath
    , findExecutable

    -- * Existence tests
    , doesFileExist		-- :: FilePath -> IO Bool
    , doesDirectoryExist        -- :: FilePath -> IO Bool

    -- * Permissions

    -- $permissions

    , Permissions(
	Permissions,
	readable,		-- :: Permissions -> Bool
	writable,		-- :: Permissions -> Bool
	executable,		-- :: Permissions -> Bool
	searchable		-- :: Permissions -> Bool
      )

    , getPermissions            -- :: FilePath -> IO Permissions
    , setPermissions	        -- :: FilePath -> Permissions -> IO ()

    -- * Timestamps

    , getModificationTime       -- :: FilePath -> IO ClockTime
   ) where

import System.Directory.Internals
import System.Environment      ( getEnv )
import System.IO.Error
import Control.Monad           ( when, unless )







import Hugs.Directory



















































































































































































copyPermissions :: FilePath -> FilePath -> IO ()
copyPermissions fromFPath toFPath
  = getPermissions fromFPath >>= setPermissions toFPath



-- | @'createDirectoryIfMissing' parents dir@ creates a new directory 
-- @dir@ if it doesn\'t exist. If the first argument is 'True'
-- the function will also create all parent directories if they are missing.
createDirectoryIfMissing :: Bool     -- ^ Create its parents too?
		         -> FilePath -- ^ The path to the directory you want to make
		         -> IO ()
createDirectoryIfMissing parents file = do
  b <- doesDirectoryExist file
  case (b,parents, file) of 
    (_,     _, "") -> return ()
    (True,  _,  _) -> return ()
    (_,  True,  _) -> mapM_ (createDirectoryIfMissing False) (tail (pathParents file))
    (_, False,  _) -> createDirectory file


















































-- | @'removeDirectoryRecursive' dir@  removes an existing directory /dir/
-- together with its content and all subdirectories. Be careful, 
-- if the directory contains symlinks, the function will follow them.
removeDirectoryRecursive :: FilePath -> IO ()
removeDirectoryRecursive startLoc = do
  cont <- getDirectoryContents startLoc
  sequence_ [rm (startLoc `joinFileName` x) | x <- cont, x /= "." && x /= ".."]
  removeDirectory startLoc
  where
    rm :: FilePath -> IO ()
    rm f = do temp <- try (removeFile f)
              case temp of
                Left e  -> do isDir <- doesDirectoryExist f
                              -- If f is not a directory, re-throw the error
                              unless isDir $ ioError e
                              removeDirectoryRecursive f
                Right _ -> return ()



































































































































































{- |@'copyFile' old new@ copies the existing file from /old/ to /new/.
If the /new/ file already exists, it is atomically replaced by the /old/ file.
Neither path may refer to an existing directory.  The permissions of /old/ are
copied to /new/, if possible.
-}

{- NOTES:

It's tempting to try to remove the target file before opening it for
writing.  This could be useful: for example if the target file is an
executable that is in use, writing will fail, but unlinking first
would succeed.

However, it certainly isn't always what you want.

 * if the target file is hardlinked, removing it would break
   the hard link, but just opening would preserve it.

 * opening and truncating will preserve permissions and
   ACLs on the target.

 * If the destination file is read-only in a writable directory,
   we might want copyFile to fail.  Removing the target first
   would succeed, however.

 * If the destination file is special (eg. /dev/null), removing
   it is probably not the right thing.  Copying to /dev/null
   should leave /dev/null intact, not replace it with a plain
   file.

 * There's a small race condition between removing the target and
   opening it for writing during which time someone might
   create it again.
-}
copyFile :: FilePath -> FilePath -> IO ()
copyFile fromFPath toFPath =

	do readFile fromFPath >>= writeFile toFPath
	   try (copyPermissions fromFPath toFPath)
	   return ()





















































-- dummy implementation
canonicalizePath :: FilePath -> IO FilePath
canonicalizePath fpath = return fpath


-- | Given an executable file name, searches for such file
-- in the directories listed in system PATH. The returned value 
-- is the path to the found executable or Nothing if there isn't
-- such executable. For example (findExecutable \"ghc\")
-- gives you the path to GHC.
findExecutable :: String -> IO (Maybe FilePath)
findExecutable binary =
























 do
  path <- getEnv "PATH"
  search (parseSearchPath path)
  where
    fileName = binary `joinFileExt` exeExtension

    search :: [FilePath] -> IO (Maybe FilePath)
    search [] = return Nothing
    search (d:ds) = do
	let path = d `joinFileName` fileName
	b <- doesFileExist path
	if b then return (Just path)
             else search ds















































































































































































































































{- | Returns the current user's home directory.

The directory returned is expected to be writable by the current user,
but note that it isn't generally considered good practice to store
application-specific data here; use 'getAppUserDataDirectory'
instead.

On Unix, 'getHomeDirectory' returns the value of the @HOME@
environment variable.  On Windows, the system is queried for a
suitable path; a typical path might be 
@C:/Documents And Settings/user@.

The operation may fail with:

* 'UnsupportedOperation'
The operating system has no notion of home directory.

* 'isDoesNotExistError'
The home directory for the current user does not exist, or
cannot be found.
-}
getHomeDirectory :: IO FilePath
getHomeDirectory =










  getEnv "HOME"


{- | Returns the pathname of a directory in which application-specific
data for the current user can be stored.  The result of
'getAppUserDataDirectory' for a given application is specific to
the current user.

The argument should be the name of the application, which will be used
to construct the pathname (so avoid using unusual characters that
might result in an invalid pathname).

Note: the directory may not actually exist, and may need to be created
first.  It is expected that the parent directory exists and is
writable.

On Unix, this function returns @$HOME\/.appName@.  On Windows, a
typical path might be 

> C:/Documents And Settings/user/Application Data/appName

The operation may fail with:

* 'UnsupportedOperation'
The operating system has no notion of application-specific data directory.

* 'isDoesNotExistError'
The home directory for the current user does not exist, or
cannot be found.
-}
getAppUserDataDirectory :: String -> IO FilePath
getAppUserDataDirectory appName = do







  path <- getEnv "HOME"
  return (path++'/':'.':appName)


{- | Returns the current user's document directory.

The directory returned is expected to be writable by the current user,
but note that it isn't generally considered good practice to store
application-specific data here; use 'getAppUserDataDirectory'
instead.

On Unix, 'getUserDocumentsDirectory' returns the value of the @HOME@
environment variable.  On Windows, the system is queried for a
suitable path; a typical path might be 
@C:\/Documents and Settings\/user\/My Documents@.

The operation may fail with:

* 'UnsupportedOperation'
The operating system has no notion of document directory.

* 'isDoesNotExistError'
The document directory for the current user does not exist, or
cannot be found.
-}
getUserDocumentsDirectory :: IO FilePath
getUserDocumentsDirectory = do






  getEnv "HOME"


{- | Returns the current directory for temporary files.

On Unix, 'getTemporaryDirectory' returns the value of the @TMPDIR@
environment variable or \"\/tmp\" if the variable isn\'t defined.
On Windows, the function checks for the existence of environment variables in 
the following order and uses the first path found:

* 
TMP environment variable. 

*
TEMP environment variable. 

*
USERPROFILE environment variable. 

*
The Windows directory

The operation may fail with:

* 'UnsupportedOperation'
The operating system has no notion of temporary directory.

The function doesn\'t verify whether the path exists.
-}
getTemporaryDirectory :: IO FilePath
getTemporaryDirectory = do





  catch (getEnv "TMPDIR") (\ex -> return "/tmp")





















-----------------------------------------------------------------------------
-- |
-- Module      :  System.Environment
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Miscellaneous information about the system environment.
--
-----------------------------------------------------------------------------

module System.Environment
    ( 
      getArgs,	     -- :: IO [String]
      getProgName,   -- :: IO String
      getEnv,        -- :: String -> IO String

      withArgs,
      withProgName,




  ) where

import Prelude










import Hugs.System










-- ---------------------------------------------------------------------------
-- getArgs, getProgName, getEnv

-- | Computation 'getArgs' returns a list of the program's command
-- line arguments (not including the program name).












































































































































-----------------------------------------------------------------------------
-- |
-- Module      :  System.Exit
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Exiting the program.
--
-----------------------------------------------------------------------------

module System.Exit
    ( 
      ExitCode(ExitSuccess,ExitFailure)
    , exitWith      -- :: ExitCode -> IO a
    , exitFailure   -- :: IO a
  ) where

import Prelude






import Hugs.Prelude
import Hugs.Exception









-- ---------------------------------------------------------------------------
-- exitWith

-- | Computation 'exitWith' @code@ throws 'ExitException' @code@.
-- Normally this terminates the program, returning @code@ to the
-- program's caller.  Before the program terminates, any open or
-- semi-closed handles are first closed.
--
-- A program that fails in any other way is treated as if it had
-- called 'exitFailure'.
-- A program that terminates successfully without calling 'exitWith'
-- explicitly is treated as it it had called 'exitWith' 'ExitSuccess'.
--
-- As an 'ExitException' is not an 'IOError', 'exitWith' bypasses
-- the error handling in the 'IO' monad and cannot be intercepted by
-- 'catch' from the "Prelude".  However it is an 'Exception', and can
-- be caught using the functions of "Control.Exception".  This means
-- that cleanup computations added with 'Control.Exception.bracket'
-- (from "Control.Exception") are also executed properly on 'exitWith'.


exitWith :: ExitCode -> IO a
exitWith ExitSuccess = throwIO (ExitException ExitSuccess)
exitWith code@(ExitFailure n)
  | n /= 0 = throwIO (ExitException code)





-- | The computation 'exitFailure' is equivalent to
-- 'exitWith' @(@'ExitFailure' /exitfail/@)@,
-- where /exitfail/ is implementation-dependent.
exitFailure :: IO a
exitFailure = exitWith (ExitFailure 1)
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  System.IO
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  stable
-- Portability :  portable
--
-- The standard IO library.
--
-----------------------------------------------------------------------------

module System.IO (
    -- * The IO monad

    IO,			       -- instance MonadFix
    fixIO,		       -- :: (a -> IO a) -> IO a

    -- * Files and handles

    FilePath,		       -- :: String

    Handle,		-- abstract, instance of: Eq, Show.

    -- ** Standard handles

    -- | Three handles are allocated during program initialisation,
    -- and are initially open.

    stdin, stdout, stderr,   -- :: Handle

    -- * Opening and closing files

    -- ** Opening files

    openFile,		       -- :: FilePath -> IOMode -> IO Handle
    IOMode(ReadMode,WriteMode,AppendMode,ReadWriteMode),

    -- ** Closing files

    hClose,		       -- :: Handle -> IO ()

    -- ** Special cases

    -- | These functions are also exported by the "Prelude".

    readFile,		       -- :: FilePath -> IO String
    writeFile,		       -- :: FilePath -> String -> IO ()
    appendFile,		       -- :: FilePath -> String -> IO ()

    -- ** File locking

    -- $locking

    -- * Operations on handles

    -- ** Determining and changing the size of a file

    hFileSize,		       -- :: Handle -> IO Integer




    -- ** Detecting the end of input

    hIsEOF,		       -- :: Handle -> IO Bool
    isEOF,		       -- :: IO Bool

    -- ** Buffering operations

    BufferMode(NoBuffering,LineBuffering,BlockBuffering),
    hSetBuffering,	       -- :: Handle -> BufferMode -> IO ()
    hGetBuffering,	       -- :: Handle -> IO BufferMode
    hFlush,		       -- :: Handle -> IO ()

    -- ** Repositioning handles

    hGetPosn,		       -- :: Handle -> IO HandlePosn
    hSetPosn,		       -- :: HandlePosn -> IO ()
    HandlePosn,                -- abstract, instance of: Eq, Show.

    hSeek,		       -- :: Handle -> SeekMode -> Integer -> IO ()
    SeekMode(AbsoluteSeek,RelativeSeek,SeekFromEnd),

    hTell,		       -- :: Handle -> IO Integer


    -- ** Handle properties

    hIsOpen, hIsClosed,        -- :: Handle -> IO Bool
    hIsReadable, hIsWritable,  -- :: Handle -> IO Bool
    hIsSeekable,               -- :: Handle -> IO Bool

    -- ** Terminal operations


    hIsTerminalDevice,	 	-- :: Handle -> IO Bool

    hSetEcho,			-- :: Handle -> Bool -> IO ()
    hGetEcho,			-- :: Handle -> IO Bool


    -- ** Showing handle state





    -- * Text input and output

    -- ** Text input

    hWaitForInput,	       -- :: Handle -> Int -> IO Bool
    hReady,		       -- :: Handle -> IO Bool
    hGetChar,		       -- :: Handle -> IO Char
    hGetLine,		       -- :: Handle -> IO [Char]
    hLookAhead,		       -- :: Handle -> IO Char
    hGetContents,	       -- :: Handle -> IO [Char]

    -- ** Text output

    hPutChar,		       -- :: Handle -> Char -> IO ()
    hPutStr,		       -- :: Handle -> [Char] -> IO ()
    hPutStrLn,		       -- :: Handle -> [Char] -> IO ()
    hPrint,		       -- :: Show a => Handle -> a -> IO ()

    -- ** Special cases for standard input and output

    -- | These functions are also exported by the "Prelude".

    interact,		       -- :: (String -> String) -> IO ()
    putChar,		       -- :: Char   -> IO ()
    putStr,		       -- :: String -> IO () 
    putStrLn,		       -- :: String -> IO ()
    print,		       -- :: Show a => a -> IO ()
    getChar,		       -- :: IO Char
    getLine,		       -- :: IO String
    getContents,	       -- :: IO String
    readIO,		       -- :: Read a => String -> IO a
    readLn,		       -- :: Read a => IO a

    -- * Binary input and output

    openBinaryFile,	       -- :: FilePath -> IOMode -> IO Handle
    hSetBinaryMode,	       -- :: Handle -> Bool -> IO ()

    hPutBuf,		       -- :: Handle -> Ptr a -> Int -> IO ()
    hGetBuf,		       -- :: Handle -> Ptr a -> Int -> IO Int






    -- * Temporary files





  ) where













import Hugs.IO
import Hugs.IOExts
import Hugs.IORef
import Hugs.Prelude	( throw, Exception(NonTermination) )
import System.IO.Unsafe	( unsafeInterleaveIO )









































-- -----------------------------------------------------------------------------
-- Standard IO












































































































-- | Computation 'hReady' @hdl@ indicates whether at least one item is
-- available for input from handle @hdl@.
-- 
-- This operation may fail with:
--
--  * 'System.IO.Error.isEOFError' if the end of file has been reached.

hReady		:: Handle -> IO Bool
hReady h 	=  hWaitForInput h 0

-- | The same as 'hPutStr', but adds a newline character.

hPutStrLn	:: Handle -> String -> IO ()
hPutStrLn hndl str = do
 hPutStr  hndl str
 hPutChar hndl '\n'

-- | Computation 'hPrint' @hdl t@ writes the string representation of @t@
-- given by the 'shows' function to the file or channel managed by @hdl@
-- and appends a newline.
--
-- This operation may fail with:
--
--  * 'System.IO.Error.isFullError' if the device is full; or
--
--  * 'System.IO.Error.isPermissionError' if another system resource limit would be exceeded.

hPrint		:: Show a => Handle -> a -> IO ()
hPrint hdl 	=  hPutStrLn hdl . show


-- ---------------------------------------------------------------------------
-- fixIO


fixIO :: (a -> IO a) -> IO a
fixIO k = do
    ref <- newIORef (throw NonTermination)
    ans <- unsafeInterleaveIO (readIORef ref)
    result <- k ans
    writeIORef ref result
    return result

-- NOTE: we do our own explicit black holing here, because GHC's lazy
-- blackholing isn't enough.  In an infinite loop, GHC may run the IO
-- computation a few times before it notices the loop, which is wrong.








-- $locking
-- Implementations should enforce as far as possible, at least locally to the
-- Haskell process, multiple-reader single-writer locking on files.
-- That is, /there may either be many handles on the same file which manage
-- input, or just one handle on the file which manages output/.  If any
-- open or semi-closed handle is managing a file for output, no new
-- handle can be allocated for that file.  If any open or semi-closed
-- handle is managing a file for input, new handles can only be allocated
-- if they do not manage output.  Whether two files are the same is
-- implementation-dependent, but they should normally be the same if they
-- have the same absolute path name and neither has been renamed, for
-- example.
--
-- /Warning/: the 'readFile' operation holds a semi-closed handle on
-- the file until the entire contents of the file have been consumed.
-- It follows that an attempt to write to a file (using 'writeFile', for
-- example) that was earlier opened by 'readFile' will usually result in
-- failure with 'System.IO.Error.isAlreadyInUseError'.

-- -----------------------------------------------------------------------------
-- Utils


















-----------------------------------------------------------------------------
-- |
-- Module      :  System.Info
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- Information about the characteristics of the host 
-- system lucky enough to run your program.
--
-----------------------------------------------------------------------------

module System.Info
   (
       os,		    -- :: String
       arch,		    -- :: String
       compilerName,	    -- :: String
       compilerVersion	    -- :: Version
   ) where

import Prelude
import Data.Version

-- | The version of 'compilerName' with which the program was compiled
-- or is being interpreted.
compilerVersion :: Version
compilerVersion = Version {versionBranch=[maj,min], versionTags=[]}
  where (maj,min) = compilerVersionRaw `divMod` 100

-- | The operating system on which the program is running.
os :: String

-- | The machine architecture on which the program is running.
arch :: String

-- | The Haskell implementation with which the program was compiled
-- or is being interpreted.
compilerName :: String

compilerVersionRaw :: Int














                                                                                                            







                                                      












                                                         











os = "linux"
arch = "x86_64"
compilerName = "hugs"
compilerVersionRaw = 0  -- ToDo




-----------------------------------------------------------------------------
-- |
-- Module      :  System.Locale
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  stable
-- Portability :  portable
--
-- This module provides the ability to adapt to local conventions.
-- At present, it supports only time and date information as used by
-- 'System.Time.calendarTimeToString' from the "System.Time" module.
--
-----------------------------------------------------------------------------

module System.Locale (

    TimeLocale(..)

    , defaultTimeLocale
    
    , iso8601DateFormat
    , rfc822DateFormat
    )
where

import Prelude

data TimeLocale = TimeLocale {
	-- |full and abbreviated week days
        wDays  :: [(String, String)],
	-- |full and abbreviated months
        months :: [(String, String)],
        intervals :: [(String, String)],
	-- |AM\/PM symbols
        amPm   :: (String, String),
	-- |formatting strings
        dateTimeFmt, dateFmt,
        timeFmt, time12Fmt :: String     
        } deriving (Eq, Ord, Show)

defaultTimeLocale :: TimeLocale 
defaultTimeLocale =  TimeLocale { 
        wDays  = [("Sunday",   "Sun"),  ("Monday",    "Mon"),   
                  ("Tuesday",  "Tue"),  ("Wednesday", "Wed"), 
                  ("Thursday", "Thu"),  ("Friday",    "Fri"), 
                  ("Saturday", "Sat")],

        months = [("January",   "Jan"), ("February",  "Feb"),
                  ("March",     "Mar"), ("April",     "Apr"),
                  ("May",       "May"), ("June",      "Jun"),
                  ("July",      "Jul"), ("August",    "Aug"),
                  ("September", "Sep"), ("October",   "Oct"),
                  ("November",  "Nov"), ("December",  "Dec")],

        intervals = [ ("year","years")
                    , ("month", "months")
                    , ("day","days")
                    , ("hour","hours")
                    , ("min","mins")
                    , ("sec","secs")
                    , ("usec","usecs")
                    ],

        amPm = ("AM", "PM"),
        dateTimeFmt = "%a %b %e %H:%M:%S %Z %Y",
        dateFmt = "%m/%d/%y",
        timeFmt = "%H:%M:%S",
        time12Fmt = "%I:%M:%S %p"
        }


-- |Normally, ISO-8601 just defines YYYY-MM-DD
-- but we can add a time spec.

iso8601DateFormat :: Maybe String -> String
iso8601DateFormat timeFmt =
    "%Y-%m-%d" ++ case timeFmt of
             Nothing  -> "" 
             Just fmt -> ' ' : fmt


rfc822DateFormat :: String
rfc822DateFormat = "%a, %_d %b %Y %H:%M:%S %Z"
-----------------------------------------------------------------------------
-- |
-- Module      :  System.Mem
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Memory-related system things.
--
-----------------------------------------------------------------------------

module System.Mem (
 	performGC	-- :: IO ()
  ) where
 
import Prelude


import Hugs.IOExts










-----------------------------------------------------------------------------
-- |
-- Module      :  System.Random
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  stable
-- Portability :  portable
--
-- Random numbers.
--
-----------------------------------------------------------------------------

module System.Random
	(

	-- $intro

	-- * The 'RandomGen' class, and the 'StdGen' generator

	  RandomGen(next, split, genRange)
	, StdGen
	, mkStdGen

	-- * The 'Random' class
	, Random ( random,   randomR,
		   randoms,  randomRs,
		   randomIO, randomRIO )

	-- * The global random number generator

	-- $globalrng

	, getStdRandom
	, getStdGen
	, setStdGen
	, newStdGen

	-- * References
	-- $references

	) where

import Prelude





import System.CPUTime	( getCPUTime )
import System.Time	( getClockTime, ClockTime(..) )

import Data.Char	( isSpace, chr, ord )
import System.IO.Unsafe ( unsafePerformIO )
import Data.IORef
import Numeric		( readDec )

-- The standard nhc98 implementation of Time.ClockTime does not match
-- the extended one expected in this module, so we lash-up a quick
-- replacement here.







{- $intro

This library deals with the common task of pseudo-random
number generation. The library makes it possible to generate
repeatable results, by starting with a specified initial random
number generator; or to get different results on each run by using the 
system-initialised generator, or by supplying a seed from some other
source.

The library is split into two layers: 

* A core /random number generator/ provides a supply of bits. The class
'RandomGen' provides a common interface to such generators.

* The class 'Random' provides a way to extract particular values from
a random number generator. For example, the 'Float' instance of 'Random'
allows one to generate random values of type 'Float'.

This implementation uses the Portable Combined Generator of L'Ecuyer
["System.Random\#LEcuyer"] for 32-bit computers, transliterated by
Lennart Augustsson.  It has a period of roughly 2.30584e18.

-}

-- | The class 'RandomGen' provides a common interface to random number
-- generators.

class RandomGen g where

   -- |The 'next' operation returns an 'Int' that is uniformly distributed
   -- in the range returned by 'genRange' (including both end points),
   -- and a new generator.
   next     :: g -> (Int, g)

   -- |The 'split' operation allows one to obtain two distinct random number
   -- generators. This is very useful in functional programs (for example, when
   -- passing a random number generator down to recursive calls), but very
   -- little work has been done on statistically robust implementations of
   -- 'split' (["System.Random\#Burton", "System.Random\#Hellekalek"]
   -- are the only examples we know of).
   split    :: g -> (g, g)

   -- |The 'genRange' operation yields the range of values returned by
   -- the generator.
   --
   -- It is required that:
   --
   -- * If @(a,b) = 'genRange' g@, then @a < b@.
   --
   -- * 'genRange' is not strict.
   --
   -- The second condition ensures that 'genRange' cannot examine its
   -- argument, and hence the value it returns can be determined only by the
   -- instance of 'RandomGen'.  That in turn allows an implementation to make
   -- a single call to 'genRange' to establish a generator's range, without
   -- being concerned that the generator returned by (say) 'next' might have
   -- a different range to the generator passed to 'next'.
   genRange :: g -> (Int,Int)

   -- default method
   genRange g = (minBound,maxBound)

{- |The "System.Random" library provides one instance of 'RandomGen', the
abstract data type 'StdGen'.

The 'StdGen' instance of 'RandomGen' has a 'genRange' of at least 30 bits.

The result of repeatedly using 'next' should be at least as statistically
robust as the /Minimal Standard Random Number Generator/ described by
["System.Random\#Park", "System.Random\#Carta"].
Until more is known about implementations of 'split', all we require is
that 'split' deliver generators that are (a) not identical and
(b) independently robust in the sense just given.

The 'Show' and 'Read' instances of 'StdGen' provide a primitive way to save the
state of a random number generator.
It is required that @'read' ('show' g) == g@.

In addition, 'read' may be used to map an arbitrary string (not necessarily one
produced by 'show') onto a value of type 'StdGen'. In general, the 'read'
instance of 'StdGen' has the following properties: 

* It guarantees to succeed on any string. 

* It guarantees to consume only a finite portion of the string. 

* Different argument strings are likely to result in different results.

-}

data StdGen 
 = StdGen Int Int

instance RandomGen StdGen where
  next  = stdNext
  split = stdSplit
  genRange _ = stdRange

instance Show StdGen where
  showsPrec p (StdGen s1 s2) = 
     showsPrec p s1 . 
     showChar ' ' .
     showsPrec p s2

instance Read StdGen where
  readsPrec _p = \ r ->
     case try_read r of
       r@[_] -> r
       _   -> [stdFromString r] -- because it shouldn't ever fail.
    where 
      try_read r = do
         (s1, r1) <- readDec (dropWhile isSpace r)
	 (s2, r2) <- readDec (dropWhile isSpace r1)
	 return (StdGen s1 s2, r2)

{-
 If we cannot unravel the StdGen from a string, create
 one based on the string given.
-}
stdFromString         :: String -> (StdGen, String)
stdFromString s        = (mkStdGen num, rest)
	where (cs, rest) = splitAt 6 s
              num        = foldl (\a x -> x + 3 * a) 1 (map ord cs)


{- |
The function 'mkStdGen' provides an alternative way of producing an initial
generator, by mapping an 'Int' into a generator. Again, distinct arguments
should be likely to produce distinct generators.

Programmers may, of course, supply their own instances of 'RandomGen'.
-}
mkStdGen :: Int -> StdGen -- why not Integer ?
mkStdGen s
 | s < 0     = mkStdGen (-s)
 | otherwise = StdGen (s1+1) (s2+1)
      where
	(q, s1) = s `divMod` 2147483562
	s2      = q `mod` 2147483398

createStdGen :: Integer -> StdGen
createStdGen s
 | s < 0     = createStdGen (-s)
 | otherwise = StdGen (fromInteger (s1+1)) (fromInteger (s2+1))
      where
	(q, s1) = s `divMod` 2147483562
	s2      = q `mod` 2147483398

-- FIXME: 1/2/3 below should be ** (vs@30082002) XXX

{- |
With a source of random number supply in hand, the 'Random' class allows the
programmer to extract random values of a variety of types.

Minimal complete definition: 'randomR' and 'random'.

-}

class Random a where
  -- | Takes a range /(lo,hi)/ and a random number generator
  -- /g/, and returns a random value uniformly distributed in the closed
  -- interval /[lo,hi]/, together with a new generator. It is unspecified
  -- what happens if /lo>hi/. For continuous types there is no requirement
  -- that the values /lo/ and /hi/ are ever produced, but they may be,
  -- depending on the implementation and the interval.
  randomR :: RandomGen g => (a,a) -> g -> (a,g)

  -- | The same as 'randomR', but using a default range determined by the type:
  --
  -- * For bounded types (instances of 'Bounded', such as 'Char'),
  --   the range is normally the whole type.
  --
  -- * For fractional types, the range is normally the semi-closed interval
  -- @[0,1)@.
  --
  -- * For 'Integer', the range is (arbitrarily) the range of 'Int'.
  random  :: RandomGen g => g -> (a, g)

  -- | Plural variant of 'randomR', producing an infinite list of
  -- random values instead of returning a new generator.
  randomRs :: RandomGen g => (a,a) -> g -> [a]
  randomRs ival g = x : randomRs ival g' where (x,g') = randomR ival g

  -- | Plural variant of 'random', producing an infinite list of
  -- random values instead of returning a new generator.
  randoms  :: RandomGen g => g -> [a]
  randoms  g      = (\(x,g') -> x : randoms g') (random g)

  -- | A variant of 'randomR' that uses the global random number generator
  -- (see "System.Random#globalrng").
  randomRIO :: (a,a) -> IO a
  randomRIO range  = getStdRandom (randomR range)

  -- | A variant of 'random' that uses the global random number generator
  -- (see "System.Random#globalrng").
  randomIO  :: IO a
  randomIO	   = getStdRandom random


instance Random Int where
  randomR (a,b) g = randomIvalInteger (toInteger a, toInteger b) g
  random g        = randomR (minBound,maxBound) g

instance Random Char where
  randomR (a,b) g = 
      case (randomIvalInteger (toInteger (ord a), toInteger (ord b)) g) of
        (x,g) -> (chr x, g)
  random g	  = randomR (minBound,maxBound) g

instance Random Bool where
  randomR (a,b) g = 
      case (randomIvalInteger (toInteger (bool2Int a), toInteger (bool2Int b)) g) of
        (x, g) -> (int2Bool x, g)
       where
         bool2Int False = 0
         bool2Int True  = 1

	 int2Bool 0	= False
	 int2Bool _	= True

  random g	  = randomR (minBound,maxBound) g
 
instance Random Integer where
  randomR ival g = randomIvalInteger ival g
  random g	 = randomR (toInteger (minBound::Int), toInteger (maxBound::Int)) g

instance Random Double where
  randomR ival g = randomIvalDouble ival id g
  random g       = randomR (0::Double,1) g
  
-- hah, so you thought you were saving cycles by using Float?
instance Random Float where
  random g        = randomIvalDouble (0::Double,1) realToFrac g
  randomR (a,b) g = randomIvalDouble (realToFrac a, realToFrac b) realToFrac g

mkStdRNG :: Integer -> IO StdGen
mkStdRNG o = do
    ct          <- getCPUTime
    (TOD sec _) <- getClockTime
    return (createStdGen (sec * 12345 + ct + o))

randomIvalInteger :: (RandomGen g, Num a) => (Integer, Integer) -> g -> (a, g)
randomIvalInteger (l,h) rng
 | l > h     = randomIvalInteger (h,l) rng
 | otherwise = case (f n 1 rng) of (v, rng') -> (fromInteger (l + v `mod` k), rng')
     where
       k = h - l + 1
       b = 2147483561
       n = iLogBase b k

       f 0 acc g = (acc, g)
       f n acc g = 
          let
	   (x,g')   = next g
	  in
	  f (n-1) (fromIntegral x + acc * b) g'

randomIvalDouble :: (RandomGen g, Fractional a) => (Double, Double) -> (Double -> a) -> g -> (a, g)
randomIvalDouble (l,h) fromDouble rng 
  | l > h     = randomIvalDouble (h,l) fromDouble rng
  | otherwise = 
       case (randomIvalInteger (toInteger (minBound::Int), toInteger (maxBound::Int)) rng) of
         (x, rng') -> 
	    let
	     scaled_x = 
		fromDouble ((l+h)/2) + 
                fromDouble ((h-l) / realToFrac intRange) *
		fromIntegral (x::Int)
	    in
	    (scaled_x, rng')

intRange :: Integer
intRange  = toInteger (maxBound::Int) - toInteger (minBound::Int)

iLogBase :: Integer -> Integer -> Integer
iLogBase b i = if i < b then 1 else 1 + iLogBase b (i `div` b)

stdRange :: (Int,Int)
stdRange = (0, 2147483562)

stdNext :: StdGen -> (Int, StdGen)
-- Returns values in the range stdRange
stdNext (StdGen s1 s2) = (z', StdGen s1'' s2'')
	where	z'   = if z < 1 then z + 2147483562 else z
		z    = s1'' - s2''

		k    = s1 `quot` 53668
		s1'  = 40014 * (s1 - k * 53668) - k * 12211
		s1'' = if s1' < 0 then s1' + 2147483563 else s1'
    
		k'   = s2 `quot` 52774
		s2'  = 40692 * (s2 - k' * 52774) - k' * 3791
		s2'' = if s2' < 0 then s2' + 2147483399 else s2'

stdSplit            :: StdGen -> (StdGen, StdGen)
stdSplit std@(StdGen s1 s2)
                     = (left, right)
                       where
                        -- no statistical foundation for this!
                        left    = StdGen new_s1 t2
                        right   = StdGen t1 new_s2

                        new_s1 | s1 == 2147483562 = 1
                               | otherwise        = s1 + 1

                        new_s2 | s2 == 1          = 2147483398
                               | otherwise        = s2 - 1

                        StdGen t1 t2 = snd (next std)

-- The global random number generator

{- $globalrng #globalrng#

There is a single, implicit, global random number generator of type
'StdGen', held in some global variable maintained by the 'IO' monad. It is
initialised automatically in some system-dependent fashion, for example, by
using the time of day, or Linux's kernel random number generator. To get
deterministic behaviour, use 'setStdGen'.
-}

-- |Sets the global random number generator.
setStdGen :: StdGen -> IO ()
setStdGen sgen = writeIORef theStdGen sgen

-- |Gets the global random number generator.
getStdGen :: IO StdGen
getStdGen  = readIORef theStdGen

theStdGen :: IORef StdGen
theStdGen  = unsafePerformIO $ do
   rng <- mkStdRNG 0
   newIORef rng

-- |Applies 'split' to the current global random generator,
-- updates it with one of the results, and returns the other.
newStdGen :: IO StdGen
newStdGen = do
  rng <- getStdGen
  let (a,b) = split rng
  setStdGen a
  return b

{- |Uses the supplied function to get a value from the current global
random generator, and updates the global generator with the new generator
returned by the function. For example, @rollDice@ gets a random integer
between 1 and 6:

>  rollDice :: IO Int
>  rollDice = getStdRandom (randomR (1,6))

-}

getStdRandom :: (StdGen -> (a,StdGen)) -> IO a
getStdRandom f = do
   rng		<- getStdGen
   let (v, new_rng) = f rng
   setStdGen new_rng
   return v

{- $references

1. FW #Burton# Burton and RL Page, /Distributed random number generation/,
Journal of Functional Programming, 2(2):203-212, April 1992.

2. SK #Park# Park, and KW Miller, /Random number generators -
good ones are hard to find/, Comm ACM 31(10), Oct 1988, pp1192-1201.

3. DG #Carta# Carta, /Two fast implementations of the minimal standard
random number generator/, Comm ACM, 33(1), Jan 1990, pp87-88.

4. P #Hellekalek# Hellekalek, /Don\'t trust parallel Monte Carlo/,
Department of Mathematics, University of Salzburg,
<http://random.mat.sbg.ac.at/~peter/pads98.ps>, 1998.

5. Pierre #LEcuyer# L'Ecuyer, /Efficient and portable combined random
number generators/, Comm ACM, 31(6), Jun 1988, pp742-749.

The Web site <http://random.mat.sbg.ac.at/> is a great source of information.

-}
{-# OPTIONS_GHC -optc-D__HUGS__ #-}
{-# LINE 1 "System/Time.hsc" #-}
-----------------------------------------------------------------------------
{-# LINE 2 "System/Time.hsc" #-}
-- |
-- Module      :  System.Time
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- The standard Time library, providing standard functionality for clock
-- times, including timezone information (i.e, the functionality of
-- \"@time.h@\", adapted to the Haskell environment).  It follows RFC
-- 1129 in its use of Coordinated Universal Time (UTC).
-----------------------------------------------------------------------------

{-
Haskell 98 Time of Day Library
------------------------------

2000/06/17 <michael.weber@post.rwth-aachen.de>:
RESTRICTIONS:
  * min./max. time diff currently is restricted to
    [minBound::Int, maxBound::Int]

  * surely other restrictions wrt. min/max bounds


NOTES:
  * printing times

    `showTime' (used in `instance Show ClockTime') always prints time
    converted to the local timezone (even if it is taken from
    `(toClockTime . toUTCTime)'), whereas `calendarTimeToString'
    honors the tzone & tz fields and prints UTC or whatever timezone
    is stored inside CalendarTime.

    Maybe `showTime' should be changed to use UTC, since it would
    better correspond to the actual representation of `ClockTime'
    (can be done by replacing localtime(3) by gmtime(3)).


BUGS:
  * add proper handling of microsecs, currently, they're mostly
    ignored

  * `formatFOO' case of `%s' is currently broken...


TODO:
  * check for unusual date cases, like 1970/1/1 00:00h, and conversions
    between different timezone's etc.

  * check, what needs to be in the IO monad, the current situation
    seems to be a bit inconsistent to me

  * check whether `isDst = -1' works as expected on other arch's
    (Solaris anyone?)

  * add functions to parse strings to `CalendarTime' (some day...)

  * implement padding capabilities ("%_", "%-") in `formatFOO'

  * add rfc822 timezone (+0200 is CEST) representation ("%z") in `formatFOO'
-}

module System.Time
     (
	-- * Clock times

        ClockTime(..) -- non-standard, lib. report gives this as abstract
	-- instance Eq, Ord
	-- instance Show (non-standard)

     ,	getClockTime

	-- * Time differences

     ,  TimeDiff(..)
     ,  noTimeDiff      -- non-standard (but useful when constructing TimeDiff vals.)
     ,  diffClockTimes
     ,  addToClockTime

     ,  normalizeTimeDiff -- non-standard
     ,  timeDiffToString  -- non-standard
     ,  formatTimeDiff    -- non-standard

	-- * Calendar times

     ,  CalendarTime(..)
     ,  Month(..)
     ,  Day(..)
     ,	toCalendarTime
     ,  toUTCTime
     ,  toClockTime
     ,  calendarTimeToString
     ,  formatCalendarTime

     ) where


{-# LINE 104 "System/Time.hsc" #-}


{-# LINE 114 "System/Time.hsc" #-}

import Prelude

import Data.Ix
import System.Locale
import System.IO.Unsafe


{-# LINE 122 "System/Time.hsc" #-}
import Hugs.Time ( getClockTimePrim, toCalTimePrim, toClockTimePrim )

{-# LINE 127 "System/Time.hsc" #-}

-- One way to partition and give name to chunks of a year and a week:

-- | A month of the year.

data Month
 = January   | February | March    | April
 | May       | June     | July     | August
 | September | October  | November | December
 deriving (Eq, Ord, Enum, Bounded, Ix, Read, Show)

-- | A day of the week.

data Day 
 = Sunday   | Monday | Tuesday | Wednesday
 | Thursday | Friday | Saturday
 deriving (Eq, Ord, Enum, Bounded, Ix, Read, Show)

-- | A representation of the internal clock time.
-- Clock times may be compared, converted to strings, or converted to an
-- external calendar time 'CalendarTime' for I\/O or other manipulations.

data ClockTime = TOD Integer Integer
		-- ^ Construct a clock time.  The arguments are a number
		-- of seconds since 00:00:00 (UTC) on 1 January 1970,
		-- and an additional number of picoseconds.
		--
		-- In Haskell 98, the 'ClockTime' type is abstract.
	       deriving (Eq, Ord)

-- When a ClockTime is shown, it is converted to a CalendarTime in the current
-- timezone and then printed.  FIXME: This is arguably wrong, since we can't
-- get the current timezone without being in the IO monad.

instance Show ClockTime where
    showsPrec _ t = showString (calendarTimeToString 
	  			 (unsafePerformIO (toCalendarTime t)))

{-
The numeric fields have the following ranges.

\begin{verbatim}
Value         Range             Comments
-----         -----             --------

year    -maxInt .. maxInt       [Pre-Gregorian dates are inaccurate]
day           1 .. 31
hour          0 .. 23
min           0 .. 59
sec           0 .. 61           [Allows for two leap seconds]
picosec       0 .. (10^12)-1    [This could be over-precise?]
yday          0 .. 365          [364 in non-Leap years]
tz       -43200 .. 43200        [Variation from UTC in seconds]
\end{verbatim}
-}

-- | 'CalendarTime' is a user-readable and manipulable
-- representation of the internal 'ClockTime' type.

data CalendarTime 
 = CalendarTime  {
       ctYear    :: Int		-- ^ Year (pre-Gregorian dates are inaccurate)
     , ctMonth   :: Month	-- ^ Month of the year
     , ctDay     :: Int		-- ^ Day of the month (1 to 31)
     , ctHour    :: Int		-- ^ Hour of the day (0 to 23)
     , ctMin     :: Int		-- ^ Minutes (0 to 59)
     , ctSec     :: Int		-- ^ Seconds (0 to 61, allowing for up to
				-- two leap seconds)
     , ctPicosec :: Integer	-- ^ Picoseconds
     , ctWDay    :: Day		-- ^ Day of the week
     , ctYDay    :: Int		-- ^ Day of the year
				-- (0 to 364, or 365 in leap years)
     , ctTZName  :: String	-- ^ Name of the time zone
     , ctTZ      :: Int		-- ^ Variation from UTC in seconds
     , ctIsDST   :: Bool	-- ^ 'True' if Daylight Savings Time would
				-- be in effect, and 'False' otherwise
 }
 deriving (Eq,Ord,Read,Show)

-- | records the difference between two clock times in a user-readable way.

data TimeDiff
 = TimeDiff {
     tdYear    :: Int,
     tdMonth   :: Int,
     tdDay     :: Int,
     tdHour    :: Int,
     tdMin     :: Int,
     tdSec     :: Int,
     tdPicosec :: Integer -- not standard
   }
   deriving (Eq,Ord,Read,Show)

-- | null time difference.

noTimeDiff :: TimeDiff
noTimeDiff = TimeDiff 0 0 0 0 0 0 0

-- -----------------------------------------------------------------------------
-- | returns the current time in its internal representation.

getClockTime :: IO ClockTime

{-# LINE 230 "System/Time.hsc" #-}
getClockTime = do
  (sec,usec) <- getClockTimePrim
  return (TOD (fromIntegral sec) ((fromIntegral usec) * 1000000))


{-# LINE 259 "System/Time.hsc" #-}

-- -----------------------------------------------------------------------------
-- | @'addToClockTime' d t@ adds a time difference @d@ and a
-- clock time @t@ to yield a new clock time.  The difference @d@
-- may be either positive or negative.

addToClockTime  :: TimeDiff  -> ClockTime -> ClockTime
addToClockTime (TimeDiff year mon day hour min sec psec) 
	       (TOD c_sec c_psec) = 
	let
	  sec_diff = toInteger sec +
                     60 * toInteger min +
                     3600 * toInteger hour +
                     24 * 3600 * toInteger day
          (d_sec, d_psec) = (c_psec + psec) `quotRem` 1000000000000
          cal      = toUTCTime (TOD (c_sec + sec_diff + d_sec) d_psec)
          new_mon  = fromEnum (ctMonth cal) + r_mon 
	  month' = fst tmp
	  yr_diff = snd tmp
          tmp
	    | new_mon < 0  = (toEnum (12 + new_mon), (-1))
	    | new_mon > 11 = (toEnum (new_mon `mod` 12), 1)
	    | otherwise    = (toEnum new_mon, 0)
	    
	  (r_yr, r_mon) = mon `quotRem` 12

          year' = ctYear cal + year + r_yr + yr_diff
	in
	toClockTime cal{ctMonth=month', ctYear=year'}

-- | @'diffClockTimes' t1 t2@ returns the difference between two clock
-- times @t1@ and @t2@ as a 'TimeDiff'.

diffClockTimes  :: ClockTime -> ClockTime -> TimeDiff
-- diffClockTimes is meant to be the dual to `addToClockTime'.
-- If you want to have the TimeDiff properly splitted, use
-- `normalizeTimeDiff' on this function's result
--
-- CAVEAT: see comment of normalizeTimeDiff
diffClockTimes (TOD sa pa) (TOD sb pb) =
    noTimeDiff{ tdSec     = fromIntegral (sa - sb) 
                -- FIXME: can handle just 68 years...
              , tdPicosec = pa - pb
              }


-- | converts a time difference to normal form.

normalizeTimeDiff :: TimeDiff -> TimeDiff
-- FIXME: handle psecs properly
-- FIXME: ?should be called by formatTimeDiff automagically?
--
-- when applied to something coming out of `diffClockTimes', you loose
-- the duality to `addToClockTime', since a year does not always have
-- 365 days, etc.
--
-- apply this function as late as possible to prevent those "rounding"
-- errors
normalizeTimeDiff td =
  let
      rest0 = toInteger (tdSec td)
               + 60 * (toInteger (tdMin td)
                    + 60 * (toInteger (tdHour td)
                         + 24 * (toInteger (tdDay td)
                              + 30 * toInteger (tdMonth td)
                              + 365 * toInteger (tdYear td))))

      (diffYears,  rest1)    = rest0 `quotRem` (365 * 24 * 3600)
      (diffMonths, rest2)    = rest1 `quotRem` (30 * 24 * 3600)
      (diffDays,   rest3)    = rest2 `quotRem` (24 * 3600)
      (diffHours,  rest4)    = rest3 `quotRem` 3600
      (diffMins,   diffSecs) = rest4 `quotRem` 60
  in
      td{ tdYear  = fromInteger diffYears
        , tdMonth = fromInteger diffMonths
        , tdDay   = fromInteger diffDays
        , tdHour  = fromInteger diffHours
        , tdMin   = fromInteger diffMins
        , tdSec   = fromInteger diffSecs
        }


{-# LINE 402 "System/Time.hsc" #-}

-- -----------------------------------------------------------------------------
-- | converts an internal clock time to a local time, modified by the
-- timezone and daylight savings time settings in force at the time
-- of conversion.  Because of this dependence on the local environment,
-- 'toCalendarTime' is in the 'IO' monad.

toCalendarTime :: ClockTime -> IO CalendarTime

{-# LINE 411 "System/Time.hsc" #-}
toCalendarTime =  toCalTime False

{-# LINE 417 "System/Time.hsc" #-}

-- | converts an internal clock time into a 'CalendarTime' in standard
-- UTC format.

toUTCTime :: ClockTime -> CalendarTime

{-# LINE 423 "System/Time.hsc" #-}
toUTCTime      =  unsafePerformIO . toCalTime True

{-# LINE 429 "System/Time.hsc" #-}


{-# LINE 431 "System/Time.hsc" #-}
toCalTime :: Bool -> ClockTime -> IO CalendarTime
toCalTime toUTC (TOD s psecs)
  | (s > fromIntegral (maxBound :: Int)) || 
    (s < fromIntegral (minBound :: Int))
  = error ((if toUTC then "toUTCTime: " else "toCalendarTime: ") ++
           "clock secs out of range")
  | otherwise = do
    (sec,min,hour,mday,mon,year,wday,yday,isdst,zone,off) <- 
  		toCalTimePrim (if toUTC then 1 else 0) (fromIntegral s)
    return (CalendarTime{ ctYear=1900+year
  		        , ctMonth=toEnum mon
		        , ctDay=mday
		        , ctHour=hour
		        , ctMin=min
		        , ctSec=sec
		        , ctPicosec=psecs
		        , ctWDay=toEnum wday
		        , ctYDay=yday
		        , ctTZName=(if toUTC then "UTC" else zone)
		        , ctTZ=(if toUTC then 0 else off)
		        , ctIsDST=not toUTC && (isdst/=0)
		        })

{-# LINE 510 "System/Time.hsc" #-}

-- | converts a 'CalendarTime' into the corresponding internal
-- 'ClockTime', ignoring the contents of the  'ctWDay', 'ctYDay',
-- 'ctTZName' and 'ctIsDST' fields.

toClockTime :: CalendarTime -> ClockTime

{-# LINE 517 "System/Time.hsc" #-}
toClockTime (CalendarTime yr mon mday hour min sec psec
			  _wday _yday _tzname tz _isdst) =
  unsafePerformIO $ do
    s <- toClockTimePrim (yr-1900) (fromEnum mon) mday hour min sec tz
    return (TOD (fromIntegral s) psec)

{-# LINE 566 "System/Time.hsc" #-}

-- -----------------------------------------------------------------------------
-- Converting time values to strings.

-- | formats calendar times using local conventions.

calendarTimeToString  :: CalendarTime -> String
calendarTimeToString  =  formatCalendarTime defaultTimeLocale "%c"

-- | formats calendar times using local conventions and a formatting string.
-- The formatting string is that understood by the ISO C @strftime()@
-- function.

formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
formatCalendarTime l fmt (CalendarTime year mon day hour min sec _
                                       wday yday tzname _ _) =
        doFmt fmt
  where doFmt ('%':'-':cs) = doFmt ('%':cs) -- padding not implemented
        doFmt ('%':'_':cs) = doFmt ('%':cs) -- padding not implemented
        doFmt ('%':c:cs)   = decode c ++ doFmt cs
        doFmt (c:cs) = c : doFmt cs
        doFmt "" = ""

        decode 'A' = fst (wDays l  !! fromEnum wday) -- day of the week, full name
        decode 'a' = snd (wDays l  !! fromEnum wday) -- day of the week, abbrev.
        decode 'B' = fst (months l !! fromEnum mon)  -- month, full name
        decode 'b' = snd (months l !! fromEnum mon)  -- month, abbrev
        decode 'h' = snd (months l !! fromEnum mon)  -- ditto
        decode 'C' = show2 (year `quot` 100)         -- century
        decode 'c' = doFmt (dateTimeFmt l)           -- locale's data and time format.
        decode 'D' = doFmt "%m/%d/%y"
        decode 'd' = show2 day                       -- day of the month
        decode 'e' = show2' day                      -- ditto, padded
        decode 'H' = show2 hour                      -- hours, 24-hour clock, padded
        decode 'I' = show2 (to12 hour)               -- hours, 12-hour clock
        decode 'j' = show3 yday                      -- day of the year
        decode 'k' = show2' hour                     -- hours, 24-hour clock, no padding
        decode 'l' = show2' (to12 hour)              -- hours, 12-hour clock, no padding
        decode 'M' = show2 min                       -- minutes
        decode 'm' = show2 (fromEnum mon+1)          -- numeric month
        decode 'n' = "\n"
        decode 'p' = (if hour < 12 then fst else snd) (amPm l) -- am or pm
        decode 'R' = doFmt "%H:%M"
        decode 'r' = doFmt (time12Fmt l)
        decode 'T' = doFmt "%H:%M:%S"
        decode 't' = "\t"
        decode 'S' = show2 sec			     -- seconds
        decode 's' = show2 sec			     -- number of secs since Epoch. (ToDo.)
        decode 'U' = show2 ((yday + 7 - fromEnum wday) `div` 7) -- week number, starting on Sunday.
        decode 'u' = show (let n = fromEnum wday in  -- numeric day of the week (1=Monday, 7=Sunday)
                           if n == 0 then 7 else n)
        decode 'V' =                                 -- week number (as per ISO-8601.)
            let (week, days) =                       -- [yep, I've always wanted to be able to display that too.]
                   (yday + 7 - if fromEnum wday > 0 then 
                               fromEnum wday - 1 else 6) `divMod` 7
            in  show2 (if days >= 4 then
                          week+1 
                       else if week == 0 then 53 else week)

        decode 'W' =				     -- week number, weeks starting on monday
            show2 ((yday + 7 - if fromEnum wday > 0 then 
                               fromEnum wday - 1 else 6) `div` 7)
        decode 'w' = show (fromEnum wday)            -- numeric day of the week, weeks starting on Sunday.
        decode 'X' = doFmt (timeFmt l)               -- locale's preferred way of printing time.
        decode 'x' = doFmt (dateFmt l)               -- locale's preferred way of printing dates.
        decode 'Y' = show year                       -- year, including century.
        decode 'y' = show2 (year `rem` 100)          -- year, within century.
        decode 'Z' = tzname                          -- timezone name
        decode '%' = "%"
        decode c   = [c]


show2, show2', show3 :: Int -> String
show2 x
 | x' < 10   = '0': show x'
 | otherwise = show x'
 where x' = x `rem` 100

show2' x
 | x' < 10   = ' ': show x'
 | otherwise = show x'
 where x' = x `rem` 100

show3 x = show (x `quot` 100) ++ show2 (x `rem` 100)

to12 :: Int -> Int
to12 h = let h' = h `mod` 12 in if h' == 0 then 12 else h'

-- Useful extensions for formatting TimeDiffs.

-- | formats time differences using local conventions.

timeDiffToString :: TimeDiff -> String
timeDiffToString = formatTimeDiff defaultTimeLocale "%c"

-- | formats time differences using local conventions and a formatting string.
-- The formatting string is that understood by the ISO C @strftime()@
-- function.

formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
formatTimeDiff l fmt td@(TimeDiff year month day hour min sec _)
 = doFmt fmt
  where 
   doFmt ""         = ""
   doFmt ('%':'-':cs) = doFmt ('%':cs) -- padding not implemented
   doFmt ('%':'_':cs) = doFmt ('%':cs) -- padding not implemented
   doFmt ('%':c:cs) = decode c ++ doFmt cs
   doFmt (c:cs)     = c : doFmt cs

   decode spec =
    case spec of
      'B' -> fst (months l !! fromEnum month)
      'b' -> snd (months l !! fromEnum month)
      'h' -> snd (months l !! fromEnum month)
      'c' -> defaultTimeDiffFmt td
      'C' -> show2 (year `quot` 100)
      'D' -> doFmt "%m/%d/%y"
      'd' -> show2 day
      'e' -> show2' day
      'H' -> show2 hour
      'I' -> show2 (to12 hour)
      'k' -> show2' hour
      'l' -> show2' (to12 hour)
      'M' -> show2 min
      'm' -> show2 (fromEnum month + 1)
      'n' -> "\n"
      'p' -> (if hour < 12 then fst else snd) (amPm l)
      'R' -> doFmt "%H:%M"
      'r' -> doFmt (time12Fmt l)
      'T' -> doFmt "%H:%M:%S"
      't' -> "\t"
      'S' -> show2 sec
      's' -> show2 sec -- Implementation-dependent, sez the lib doc..
      'X' -> doFmt (timeFmt l)
      'x' -> doFmt (dateFmt l)
      'Y' -> show year
      'y' -> show2 (year `rem` 100)
      '%' -> "%"
      c   -> [c]

   defaultTimeDiffFmt (TimeDiff year month day hour min sec _) =
       foldr (\ (v,s) rest -> 
                  (if v /= 0 
                     then show v ++ ' ':(addS v s)
                       ++ if null rest then "" else ", "
                     else "") ++ rest
             )
             ""
             (zip [year, month, day, hour, min, sec] (intervals l))

   addS v s = if abs v == 1 then fst s else snd s


{-# LINE 756 "System/Time.hsc" #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  System.Console.GetOpt
-- Copyright   :  (c) Sven Panne 2002-2005
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- This library provides facilities for parsing the command-line options
-- in a standalone program.  It is essentially a Haskell port of the GNU 
-- @getopt@ library.
--
-----------------------------------------------------------------------------

{-
Sven Panne <Sven.Panne@informatik.uni-muenchen.de> Oct. 1996 (small
changes Dec. 1997)

Two rather obscure features are missing: The Bash 2.0 non-option hack
(if you don't already know it, you probably don't want to hear about
it...) and the recognition of long options with a single dash
(e.g. '-help' is recognised as '--help', as long as there is no short
option 'h').

Other differences between GNU's getopt and this implementation:

* To enforce a coherent description of options and arguments, there
  are explanation fields in the option/argument descriptor.

* Error messages are now more informative, but no longer POSIX
  compliant... :-(

And a final Haskell advertisement: The GNU C implementation uses well
over 1100 lines, we need only 195 here, including a 46 line example! 
:-)
-}

module System.Console.GetOpt (
   -- * GetOpt
   getOpt, getOpt',
   usageInfo,
   ArgOrder(..),
   OptDescr(..),
   ArgDescr(..),

   -- * Example

   -- $example
) where

import Prelude -- necessary to get dependencies right

import Data.List ( isPrefixOf )

-- |What to do with options following non-options
data ArgOrder a
  = RequireOrder                -- ^ no option processing after first non-option
  | Permute                     -- ^ freely intersperse options and non-options
  | ReturnInOrder (String -> a) -- ^ wrap non-options into options

{-|
Each 'OptDescr' describes a single option.

The arguments to 'Option' are:

* list of short option characters

* list of long option strings (without \"--\")

* argument descriptor

* explanation of option for user
-}
data OptDescr a =              -- description of a single options:
   Option [Char]                --    list of short option characters
          [String]              --    list of long option strings (without "--")
          (ArgDescr a)          --    argument descriptor
          String                --    explanation of option for user

-- |Describes whether an option takes an argument or not, and if so
-- how the argument is injected into a value of type @a@.
data ArgDescr a
   = NoArg                   a         -- ^   no argument expected
   | ReqArg (String       -> a) String -- ^   option requires argument
   | OptArg (Maybe String -> a) String -- ^   optional argument

data OptKind a                -- kind of cmd line arg (internal use only):
   = Opt       a                --    an option
   | UnreqOpt  String           --    an un-recognized option
   | NonOpt    String           --    a non-option
   | EndOfOpts                  --    end-of-options marker (i.e. "--")
   | OptErr    String           --    something went wrong...

-- | Return a string describing the usage of a command, derived from
-- the header (first argument) and the options described by the 
-- second argument.
usageInfo :: String                    -- header
          -> [OptDescr a]              -- option descriptors
          -> String                    -- nicely formatted decription of options
usageInfo header optDescr = unlines (header:table)
   where (ss,ls,ds)     = (unzip3 . concatMap fmtOpt) optDescr
         table          = zipWith3 paste (sameLen ss) (sameLen ls) ds
         paste x y z    = "  " ++ x ++ "  " ++ y ++ "  " ++ z
         sameLen xs     = flushLeft ((maximum . map length) xs) xs
         flushLeft n xs = [ take n (x ++ repeat ' ') | x <- xs ]

fmtOpt :: OptDescr a -> [(String,String,String)]
fmtOpt (Option sos los ad descr) =
   case lines descr of
     []     -> [(sosFmt,losFmt,"")]
     (d:ds) ->  (sosFmt,losFmt,d) : [ ("","",d') | d' <- ds ]
   where sepBy _  []     = ""
         sepBy _  [x]    = x
         sepBy ch (x:xs) = x ++ ch:' ':sepBy ch xs
         sosFmt = sepBy ',' (map (fmtShort ad) sos)
         losFmt = sepBy ',' (map (fmtLong  ad) los)

fmtShort :: ArgDescr a -> Char -> String
fmtShort (NoArg  _   ) so = "-" ++ [so]
fmtShort (ReqArg _ ad) so = "-" ++ [so] ++ " " ++ ad
fmtShort (OptArg _ ad) so = "-" ++ [so] ++ "[" ++ ad ++ "]"

fmtLong :: ArgDescr a -> String -> String
fmtLong (NoArg  _   ) lo = "--" ++ lo
fmtLong (ReqArg _ ad) lo = "--" ++ lo ++ "=" ++ ad
fmtLong (OptArg _ ad) lo = "--" ++ lo ++ "[=" ++ ad ++ "]"

{-|
Process the command-line, and return the list of values that matched
(and those that didn\'t). The arguments are:

* The order requirements (see 'ArgOrder')

* The option descriptions (see 'OptDescr')

* The actual command line arguments (presumably got from 
  'System.Environment.getArgs').

'getOpt' returns a triple consisting of the option arguments, a list
of non-options, and a list of error messages.
-}
getOpt :: ArgOrder a                   -- non-option handling
       -> [OptDescr a]                 -- option descriptors
       -> [String]                     -- the command-line arguments
       -> ([a],[String],[String])      -- (options,non-options,error messages)
getOpt ordering optDescr args = (os,xs,es ++ map errUnrec us)
   where (os,xs,us,es) = getOpt' ordering optDescr args

{-|
This is almost the same as 'getOpt', but returns a quadruple
consisting of the option arguments, a list of non-options, a list of
unrecognized options, and a list of error messages.
-}
getOpt' :: ArgOrder a                         -- non-option handling
        -> [OptDescr a]                       -- option descriptors
        -> [String]                           -- the command-line arguments
        -> ([a],[String], [String] ,[String]) -- (options,non-options,unrecognized,error messages)
getOpt' _        _        []         =  ([],[],[],[])
getOpt' ordering optDescr (arg:args) = procNextOpt opt ordering
   where procNextOpt (Opt o)      _                 = (o:os,xs,us,es)
         procNextOpt (UnreqOpt u) _                 = (os,xs,u:us,es)
         procNextOpt (NonOpt x)   RequireOrder      = ([],x:rest,[],[])
         procNextOpt (NonOpt x)   Permute           = (os,x:xs,us,es)
         procNextOpt (NonOpt x)   (ReturnInOrder f) = (f x :os, xs,us,es)
         procNextOpt EndOfOpts    RequireOrder      = ([],rest,[],[])
         procNextOpt EndOfOpts    Permute           = ([],rest,[],[])
         procNextOpt EndOfOpts    (ReturnInOrder f) = (map f rest,[],[],[])
         procNextOpt (OptErr e)   _                 = (os,xs,us,e:es)

         (opt,rest) = getNext arg args optDescr
         (os,xs,us,es) = getOpt' ordering optDescr rest

-- take a look at the next cmd line arg and decide what to do with it
getNext :: String -> [String] -> [OptDescr a] -> (OptKind a,[String])
getNext ('-':'-':[]) rest _        = (EndOfOpts,rest)
getNext ('-':'-':xs) rest optDescr = longOpt xs rest optDescr
getNext ('-': x :xs) rest optDescr = shortOpt x xs rest optDescr
getNext a            rest _        = (NonOpt a,rest)

-- handle long option
longOpt :: String -> [String] -> [OptDescr a] -> (OptKind a,[String])
longOpt ls rs optDescr = long ads arg rs
   where (opt,arg) = break (=='=') ls
         getWith p = [ o  | o@(Option _ xs _ _) <- optDescr, x <- xs, opt `p` x ]
         exact     = getWith (==)
         options   = if null exact then getWith isPrefixOf else exact
         ads       = [ ad | Option _ _ ad _ <- options ]
         optStr    = ("--"++opt)

         long (_:_:_)      _        rest     = (errAmbig options optStr,rest)
         long [NoArg  a  ] []       rest     = (Opt a,rest)
         long [NoArg  _  ] ('=':_)  rest     = (errNoArg optStr,rest)
         long [ReqArg _ d] []       []       = (errReq d optStr,[])
         long [ReqArg f _] []       (r:rest) = (Opt (f r),rest)
         long [ReqArg f _] ('=':xs) rest     = (Opt (f xs),rest)
         long [OptArg f _] []       rest     = (Opt (f Nothing),rest)
         long [OptArg f _] ('=':xs) rest     = (Opt (f (Just xs)),rest)
         long _            _        rest     = (UnreqOpt ("--"++ls),rest)

-- handle short option
shortOpt :: Char -> String -> [String] -> [OptDescr a] -> (OptKind a,[String])
shortOpt y ys rs optDescr = short ads ys rs
  where options = [ o  | o@(Option ss _ _ _) <- optDescr, s <- ss, y == s ]
        ads     = [ ad | Option _ _ ad _ <- options ]
        optStr  = '-':[y]

        short (_:_:_)        _  rest     = (errAmbig options optStr,rest)
        short (NoArg  a  :_) [] rest     = (Opt a,rest)
        short (NoArg  a  :_) xs rest     = (Opt a,('-':xs):rest)
        short (ReqArg _ d:_) [] []       = (errReq d optStr,[])
        short (ReqArg f _:_) [] (r:rest) = (Opt (f r),rest)
        short (ReqArg f _:_) xs rest     = (Opt (f xs),rest)
        short (OptArg f _:_) [] rest     = (Opt (f Nothing),rest)
        short (OptArg f _:_) xs rest     = (Opt (f (Just xs)),rest)
        short []             [] rest     = (UnreqOpt optStr,rest)
        short []             xs rest     = (UnreqOpt optStr,('-':xs):rest)

-- miscellaneous error formatting

errAmbig :: [OptDescr a] -> String -> OptKind a
errAmbig ods optStr = OptErr (usageInfo header ods)
   where header = "option `" ++ optStr ++ "' is ambiguous; could be one of:"

errReq :: String -> String -> OptKind a
errReq d optStr = OptErr ("option `" ++ optStr ++ "' requires an argument " ++ d ++ "\n")

errUnrec :: String -> String
errUnrec optStr = "unrecognized option `" ++ optStr ++ "'\n"

errNoArg :: String -> OptKind a
errNoArg optStr = OptErr ("option `" ++ optStr ++ "' doesn't allow an argument\n")

{-
-----------------------------------------------------------------------------------------
-- and here a small and hopefully enlightening example:

data Flag = Verbose | Version | Name String | Output String | Arg String   deriving Show

options :: [OptDescr Flag]
options =
   [Option ['v']     ["verbose"]           (NoArg Verbose)      "verbosely list files",
    Option ['V','?'] ["version","release"] (NoArg Version)      "show version info",
    Option ['o']     ["output"]            (OptArg out "FILE")  "use FILE for dump",
    Option ['n']     ["name"]              (ReqArg Name "USER") "only dump USER's files"]

out :: Maybe String -> Flag
out Nothing  = Output "stdout"
out (Just o) = Output o

test :: ArgOrder Flag -> [String] -> String
test order cmdline = case getOpt order options cmdline of
                        (o,n,[]  ) -> "options=" ++ show o ++ "  args=" ++ show n ++ "\n"
                        (_,_,errs) -> concat errs ++ usageInfo header options
   where header = "Usage: foobar [OPTION...] files..."

-- example runs:
-- putStr (test RequireOrder ["foo","-v"])
--    ==> options=[]  args=["foo", "-v"]
-- putStr (test Permute ["foo","-v"])
--    ==> options=[Verbose]  args=["foo"]
-- putStr (test (ReturnInOrder Arg) ["foo","-v"])
--    ==> options=[Arg "foo", Verbose]  args=[]
-- putStr (test Permute ["foo","--","-v"])
--    ==> options=[]  args=["foo", "-v"]
-- putStr (test Permute ["-?o","--name","bar","--na=baz"])
--    ==> options=[Version, Output "stdout", Name "bar", Name "baz"]  args=[]
-- putStr (test Permute ["--ver","foo"])
--    ==> option `--ver' is ambiguous; could be one of:
--          -v      --verbose             verbosely list files
--          -V, -?  --version, --release  show version info   
--        Usage: foobar [OPTION...] files...
--          -v        --verbose             verbosely list files  
--          -V, -?    --version, --release  show version info     
--          -o[FILE]  --output[=FILE]       use FILE for dump     
--          -n USER   --name=USER           only dump USER's files
-----------------------------------------------------------------------------------------
-}

{- $example

To hopefully illuminate the role of the different data
structures, here\'s the command-line options for a (very simple)
compiler:

>    module Opts where
>    
>    import System.Console.GetOpt
>    import Data.Maybe ( fromMaybe )
>    
>    data Flag 
>     = Verbose  | Version 
>     | Input String | Output String | LibDir String
>       deriving Show
>    
>    options :: [OptDescr Flag]
>    options =
>     [ Option ['v']     ["verbose"] (NoArg Verbose)       "chatty output on stderr"
>     , Option ['V','?'] ["version"] (NoArg Version)       "show version number"
>     , Option ['o']     ["output"]  (OptArg outp "FILE")  "output FILE"
>     , Option ['c']     []          (OptArg inp  "FILE")  "input FILE"
>     , Option ['L']     ["libdir"]  (ReqArg LibDir "DIR") "library directory"
>     ]
>    
>    inp,outp :: Maybe String -> Flag
>    outp = Output . fromMaybe "stdout"
>    inp  = Input  . fromMaybe "stdin"
>    
>    compilerOpts :: [String] -> IO ([Flag], [String])
>    compilerOpts argv = 
>       case getOpt Permute options argv of
>          (o,n,[]  ) -> return (o,n)
>          (_,_,errs) -> ioError (userError (concat errs ++ usageInfo header options))
>      where header = "Usage: ic [OPTION...] files..."

-}
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  System.Directory.Internals
-- Copyright   :  (c) The University of Glasgow 2005
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  hidden
-- Portability :  portable
--
-- System-independent pathname manipulations.
--
-----------------------------------------------------------------------------

-- #hide
module System.Directory.Internals (
        joinFileName,
	joinFileExt,
	parseSearchPath,
	pathParents,
	exeExtension,
  ) where





import Data.List

-- | The 'joinFileName' function is the opposite of 'splitFileName'. 
-- It joins directory and file names to form a complete file path.
--
-- The general rule is:
--
-- > dir `joinFileName` basename == path
-- >   where
-- >     (dir,basename) = splitFileName path
--
-- There might be an exceptions to the rule but in any case the
-- reconstructed path will refer to the same object (file or directory).
-- An example exception is that on Windows some slashes might be converted
-- to backslashes.
joinFileName :: String -> String -> FilePath
joinFileName ""  fname = fname
joinFileName "." fname = fname
joinFileName dir ""    = dir
joinFileName dir fname
  | isPathSeparator (last dir) = dir++fname
  | otherwise                  = dir++pathSeparator:fname

-- | The 'joinFileExt' function is the opposite of 'splitFileExt'.
-- It joins a file name and an extension to form a complete file path.
--
-- The general rule is:
--
-- > filename `joinFileExt` ext == path
-- >   where
-- >     (filename,ext) = splitFileExt path
joinFileExt :: String -> String -> FilePath
joinFileExt path ""  = path
joinFileExt path ext = path ++ '.':ext

-- | Gets this path and all its parents.
-- The function is useful in case if you want to create 
-- some file but you aren\'t sure whether all directories 
-- in the path exist or if you want to search upward for some file.
-- 
-- Some examples:
--
-- \[Posix\]
--
-- >  pathParents "/"          == ["/"]
-- >  pathParents "/dir1"      == ["/", "/dir1"]
-- >  pathParents "/dir1/dir2" == ["/", "/dir1", "/dir1/dir2"]
-- >  pathParents "dir1"       == [".", "dir1"]
-- >  pathParents "dir1/dir2"  == [".", "dir1", "dir1/dir2"]
--
-- \[Windows\]
--
-- >  pathParents "c:"             == ["c:."]
-- >  pathParents "c:\\"           == ["c:\\"]
-- >  pathParents "c:\\dir1"       == ["c:\\", "c:\\dir1"]
-- >  pathParents "c:\\dir1\\dir2" == ["c:\\", "c:\\dir1", "c:\\dir1\\dir2"]
-- >  pathParents "c:dir1"         == ["c:.","c:dir1"]
-- >  pathParents "dir1\\dir2"     == [".", "dir1", "dir1\\dir2"]
--
-- Note that if the file is relative then the current directory (\".\") 
-- will be explicitly listed.
pathParents :: FilePath -> [FilePath]
pathParents p =
    root'' : map ((++) root') (dropEmptyPath $ inits path')
    where





       (root,path) = ("",p)

       (root',root'',path') = case path of
         (c:path) | isPathSeparator c -> (root++[pathSeparator],root++[pathSeparator],path)
         _                            -> (root                 ,root++"."            ,path)

       dropEmptyPath ("":paths) = paths
       dropEmptyPath paths      = paths

       inits :: String -> [String]
       inits [] =  [""]
       inits cs = 
         case pre of
           "."  -> inits suf
           ".." -> map (joinFileName pre) (dropEmptyPath $ inits suf)
           _    -> "" : map (joinFileName pre) (inits suf)
         where
           (pre,suf) = case break isPathSeparator cs of
              (pre,"")    -> (pre, "")
              (pre,_:suf) -> (pre,suf)

--------------------------------------------------------------
-- * Search path
--------------------------------------------------------------

-- | The function splits the given string to substrings
-- using the 'searchPathSeparator'.
parseSearchPath :: String -> [FilePath]
parseSearchPath path = split path
  where
    split :: String -> [String]
    split s =
      case rest' of
        []     -> [chunk] 
        _:rest -> chunk : split rest
      where
        chunk = 
          case chunk' of



            _                                 -> chunk'
    
        (chunk', rest') = break (==searchPathSeparator) s

--------------------------------------------------------------
-- * Separators
--------------------------------------------------------------

-- | Checks whether the character is a valid path separator for the host
-- platform. The valid character is a 'pathSeparator' but since the Windows
-- operating system also accepts a slash (\"\/\") since DOS 2, the function
-- checks for it on this platform, too.
isPathSeparator :: Char -> Bool
isPathSeparator ch = ch == pathSeparator || ch == '/'

-- | Provides a platform-specific character used to separate directory levels in
-- a path string that reflects a hierarchical file system organization. The
-- separator is a slash (@\"\/\"@) on Unix and Macintosh, and a backslash
-- (@\"\\\"@) on the Windows operating system.
pathSeparator :: Char



pathSeparator = '/'


-- ToDo: This should be determined via autoconf (PATH_SEPARATOR)
-- | A platform-specific character used to separate search path strings in
-- environment variables. The separator is a colon (@\":\"@) on Unix and
-- Macintosh, and a semicolon (@\";\"@) on the Windows operating system.
searchPathSeparator :: Char



searchPathSeparator = ':'


-- ToDo: This should be determined via autoconf (AC_EXEEXT)
-- | Extension for executable files
-- (typically @\"\"@ on Unix and @\"exe\"@ on Windows or OS\/2)
exeExtension :: String



exeExtension = ""


{-# OPTIONS_GHC -fno-implicit-prelude #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  System.IO.Error
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Standard IO Errors.
--
-----------------------------------------------------------------------------

module System.IO.Error (

    -- * I\/O errors
    IOError,			-- = IOException

    userError,		       	-- :: String  -> IOError


    mkIOError,			-- :: IOErrorType -> String -> Maybe Handle
				--    -> Maybe FilePath -> IOError

    annotateIOError,		-- :: IOError -> String -> Maybe Handle
				--    -> Maybe FilePath -> IOError


    -- ** Classifying I\/O errors
    isAlreadyExistsError,	-- :: IOError -> Bool
    isDoesNotExistError,
    isAlreadyInUseError,
    isFullError, 
    isEOFError,
    isIllegalOperation, 
    isPermissionError,
    isUserError,

    -- ** Attributes of I\/O errors

    ioeGetErrorType,		-- :: IOError -> IOErrorType

    ioeGetErrorString,		-- :: IOError -> String
    ioeGetHandle,		-- :: IOError -> Maybe Handle
    ioeGetFileName,		-- :: IOError -> Maybe FilePath


    ioeSetErrorType,		-- :: IOError -> IOErrorType -> IOError
    ioeSetErrorString,		-- :: IOError -> String -> IOError
    ioeSetHandle,		-- :: IOError -> Handle -> IOError
    ioeSetFileName,		-- :: IOError -> FilePath -> IOError


    -- * Types of I\/O error
    IOErrorType,		-- abstract

    alreadyExistsErrorType,	-- :: IOErrorType
    doesNotExistErrorType,
    alreadyInUseErrorType,
    fullErrorType,
    eofErrorType,
    illegalOperationErrorType, 
    permissionErrorType,
    userErrorType,

    -- ** 'IOErrorType' predicates
    isAlreadyExistsErrorType,	-- :: IOErrorType -> Bool
    isDoesNotExistErrorType,
    isAlreadyInUseErrorType,
    isFullErrorType, 
    isEOFErrorType,
    isIllegalOperationErrorType, 
    isPermissionErrorType,
    isUserErrorType, 

    -- * Throwing and catching I\/O errors

    ioError,		       	-- :: IOError -> IO a

    catch,			-- :: IO a -> (IOError -> IO a) -> IO a
    try,			-- :: IO a -> IO (Either IOError a)


    modifyIOError,		-- :: (IOError -> IOError) -> IO a -> IO a

  ) where

import Data.Either
import Data.Maybe









import Hugs.Prelude(Handle, IOException(..), IOErrorType(..))
























-- | The construct 'try' @comp@ exposes IO errors which occur within a
-- computation, and which are not fully handled.
--
-- Non-I\/O exceptions are not caught by this variant; to catch all
-- exceptions, use 'Control.Exception.try' from "Control.Exception".


try            :: IO a -> IO (Either IOError a)
try f          =  catch (do r <- f
                            return (Right r))
                        (return . Left)



-- -----------------------------------------------------------------------------
-- Constructing an IOError

-- | Construct an 'IOError' of the given type where the second argument
-- describes the error location and the third and fourth argument
-- contain the file handle and file path of the file involved in the
-- error if applicable.
mkIOError :: IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError
mkIOError t location maybe_hdl maybe_filename =
               IOError{ ioe_type = t, 
			ioe_location = location,
	   		ioe_description = "",
			ioe_handle = maybe_hdl, 
			ioe_filename = maybe_filename
 			}


















-- -----------------------------------------------------------------------------
-- IOErrorType

-- | An error indicating that an 'IO' operation failed because
-- one of its arguments already exists.
isAlreadyExistsError :: IOError -> Bool
isAlreadyExistsError = isAlreadyExistsErrorType    . ioeGetErrorType

-- | An error indicating that an 'IO' operation failed because
-- one of its arguments does not exist.
isDoesNotExistError :: IOError -> Bool
isDoesNotExistError  = isDoesNotExistErrorType     . ioeGetErrorType

-- | An error indicating that an 'IO' operation failed because
-- one of its arguments is a single-use resource, which is already
-- being used (for example, opening the same file twice for writing
-- might give this error).
isAlreadyInUseError :: IOError -> Bool
isAlreadyInUseError  = isAlreadyInUseErrorType     . ioeGetErrorType

-- | An error indicating that an 'IO' operation failed because
-- the device is full.
isFullError         :: IOError -> Bool
isFullError          = isFullErrorType             . ioeGetErrorType

-- | An error indicating that an 'IO' operation failed because
-- the end of file has been reached.
isEOFError          :: IOError -> Bool
isEOFError           = isEOFErrorType              . ioeGetErrorType

-- | An error indicating that an 'IO' operation failed because
-- the operation was not possible.
-- Any computation which returns an 'IO' result may fail with
-- 'isIllegalOperation'.  In some cases, an implementation will not be
-- able to distinguish between the possible error causes.  In this case
-- it should fail with 'isIllegalOperation'.
isIllegalOperation  :: IOError -> Bool
isIllegalOperation   = isIllegalOperationErrorType . ioeGetErrorType

-- | An error indicating that an 'IO' operation failed because
-- the user does not have sufficient operating system privilege
-- to perform that operation.
isPermissionError   :: IOError -> Bool
isPermissionError    = isPermissionErrorType       . ioeGetErrorType

-- | A programmer-defined error value constructed using 'userError'.
isUserError         :: IOError -> Bool
isUserError          = isUserErrorType             . ioeGetErrorType


-- -----------------------------------------------------------------------------
-- IOErrorTypes







-- | I\/O error where the operation failed because one of its arguments
-- already exists.
alreadyExistsErrorType   :: IOErrorType
alreadyExistsErrorType    = AlreadyExists

-- | I\/O error where the operation failed because one of its arguments
-- does not exist.
doesNotExistErrorType    :: IOErrorType
doesNotExistErrorType     = NoSuchThing

-- | I\/O error where the operation failed because one of its arguments
-- is a single-use resource, which is already being used.
alreadyInUseErrorType    :: IOErrorType
alreadyInUseErrorType     = ResourceBusy

-- | I\/O error where the operation failed because the device is full.
fullErrorType            :: IOErrorType
fullErrorType             = ResourceExhausted

-- | I\/O error where the operation failed because the end of file has
-- been reached.
eofErrorType             :: IOErrorType
eofErrorType              = EOF

-- | I\/O error where the operation is not possible.
illegalOperationErrorType :: IOErrorType
illegalOperationErrorType = IllegalOperation

-- | I\/O error where the operation failed because the user does not
-- have sufficient operating system privilege to perform that operation.
permissionErrorType      :: IOErrorType
permissionErrorType       = PermissionDenied

-- | I\/O error that is programmer-defined.
userErrorType		 :: IOErrorType
userErrorType		  = UserError

-- -----------------------------------------------------------------------------
-- IOErrorType predicates

-- | I\/O error where the operation failed because one of its arguments
-- already exists.
isAlreadyExistsErrorType :: IOErrorType -> Bool
isAlreadyExistsErrorType AlreadyExists = True
isAlreadyExistsErrorType _ = False

-- | I\/O error where the operation failed because one of its arguments
-- does not exist.
isDoesNotExistErrorType :: IOErrorType -> Bool
isDoesNotExistErrorType NoSuchThing = True
isDoesNotExistErrorType _ = False

-- | I\/O error where the operation failed because one of its arguments
-- is a single-use resource, which is already being used.
isAlreadyInUseErrorType :: IOErrorType -> Bool
isAlreadyInUseErrorType ResourceBusy = True
isAlreadyInUseErrorType _ = False

-- | I\/O error where the operation failed because the device is full.
isFullErrorType :: IOErrorType -> Bool
isFullErrorType ResourceExhausted = True
isFullErrorType _ = False

-- | I\/O error where the operation failed because the end of file has
-- been reached.
isEOFErrorType :: IOErrorType -> Bool
isEOFErrorType EOF = True
isEOFErrorType _ = False

-- | I\/O error where the operation is not possible.
isIllegalOperationErrorType :: IOErrorType -> Bool
isIllegalOperationErrorType IllegalOperation = True
isIllegalOperationErrorType _ = False

-- | I\/O error where the operation failed because the user does not
-- have sufficient operating system privilege to perform that operation.
isPermissionErrorType :: IOErrorType -> Bool
isPermissionErrorType PermissionDenied = True
isPermissionErrorType _ = False

-- | I\/O error that is programmer-defined.
isUserErrorType :: IOErrorType -> Bool
isUserErrorType UserError = True
isUserErrorType _ = False

-- -----------------------------------------------------------------------------
-- Miscellaneous


ioeGetErrorType	      :: IOError -> IOErrorType
ioeGetErrorString     :: IOError -> String
ioeGetHandle          :: IOError -> Maybe Handle
ioeGetFileName        :: IOError -> Maybe FilePath

ioeGetErrorType ioe = ioe_type ioe

ioeGetErrorString ioe
   | isUserErrorType (ioe_type ioe) = ioe_description ioe
   | otherwise                      = show (ioe_type ioe)

ioeGetHandle ioe = ioe_handle ioe

ioeGetFileName ioe = ioe_filename ioe

ioeSetErrorType		:: IOError -> IOErrorType -> IOError
ioeSetErrorString	:: IOError -> String      -> IOError
ioeSetHandle		:: IOError -> Handle      -> IOError
ioeSetFileName		:: IOError -> FilePath    -> IOError

ioeSetErrorType   ioe errtype  = ioe{ ioe_type = errtype }
ioeSetErrorString ioe str      = ioe{ ioe_description = str }
ioeSetHandle      ioe hdl      = ioe{ ioe_handle = Just hdl }
ioeSetFileName    ioe filename = ioe{ ioe_filename = Just filename }

-- | Catch any 'IOError' that occurs in the computation and throw a
-- modified version.
modifyIOError :: (IOError -> IOError) -> IO a -> IO a
modifyIOError f io = catch io (\e -> ioError (f e))

-- -----------------------------------------------------------------------------
-- annotating an IOError

-- | Adds a location description and maybe a file path and file handle
-- to an 'IOError'.  If any of the file handle or file path is not given
-- the corresponding value in the 'IOError' remains unaltered.
annotateIOError :: IOError 
              -> String 
              -> Maybe Handle 
              -> Maybe FilePath 
              -> IOError 
annotateIOError (IOError ohdl errTy _ str opath) loc hdl path = 
  IOError (hdl `mplus` ohdl) errTy loc str (path `mplus` opath)
  where
    Nothing `mplus` ys = ys
    xs      `mplus` _  = xs












{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  System.IO.Unsafe
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- \"Unsafe\" IO operations.
--
-----------------------------------------------------------------------------

module System.IO.Unsafe (
   -- * Unsafe 'System.IO.IO' operations
   unsafePerformIO,	-- :: IO a -> a
   unsafeInterleaveIO,	-- :: IO a -> IO a
  ) where






import Hugs.IOExts (unsafePerformIO, unsafeInterleaveIO)










-----------------------------------------------------------------------------
-- |
-- Module      :  System.Mem.StableName
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable
--
-- Stable names are a way of performing fast (O(1)), not-quite-exact
-- comparison between objects.
-- 
-- Stable names solve the following problem: suppose you want to build
-- a hash table with Haskell objects as keys, but you want to use
-- pointer equality for comparison; maybe because the keys are large
-- and hashing would be slow, or perhaps because the keys are infinite
-- in size.  We can\'t build a hash table using the address of the
-- object as the key, because objects get moved around by the garbage
-- collector, meaning a re-hash would be necessary after every garbage
-- collection.
--
-------------------------------------------------------------------------------

module System.Mem.StableName (
  -- * Stable Names
  StableName,
  makeStableName,
  hashStableName,
  ) where

import Prelude

import Data.Typeable


import Hugs.Stable











































































                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      























































stableNameTc = mkTyCon "StableName"; instance Typeable1 StableName where { typeOf1 _ = mkTyConApp stableNameTc [] }; instance Typeable a => Typeable (StableName a) where { typeOf = typeOfDefault }
-----------------------------------------------------------------------------
-- |
-- Module      :  System.Mem.Weak
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  non-portable
--
-- In general terms, a weak pointer is a reference to an object that is
-- not followed by the garbage collector - that is, the existence of a
-- weak pointer to an object has no effect on the lifetime of that
-- object.  A weak pointer can be de-referenced to find out
-- whether the object it refers to is still alive or not, and if so
-- to return the object itself.
-- 
-- Weak pointers are particularly useful for caches and memo tables.
-- To build a memo table, you build a data structure 
-- mapping from the function argument (the key) to its result (the
-- value).  When you apply the function to a new argument you first
-- check whether the key\/value pair is already in the memo table.
-- The key point is that the memo table itself should not keep the
-- key and value alive.  So the table should contain a weak pointer
-- to the key, not an ordinary pointer.  The pointer to the value must
-- not be weak, because the only reference to the value might indeed be
-- from the memo table.   
-- 
-- So it looks as if the memo table will keep all its values
-- alive for ever.  One way to solve this is to purge the table
-- occasionally, by deleting entries whose keys have died.
-- 
-- The weak pointers in this library
-- support another approach, called /finalization/.
-- When the key referred to by a weak pointer dies, the storage manager
-- arranges to run a programmer-specified finalizer.  In the case of memo
-- tables, for example, the finalizer could remove the key\/value pair
-- from the memo table.  
-- 
-- Another difficulty with the memo table is that the value of a
-- key\/value pair might itself contain a pointer to the key.
-- So the memo table keeps the value alive, which keeps the key alive,
-- even though there may be no other references to the key so both should
-- die.  The weak pointers in this library provide a slight 
-- generalisation of the basic weak-pointer idea, in which each
-- weak pointer actually contains both a key and a value.
--
-----------------------------------------------------------------------------

module System.Mem.Weak (
	-- * The @Weak@ type
	Weak,	    		-- abstract

	-- * The general interface
	mkWeak,      		-- :: k -> v -> Maybe (IO ()) -> IO (Weak v)
	deRefWeak, 		-- :: Weak v -> IO (Maybe v)
	finalize,		-- :: Weak v -> IO ()

	-- * Specialised versions
	mkWeakPtr, 		-- :: k -> Maybe (IO ()) -> IO (Weak k)
	addFinalizer, 		-- :: key -> IO () -> IO ()
	mkWeakPair, 		-- :: k -> v -> Maybe (IO ()) -> IO (Weak (k,v))
	-- replaceFinaliser	-- :: Weak v -> IO () -> IO ()

	-- * A precise semantics
	
	-- $precise
   ) where

import Prelude

import Data.Typeable


import Hugs.Weak






-- | A specialised version of 'mkWeak', where the key and the value are
-- the same object:
--
-- > mkWeakPtr key finalizer = mkWeak key key finalizer
--
mkWeakPtr :: k -> Maybe (IO ()) -> IO (Weak k)
mkWeakPtr key finalizer = mkWeak key key finalizer

{-|
  A specialised version of 'mkWeakPtr', where the 'Weak' object
  returned is simply thrown away (however the finalizer will be
  remembered by the garbage collector, and will still be run
  when the key becomes unreachable).

  Note: adding a finalizer to a 'Foreign.ForeignPtr.ForeignPtr' using
  'addFinalizer' won't work as well as using the specialised version
  'Foreign.ForeignPtr.addForeignPtrFinalizer' because the latter
  version adds the finalizer to the primitive 'ForeignPtr#' object
  inside, whereas the generic 'addFinalizer' will add the finalizer to
  the box.  Optimisations tend to remove the box, which may cause the
  finalizer to run earlier than you intended.  The same motivation
  justifies the existence of
  'Control.Concurrent.MVar.addMVarFinalizer' and
  'Data.IORef.mkWeakIORef' (the non-uniformity is accidental).
-}
addFinalizer :: key -> IO () -> IO ()
addFinalizer key finalizer = do
   mkWeakPtr key (Just finalizer)	-- throw it away
   return ()

-- | A specialised version of 'mkWeak' where the value is actually a pair
-- of the key and value passed to 'mkWeakPair':
--
-- > mkWeakPair key val finalizer = mkWeak key (key,val) finalizer
--
-- The advantage of this is that the key can be retrieved by 'deRefWeak'
-- in addition to the value.
mkWeakPair :: k -> v -> Maybe (IO ()) -> IO (Weak (k,v))
mkWeakPair key val finalizer = mkWeak key (key,val) finalizer


{- $precise

The above informal specification is fine for simple situations, but
matters can get complicated.  In particular, it needs to be clear
exactly when a key dies, so that any weak pointers that refer to it
can be finalized.  Suppose, for example, the value of one weak pointer
refers to the key of another...does that keep the key alive?

The behaviour is simply this:

 *  If a weak pointer (object) refers to an /unreachable/
    key, it may be finalized.

 *  Finalization means (a) arrange that subsequent calls
    to 'deRefWeak' return 'Nothing'; and (b) run the finalizer.

This behaviour depends on what it means for a key to be reachable.
Informally, something is reachable if it can be reached by following
ordinary pointers from the root set, but not following weak pointers.
We define reachability more precisely as follows A heap object is
reachable if:

 * It is a member of the /root set/.

 * It is directly pointed to by a reachable object, other than
   a weak pointer object.

 * It is a weak pointer object whose key is reachable.

 * It is the value or finalizer of an object whose key is reachable.
-}
/* Machine generated file, do not modify */
#include <stdlib.h>
#include "HsFFI.h"
#include "HsBase.h"

static HugsAPI5 *hugs = 0;
#include "HsBase.h"

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_s_issock
#endif

static void hugsprim___hscore_s_issock_78(HugsStackPtr);
static void hugsprim___hscore_s_issock_78(HugsStackPtr hugs_root)
{
    HsWord32 arg1;
    HsBool res1;
    arg1 = hugs->getWord32();
    res1 = __hscore_s_issock(arg1);
    hugs->putBool(res1);
    hugs->returnId(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_ptr_c_cc
#endif

static void hugsprim___hscore_ptr_c_cc_77(HugsStackPtr);
static void hugsprim___hscore_ptr_c_cc_77(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr res1;
    arg1 = hugs->getPtr();
    res1 = __hscore_ptr_c_cc(arg1);
    hugs->putPtr(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_poke_lflag
#endif

static void hugsprim___hscore_poke_lflag_76(HugsStackPtr);
static void hugsprim___hscore_poke_lflag_76(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord32 arg2;
    arg1 = hugs->getPtr();
    arg2 = hugs->getWord32();
    __hscore_poke_lflag(arg1, arg2);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_lflag
#endif

static void hugsprim___hscore_lflag_75(HugsStackPtr);
static void hugsprim___hscore_lflag_75(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord32 res1;
    arg1 = hugs->getPtr();
    res1 = __hscore_lflag(arg1);
    hugs->putWord32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_sizeof_sigset_t
#endif

static void hugsprim___hscore_sizeof_sigset_t_74(HugsStackPtr);
static void hugsprim___hscore_sizeof_sigset_t_74(HugsStackPtr hugs_root)
{
    HsInt res1;
    res1 = __hscore_sizeof_sigset_t();
    hugs->putInt(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_sizeof_termios
#endif

static void hugsprim___hscore_sizeof_termios_73(HugsStackPtr);
static void hugsprim___hscore_sizeof_termios_73(HugsStackPtr hugs_root)
{
    HsInt res1;
    res1 = __hscore_sizeof_termios();
    hugs->putInt(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_f_setfl
#endif

static void hugsprim___hscore_f_setfl_72(HugsStackPtr);
static void hugsprim___hscore_f_setfl_72(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_f_setfl();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_f_getfl
#endif

static void hugsprim___hscore_f_getfl_71(HugsStackPtr);
static void hugsprim___hscore_f_getfl_71(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_f_getfl();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_sig_setmask
#endif

static void hugsprim___hscore_sig_setmask_70(HugsStackPtr);
static void hugsprim___hscore_sig_setmask_70(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_sig_setmask();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_sig_block
#endif

static void hugsprim___hscore_sig_block_69(HugsStackPtr);
static void hugsprim___hscore_sig_block_69(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_sig_block();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_sigttou
#endif

static void hugsprim___hscore_sigttou_68(HugsStackPtr);
static void hugsprim___hscore_sigttou_68(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_sigttou();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_vtime
#endif

static void hugsprim___hscore_vtime_67(HugsStackPtr);
static void hugsprim___hscore_vtime_67(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_vtime();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_vmin
#endif

static void hugsprim___hscore_vmin_66(HugsStackPtr);
static void hugsprim___hscore_vmin_66(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_vmin();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_icanon
#endif

static void hugsprim___hscore_icanon_65(HugsStackPtr);
static void hugsprim___hscore_icanon_65(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_icanon();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_tcsanow
#endif

static void hugsprim___hscore_tcsanow_64(HugsStackPtr);
static void hugsprim___hscore_tcsanow_64(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_tcsanow();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_echo
#endif

static void hugsprim___hscore_echo_63(HugsStackPtr);
static void hugsprim___hscore_echo_63(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_echo();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_st_mode
#endif

static void hugsprim___hscore_st_mode_62(HugsStackPtr);
static void hugsprim___hscore_st_mode_62(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord32 res1;
    arg1 = hugs->getPtr();
    res1 = __hscore_st_mode(arg1);
    hugs->putWord32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_st_size
#endif

static void hugsprim___hscore_st_size_61(HugsStackPtr);
static void hugsprim___hscore_st_size_61(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt64 res1;
    arg1 = hugs->getPtr();
    res1 = __hscore_st_size(arg1);
    hugs->putInt64(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_st_mtime
#endif

static void hugsprim___hscore_st_mtime_60(HugsStackPtr);
static void hugsprim___hscore_st_mtime_60(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt64 res1;
    arg1 = hugs->getPtr();
    res1 = __hscore_st_mtime(arg1);
    hugs->putInt64(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_sizeof_stat
#endif

static void hugsprim___hscore_sizeof_stat_59(HugsStackPtr);
static void hugsprim___hscore_sizeof_stat_59(HugsStackPtr hugs_root)
{
    HsInt res1;
    res1 = __hscore_sizeof_stat();
    hugs->putInt(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_s_isfifo
#endif

static void hugsprim___hscore_s_isfifo_58(HugsStackPtr);
static void hugsprim___hscore_s_isfifo_58(HugsStackPtr hugs_root)
{
    HsWord32 arg1;
    HsBool res1;
    arg1 = hugs->getWord32();
    res1 = __hscore_s_isfifo(arg1);
    hugs->putBool(res1);
    hugs->returnId(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_s_isdir
#endif

static void hugsprim___hscore_s_isdir_57(HugsStackPtr);
static void hugsprim___hscore_s_isdir_57(HugsStackPtr hugs_root)
{
    HsWord32 arg1;
    HsBool res1;
    arg1 = hugs->getWord32();
    res1 = __hscore_s_isdir(arg1);
    hugs->putBool(res1);
    hugs->returnId(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_s_isblk
#endif

static void hugsprim___hscore_s_isblk_56(HugsStackPtr);
static void hugsprim___hscore_s_isblk_56(HugsStackPtr hugs_root)
{
    HsWord32 arg1;
    HsBool res1;
    arg1 = hugs->getWord32();
    res1 = __hscore_s_isblk(arg1);
    hugs->putBool(res1);
    hugs->returnId(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_s_ischr
#endif

static void hugsprim___hscore_s_ischr_55(HugsStackPtr);
static void hugsprim___hscore_s_ischr_55(HugsStackPtr hugs_root)
{
    HsWord32 arg1;
    HsBool res1;
    arg1 = hugs->getWord32();
    res1 = __hscore_s_ischr(arg1);
    hugs->putBool(res1);
    hugs->returnId(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_s_isreg
#endif

static void hugsprim___hscore_s_isreg_54(HugsStackPtr);
static void hugsprim___hscore_s_isreg_54(HugsStackPtr hugs_root)
{
    HsWord32 arg1;
    HsBool res1;
    arg1 = hugs->getWord32();
    res1 = __hscore_s_isreg(arg1);
    hugs->putBool(res1);
    hugs->returnId(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_o_binary
#endif

static void hugsprim___hscore_o_binary_53(HugsStackPtr);
static void hugsprim___hscore_o_binary_53(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_o_binary();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_o_nonblock
#endif

static void hugsprim___hscore_o_nonblock_52(HugsStackPtr);
static void hugsprim___hscore_o_nonblock_52(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_o_nonblock();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_o_noctty
#endif

static void hugsprim___hscore_o_noctty_51(HugsStackPtr);
static void hugsprim___hscore_o_noctty_51(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_o_noctty();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_o_trunc
#endif

static void hugsprim___hscore_o_trunc_50(HugsStackPtr);
static void hugsprim___hscore_o_trunc_50(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_o_trunc();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_o_excl
#endif

static void hugsprim___hscore_o_excl_49(HugsStackPtr);
static void hugsprim___hscore_o_excl_49(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_o_excl();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_o_creat
#endif

static void hugsprim___hscore_o_creat_48(HugsStackPtr);
static void hugsprim___hscore_o_creat_48(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_o_creat();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_o_append
#endif

static void hugsprim___hscore_o_append_47(HugsStackPtr);
static void hugsprim___hscore_o_append_47(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_o_append();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_o_rdwr
#endif

static void hugsprim___hscore_o_rdwr_46(HugsStackPtr);
static void hugsprim___hscore_o_rdwr_46(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_o_rdwr();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_o_wronly
#endif

static void hugsprim___hscore_o_wronly_45(HugsStackPtr);
static void hugsprim___hscore_o_wronly_45(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_o_wronly();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_o_rdonly
#endif

static void hugsprim___hscore_o_rdonly_44(HugsStackPtr);
static void hugsprim___hscore_o_rdonly_44(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_o_rdonly();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_d_name
#endif

static void hugsprim___hscore_d_name_43(HugsStackPtr);
static void hugsprim___hscore_d_name_43(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr res1;
    arg1 = hugs->getPtr();
    res1 = __hscore_d_name(arg1);
    hugs->putPtr(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_end_of_dir
#endif

static void hugsprim___hscore_end_of_dir_42(HugsStackPtr);
static void hugsprim___hscore_end_of_dir_42(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = __hscore_end_of_dir();
    hugs->putInt32(res1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_free_dirent
#endif

static void hugsprim___hscore_free_dirent_41(HugsStackPtr);
static void hugsprim___hscore_free_dirent_41(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    arg1 = hugs->getPtr();
    __hscore_free_dirent(arg1);
    
    hugs->returnIO(hugs_root,0);
}
#include "dirUtils.h"

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_readdir
#endif

static void hugsprim___hscore_readdir_40(HugsStackPtr);
static void hugsprim___hscore_readdir_40(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr arg2;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getPtr();
    res1 = __hscore_readdir(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef waitpid
#endif

static void hugsprim_waitpid_39(HugsStackPtr);
static void hugsprim_waitpid_39(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsPtr arg2;
    HsInt32 arg3;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getPtr();
    arg3 = hugs->getInt32();
    res1 = waitpid(arg1, arg2, arg3);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef utime
#endif

static void hugsprim_utime_38(HugsStackPtr);
static void hugsprim_utime_38(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr arg2;
    HsWord32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getPtr();
    res1 = utime(arg1, arg2);
    hugs->putWord32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef tcsetattr
#endif

static void hugsprim_tcsetattr_37(HugsStackPtr);
static void hugsprim_tcsetattr_37(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsInt32 arg2;
    HsPtr arg3;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getInt32();
    arg3 = hugs->getPtr();
    res1 = tcsetattr(arg1, arg2, arg3);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef tcgetattr
#endif

static void hugsprim_tcgetattr_36(HugsStackPtr);
static void hugsprim_tcgetattr_36(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsPtr arg2;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getPtr();
    res1 = tcgetattr(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef sigprocmask
#endif

static void hugsprim_sigprocmask_35(HugsStackPtr);
static void hugsprim_sigprocmask_35(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsPtr arg2;
    HsPtr arg3;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getPtr();
    arg3 = hugs->getPtr();
    res1 = sigprocmask(arg1, arg2, arg3);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_sigaddset
#endif

static void hugsprim___hscore_sigaddset_34(HugsStackPtr);
static void hugsprim___hscore_sigaddset_34(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 arg2;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt32();
    res1 = __hscore_sigaddset(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_sigemptyset
#endif

static void hugsprim___hscore_sigemptyset_33(HugsStackPtr);
static void hugsprim___hscore_sigemptyset_33(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    res1 = __hscore_sigemptyset(arg1);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef pipe
#endif

static void hugsprim_pipe_32(HugsStackPtr);
static void hugsprim_pipe_32(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    res1 = pipe(arg1);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef mkfifo
#endif

static void hugsprim_mkfifo_31(HugsStackPtr);
static void hugsprim_mkfifo_31(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord32 arg2;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getWord32();
    res1 = mkfifo(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef link
#endif

static void hugsprim_link_30(HugsStackPtr);
static void hugsprim_link_30(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr arg2;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getPtr();
    res1 = link(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef fork
#endif

static void hugsprim_fork_29(HugsStackPtr);
static void hugsprim_fork_29(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = fork();
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef fcntl
#endif

static void hugsprim_fcntl_28(HugsStackPtr);
static void hugsprim_fcntl_28(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsInt32 arg2;
    HsPtr arg3;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getInt32();
    arg3 = hugs->getPtr();
    res1 = fcntl(arg1, arg2, arg3);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef fcntl
#endif

static void hugsprim_fcntl_27(HugsStackPtr);
static void hugsprim_fcntl_27(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsInt32 arg2;
    HsInt32 arg3;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getInt32();
    arg3 = hugs->getInt32();
    res1 = fcntl(arg1, arg2, arg3);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef fcntl
#endif

static void hugsprim_fcntl_26(HugsStackPtr);
static void hugsprim_fcntl_26(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsInt32 arg2;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getInt32();
    res1 = fcntl(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef getpid
#endif

static void hugsprim_getpid_25(HugsStackPtr);
static void hugsprim_getpid_25(HugsStackPtr hugs_root)
{
    HsInt32 res1;
    res1 = getpid();
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef unlink
#endif

static void hugsprim_unlink_24(HugsStackPtr);
static void hugsprim_unlink_24(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    res1 = unlink(arg1);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_ftruncate
#endif

static void hugsprim___hscore_ftruncate_23(HugsStackPtr);
static void hugsprim___hscore_ftruncate_23(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsInt64 arg2;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getInt64();
    res1 = __hscore_ftruncate(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef write
#endif

static void hugsprim_write_22(HugsStackPtr);
static void hugsprim_write_22(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsPtr arg2;
    HsWord64 arg3;
    HsInt64 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getPtr();
    arg3 = hugs->getWord64();
    res1 = write(arg1, arg2, arg3);
    hugs->putInt64(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef umask
#endif

static void hugsprim_umask_21(HugsStackPtr);
static void hugsprim_umask_21(HugsStackPtr hugs_root)
{
    HsWord32 arg1;
    HsWord32 res1;
    arg1 = hugs->getWord32();
    res1 = umask(arg1);
    hugs->putWord32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_stat
#endif

static void hugsprim___hscore_stat_20(HugsStackPtr);
static void hugsprim___hscore_stat_20(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr arg2;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getPtr();
    res1 = __hscore_stat(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef rmdir
#endif

static void hugsprim_rmdir_19(HugsStackPtr);
static void hugsprim_rmdir_19(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    res1 = rmdir(arg1);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef rewinddir
#endif

static void hugsprim_rewinddir_18(HugsStackPtr);
static void hugsprim_rewinddir_18(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    arg1 = hugs->getPtr();
    rewinddir(arg1);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_renameFile
#endif

static void hugsprim___hscore_renameFile_17(HugsStackPtr);
static void hugsprim___hscore_renameFile_17(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr arg2;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getPtr();
    res1 = __hscore_renameFile(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef read
#endif

static void hugsprim_read_16(HugsStackPtr);
static void hugsprim_read_16(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsPtr arg2;
    HsWord64 arg3;
    HsInt64 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getPtr();
    arg3 = hugs->getWord64();
    res1 = read(arg1, arg2, arg3);
    hugs->putInt64(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_mkdir
#endif

static void hugsprim___hscore_mkdir_15(HugsStackPtr);
static void hugsprim___hscore_mkdir_15(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 arg2;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt32();
    res1 = __hscore_mkdir(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef opendir
#endif

static void hugsprim_opendir_14(HugsStackPtr);
static void hugsprim_opendir_14(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr res1;
    arg1 = hugs->getPtr();
    res1 = opendir(arg1);
    hugs->putPtr(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_open
#endif

static void hugsprim___hscore_open_13(HugsStackPtr);
static void hugsprim___hscore_open_13(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 arg2;
    HsWord32 arg3;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt32();
    arg3 = hugs->getWord32();
    res1 = __hscore_open(arg1, arg2, arg3);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_lstat
#endif

static void hugsprim___hscore_lstat_12(HugsStackPtr);
static void hugsprim___hscore_lstat_12(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr arg2;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getPtr();
    res1 = __hscore_lstat(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_lseek
#endif

static void hugsprim___hscore_lseek_11(HugsStackPtr);
static void hugsprim___hscore_lseek_11(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsInt64 arg2;
    HsInt32 arg3;
    HsInt64 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getInt64();
    arg3 = hugs->getInt32();
    res1 = __hscore_lseek(arg1, arg2, arg3);
    hugs->putInt64(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef isatty
#endif

static void hugsprim_isatty_10(HugsStackPtr);
static void hugsprim_isatty_10(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    res1 = isatty(arg1);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef getcwd
#endif

static void hugsprim_getcwd_9(HugsStackPtr);
static void hugsprim_getcwd_9(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 arg2;
    HsPtr res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt32();
    res1 = getcwd(arg1, arg2);
    hugs->putPtr(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef __hscore_fstat
#endif

static void hugsprim___hscore_fstat_8(HugsStackPtr);
static void hugsprim___hscore_fstat_8(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsPtr arg2;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getPtr();
    res1 = __hscore_fstat(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef dup2
#endif

static void hugsprim_dup2_7(HugsStackPtr);
static void hugsprim_dup2_7(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsInt32 arg2;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getInt32();
    res1 = dup2(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef dup
#endif

static void hugsprim_dup_6(HugsStackPtr);
static void hugsprim_dup_6(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    res1 = dup(arg1);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef creat
#endif

static void hugsprim_creat_5(HugsStackPtr);
static void hugsprim_creat_5(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord32 arg2;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getWord32();
    res1 = creat(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef closedir
#endif

static void hugsprim_closedir_4(HugsStackPtr);
static void hugsprim_closedir_4(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    res1 = closedir(arg1);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef close
#endif

static void hugsprim_close_3(HugsStackPtr);
static void hugsprim_close_3(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    res1 = close(arg1);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef chdir
#endif

static void hugsprim_chdir_2(HugsStackPtr);
static void hugsprim_chdir_2(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    res1 = chdir(arg1);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef chmod
#endif

static void hugsprim_chmod_1(HugsStackPtr);
static void hugsprim_chmod_1(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord32 arg2;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getWord32();
    res1 = chmod(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef access
#endif

static void hugsprim_access_0(HugsStackPtr);
static void hugsprim_access_0(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsWord32 arg2;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getWord32();
    res1 = access(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

static struct hugs_primitive hugs_primTable[] = {
    {"s_issock", 1, hugsprim___hscore_s_issock_78},
    {"ptr_c_cc", 2, hugsprim___hscore_ptr_c_cc_77},
    {"poke_c_lflag", 3, hugsprim___hscore_poke_lflag_76},
    {"c_lflag", 2, hugsprim___hscore_lflag_75},
    {"sizeof_sigset_t", 0, hugsprim___hscore_sizeof_sigset_t_74},
    {"sizeof_termios", 0, hugsprim___hscore_sizeof_termios_73},
    {"const_f_setfl", 0, hugsprim___hscore_f_setfl_72},
    {"const_f_getfl", 0, hugsprim___hscore_f_getfl_71},
    {"const_sig_setmask", 0, hugsprim___hscore_sig_setmask_70},
    {"const_sig_block", 0, hugsprim___hscore_sig_block_69},
    {"const_sigttou", 0, hugsprim___hscore_sigttou_68},
    {"const_vtime", 0, hugsprim___hscore_vtime_67},
    {"const_vmin", 0, hugsprim___hscore_vmin_66},
    {"const_icanon", 0, hugsprim___hscore_icanon_65},
    {"const_tcsanow", 0, hugsprim___hscore_tcsanow_64},
    {"const_echo", 0, hugsprim___hscore_echo_63},
    {"st_mode", 2, hugsprim___hscore_st_mode_62},
    {"st_size", 2, hugsprim___hscore_st_size_61},
    {"st_mtime", 2, hugsprim___hscore_st_mtime_60},
    {"sizeof_stat", 0, hugsprim___hscore_sizeof_stat_59},
    {"s_isfifo", 1, hugsprim___hscore_s_isfifo_58},
    {"s_isdir", 1, hugsprim___hscore_s_isdir_57},
    {"s_isblk", 1, hugsprim___hscore_s_isblk_56},
    {"s_ischr", 1, hugsprim___hscore_s_ischr_55},
    {"s_isreg", 1, hugsprim___hscore_s_isreg_54},
    {"o_BINARY", 0, hugsprim___hscore_o_binary_53},
    {"o_NONBLOCK", 0, hugsprim___hscore_o_nonblock_52},
    {"o_NOCTTY", 0, hugsprim___hscore_o_noctty_51},
    {"o_TRUNC", 0, hugsprim___hscore_o_trunc_50},
    {"o_EXCL", 0, hugsprim___hscore_o_excl_49},
    {"o_CREAT", 0, hugsprim___hscore_o_creat_48},
    {"o_APPEND", 0, hugsprim___hscore_o_append_47},
    {"o_RDWR", 0, hugsprim___hscore_o_rdwr_46},
    {"o_WRONLY", 0, hugsprim___hscore_o_wronly_45},
    {"o_RDONLY", 0, hugsprim___hscore_o_rdonly_44},
    {"d_name", 2, hugsprim___hscore_d_name_43},
    {"end_of_dir", 0, hugsprim___hscore_end_of_dir_42},
    {"freeDirEnt", 2, hugsprim___hscore_free_dirent_41},
    {"readdir", 3, hugsprim___hscore_readdir_40},
    {"c_waitpid", 4, hugsprim_waitpid_39},
    {"c_utime", 3, hugsprim_utime_38},
    {"c_tcsetattr", 4, hugsprim_tcsetattr_37},
    {"c_tcgetattr", 3, hugsprim_tcgetattr_36},
    {"c_sigprocmask", 4, hugsprim_sigprocmask_35},
    {"c_sigaddset", 3, hugsprim___hscore_sigaddset_34},
    {"c_sigemptyset", 2, hugsprim___hscore_sigemptyset_33},
    {"c_pipe", 2, hugsprim_pipe_32},
    {"c_mkfifo", 3, hugsprim_mkfifo_31},
    {"c_link", 3, hugsprim_link_30},
    {"c_fork", 1, hugsprim_fork_29},
    {"c_fcntl_lock", 4, hugsprim_fcntl_28},
    {"c_fcntl_write", 4, hugsprim_fcntl_27},
    {"c_fcntl_read", 3, hugsprim_fcntl_26},
    {"c_getpid", 1, hugsprim_getpid_25},
    {"c_unlink", 2, hugsprim_unlink_24},
    {"c_ftruncate", 3, hugsprim___hscore_ftruncate_23},
    {"c_write", 4, hugsprim_write_22},
    {"c_umask", 2, hugsprim_umask_21},
    {"c_stat", 3, hugsprim___hscore_stat_20},
    {"c_rmdir", 2, hugsprim_rmdir_19},
    {"c_rewinddir", 2, hugsprim_rewinddir_18},
    {"c_rename", 3, hugsprim___hscore_renameFile_17},
    {"c_read", 4, hugsprim_read_16},
    {"mkdir", 3, hugsprim___hscore_mkdir_15},
    {"c_opendir", 2, hugsprim_opendir_14},
    {"c_open", 4, hugsprim___hscore_open_13},
    {"lstat", 3, hugsprim___hscore_lstat_12},
    {"c_lseek", 4, hugsprim___hscore_lseek_11},
    {"c_isatty", 2, hugsprim_isatty_10},
    {"c_getcwd", 3, hugsprim_getcwd_9},
    {"c_fstat", 3, hugsprim___hscore_fstat_8},
    {"c_dup2", 3, hugsprim_dup2_7},
    {"c_dup", 2, hugsprim_dup_6},
    {"c_creat", 3, hugsprim_creat_5},
    {"c_closedir", 2, hugsprim_closedir_4},
    {"c_close", 2, hugsprim_close_3},
    {"c_chdir", 2, hugsprim_chdir_2},
    {"c_chmod", 3, hugsprim_chmod_1},
    {"c_access", 3, hugsprim_access_0},
};

static void hugs_primControl(int);
static void hugs_primControl(what)
int what; {
}

#ifdef STATIC_LINKAGE
#define initModule initSPInternals
#endif

static struct hugs_primInfo hugs_prims = { hugs_primControl, hugs_primTable, 0 };

#ifdef __cplusplus
extern "C" {
#endif
#ifndef __cplusplus
DLLEXPORT(int)  HugsAPIVersion(void);
#endif
DLLEXPORT(int)  HugsAPIVersion() {return (5);}
DLLEXPORT(void) initModule(HugsAPI5 *);
DLLEXPORT(void) initModule(HugsAPI5 *hugsAPI) {
    hugs = hugsAPI;
    hugs->registerPrims(&hugs_prims);
}
#ifdef __cplusplus
}
#endif

{-# OPTIONS_GHC -fno-implicit-prelude #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  System.Posix.Internals
-- Copyright   :  (c) The University of Glasgow, 1992-2002
-- License     :  see libraries/base/LICENSE
-- 
-- Maintainer  :  cvs-ghc@haskell.org
-- Stability   :  internal
-- Portability :  non-portable (requires POSIX)
--
-- POSIX support layer for the standard libraries.
-- This library is built on *every* platform, including Win32.
--
-- Non-posix compliant in order to support the following features:
--	* S_ISSOCK (no sockets in POSIX)
--
-----------------------------------------------------------------------------

-- #hide
module System.Posix.Internals where

                                                                              
                                                                             

                         


                          


                              


                                 


                        


                                


                          


                            


                         


                           


                           


                         


                          


                         


                                


                                


                              


                           


                                


                          


                        


                          


                          


                          


                         


                          


                             


                                


                         


                          


                               


                         


                          


                       


                           


                          


                         


                          


                          


                            


                             


                                


                            


                             


                               


                          


                           


                            


                           


                          


                          


                           


                          


                           


                          


                          


                          


                               


                          


                         


                          


                          


                           


                            


                           


                             


                            


                          


                         


                              


                         


                                


                         


                            


                                


                                 


                                


                          


                                   


                              


                          


                           


                           


                         


                                


                            


                             


                                   


                          


                         


                          


                          


                         


                             


                                


                           


                          


                               


                         


                            


                           


                           


                          


                           


                           


                          


                          


                          


                          


                           


                           


                           


                           


                           


                           


                           


                          


                           


                           


                           


                           


                           


                          


                           


                           


                             


                           


                           


                             


                           


                           


                           


                               


                               


                                                        


                                                                                     


                                                                                    
                             

                                                         


                                                        


                                                        


                                                  


                                                   


                                                       


                                                      
                          

                                                       


                                                          


                                                      


                                                           


                                                      


                                                         


                                                         


                                                         


                                                   


                                                         


                                                       


                                                       


                                                         


                                                         


                                                         


                                                          


                                                         


                                                          


                                                               


                                                             


                                                           


                                                              


                                                            


                                                             
                              

                                                            


                                                           


                                                            


                                                              


                                                           


                                                          


                                                   


                                                       


                                                                                                         


                                                                                         
                        

                                                         


                                                        


                                                   


                                                        
                         

                                                         


                                                          
                           

                                                          
                           

                                  


                                   


                                                     
                         

                                     


                                     


                                        


                                      


                                       


                                      


                                      


                                      


                                    


                                         


                                         


                                     


                                          


                                       


                                        


                                      


                                      


                                          


                                       


                                      


                                            


                                             


                                       


                                        


                                        


                                         


                                       


                                      


                                          


                                          


                                              


                                             


                                              


                                                   


                                               


                                        


                                       
                         

                                                                              


                                              


                                                          


                                                          


                                               


                                            


                                           


                                                      


                                                                           


                                                            
                           

                                                   




                                                                       
                              

                                                 
                         

                                                            
                  

                                                       
                  

                                                
                  



import Control.Monad
import System.Posix.Types

import Foreign
import Foreign.C

import Data.Bits
import Data.Maybe







import System.IO



import Hugs.Prelude (IOException(..), IOErrorType(..))

{-# CFILES cbits/PrelIOUtils.c cbits/dirUtils.c cbits/consUtils.c #-}


-- ---------------------------------------------------------------------------
-- Types

type CDir       = ()
type CDirent    = ()
type CFLock     = ()
type CGroup     = ()
type CLconv     = ()
type CPasswd    = ()
type CSigaction = ()
type CSigset    = ()
type CStat      = ()
type CTermios   = ()
type CTm	= ()
type CTms	= ()
type CUtimbuf   = ()
type CUtsname   = ()


type FD = Int


-- ---------------------------------------------------------------------------
-- stat()-related stuff

fdFileSize :: Int -> IO Integer
fdFileSize fd = 
  allocaBytes sizeof_stat $ \ p_stat -> do
    throwErrnoIfMinus1Retry "fileSize" $
	c_fstat (fromIntegral fd) p_stat
    c_mode <- st_mode p_stat :: IO CMode 
    if not (s_isreg c_mode)
	then return (-1)
	else do
    c_size <- st_size p_stat :: IO COff
    return (fromIntegral c_size)

data FDType  = Directory | Stream | RegularFile | RawDevice
	       deriving (Eq)

fileType :: FilePath -> IO FDType
fileType file =
  allocaBytes sizeof_stat $ \ p_stat -> do
  withCString file $ \p_file -> do
    throwErrnoIfMinus1Retry "fileType" $
      c_stat p_file p_stat
    statGetType p_stat

-- NOTE: On Win32 platforms, this will only work with file descriptors
-- referring to file handles. i.e., it'll fail for socket FDs.
fdType :: Int -> IO FDType
fdType fd = 
  allocaBytes sizeof_stat $ \ p_stat -> do
    throwErrnoIfMinus1Retry "fdType" $
	c_fstat (fromIntegral fd) p_stat
    statGetType p_stat

statGetType p_stat = do
  c_mode <- st_mode p_stat :: IO CMode
  case () of
      _ | s_isdir c_mode    	-> return Directory
        | s_isfifo c_mode || s_issock c_mode || s_ischr  c_mode
			  	-> return Stream
	| s_isreg c_mode	-> return RegularFile
	 -- Q: map char devices to RawDevice too?
	| s_isblk c_mode        -> return RawDevice
	| otherwise		-> ioError ioe_unknownfiletype
    

ioe_unknownfiletype = IOError Nothing UnsupportedOperation "fdType"
			"unknown file type" Nothing











fdGetMode :: Int -> IO IOMode
fdGetMode fd = do







    flags <- throwErrnoIfMinus1Retry "fdGetMode" 
		(c_fcntl_read (fromIntegral fd) const_f_getfl)

    let
       wH  = (flags .&. o_WRONLY) /= 0
       aH  = (flags .&. o_APPEND) /= 0
       rwH = (flags .&. o_RDWR) /= 0

       mode
	 | wH && aH  = AppendMode
	 | wH        = WriteMode
	 | rwH       = ReadWriteMode
	 | otherwise = ReadMode
	  
    return mode

-- ---------------------------------------------------------------------------
-- Terminal-related stuff

fdIsTTY :: Int -> IO Bool
fdIsTTY fd = c_isatty (fromIntegral fd) >>= return.toBool



setEcho :: Int -> Bool -> IO ()
setEcho fd on = do
  tcSetAttr fd $ \ p_tios -> do
    c_lflag <- c_lflag p_tios :: IO CTcflag
    let new_c_lflag
	 | on        = c_lflag .|. fromIntegral const_echo
	 | otherwise = c_lflag .&. complement (fromIntegral const_echo)
    poke_c_lflag p_tios (new_c_lflag :: CTcflag)

getEcho :: Int -> IO Bool
getEcho fd = do
  tcSetAttr fd $ \ p_tios -> do
    c_lflag <- c_lflag p_tios :: IO CTcflag
    return ((c_lflag .&. fromIntegral const_echo) /= 0)

setCooked :: Int -> Bool -> IO ()
setCooked fd cooked = 
  tcSetAttr fd $ \ p_tios -> do

    -- turn on/off ICANON
    c_lflag <- c_lflag p_tios :: IO CTcflag
    let new_c_lflag | cooked    = c_lflag .|. (fromIntegral const_icanon)
	            | otherwise = c_lflag .&. complement (fromIntegral const_icanon)
    poke_c_lflag p_tios (new_c_lflag :: CTcflag)

    -- set VMIN & VTIME to 1/0 respectively
    when (not cooked) $ do
            c_cc <- ptr_c_cc p_tios
	    let vmin  = (c_cc `plusPtr` (fromIntegral const_vmin))  :: Ptr Word8
		vtime = (c_cc `plusPtr` (fromIntegral const_vtime)) :: Ptr Word8
	    poke vmin  1
	    poke vtime 0

tcSetAttr :: FD -> (Ptr CTermios -> IO a) -> IO a
tcSetAttr fd fun = do
     allocaBytes sizeof_termios  $ \p_tios -> do
	throwErrnoIfMinus1Retry "tcSetAttr"
	   (c_tcgetattr (fromIntegral fd) p_tios)












	-- tcsetattr() when invoked by a background process causes the process
	-- to be sent SIGTTOU regardless of whether the process has TOSTOP set
	-- in its terminal flags (try it...).  This function provides a
	-- wrapper which temporarily blocks SIGTTOU around the call, making it
	-- transparent.
	allocaBytes sizeof_sigset_t $ \ p_sigset -> do
	allocaBytes sizeof_sigset_t $ \ p_old_sigset -> do
	     c_sigemptyset p_sigset
	     c_sigaddset   p_sigset const_sigttou
	     c_sigprocmask const_sig_block p_sigset p_old_sigset
	     r <- fun p_tios  -- do the business
	     throwErrnoIfMinus1Retry_ "tcSetAttr" $
		 c_tcsetattr (fromIntegral fd) const_tcsanow p_tios
	     c_sigprocmask const_sig_setmask p_old_sigset nullPtr
	     return r
























































-- ---------------------------------------------------------------------------
-- Turning on non-blocking for a file descriptor



setNonBlockingFD fd = do
  flags <- throwErrnoIfMinus1Retry "setNonBlockingFD"
		 (c_fcntl_read (fromIntegral fd) const_f_getfl)
  -- An error when setting O_NONBLOCK isn't fatal: on some systems 
  -- there are certain file handles on which this will fail (eg. /dev/null
  -- on FreeBSD) so we throw away the return code from fcntl_write.
  unless (testBit flags (fromIntegral o_NONBLOCK)) $ do
    c_fcntl_write (fromIntegral fd) const_f_setfl (flags .|. o_NONBLOCK)
    return ()







-- -----------------------------------------------------------------------------
-- foreign imports

foreign import ccall unsafe "HsBase.h access"
   c_access :: CString -> CMode -> IO CInt

foreign import ccall unsafe "HsBase.h chmod"
   c_chmod :: CString -> CMode -> IO CInt

foreign import ccall unsafe "HsBase.h chdir"
   c_chdir :: CString -> IO CInt

foreign import ccall unsafe "HsBase.h close"
   c_close :: CInt -> IO CInt

foreign import ccall unsafe "HsBase.h closedir" 
   c_closedir :: Ptr CDir -> IO CInt

foreign import ccall unsafe "HsBase.h creat"
   c_creat :: CString -> CMode -> IO CInt

foreign import ccall unsafe "HsBase.h dup"
   c_dup :: CInt -> IO CInt

foreign import ccall unsafe "HsBase.h dup2"
   c_dup2 :: CInt -> CInt -> IO CInt

foreign import ccall unsafe "HsBase.h __hscore_fstat"
   c_fstat :: CInt -> Ptr CStat -> IO CInt

foreign import ccall unsafe "HsBase.h getcwd"
   c_getcwd   :: Ptr CChar -> CInt -> IO (Ptr CChar)

foreign import ccall unsafe "HsBase.h isatty"
   c_isatty :: CInt -> IO CInt

foreign import ccall unsafe "HsBase.h __hscore_lseek"
   c_lseek :: CInt -> COff -> CInt -> IO COff

foreign import ccall unsafe "HsBase.h __hscore_lstat"
   lstat :: CString -> Ptr CStat -> IO CInt

foreign import ccall unsafe "HsBase.h __hscore_open"
   c_open :: CString -> CInt -> CMode -> IO CInt

foreign import ccall unsafe "HsBase.h opendir" 
   c_opendir :: CString  -> IO (Ptr CDir)

foreign import ccall unsafe "HsBase.h __hscore_mkdir"
   mkdir :: CString -> CInt -> IO CInt

foreign import ccall unsafe "HsBase.h read" 
   c_read :: CInt -> Ptr CChar -> CSize -> IO CSsize

foreign import ccall unsafe "dirUtils.h __hscore_renameFile"
   c_rename :: CString -> CString -> IO CInt
		     
foreign import ccall unsafe "HsBase.h rewinddir"
   c_rewinddir :: Ptr CDir -> IO ()

foreign import ccall unsafe "HsBase.h rmdir"
   c_rmdir :: CString -> IO CInt

foreign import ccall unsafe "HsBase.h __hscore_stat"
   c_stat :: CString -> Ptr CStat -> IO CInt

foreign import ccall unsafe "HsBase.h umask"
   c_umask :: CMode -> IO CMode

foreign import ccall unsafe "HsBase.h write" 
   c_write :: CInt -> Ptr CChar -> CSize -> IO CSsize

foreign import ccall unsafe "HsBase.h __hscore_ftruncate"
   c_ftruncate :: CInt -> COff -> IO CInt

foreign import ccall unsafe "HsBase.h unlink"
   c_unlink :: CString -> IO CInt

foreign import ccall unsafe "HsBase.h getpid"
   c_getpid :: IO CPid


foreign import ccall unsafe "HsBase.h fcntl"
   c_fcntl_read  :: CInt -> CInt -> IO CInt

foreign import ccall unsafe "HsBase.h fcntl"
   c_fcntl_write :: CInt -> CInt -> CInt -> IO CInt

foreign import ccall unsafe "HsBase.h fcntl"
   c_fcntl_lock  :: CInt -> CInt -> Ptr CFLock -> IO CInt

foreign import ccall unsafe "HsBase.h fork"
   c_fork :: IO CPid 

foreign import ccall unsafe "HsBase.h link"
   c_link :: CString -> CString -> IO CInt

foreign import ccall unsafe "HsBase.h mkfifo"
   c_mkfifo :: CString -> CMode -> IO CInt

foreign import ccall unsafe "HsBase.h pipe"
   c_pipe :: Ptr CInt -> IO CInt

foreign import ccall unsafe "HsBase.h __hscore_sigemptyset"
   c_sigemptyset :: Ptr CSigset -> IO CInt

foreign import ccall unsafe "HsBase.h __hscore_sigaddset"
   c_sigaddset :: Ptr CSigset -> CInt -> IO CInt

foreign import ccall unsafe "HsBase.h sigprocmask"
   c_sigprocmask :: CInt -> Ptr CSigset -> Ptr CSigset -> IO CInt

foreign import ccall unsafe "HsBase.h tcgetattr"
   c_tcgetattr :: CInt -> Ptr CTermios -> IO CInt

foreign import ccall unsafe "HsBase.h tcsetattr"
   c_tcsetattr :: CInt -> CInt -> Ptr CTermios -> IO CInt

foreign import ccall unsafe "HsBase.h utime"
   c_utime :: CString -> Ptr CUtimbuf -> IO CMode

foreign import ccall unsafe "HsBase.h waitpid"
   c_waitpid :: CPid -> Ptr CInt -> CInt -> IO CPid












-- traversing directories
foreign import ccall unsafe "dirUtils.h __hscore_readdir"
  readdir  :: Ptr CDir -> Ptr (Ptr CDirent) -> IO CInt
 
foreign import ccall unsafe "HsBase.h __hscore_free_dirent"
  freeDirEnt  :: Ptr CDirent -> IO ()
 
foreign import ccall unsafe "HsBase.h __hscore_end_of_dir"
  end_of_dir :: CInt
 
foreign import ccall unsafe "HsBase.h __hscore_d_name"
  d_name :: Ptr CDirent -> IO CString

-- POSIX flags only:
foreign import ccall unsafe "HsBase.h __hscore_o_rdonly" o_RDONLY :: CInt
foreign import ccall unsafe "HsBase.h __hscore_o_wronly" o_WRONLY :: CInt
foreign import ccall unsafe "HsBase.h __hscore_o_rdwr"   o_RDWR   :: CInt
foreign import ccall unsafe "HsBase.h __hscore_o_append" o_APPEND :: CInt
foreign import ccall unsafe "HsBase.h __hscore_o_creat"  o_CREAT  :: CInt
foreign import ccall unsafe "HsBase.h __hscore_o_excl"   o_EXCL   :: CInt
foreign import ccall unsafe "HsBase.h __hscore_o_trunc"  o_TRUNC  :: CInt

-- non-POSIX flags.
foreign import ccall unsafe "HsBase.h __hscore_o_noctty"   o_NOCTTY   :: CInt
foreign import ccall unsafe "HsBase.h __hscore_o_nonblock" o_NONBLOCK :: CInt
foreign import ccall unsafe "HsBase.h __hscore_o_binary"   o_BINARY   :: CInt

foreign import ccall unsafe "HsBase.h __hscore_s_isreg"  s_isreg  :: CMode -> Bool
foreign import ccall unsafe "HsBase.h __hscore_s_ischr"  s_ischr  :: CMode -> Bool
foreign import ccall unsafe "HsBase.h __hscore_s_isblk"  s_isblk  :: CMode -> Bool
foreign import ccall unsafe "HsBase.h __hscore_s_isdir"  s_isdir  :: CMode -> Bool
foreign import ccall unsafe "HsBase.h __hscore_s_isfifo" s_isfifo :: CMode -> Bool

foreign import ccall unsafe "HsBase.h __hscore_sizeof_stat" sizeof_stat :: Int
foreign import ccall unsafe "HsBase.h __hscore_st_mtime" st_mtime :: Ptr CStat -> IO CTime
foreign import ccall unsafe "HsBase.h __hscore_st_size" st_size :: Ptr CStat -> IO COff
foreign import ccall unsafe "HsBase.h __hscore_st_mode" st_mode :: Ptr CStat -> IO CMode

foreign import ccall unsafe "HsBase.h __hscore_echo"         const_echo :: CInt
foreign import ccall unsafe "HsBase.h __hscore_tcsanow"      const_tcsanow :: CInt
foreign import ccall unsafe "HsBase.h __hscore_icanon"       const_icanon :: CInt
foreign import ccall unsafe "HsBase.h __hscore_vmin"         const_vmin   :: CInt
foreign import ccall unsafe "HsBase.h __hscore_vtime"        const_vtime  :: CInt
foreign import ccall unsafe "HsBase.h __hscore_sigttou"      const_sigttou :: CInt
foreign import ccall unsafe "HsBase.h __hscore_sig_block"    const_sig_block :: CInt
foreign import ccall unsafe "HsBase.h __hscore_sig_setmask"  const_sig_setmask :: CInt
foreign import ccall unsafe "HsBase.h __hscore_f_getfl"      const_f_getfl :: CInt
foreign import ccall unsafe "HsBase.h __hscore_f_setfl"      const_f_setfl :: CInt


foreign import ccall unsafe "HsBase.h __hscore_sizeof_termios"  sizeof_termios :: Int
foreign import ccall unsafe "HsBase.h __hscore_sizeof_sigset_t" sizeof_sigset_t :: Int

foreign import ccall unsafe "HsBase.h __hscore_lflag" c_lflag :: Ptr CTermios -> IO CTcflag
foreign import ccall unsafe "HsBase.h __hscore_poke_lflag" poke_c_lflag :: Ptr CTermios -> CTcflag -> IO ()
foreign import ccall unsafe "HsBase.h __hscore_ptr_c_cc" ptr_c_cc  :: Ptr CTermios -> IO (Ptr Word8)



foreign import ccall unsafe "HsBase.h __hscore_s_issock" s_issock :: CMode -> Bool




 asm    dylink‡ç¿Ä'` ` ` ````  ` |†Uenv
memoryBase env	tableBase envabort  envgetTempRet0 env___hscore_d_name env___hscore_echo env___hscore_end_of_dir env___hscore_f_getfl env___hscore_f_setfl env___hscore_free_dirent  env___hscore_fstat env___hscore_ftruncate env___hscore_icanon env___hscore_lflag env___hscore_lseek env___hscore_lstat env___hscore_mkdir env___hscore_o_append env___hscore_o_binary env___hscore_o_creat env___hscore_o_excl env___hscore_o_noctty env___hscore_o_nonblock env___hscore_o_rdonly env___hscore_o_rdwr env___hscore_o_trunc env___hscore_o_wronly env___hscore_open env___hscore_poke_lflag env___hscore_ptr_c_cc env___hscore_s_isblk env___hscore_s_ischr env___hscore_s_isdir env___hscore_s_isfifo env___hscore_s_isreg env___hscore_s_issock env___hscore_sig_block env___hscore_sig_setmask env___hscore_sigaddset env___hscore_sigemptyset env___hscore_sigttou env___hscore_sizeof_sigset_t env___hscore_sizeof_stat env___hscore_sizeof_termios env___hscore_st_mode env___hscore_st_mtime env___hscore_st_size env___hscore_stat env___hscore_tcsanow env___hscore_vmin env___hscore_vtime env_access env_chdir env_chmod env_close env	_closedir env_creat env_dup env_dup2 env_fcntl env_fork env_free  env_getcwd env_getpid env_isatty env_link env_malloc env_mkfifo env_opendir env_pipe env_read env
_readdir_r env_rename env
_rewinddir  env_rmdir env_sigprocmask env
_tcgetattr env
_tcsetattr env_umask env_unlink env_utime env_waitpid env_write envmemory Äenvtablep ÄYX                                                                                 A A ÏV_HugsAPIVersion Q___hscore_readdir £___hscore_renameFile §__post_instantiate ß_hugs_primControl S_hugsprim___hscore_d_name_43 w_hugsprim___hscore_echo_63 c _hugsprim___hscore_end_of_dir_42 x_hugsprim___hscore_f_getfl_71 [_hugsprim___hscore_f_setfl_72 Z!_hugsprim___hscore_free_dirent_41 y_hugsprim___hscore_fstat_8 ö_hugsprim___hscore_ftruncate_23 ã_hugsprim___hscore_icanon_65 a_hugsprim___hscore_lflag_75 W_hugsprim___hscore_lseek_11 ó_hugsprim___hscore_lstat_12 ñ_hugsprim___hscore_mkdir_15 ì_hugsprim___hscore_o_append_47 s_hugsprim___hscore_o_binary_53 m_hugsprim___hscore_o_creat_48 r_hugsprim___hscore_o_excl_49 q_hugsprim___hscore_o_noctty_51 o _hugsprim___hscore_o_nonblock_52 n_hugsprim___hscore_o_rdonly_44 v_hugsprim___hscore_o_rdwr_46 t_hugsprim___hscore_o_trunc_50 p_hugsprim___hscore_o_wronly_45 u_hugsprim___hscore_open_13 ï _hugsprim___hscore_poke_lflag_76 V_hugsprim___hscore_ptr_c_cc_77 U_hugsprim___hscore_readdir_40 z _hugsprim___hscore_renameFile_17 ë_hugsprim___hscore_s_isblk_56 j_hugsprim___hscore_s_ischr_55 k_hugsprim___hscore_s_isdir_57 i_hugsprim___hscore_s_isfifo_58 h_hugsprim___hscore_s_isreg_54 l_hugsprim___hscore_s_issock_78 T_hugsprim___hscore_sig_block_69 ]!_hugsprim___hscore_sig_setmask_70 \_hugsprim___hscore_sigaddset_34 Ä!_hugsprim___hscore_sigemptyset_33 Å_hugsprim___hscore_sigttou_68 ^%_hugsprim___hscore_sizeof_sigset_t_74 X!_hugsprim___hscore_sizeof_stat_59 g$_hugsprim___hscore_sizeof_termios_73 Y_hugsprim___hscore_st_mode_62 d_hugsprim___hscore_st_mtime_60 f_hugsprim___hscore_st_size_61 e_hugsprim___hscore_stat_20 é_hugsprim___hscore_tcsanow_64 b_hugsprim___hscore_vmin_66 `_hugsprim___hscore_vtime_67 __hugsprim_access_0 ¢_hugsprim_chdir_2 †_hugsprim_chmod_1 °_hugsprim_close_3 ü_hugsprim_closedir_4 û_hugsprim_creat_5 ù_hugsprim_dup2_7 õ_hugsprim_dup_6 ú_hugsprim_fcntl_26 à_hugsprim_fcntl_27 á_hugsprim_fcntl_28 Ü_hugsprim_fork_29 Ö_hugsprim_getcwd_9 ô_hugsprim_getpid_25 â_hugsprim_isatty_10 ò_hugsprim_link_30 Ñ_hugsprim_mkfifo_31 É_hugsprim_opendir_14 î_hugsprim_pipe_32 Ç_hugsprim_read_16 í_hugsprim_rewinddir_18 ê_hugsprim_rmdir_19 è_hugsprim_sigprocmask_35 _hugsprim_tcgetattr_36 ~_hugsprim_tcsetattr_37 }_hugsprim_umask_21 ç_hugsprim_unlink_24 ä_hugsprim_utime_38 |_hugsprim_waitpid_39 {_hugsprim_write_22 å_initModule RrunPostSets •	⁄ #Ä®STUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®®
«8X A # A–ç¿j  6 #   (∞   < # A–ç¿j( (< !# A–ç¿j( (P    A# A–ç¿j( (® = # A–ç¿j( (D # A–ç¿j( (ê    A# A–ç¿j( († < # A–ç¿j( (D # A–ç¿j( (<   A # A–ç¿j( († = # A–ç¿j( (D # A–ç¿j( (à    A# A–ç¿j( (†  '# A–ç¿j( (T   )# A–ç¿j( (T   # A–ç¿j( (x   # A–ç¿j( (x   ## A–ç¿j( (x   "# A–ç¿j( (x   &# A–ç¿j( (x   0# A–ç¿j( (x   /# A–ç¿j( (x   
# A–ç¿j( (x   .# A–ç¿j( (x   # A–ç¿j( (x  = # A–ç¿j( (D *# A–ç¿j( (à    A# A–ç¿j( († K# A–ç¿j( (D ," A HAtAu# A–ç¿j( (|   A# A–ç¿j( († K# A–ç¿j( (D +" A HAtAu# A–ç¿j( (|   A# A–ç¿j( (†  (# A–ç¿j( (T  < # A–ç¿j( (< # A–ç¿j( (P    A# A–ç¿j( (® < # A–ç¿j( (< # A–ç¿j( (P    A# A–ç¿j( (® < # A–ç¿j( (< # A–ç¿j( (P    A# A–ç¿j( (® < # A–ç¿j( (< # A–ç¿j( (P    A# A–ç¿j( (® < # A–ç¿j( (<  # A–ç¿j( (P    A# A–ç¿j( (®  # A–ç¿j( (x   # A–ç¿j( (x   # A–ç¿j( (x   # A–ç¿j( (x   # A–ç¿j( (x   # A–ç¿j( (x   # A–ç¿j( (x   # A–ç¿j( (x   # A–ç¿j( (x   # A–ç¿j( (x  = # A–ç¿j( (D # A–ç¿j( (ê    A# A–ç¿j( (†  # A–ç¿j( (x  + # A–ç¿j( (D   A # A–ç¿j( († N # A–ç¿j( (D # A–ç¿j( (D £# A–ç¿j( (x    A# A–ç¿j( († ^ # A–ç¿j( (, # A–ç¿j( (D # A–ç¿j( (, O# A–ç¿j( (x    A# A–ç¿j( († N # A–ç¿j( (D # A–ç¿j( (D N# A–ç¿j( (à    A# A–ç¿j( († ^ # A–ç¿j( (, # A–ç¿j( (, # A–ç¿j( (D K# A–ç¿j( (x    A# A–ç¿j( († M # A–ç¿j( (, # A–ç¿j( (D J# A–ç¿j( (x    A# A–ç¿j( († ^ # A–ç¿j( (, # A–ç¿j( (D # A–ç¿j( (D I# A–ç¿j( (x    A# A–ç¿j( († M # A–ç¿j( (D # A–ç¿j( (, $# A–ç¿j( (x    A# A–ç¿j( († < # A–ç¿j( (D %# A–ç¿j( (x    A# A–ç¿j( († < # A–ç¿j( (D C# A–ç¿j( (x    A# A–ç¿j( († M # A–ç¿j( (D # A–ç¿j( (< A# A–ç¿j( (x    A# A–ç¿j( († M # A–ç¿j( (D # A–ç¿j( (D ?# A–ç¿j( (x    A# A–ç¿j( († + :# A–ç¿j( (x    A# A–ç¿j( († Ä#!#Aj$# A–ç¿j( (, !# A–ç¿j( (, ! "# A–ç¿j( (D 6    9# A–ç¿j( (x    A# A–ç¿j( (†  $Ä#!#Aj$# A–ç¿j( (, !# A–ç¿j( (, ! "# A–ç¿j( (, 6    9# A–ç¿j( (x    A# A–ç¿j( (†  $`#!#Aj$# A–ç¿j( (, # A–ç¿j( (,  9# A–ç¿j( (x    A# A–ç¿j( (†  $+ =# A–ç¿j( (x    A# A–ç¿j( († < # A–ç¿j( (D M# A–ç¿j( (x    A# A–ç¿j( († Z# A–ç¿j( (, !# A–ç¿j( (0 !  	# A–ç¿j( (x    A# A–ç¿j( († |# A–ç¿j( (, !# A–ç¿j( (D !# A–ç¿j( (@ !   P" A HAtAu# A–ç¿j( (|   A# A–ç¿j( († = # A–ç¿j( (< L# A–ç¿j( (à    A# A–ç¿j( († M # A–ç¿j( (D # A–ç¿j( (D -# A–ç¿j( (x    A# A–ç¿j( († < # A–ç¿j( (D H# A–ç¿j( (x    A# A–ç¿j( († + # A–ç¿j( (D G  A # A–ç¿j( († N # A–ç¿j( (D # A–ç¿j( (D §# A–ç¿j( (x    A# A–ç¿j( († |# A–ç¿j( (, !# A–ç¿j( (D !# A–ç¿j( (@ !   D" A HAtAu# A–ç¿j( (|   A# A–ç¿j( († M # A–ç¿j( (D # A–ç¿j( (, # A–ç¿j( (x    A# A–ç¿j( († = # A–ç¿j( (D B# A–ç¿j( (ê    A# A–ç¿j( († ^ # A–ç¿j( (D # A–ç¿j( (, # A–ç¿j( (< # A–ç¿j( (x    A# A–ç¿j( († M # A–ç¿j( (D # A–ç¿j( (D # A–ç¿j( (x    A# A–ç¿j( († x# A–ç¿j( (, !# A–ç¿j( (0 !  # A–ç¿j( (, " A HAtAu# A–ç¿j( (|   A# A–ç¿j( († < # A–ç¿j( (, ># A–ç¿j( (x    A# A–ç¿j( († N # A–ç¿j( (D # A–ç¿j( (, <# A–ç¿j( (ê    A# A–ç¿j( († M # A–ç¿j( (, # A–ç¿j( (D # A–ç¿j( (x    A# A–ç¿j( († M # A–ç¿j( (, # A–ç¿j( (, 8# A–ç¿j( (x    A# A–ç¿j( († < # A–ç¿j( (, 7# A–ç¿j( (x    A# A–ç¿j( († M # A–ç¿j( (D # A–ç¿j( (< 6# A–ç¿j( (x    A# A–ç¿j( († < # A–ç¿j( (D 5# A–ç¿j( (x    A# A–ç¿j( († < # A–ç¿j( (, 4# A–ç¿j( (x    A# A–ç¿j( († < # A–ç¿j( (D 2# A–ç¿j( (x    A# A–ç¿j( († M # A–ç¿j( (D # A–ç¿j( (< 3# A–ç¿j( (x    A# A–ç¿j( († M # A–ç¿j( (D # A–ç¿j( (< 1# A–ç¿j( (x    A# A–ç¿j( († f E@A# (¿"AF@# AÄ6¿AÄ! Aåj@"E@A    E" @ A 6  ;   ( @A  ;A     F¿ # #Aj6 # # (# Ajj6# # (# Aƒjj6# #Aj6# # (# AÕjj6# #Aj6 # # ($# A÷jj6$# #Aj6,# # (0# A„jj60# #Aj68# # (<# AÎjj6<# #Aj6D# # (H# A˚jj6H# #Aj6P# # (T# Aäjj6T# #Aj6\# # (`# Aòjj6`# #A	j6h# # (l# A¶jj6l# #A
j6t# # (x# A∏jj6x# #Aj6Ä# # (Ñ# A»jj6Ñ# #Aj6å# # (ê# A÷jj6ê# #Aj6ò# # (ú# A‚jj6ú# #Aj6§# # (®# AÌjj6®# #Aj6∞# # (¥# A˙jj6¥# #Aj6º# # (¿# Aà	jj6¿# #Aj6»# # (Ã# Aì	jj6Ã# #Aj6‘# # (ÿ# Aõ	jj6ÿ# #Aj6‡# # (‰# A£	jj6‰# #Aj6Ï# # (# A¨	jj6# #Aj6¯# # (¸# A∏	jj6¸# #Aj6Ñ# # (à# A¡	jj6à# #Aj6ê# # (î# A…	jj6î# #Aj6ú# # (†# A—	jj6†# #Aj6®# # (¨# AŸ	jj6¨# #Aj6¥# # (∏# A·	jj6∏# #Aj6¿# # (ƒ# AÍ	jj6ƒ# #Aj6Ã# # (–# Aı	jj6–# #Aj6ÿ# # (‹# A˛	jj6‹# #Aj6‰# # (Ë# AÜ
jj6Ë# #Aj6# # (Ù# Aç
jj6Ù# #A j6¸# # (Ä# Aï
jj6Ä# #A!j6à# # (å# Aû
jj6å# #A"j6î# # (ò# A•
jj6ò# #A#j6†# # (§# AÆ
jj6§# #A$j6¨# # (∞# A∑
jj6∞# #A%j6∏# # (º# Aæ
jj6º# #A&j6ƒ# # (»# A…
jj6»# #A'j6–# # (‘# A‘
jj6‘# #A(j6‹# # (‡# A‹
jj6‡# #A)j6Ë# # (Ï# AÊ
jj6Ï# #A*j6Ù# # (¯# AÓ
jj6¯# #A+j6Ä# # (Ñ# A˙
jj6Ñ# #A,j6å# # (ê# AÜjj6ê# #A-j6ò# # (ú# Aîjj6ú# #A.j6§# # (®# A†jj6®# #A/j6∞# # (¥# AÆjj6¥# #A0j6º# # (¿# Aµjj6¿# #A1j6»# # (Ã# Aæjj6Ã# #A2j6‘¶ó # # (ÿ# A≈jj6ÿ# #A3j6‡# # (‰# AÃjj6‰# #A4j6Ï# # (# AŸjj6# #A5j6¯# # (¸# AÁjj6¸# #A6j6Ñ# # (à# AÙjj6à# #A7j6ê# # (î# A˝jj6î# #A8j6ú# # (†# AÜjj6†# #A9j6®# # (¨# Aíjj6¨# #A:j6¥# # (∏# Aöjj6∏# #A;j6¿# # (ƒ# A¢jj6ƒ# #A<j6Ã# # (–# A©jj6–# #A=j6ÿ# # (‹# A±jj6‹# #A>j6‰# # (Ë# AΩjj6Ë# #A?j6# # (Ù# A∆jj6Ù# #A¿ j6¸# # (Ä# AÕjj6Ä# #A¡ j6à# # (å# A”jj6å# #A¬ j6î# # (ò# A›jj6ò# #A√ j6†# # (§# A‰jj6§# #Aƒ j6¨# # (∞# AÍjj6∞# #A≈ j6∏# # (º# AÚjj6º# #A∆ j6ƒ# # (»# A˚jj6»# #A« j6–# # (‘# AÑjj6‘# #A» j6‹# # (‡# Aåjj6‡# #A… j6Ë# # (Ï# Aìjj6Ï# #A  j6Ù# # (¯# Aôjj6¯# #AÀ j6Ä# # (Ñ# A°jj6Ñ# #AÃ j6å# # (ê# A¨jj6ê# #AÕ j6ò# # (ú# A¥jj6ú# #AŒ j6§# # (®# Aºjj6®# #Aœ j6∞# # (¥# Aƒjj6¥# #A– j6º # A–j$#AÄÄ¿j$• A  D        ” # Ã                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ˇˇˇˇs_issock ptr_c_cc poke_c_lflag c_lflag sizeof_sigset_t sizeof_termios const_f_setfl const_f_getfl const_sig_setmask const_sig_block const_sigttou const_vtime const_vmin const_icanon const_tcsanow const_echo st_mode st_size st_mtime sizeof_stat s_isfifo s_isdir s_isblk s_ischr s_isreg o_BINARY o_NONBLOCK o_NOCTTY o_TRUNC o_EXCL o_CREAT o_APPEND o_RDWR o_WRONLY o_RDONLY d_name end_of_dir freeDirEnt readdir c_waitpid c_utime c_tcsetattr c_tcgetattr c_sigprocmask c_sigaddset c_sigemptyset c_pipe c_mkfifo c_link c_fork c_fcntl_lock c_fcntl_write c_fcntl_read c_getpid c_unlink c_ftruncate c_write c_umask c_stat c_rmdir c_rewinddir c_rename c_read mkdir c_opendir c_open lstat c_lseek c_isatty c_getcwd c_fstat c_dup2 c_dup c_creat c_closedir c_close c_chdir c_chmod c_access/* Machine generated file, do not modify */
#include <stdlib.h>
#include "HsFFI.h"
#include "HsBase.h"

static HugsAPI5 *hugs = 0;

#ifndef ENABLE_MACRO_INTERFACE
#undef sigpending
#endif

static void hugsprim_sigpending_8(HugsStackPtr);
static void hugsprim_sigpending_8(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    res1 = sigpending(arg1);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef sigismember
#endif

static void hugsprim_sigismember_7(HugsStackPtr);
static void hugsprim_sigismember_7(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 arg2;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt32();
    res1 = sigismember(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef sigfillset
#endif

static void hugsprim_sigfillset_6(HugsStackPtr);
static void hugsprim_sigfillset_6(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    res1 = sigfillset(arg1);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef sigdelset
#endif

static void hugsprim_sigdelset_5(HugsStackPtr);
static void hugsprim_sigdelset_5(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 arg2;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt32();
    res1 = sigdelset(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef sigsuspend
#endif

static void hugsprim_sigsuspend_4(HugsStackPtr);
static void hugsprim_sigsuspend_4(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    res1 = sigsuspend(arg1);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef alarm
#endif

static void hugsprim_alarm_3(HugsStackPtr);
static void hugsprim_alarm_3(HugsStackPtr hugs_root)
{
    HsWord32 arg1;
    HsWord32 res1;
    arg1 = hugs->getWord32();
    res1 = alarm(arg1);
    hugs->putWord32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef raise
#endif

static void hugsprim_raise_2(HugsStackPtr);
static void hugsprim_raise_2(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    res1 = raise(arg1);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef killpg
#endif

static void hugsprim_killpg_1(HugsStackPtr);
static void hugsprim_killpg_1(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsInt32 arg2;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getInt32();
    res1 = killpg(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef kill
#endif

static void hugsprim_kill_0(HugsStackPtr);
static void hugsprim_kill_0(HugsStackPtr hugs_root)
{
    HsInt32 arg1;
    HsInt32 arg2;
    HsInt32 res1;
    arg1 = hugs->getInt32();
    arg2 = hugs->getInt32();
    res1 = kill(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

static struct hugs_primitive hugs_primTable[] = {
    {"c_sigpending", 2, hugsprim_sigpending_8},
    {"c_sigismember", 3, hugsprim_sigismember_7},
    {"c_sigfillset", 2, hugsprim_sigfillset_6},
    {"c_sigdelset", 3, hugsprim_sigdelset_5},
    {"c_sigsuspend", 2, hugsprim_sigsuspend_4},
    {"c_alarm", 2, hugsprim_alarm_3},
    {"c_raise", 2, hugsprim_raise_2},
    {"c_killpg", 3, hugsprim_killpg_1},
    {"c_kill", 3, hugsprim_kill_0},
};

static void hugs_primControl(int);
static void hugs_primControl(what)
int what; {
}

#ifdef STATIC_LINKAGE
#define initModule initSPSignals
#endif

static struct hugs_primInfo hugs_prims = { hugs_primControl, hugs_primTable, 0 };

#ifdef __cplusplus
extern "C" {
#endif
#ifndef __cplusplus
DLLEXPORT(int)  HugsAPIVersion(void);
#endif
DLLEXPORT(int)  HugsAPIVersion() {return (5);}
DLLEXPORT(void) initModule(HugsAPI5 *);
DLLEXPORT(void) initModule(HugsAPI5 *hugsAPI) {
    hugs = hugsAPI;
    hugs->registerPrims(&hugs_prims);
}
#ifdef __cplusplus
}
#endif

-----------------------------------------------------------------------------
-- |
-- Module      :  System.Posix.Signals
-- Copyright   :  (c) The University of Glasgow 2002
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  non-portable (requires POSIX)
--
-- POSIX signal support
--
-----------------------------------------------------------------------------

                                                                              
                                                                             

                         


                          


                              


                                 


                        


                                


                          


                            


                         


                           


                           


                         


                          


                         


                                


                                


                              


                           


                                


                          


                        


                          


                          


                          


                         


                          


                             


                                


                         


                          


                               


                         


                          


                       


                           


                          


                         


                          


                          


                            


                             


                                


                            


                             


                               


                          


                           


                            


                           


                          


                          


                           


                          


                           


                          


                          


                          


                               


                          


                         


                          


                          


                           


                            


                           


                             


                            


                          


                         


                              


                         


                                


                         


                            


                                


                                 


                                


                          


                                   


                              


                          


                           


                           


                         


                                


                            


                             


                                   


                          


                         


                          


                          


                         


                             


                                


                           


                          


                               


                         


                            


                           


                           


                          


                           


                           


                          


                          


                          


                          


                           


                           


                           


                           


                           


                           


                           


                          


                           


                           


                           


                           


                           


                          


                           


                           


                             


                           


                           


                             


                           


                           


                           


                               


                               


                                                        


                                                                                     


                                                                                    
                             

                                                         


                                                        


                                                        


                                                  


                                                   


                                                       


                                                      
                          

                                                       


                                                          


                                                      


                                                           


                                                      


                                                         


                                                         


                                                         


                                                   


                                                         


                                                       


                                                       


                                                         


                                                         


                                                         


                                                          


                                                         


                                                          


                                                               


                                                             


                                                           


                                                              


                                                            


                                                             
                              

                                                            


                                                           


                                                            


                                                              


                                                           


                                                          


                                                   


                                                       


                                                                                                         


                                                                                         
                        

                                                         


                                                        


                                                   


                                                        
                         

                                                         


                                                          
                           

                                                          
                           

                                  


                                   


                                                     
                         

                                     


                                     


                                        


                                      


                                       


                                      


                                      


                                      


                                    


                                         


                                         


                                     


                                          


                                       


                                        


                                      


                                      


                                          


                                       


                                      


                                            


                                             


                                       


                                        


                                        


                                         


                                       


                                      


                                          


                                          


                                              


                                             


                                              


                                                   


                                               


                                        


                                       
                         

                                                                              


                                              


                                                          


                                                          


                                               


                                            


                                           


                                                      


                                                                           


                                                            
                           

                                                   




                                                                       
                              

                                                 
                         

                                                            
                  

                                                       
                  

                                                
                  



module System.Posix.Signals (

  -- * The Signal type
  Signal,

  -- * Specific signals
  nullSignal,
  internalAbort, sigABRT,
  realTimeAlarm, sigALRM,
  busError, sigBUS,
  processStatusChanged, sigCHLD,
  continueProcess, sigCONT,
  floatingPointException, sigFPE,
  lostConnection, sigHUP,
  illegalInstruction, sigILL,
  keyboardSignal, sigINT,
  killProcess, sigKILL,
  openEndedPipe, sigPIPE,
  keyboardTermination, sigQUIT,
  segmentationViolation, sigSEGV,
  softwareStop, sigSTOP,
  softwareTermination, sigTERM,
  keyboardStop, sigTSTP,
  backgroundRead, sigTTIN,
  backgroundWrite, sigTTOU,
  userDefinedSignal1, sigUSR1,
  userDefinedSignal2, sigUSR2,

  pollableEvent, sigPOLL,

  profilingTimerExpired, sigPROF,
  badSystemCall, sigSYS,
  breakpointTrap, sigTRAP,
  urgentDataAvailable, sigURG,
  virtualTimerExpired, sigVTALRM,
  cpuTimeLimitExceeded, sigXCPU,
  fileSizeLimitExceeded, sigXFSZ,

  -- * Sending signals
  raiseSignal,
  signalProcess,
  signalProcessGroup,







  -- * Signal sets
  SignalSet,
  emptySignalSet, fullSignalSet, 
  addSignal, deleteSignal, inSignalSet,

  -- * The process signal mask
  getSignalMask, setSignalMask, blockSignals, unblockSignals,

  -- * The alarm timer
  scheduleAlarm,

  -- * Waiting for signals
  getPendingSignals,

  awaitSignal,







  -- MISSING FUNCTIONALITY:
  -- sigaction(), (inc. the sigaction structure + flags etc.)
  -- the siginfo structure
  -- sigaltstack()
  -- sighold, sigignore, sigpause, sigrelse, sigset
  -- siginterrupt

  ) where

import Prelude -- necessary to get dependencies right

import Foreign
import Foreign.C
import System.IO.Unsafe
import System.Posix.Types
import System.Posix.Internals


-- WHOLE FILE...






-- -----------------------------------------------------------------------------
-- Specific signals

type Signal = CInt

nullSignal :: Signal
nullSignal = 0

sigABRT   :: CInt
sigABRT   = 6
sigALRM   :: CInt
sigALRM   = 14
sigBUS    :: CInt
sigBUS    = 7
sigCHLD   :: CInt
sigCHLD   = 17
sigCONT   :: CInt
sigCONT   = 18
sigFPE    :: CInt
sigFPE    = 8
sigHUP    :: CInt
sigHUP    = 1
sigILL    :: CInt
sigILL    = 4
sigINT    :: CInt
sigINT    = 2
sigKILL   :: CInt
sigKILL   = 9
sigPIPE   :: CInt
sigPIPE   = 13
sigQUIT   :: CInt
sigQUIT   = 3
sigSEGV   :: CInt
sigSEGV   = 11
sigSTOP   :: CInt
sigSTOP   = 19
sigTERM   :: CInt
sigTERM   = 15
sigTSTP   :: CInt
sigTSTP   = 20
sigTTIN   :: CInt
sigTTIN   = 21
sigTTOU   :: CInt
sigTTOU   = 22
sigUSR1   :: CInt
sigUSR1   = 10
sigUSR2   :: CInt
sigUSR2   = 12
sigPOLL   :: CInt
sigPOLL   = 29
sigPROF   :: CInt
sigPROF   = 27
sigSYS    :: CInt
sigSYS    = 31
sigTRAP   :: CInt
sigTRAP   = 5
sigURG    :: CInt
sigURG    = 23
sigVTALRM :: CInt
sigVTALRM = 26
sigXCPU   :: CInt
sigXCPU   = 24
sigXFSZ   :: CInt
sigXFSZ   = 25

internalAbort ::Signal
internalAbort = sigABRT

realTimeAlarm :: Signal
realTimeAlarm = sigALRM

busError :: Signal
busError = sigBUS

processStatusChanged :: Signal
processStatusChanged = sigCHLD

continueProcess :: Signal
continueProcess = sigCONT

floatingPointException :: Signal
floatingPointException = sigFPE

lostConnection :: Signal
lostConnection = sigHUP

illegalInstruction :: Signal
illegalInstruction = sigILL

keyboardSignal :: Signal
keyboardSignal = sigINT

killProcess :: Signal
killProcess = sigKILL

openEndedPipe :: Signal
openEndedPipe = sigPIPE

keyboardTermination :: Signal
keyboardTermination = sigQUIT

segmentationViolation :: Signal
segmentationViolation = sigSEGV

softwareStop :: Signal
softwareStop = sigSTOP

softwareTermination :: Signal
softwareTermination = sigTERM

keyboardStop :: Signal
keyboardStop = sigTSTP

backgroundRead :: Signal
backgroundRead = sigTTIN

backgroundWrite :: Signal
backgroundWrite = sigTTOU

userDefinedSignal1 :: Signal
userDefinedSignal1 = sigUSR1

userDefinedSignal2 :: Signal
userDefinedSignal2 = sigUSR2


pollableEvent :: Signal
pollableEvent = sigPOLL


profilingTimerExpired :: Signal
profilingTimerExpired = sigPROF

badSystemCall :: Signal
badSystemCall = sigSYS

breakpointTrap :: Signal
breakpointTrap = sigTRAP

urgentDataAvailable :: Signal
urgentDataAvailable = sigURG

virtualTimerExpired :: Signal
virtualTimerExpired = sigVTALRM

cpuTimeLimitExceeded :: Signal
cpuTimeLimitExceeded = sigXCPU

fileSizeLimitExceeded :: Signal
fileSizeLimitExceeded = sigXFSZ

-- -----------------------------------------------------------------------------
-- Signal-related functions

-- | @signalProcess int pid@ calls @kill@ to signal process @pid@ 
--   with interrupt signal @int@.
signalProcess :: Signal -> ProcessID -> IO ()
signalProcess sig pid 
 = throwErrnoIfMinus1_ "signalProcess" (c_kill (fromIntegral pid) sig)

foreign import ccall unsafe "kill"
  c_kill :: CPid -> CInt -> IO CInt


-- | @signalProcessGroup int pgid@ calls @kill@ to signal 
--  all processes in group @pgid@ with interrupt signal @int@.
signalProcessGroup :: Signal -> ProcessGroupID -> IO ()
signalProcessGroup sig pgid 
  = throwErrnoIfMinus1_ "signalProcessGroup" (c_killpg (fromIntegral pgid) sig)

foreign import ccall unsafe "killpg"
  c_killpg :: CPid -> CInt -> IO CInt

-- | @raiseSignal int@ calls @kill@ to signal the current process
--   with interrupt signal @int@. 
raiseSignal :: Signal -> IO ()
raiseSignal sig = throwErrnoIfMinus1_ "raiseSignal" (c_raise sig)





foreign import ccall unsafe "raise"
  c_raise :: CInt -> IO CInt












































































-- -----------------------------------------------------------------------------
-- Alarms

-- | @scheduleAlarm i@ calls @alarm@ to schedule a real time
--   alarm at least @i@ seconds in the future.
scheduleAlarm :: Int -> IO Int
scheduleAlarm secs = do
   r <- c_alarm (fromIntegral secs)
   return (fromIntegral r)

foreign import ccall unsafe "alarm"
  c_alarm :: CUInt -> IO CUInt






















-- -----------------------------------------------------------------------------
-- Manipulating signal sets

newtype SignalSet = SignalSet (ForeignPtr CSigset)

emptySignalSet :: SignalSet
emptySignalSet = unsafePerformIO $ do
  fp <- mallocForeignPtrBytes sizeof_sigset_t
  throwErrnoIfMinus1_ "emptySignalSet" (withForeignPtr fp $ c_sigemptyset)
  return (SignalSet fp)

fullSignalSet :: SignalSet
fullSignalSet = unsafePerformIO $ do
  fp <- mallocForeignPtrBytes sizeof_sigset_t
  throwErrnoIfMinus1_ "fullSignalSet" (withForeignPtr fp $ c_sigfillset)
  return (SignalSet fp)

infixr `addSignal`, `deleteSignal`
addSignal :: Signal -> SignalSet -> SignalSet
addSignal sig (SignalSet fp1) = unsafePerformIO $ do
  fp2 <- mallocForeignPtrBytes sizeof_sigset_t
  withForeignPtr fp1 $ \p1 ->
    withForeignPtr fp2 $ \p2 -> do
      copyBytes p2 p1 sizeof_sigset_t
      throwErrnoIfMinus1_ "addSignal" (c_sigaddset p2 sig)
  return (SignalSet fp2)

deleteSignal :: Signal -> SignalSet -> SignalSet
deleteSignal sig (SignalSet fp1) = unsafePerformIO $ do
  fp2 <- mallocForeignPtrBytes sizeof_sigset_t
  withForeignPtr fp1 $ \p1 ->
    withForeignPtr fp2 $ \p2 -> do
      copyBytes p2 p1 sizeof_sigset_t
      throwErrnoIfMinus1_ "deleteSignal" (c_sigdelset p2 sig)
  return (SignalSet fp2)

inSignalSet :: Signal -> SignalSet -> Bool
inSignalSet sig (SignalSet fp) = unsafePerformIO $
  withForeignPtr fp $ \p -> do
    r <- throwErrnoIfMinus1 "inSignalSet" (c_sigismember p sig)
    return (r /= 0)

-- | @getSignalMask@ calls @sigprocmask@ to determine the
--   set of interrupts which are currently being blocked.
getSignalMask :: IO SignalSet
getSignalMask = do
  fp <- mallocForeignPtrBytes sizeof_sigset_t
  withForeignPtr fp $ \p ->
    throwErrnoIfMinus1_ "getSignalMask" (c_sigprocmask 0 nullPtr p)
  return (SignalSet fp)
   
sigProcMask :: String -> CInt -> SignalSet -> IO ()
sigProcMask fn how (SignalSet set) =
  withForeignPtr set $ \p_set ->
    throwErrnoIfMinus1_ fn (c_sigprocmask how p_set nullPtr)

-- | @setSignalMask mask@ calls @sigprocmask@ with
--   @SIG_SETMASK@ to block all interrupts in @mask@.
setSignalMask :: SignalSet -> IO ()
setSignalMask set = sigProcMask "setSignalMask" (2 :: CInt) set

-- | @blockSignals mask@ calls @sigprocmask@ with
--   @SIG_BLOCK@ to add all interrupts in @mask@ to the
--  set of blocked interrupts.
blockSignals :: SignalSet -> IO ()
blockSignals set = sigProcMask "blockSignals" (0 :: CInt) set

-- | @unblockSignals mask@ calls @sigprocmask@ with
--   @SIG_UNBLOCK@ to remove all interrupts in @mask@ from the
--   set of blocked interrupts. 
unblockSignals :: SignalSet -> IO ()
unblockSignals set = sigProcMask "unblockSignals" (1 :: CInt) set

-- | @getPendingSignals@ calls @sigpending@ to obtain
--   the set of interrupts which have been received but are currently blocked.
getPendingSignals :: IO SignalSet
getPendingSignals = do
  fp <- mallocForeignPtrBytes sizeof_sigset_t
  withForeignPtr fp $ \p -> 
   throwErrnoIfMinus1_ "getPendingSignals" (c_sigpending p)
  return (SignalSet fp)



-- | @awaitSignal iset@ suspends execution until an interrupt is received.
-- If @iset@ is @Just s@, @awaitSignal@ calls @sigsuspend@, installing
-- @s@ as the new signal mask before suspending execution; otherwise, it
-- calls @pause@.  @awaitSignal@ returns on receipt of a signal.  If you
-- have installed any signal handlers with @installHandler@, it may be
-- wise to call @yield@ directly after @awaitSignal@ to ensure that the
-- signal handler runs as promptly as possible.
awaitSignal :: Maybe SignalSet -> IO ()
awaitSignal maybe_sigset = do
  fp <- case maybe_sigset of
    	  Nothing -> do SignalSet fp <- getSignalMask; return fp
    	  Just (SignalSet fp) -> return fp
  withForeignPtr fp $ \p -> do
  c_sigsuspend p
  return ()
  -- ignore the return value; according to the docs it can only ever be
  -- (-1) with errno set to EINTR.
 
foreign import ccall unsafe "sigsuspend"
  c_sigsuspend :: Ptr CSigset -> IO CInt



foreign import ccall unsafe "sigdelset"
  c_sigdelset   :: Ptr CSigset -> CInt -> IO CInt

foreign import ccall unsafe "sigfillset"
  c_sigfillset  :: Ptr CSigset -> IO CInt

foreign import ccall unsafe "sigismember"
  c_sigismember :: Ptr CSigset -> CInt -> IO CInt











foreign import ccall unsafe "sigpending"
  c_sigpending :: Ptr CSigset -> IO CInt



 asm    dylinkÅ¿ ` ` ` ```  ` |€env
memoryBase env	tableBase envabort  env_alarm env_kill env_killpg env_raise env
_sigdelset env_sigfillset env_sigismember env_sigpending env_sigsuspend envmemory Äenvtablep            A A •_HugsAPIVersion 
__post_instantiate _hugs_primControl _hugsprim_alarm_3 _hugsprim_kill_0 _hugsprim_killpg_1 _hugsprim_raise_2 _hugsprim_sigdelset_5 _hugsprim_sigfillset_6 _hugsprim_sigismember_7 _hugsprim_sigpending_8 _hugsprim_sigsuspend_4 _initModule runPostSets 	 #
« A # A‡Å¿j  6 #   (∞   < # A‡Å¿j( (D # A‡Å¿j( (x    A# A‡Å¿j( († M # A‡Å¿j( (D # A‡Å¿j( (, # A‡Å¿j( (x    A# A‡Å¿j( († < # A‡Å¿j( (D # A‡Å¿j( (x    A# A‡Å¿j( († M # A‡Å¿j( (D # A‡Å¿j( (, # A‡Å¿j( (x    A# A‡Å¿j( († < # A‡Å¿j( (D 	# A‡Å¿j( (x    A# A‡Å¿j( († = # A‡Å¿j( (< # A‡Å¿j( (à    A# A‡Å¿j( († < # A‡Å¿j( (, # A‡Å¿j( (x    A# A‡Å¿j( († M # A‡Å¿j( (, # A‡Å¿j( (, # A‡Å¿j( (x    A# A‡Å¿j( († M # A‡Å¿j( (, # A‡Å¿j( (, # A‡Å¿j( (x    A# A‡Å¿j( († è # #Aj6 # # (# Ajj6# # (# A¯ jj6# #Aj6# # (# AÖjj6# #Aj6 # # ($# Aìjj6$# #Aj6,# # (0# A†jj60# #Aj68# # (<# A¨jj6<# #Aj6D# # (H# Aπjj6H# #Aj6P# # (T# A¡jj6T# #Aj6\# # (`# A…jj6`# #A	j6h# # (l# A“jj6l# #A
j6t # A‡j$#AÄÄ¿j$ A  D        ﬂ # ÿ                                                                                                               c_sigpending c_sigismember c_sigfillset c_sigdelset c_sigsuspend c_alarm c_raise c_killpg c_kill{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  System.Posix.Types
-- Copyright   :  (c) The University of Glasgow 2002
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  non-portable (requires POSIX)
--
-- POSIX data types: Haskell equivalents of the types defined by the
-- @\<sys\/types.h>@ C header on a POSIX system.
--
-----------------------------------------------------------------------------

                                                                              
                                                                             

                         


                          


                              


                                 


                        


                                


                          


                            


                         


                           


                           


                         


                          


                         


                                


                                


                              


                           


                                


                          


                        


                          


                          


                          


                         


                          


                             


                                


                         


                          


                               


                         


                          


                       


                           


                          


                         


                          


                          


                            


                             


                                


                            


                             


                               


                          


                           


                            


                           


                          


                          


                           


                          


                           


                          


                          


                          


                               


                          


                         


                          


                          


                           


                            


                           


                             


                            


                          


                         


                              


                         


                                


                         


                            


                                


                                 


                                


                          


                                   


                              


                          


                           


                           


                         


                                


                            


                             


                                   


                          


                         


                          


                          


                         


                             


                                


                           


                          


                               


                         


                            


                           


                           


                          


                           


                           


                          


                          


                          


                          


                           


                           


                           


                           


                           


                           


                           


                          


                           


                           


                           


                           


                           


                          


                           


                           


                             


                           


                           


                             


                           


                           


                           


                               


                               


                                                        


                                                                                     


                                                                                    
                             

                                                         


                                                        


                                                        


                                                  


                                                   


                                                       


                                                      
                          

                                                       


                                                          


                                                      


                                                           


                                                      


                                                         


                                                         


                                                         


                                                   


                                                         


                                                       


                                                       


                                                         


                                                         


                                                         


                                                          


                                                         


                                                          


                                                               


                                                             


                                                           


                                                              


                                                            


                                                             
                              

                                                            


                                                           


                                                            


                                                              


                                                           


                                                          


                                                   


                                                       


                                                                                                         


                                                                                         
                        

                                                         


                                                        


                                                   


                                                        
                         

                                                         


                                                          
                           

                                                          
                           

                                  


                                   


                                                     
                         

                                     


                                     


                                        


                                      


                                       


                                      


                                      


                                      


                                    


                                         


                                         


                                     


                                          


                                       


                                        


                                      


                                      


                                          


                                       


                                      


                                            


                                             


                                       


                                        


                                        


                                         


                                       


                                      


                                          


                                          


                                              


                                             


                                              


                                                   


                                               


                                        


                                       
                         

                                                                              


                                              


                                                          


                                                          


                                               


                                            


                                           


                                                      


                                                                           


                                                            
                           

                                                   




                                                                       
                              

                                                 
                         

                                                            
                  

                                                       
                  

                                                
                  



module System.Posix.Types (

  -- * POSIX data types

  CDev,


  CIno,


  CMode,


  COff,


  CPid,


  CSsize,



  CGid,


  CNlink,


  CUid,


  CCc,


  CSpeed,


  CTcflag,


  CRLim,


  Fd(..),


  LinkCount,


  UserID,


  GroupID,


  ByteCount,
  ClockTick,
  EpochTime,
  FileOffset,
  ProcessID,
  ProcessGroupID,
  DeviceID,
  FileID,
  FileMode,
  Limit
 ) where

import Foreign
import Foreign.C
import Data.Typeable
import Data.Bits










import Control.Monad


                                                                                                                                                                                                                                              




                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
























































                                                                                                                                                                                                                                        

                                                                






































































































































































































newtype CDev = CDev Word64 deriving (Eq, Ord) ; instance Num CDev where {    (CDev i) + (CDev j) = CDev (i + j) ;    (CDev i) - (CDev j) = CDev (i - j) ;    (CDev i) * (CDev j) = CDev (i * j) ;    negate  (CDev i) = CDev (negate i) ;    abs     (CDev i) = CDev (abs    i) ;    signum  (CDev i) = CDev (signum i) ;    fromInteger x = CDev (fromInteger x) } ; instance Real CDev where {    toRational (CDev i) = toRational i } ; instance Read CDev where {    readsPrec p s = map (\(x, t) -> (CDev x, t)) (readsPrec p s) } ; instance Show CDev where {    showsPrec p (CDev x) = showsPrec p x } ; instance Enum CDev where {    succ           (CDev i)             = CDev (succ i) ;    pred           (CDev i)             = CDev (pred i) ;    toEnum               x           = CDev (toEnum x) ;    fromEnum       (CDev i)             = fromEnum i ;    enumFrom       (CDev i)             = map CDev (enumFrom i) ;    enumFromThen   (CDev i) (CDev j)       = map CDev (enumFromThen i j) ;    enumFromTo     (CDev i) (CDev j)       = map CDev (enumFromTo i j) ;    enumFromThenTo (CDev i) (CDev j) (CDev k) = map CDev (enumFromThenTo i j k) } ; instance Storable CDev where {    sizeOf    (CDev x)       = sizeOf x ;    alignment (CDev x)       = alignment x ;    peekElemOff a i       = liftM CDev (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CDev x) = pokeElemOff (castPtr a) i x } ; tyConCDev = mkTyCon "CDev"; instance Typeable CDev where { typeOf _ = mkTyConApp tyConCDev [] } ;


newtype CIno = CIno Word64 deriving (Eq, Ord) ; instance Num CIno where {    (CIno i) + (CIno j) = CIno (i + j) ;    (CIno i) - (CIno j) = CIno (i - j) ;    (CIno i) * (CIno j) = CIno (i * j) ;    negate  (CIno i) = CIno (negate i) ;    abs     (CIno i) = CIno (abs    i) ;    signum  (CIno i) = CIno (signum i) ;    fromInteger x = CIno (fromInteger x) } ; instance Real CIno where {    toRational (CIno i) = toRational i } ; instance Read CIno where {    readsPrec p s = map (\(x, t) -> (CIno x, t)) (readsPrec p s) } ; instance Show CIno where {    showsPrec p (CIno x) = showsPrec p x } ; instance Enum CIno where {    succ           (CIno i)             = CIno (succ i) ;    pred           (CIno i)             = CIno (pred i) ;    toEnum               x           = CIno (toEnum x) ;    fromEnum       (CIno i)             = fromEnum i ;    enumFrom       (CIno i)             = map CIno (enumFrom i) ;    enumFromThen   (CIno i) (CIno j)       = map CIno (enumFromThen i j) ;    enumFromTo     (CIno i) (CIno j)       = map CIno (enumFromTo i j) ;    enumFromThenTo (CIno i) (CIno j) (CIno k) = map CIno (enumFromThenTo i j k) } ; instance Storable CIno where {    sizeOf    (CIno x)       = sizeOf x ;    alignment (CIno x)       = alignment x ;    peekElemOff a i       = liftM CIno (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CIno x) = pokeElemOff (castPtr a) i x } ; tyConCIno = mkTyCon "CIno"; instance Typeable CIno where { typeOf _ = mkTyConApp tyConCIno [] } ; ; instance Bounded CIno where {    minBound = CIno minBound ;    maxBound = CIno maxBound } ; instance Integral CIno where {    (CIno i) `quot`    (CIno j) = CIno (i `quot` j) ;    (CIno i) `rem`     (CIno j) = CIno (i `rem`  j) ;    (CIno i) `div`     (CIno j) = CIno (i `div`  j) ;    (CIno i) `mod`     (CIno j) = CIno (i `mod`  j) ;    (CIno i) `quotRem` (CIno j) = let (q,r) = i `quotRem` j in (CIno q, CIno r) ;    (CIno i) `divMod`  (CIno j) = let (d,m) = i `divMod`  j in (CIno d, CIno m) ;    toInteger (CIno i)       = toInteger i } ; instance Bits CIno where {   (CIno x) .&.     (CIno y)   = CIno (x .&.   y) ;   (CIno x) .|.     (CIno y)   = CIno (x .|.   y) ;   (CIno x) `xor`   (CIno y)   = CIno (x `xor` y) ;   complement    (CIno x)   = CIno (complement x) ;   shift         (CIno x) n = CIno (shift x n) ;   rotate        (CIno x) n = CIno (rotate x n) ;   bit                 n = CIno (bit n) ;   setBit        (CIno x) n = CIno (setBit x n) ;   clearBit      (CIno x) n = CIno (clearBit x n) ;   complementBit (CIno x) n = CIno (complementBit x n) ;   testBit       (CIno x) n = testBit x n ;   bitSize       (CIno x)   = bitSize x ;   isSigned      (CIno x)   = isSigned x }


newtype CMode = CMode Word32 deriving (Eq, Ord) ; instance Num CMode where {    (CMode i) + (CMode j) = CMode (i + j) ;    (CMode i) - (CMode j) = CMode (i - j) ;    (CMode i) * (CMode j) = CMode (i * j) ;    negate  (CMode i) = CMode (negate i) ;    abs     (CMode i) = CMode (abs    i) ;    signum  (CMode i) = CMode (signum i) ;    fromInteger x = CMode (fromInteger x) } ; instance Real CMode where {    toRational (CMode i) = toRational i } ; instance Read CMode where {    readsPrec p s = map (\(x, t) -> (CMode x, t)) (readsPrec p s) } ; instance Show CMode where {    showsPrec p (CMode x) = showsPrec p x } ; instance Enum CMode where {    succ           (CMode i)             = CMode (succ i) ;    pred           (CMode i)             = CMode (pred i) ;    toEnum               x           = CMode (toEnum x) ;    fromEnum       (CMode i)             = fromEnum i ;    enumFrom       (CMode i)             = map CMode (enumFrom i) ;    enumFromThen   (CMode i) (CMode j)       = map CMode (enumFromThen i j) ;    enumFromTo     (CMode i) (CMode j)       = map CMode (enumFromTo i j) ;    enumFromThenTo (CMode i) (CMode j) (CMode k) = map CMode (enumFromThenTo i j k) } ; instance Storable CMode where {    sizeOf    (CMode x)       = sizeOf x ;    alignment (CMode x)       = alignment x ;    peekElemOff a i       = liftM CMode (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CMode x) = pokeElemOff (castPtr a) i x } ; tyConCMode = mkTyCon "CMode"; instance Typeable CMode where { typeOf _ = mkTyConApp tyConCMode [] } ; ; instance Bounded CMode where {    minBound = CMode minBound ;    maxBound = CMode maxBound } ; instance Integral CMode where {    (CMode i) `quot`    (CMode j) = CMode (i `quot` j) ;    (CMode i) `rem`     (CMode j) = CMode (i `rem`  j) ;    (CMode i) `div`     (CMode j) = CMode (i `div`  j) ;    (CMode i) `mod`     (CMode j) = CMode (i `mod`  j) ;    (CMode i) `quotRem` (CMode j) = let (q,r) = i `quotRem` j in (CMode q, CMode r) ;    (CMode i) `divMod`  (CMode j) = let (d,m) = i `divMod`  j in (CMode d, CMode m) ;    toInteger (CMode i)       = toInteger i } ; instance Bits CMode where {   (CMode x) .&.     (CMode y)   = CMode (x .&.   y) ;   (CMode x) .|.     (CMode y)   = CMode (x .|.   y) ;   (CMode x) `xor`   (CMode y)   = CMode (x `xor` y) ;   complement    (CMode x)   = CMode (complement x) ;   shift         (CMode x) n = CMode (shift x n) ;   rotate        (CMode x) n = CMode (rotate x n) ;   bit                 n = CMode (bit n) ;   setBit        (CMode x) n = CMode (setBit x n) ;   clearBit      (CMode x) n = CMode (clearBit x n) ;   complementBit (CMode x) n = CMode (complementBit x n) ;   testBit       (CMode x) n = testBit x n ;   bitSize       (CMode x)   = bitSize x ;   isSigned      (CMode x)   = isSigned x }


newtype COff = COff Int64 deriving (Eq, Ord) ; instance Num COff where {    (COff i) + (COff j) = COff (i + j) ;    (COff i) - (COff j) = COff (i - j) ;    (COff i) * (COff j) = COff (i * j) ;    negate  (COff i) = COff (negate i) ;    abs     (COff i) = COff (abs    i) ;    signum  (COff i) = COff (signum i) ;    fromInteger x = COff (fromInteger x) } ; instance Real COff where {    toRational (COff i) = toRational i } ; instance Read COff where {    readsPrec p s = map (\(x, t) -> (COff x, t)) (readsPrec p s) } ; instance Show COff where {    showsPrec p (COff x) = showsPrec p x } ; instance Enum COff where {    succ           (COff i)             = COff (succ i) ;    pred           (COff i)             = COff (pred i) ;    toEnum               x           = COff (toEnum x) ;    fromEnum       (COff i)             = fromEnum i ;    enumFrom       (COff i)             = map COff (enumFrom i) ;    enumFromThen   (COff i) (COff j)       = map COff (enumFromThen i j) ;    enumFromTo     (COff i) (COff j)       = map COff (enumFromTo i j) ;    enumFromThenTo (COff i) (COff j) (COff k) = map COff (enumFromThenTo i j k) } ; instance Storable COff where {    sizeOf    (COff x)       = sizeOf x ;    alignment (COff x)       = alignment x ;    peekElemOff a i       = liftM COff (peekElemOff (castPtr a) i) ;    pokeElemOff a i (COff x) = pokeElemOff (castPtr a) i x } ; tyConCOff = mkTyCon "COff"; instance Typeable COff where { typeOf _ = mkTyConApp tyConCOff [] } ; ; instance Bounded COff where {    minBound = COff minBound ;    maxBound = COff maxBound } ; instance Integral COff where {    (COff i) `quot`    (COff j) = COff (i `quot` j) ;    (COff i) `rem`     (COff j) = COff (i `rem`  j) ;    (COff i) `div`     (COff j) = COff (i `div`  j) ;    (COff i) `mod`     (COff j) = COff (i `mod`  j) ;    (COff i) `quotRem` (COff j) = let (q,r) = i `quotRem` j in (COff q, COff r) ;    (COff i) `divMod`  (COff j) = let (d,m) = i `divMod`  j in (COff d, COff m) ;    toInteger (COff i)       = toInteger i } ; instance Bits COff where {   (COff x) .&.     (COff y)   = COff (x .&.   y) ;   (COff x) .|.     (COff y)   = COff (x .|.   y) ;   (COff x) `xor`   (COff y)   = COff (x `xor` y) ;   complement    (COff x)   = COff (complement x) ;   shift         (COff x) n = COff (shift x n) ;   rotate        (COff x) n = COff (rotate x n) ;   bit                 n = COff (bit n) ;   setBit        (COff x) n = COff (setBit x n) ;   clearBit      (COff x) n = COff (clearBit x n) ;   complementBit (COff x) n = COff (complementBit x n) ;   testBit       (COff x) n = testBit x n ;   bitSize       (COff x)   = bitSize x ;   isSigned      (COff x)   = isSigned x }


newtype CPid = CPid Int32 deriving (Eq, Ord) ; instance Num CPid where {    (CPid i) + (CPid j) = CPid (i + j) ;    (CPid i) - (CPid j) = CPid (i - j) ;    (CPid i) * (CPid j) = CPid (i * j) ;    negate  (CPid i) = CPid (negate i) ;    abs     (CPid i) = CPid (abs    i) ;    signum  (CPid i) = CPid (signum i) ;    fromInteger x = CPid (fromInteger x) } ; instance Real CPid where {    toRational (CPid i) = toRational i } ; instance Read CPid where {    readsPrec p s = map (\(x, t) -> (CPid x, t)) (readsPrec p s) } ; instance Show CPid where {    showsPrec p (CPid x) = showsPrec p x } ; instance Enum CPid where {    succ           (CPid i)             = CPid (succ i) ;    pred           (CPid i)             = CPid (pred i) ;    toEnum               x           = CPid (toEnum x) ;    fromEnum       (CPid i)             = fromEnum i ;    enumFrom       (CPid i)             = map CPid (enumFrom i) ;    enumFromThen   (CPid i) (CPid j)       = map CPid (enumFromThen i j) ;    enumFromTo     (CPid i) (CPid j)       = map CPid (enumFromTo i j) ;    enumFromThenTo (CPid i) (CPid j) (CPid k) = map CPid (enumFromThenTo i j k) } ; instance Storable CPid where {    sizeOf    (CPid x)       = sizeOf x ;    alignment (CPid x)       = alignment x ;    peekElemOff a i       = liftM CPid (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CPid x) = pokeElemOff (castPtr a) i x } ; tyConCPid = mkTyCon "CPid"; instance Typeable CPid where { typeOf _ = mkTyConApp tyConCPid [] } ; ; instance Bounded CPid where {    minBound = CPid minBound ;    maxBound = CPid maxBound } ; instance Integral CPid where {    (CPid i) `quot`    (CPid j) = CPid (i `quot` j) ;    (CPid i) `rem`     (CPid j) = CPid (i `rem`  j) ;    (CPid i) `div`     (CPid j) = CPid (i `div`  j) ;    (CPid i) `mod`     (CPid j) = CPid (i `mod`  j) ;    (CPid i) `quotRem` (CPid j) = let (q,r) = i `quotRem` j in (CPid q, CPid r) ;    (CPid i) `divMod`  (CPid j) = let (d,m) = i `divMod`  j in (CPid d, CPid m) ;    toInteger (CPid i)       = toInteger i } ; instance Bits CPid where {   (CPid x) .&.     (CPid y)   = CPid (x .&.   y) ;   (CPid x) .|.     (CPid y)   = CPid (x .|.   y) ;   (CPid x) `xor`   (CPid y)   = CPid (x `xor` y) ;   complement    (CPid x)   = CPid (complement x) ;   shift         (CPid x) n = CPid (shift x n) ;   rotate        (CPid x) n = CPid (rotate x n) ;   bit                 n = CPid (bit n) ;   setBit        (CPid x) n = CPid (setBit x n) ;   clearBit      (CPid x) n = CPid (clearBit x n) ;   complementBit (CPid x) n = CPid (complementBit x n) ;   testBit       (CPid x) n = testBit x n ;   bitSize       (CPid x)   = bitSize x ;   isSigned      (CPid x)   = isSigned x }



newtype CSsize = CSsize Int64 deriving (Eq, Ord) ; instance Num CSsize where {    (CSsize i) + (CSsize j) = CSsize (i + j) ;    (CSsize i) - (CSsize j) = CSsize (i - j) ;    (CSsize i) * (CSsize j) = CSsize (i * j) ;    negate  (CSsize i) = CSsize (negate i) ;    abs     (CSsize i) = CSsize (abs    i) ;    signum  (CSsize i) = CSsize (signum i) ;    fromInteger x = CSsize (fromInteger x) } ; instance Real CSsize where {    toRational (CSsize i) = toRational i } ; instance Read CSsize where {    readsPrec p s = map (\(x, t) -> (CSsize x, t)) (readsPrec p s) } ; instance Show CSsize where {    showsPrec p (CSsize x) = showsPrec p x } ; instance Enum CSsize where {    succ           (CSsize i)             = CSsize (succ i) ;    pred           (CSsize i)             = CSsize (pred i) ;    toEnum               x           = CSsize (toEnum x) ;    fromEnum       (CSsize i)             = fromEnum i ;    enumFrom       (CSsize i)             = map CSsize (enumFrom i) ;    enumFromThen   (CSsize i) (CSsize j)       = map CSsize (enumFromThen i j) ;    enumFromTo     (CSsize i) (CSsize j)       = map CSsize (enumFromTo i j) ;    enumFromThenTo (CSsize i) (CSsize j) (CSsize k) = map CSsize (enumFromThenTo i j k) } ; instance Storable CSsize where {    sizeOf    (CSsize x)       = sizeOf x ;    alignment (CSsize x)       = alignment x ;    peekElemOff a i       = liftM CSsize (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CSsize x) = pokeElemOff (castPtr a) i x } ; tyConCSsize = mkTyCon "CSsize"; instance Typeable CSsize where { typeOf _ = mkTyConApp tyConCSsize [] } ; ; instance Bounded CSsize where {    minBound = CSsize minBound ;    maxBound = CSsize maxBound } ; instance Integral CSsize where {    (CSsize i) `quot`    (CSsize j) = CSsize (i `quot` j) ;    (CSsize i) `rem`     (CSsize j) = CSsize (i `rem`  j) ;    (CSsize i) `div`     (CSsize j) = CSsize (i `div`  j) ;    (CSsize i) `mod`     (CSsize j) = CSsize (i `mod`  j) ;    (CSsize i) `quotRem` (CSsize j) = let (q,r) = i `quotRem` j in (CSsize q, CSsize r) ;    (CSsize i) `divMod`  (CSsize j) = let (d,m) = i `divMod`  j in (CSsize d, CSsize m) ;    toInteger (CSsize i)       = toInteger i } ; instance Bits CSsize where {   (CSsize x) .&.     (CSsize y)   = CSsize (x .&.   y) ;   (CSsize x) .|.     (CSsize y)   = CSsize (x .|.   y) ;   (CSsize x) `xor`   (CSsize y)   = CSsize (x `xor` y) ;   complement    (CSsize x)   = CSsize (complement x) ;   shift         (CSsize x) n = CSsize (shift x n) ;   rotate        (CSsize x) n = CSsize (rotate x n) ;   bit                 n = CSsize (bit n) ;   setBit        (CSsize x) n = CSsize (setBit x n) ;   clearBit      (CSsize x) n = CSsize (clearBit x n) ;   complementBit (CSsize x) n = CSsize (complementBit x n) ;   testBit       (CSsize x) n = testBit x n ;   bitSize       (CSsize x)   = bitSize x ;   isSigned      (CSsize x)   = isSigned x }



newtype CGid = CGid Word32 deriving (Eq, Ord) ; instance Num CGid where {    (CGid i) + (CGid j) = CGid (i + j) ;    (CGid i) - (CGid j) = CGid (i - j) ;    (CGid i) * (CGid j) = CGid (i * j) ;    negate  (CGid i) = CGid (negate i) ;    abs     (CGid i) = CGid (abs    i) ;    signum  (CGid i) = CGid (signum i) ;    fromInteger x = CGid (fromInteger x) } ; instance Real CGid where {    toRational (CGid i) = toRational i } ; instance Read CGid where {    readsPrec p s = map (\(x, t) -> (CGid x, t)) (readsPrec p s) } ; instance Show CGid where {    showsPrec p (CGid x) = showsPrec p x } ; instance Enum CGid where {    succ           (CGid i)             = CGid (succ i) ;    pred           (CGid i)             = CGid (pred i) ;    toEnum               x           = CGid (toEnum x) ;    fromEnum       (CGid i)             = fromEnum i ;    enumFrom       (CGid i)             = map CGid (enumFrom i) ;    enumFromThen   (CGid i) (CGid j)       = map CGid (enumFromThen i j) ;    enumFromTo     (CGid i) (CGid j)       = map CGid (enumFromTo i j) ;    enumFromThenTo (CGid i) (CGid j) (CGid k) = map CGid (enumFromThenTo i j k) } ; instance Storable CGid where {    sizeOf    (CGid x)       = sizeOf x ;    alignment (CGid x)       = alignment x ;    peekElemOff a i       = liftM CGid (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CGid x) = pokeElemOff (castPtr a) i x } ; tyConCGid = mkTyCon "CGid"; instance Typeable CGid where { typeOf _ = mkTyConApp tyConCGid [] } ; ; instance Bounded CGid where {    minBound = CGid minBound ;    maxBound = CGid maxBound } ; instance Integral CGid where {    (CGid i) `quot`    (CGid j) = CGid (i `quot` j) ;    (CGid i) `rem`     (CGid j) = CGid (i `rem`  j) ;    (CGid i) `div`     (CGid j) = CGid (i `div`  j) ;    (CGid i) `mod`     (CGid j) = CGid (i `mod`  j) ;    (CGid i) `quotRem` (CGid j) = let (q,r) = i `quotRem` j in (CGid q, CGid r) ;    (CGid i) `divMod`  (CGid j) = let (d,m) = i `divMod`  j in (CGid d, CGid m) ;    toInteger (CGid i)       = toInteger i } ; instance Bits CGid where {   (CGid x) .&.     (CGid y)   = CGid (x .&.   y) ;   (CGid x) .|.     (CGid y)   = CGid (x .|.   y) ;   (CGid x) `xor`   (CGid y)   = CGid (x `xor` y) ;   complement    (CGid x)   = CGid (complement x) ;   shift         (CGid x) n = CGid (shift x n) ;   rotate        (CGid x) n = CGid (rotate x n) ;   bit                 n = CGid (bit n) ;   setBit        (CGid x) n = CGid (setBit x n) ;   clearBit      (CGid x) n = CGid (clearBit x n) ;   complementBit (CGid x) n = CGid (complementBit x n) ;   testBit       (CGid x) n = testBit x n ;   bitSize       (CGid x)   = bitSize x ;   isSigned      (CGid x)   = isSigned x }


newtype CNlink = CNlink Word64 deriving (Eq, Ord) ; instance Num CNlink where {    (CNlink i) + (CNlink j) = CNlink (i + j) ;    (CNlink i) - (CNlink j) = CNlink (i - j) ;    (CNlink i) * (CNlink j) = CNlink (i * j) ;    negate  (CNlink i) = CNlink (negate i) ;    abs     (CNlink i) = CNlink (abs    i) ;    signum  (CNlink i) = CNlink (signum i) ;    fromInteger x = CNlink (fromInteger x) } ; instance Real CNlink where {    toRational (CNlink i) = toRational i } ; instance Read CNlink where {    readsPrec p s = map (\(x, t) -> (CNlink x, t)) (readsPrec p s) } ; instance Show CNlink where {    showsPrec p (CNlink x) = showsPrec p x } ; instance Enum CNlink where {    succ           (CNlink i)             = CNlink (succ i) ;    pred           (CNlink i)             = CNlink (pred i) ;    toEnum               x           = CNlink (toEnum x) ;    fromEnum       (CNlink i)             = fromEnum i ;    enumFrom       (CNlink i)             = map CNlink (enumFrom i) ;    enumFromThen   (CNlink i) (CNlink j)       = map CNlink (enumFromThen i j) ;    enumFromTo     (CNlink i) (CNlink j)       = map CNlink (enumFromTo i j) ;    enumFromThenTo (CNlink i) (CNlink j) (CNlink k) = map CNlink (enumFromThenTo i j k) } ; instance Storable CNlink where {    sizeOf    (CNlink x)       = sizeOf x ;    alignment (CNlink x)       = alignment x ;    peekElemOff a i       = liftM CNlink (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CNlink x) = pokeElemOff (castPtr a) i x } ; tyConCNlink = mkTyCon "CNlink"; instance Typeable CNlink where { typeOf _ = mkTyConApp tyConCNlink [] } ; ; instance Bounded CNlink where {    minBound = CNlink minBound ;    maxBound = CNlink maxBound } ; instance Integral CNlink where {    (CNlink i) `quot`    (CNlink j) = CNlink (i `quot` j) ;    (CNlink i) `rem`     (CNlink j) = CNlink (i `rem`  j) ;    (CNlink i) `div`     (CNlink j) = CNlink (i `div`  j) ;    (CNlink i) `mod`     (CNlink j) = CNlink (i `mod`  j) ;    (CNlink i) `quotRem` (CNlink j) = let (q,r) = i `quotRem` j in (CNlink q, CNlink r) ;    (CNlink i) `divMod`  (CNlink j) = let (d,m) = i `divMod`  j in (CNlink d, CNlink m) ;    toInteger (CNlink i)       = toInteger i } ; instance Bits CNlink where {   (CNlink x) .&.     (CNlink y)   = CNlink (x .&.   y) ;   (CNlink x) .|.     (CNlink y)   = CNlink (x .|.   y) ;   (CNlink x) `xor`   (CNlink y)   = CNlink (x `xor` y) ;   complement    (CNlink x)   = CNlink (complement x) ;   shift         (CNlink x) n = CNlink (shift x n) ;   rotate        (CNlink x) n = CNlink (rotate x n) ;   bit                 n = CNlink (bit n) ;   setBit        (CNlink x) n = CNlink (setBit x n) ;   clearBit      (CNlink x) n = CNlink (clearBit x n) ;   complementBit (CNlink x) n = CNlink (complementBit x n) ;   testBit       (CNlink x) n = testBit x n ;   bitSize       (CNlink x)   = bitSize x ;   isSigned      (CNlink x)   = isSigned x }



newtype CUid = CUid Word32 deriving (Eq, Ord) ; instance Num CUid where {    (CUid i) + (CUid j) = CUid (i + j) ;    (CUid i) - (CUid j) = CUid (i - j) ;    (CUid i) * (CUid j) = CUid (i * j) ;    negate  (CUid i) = CUid (negate i) ;    abs     (CUid i) = CUid (abs    i) ;    signum  (CUid i) = CUid (signum i) ;    fromInteger x = CUid (fromInteger x) } ; instance Real CUid where {    toRational (CUid i) = toRational i } ; instance Read CUid where {    readsPrec p s = map (\(x, t) -> (CUid x, t)) (readsPrec p s) } ; instance Show CUid where {    showsPrec p (CUid x) = showsPrec p x } ; instance Enum CUid where {    succ           (CUid i)             = CUid (succ i) ;    pred           (CUid i)             = CUid (pred i) ;    toEnum               x           = CUid (toEnum x) ;    fromEnum       (CUid i)             = fromEnum i ;    enumFrom       (CUid i)             = map CUid (enumFrom i) ;    enumFromThen   (CUid i) (CUid j)       = map CUid (enumFromThen i j) ;    enumFromTo     (CUid i) (CUid j)       = map CUid (enumFromTo i j) ;    enumFromThenTo (CUid i) (CUid j) (CUid k) = map CUid (enumFromThenTo i j k) } ; instance Storable CUid where {    sizeOf    (CUid x)       = sizeOf x ;    alignment (CUid x)       = alignment x ;    peekElemOff a i       = liftM CUid (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CUid x) = pokeElemOff (castPtr a) i x } ; tyConCUid = mkTyCon "CUid"; instance Typeable CUid where { typeOf _ = mkTyConApp tyConCUid [] } ; ; instance Bounded CUid where {    minBound = CUid minBound ;    maxBound = CUid maxBound } ; instance Integral CUid where {    (CUid i) `quot`    (CUid j) = CUid (i `quot` j) ;    (CUid i) `rem`     (CUid j) = CUid (i `rem`  j) ;    (CUid i) `div`     (CUid j) = CUid (i `div`  j) ;    (CUid i) `mod`     (CUid j) = CUid (i `mod`  j) ;    (CUid i) `quotRem` (CUid j) = let (q,r) = i `quotRem` j in (CUid q, CUid r) ;    (CUid i) `divMod`  (CUid j) = let (d,m) = i `divMod`  j in (CUid d, CUid m) ;    toInteger (CUid i)       = toInteger i } ; instance Bits CUid where {   (CUid x) .&.     (CUid y)   = CUid (x .&.   y) ;   (CUid x) .|.     (CUid y)   = CUid (x .|.   y) ;   (CUid x) `xor`   (CUid y)   = CUid (x `xor` y) ;   complement    (CUid x)   = CUid (complement x) ;   shift         (CUid x) n = CUid (shift x n) ;   rotate        (CUid x) n = CUid (rotate x n) ;   bit                 n = CUid (bit n) ;   setBit        (CUid x) n = CUid (setBit x n) ;   clearBit      (CUid x) n = CUid (clearBit x n) ;   complementBit (CUid x) n = CUid (complementBit x n) ;   testBit       (CUid x) n = testBit x n ;   bitSize       (CUid x)   = bitSize x ;   isSigned      (CUid x)   = isSigned x }


newtype CCc = CCc Word8 deriving (Eq, Ord) ; instance Num CCc where {    (CCc i) + (CCc j) = CCc (i + j) ;    (CCc i) - (CCc j) = CCc (i - j) ;    (CCc i) * (CCc j) = CCc (i * j) ;    negate  (CCc i) = CCc (negate i) ;    abs     (CCc i) = CCc (abs    i) ;    signum  (CCc i) = CCc (signum i) ;    fromInteger x = CCc (fromInteger x) } ; instance Real CCc where {    toRational (CCc i) = toRational i } ; instance Read CCc where {    readsPrec p s = map (\(x, t) -> (CCc x, t)) (readsPrec p s) } ; instance Show CCc where {    showsPrec p (CCc x) = showsPrec p x } ; instance Enum CCc where {    succ           (CCc i)             = CCc (succ i) ;    pred           (CCc i)             = CCc (pred i) ;    toEnum               x           = CCc (toEnum x) ;    fromEnum       (CCc i)             = fromEnum i ;    enumFrom       (CCc i)             = map CCc (enumFrom i) ;    enumFromThen   (CCc i) (CCc j)       = map CCc (enumFromThen i j) ;    enumFromTo     (CCc i) (CCc j)       = map CCc (enumFromTo i j) ;    enumFromThenTo (CCc i) (CCc j) (CCc k) = map CCc (enumFromThenTo i j k) } ; instance Storable CCc where {    sizeOf    (CCc x)       = sizeOf x ;    alignment (CCc x)       = alignment x ;    peekElemOff a i       = liftM CCc (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CCc x) = pokeElemOff (castPtr a) i x } ; tyConCCc = mkTyCon "CCc"; instance Typeable CCc where { typeOf _ = mkTyConApp tyConCCc [] } ;


newtype CSpeed = CSpeed Word32 deriving (Eq, Ord) ; instance Num CSpeed where {    (CSpeed i) + (CSpeed j) = CSpeed (i + j) ;    (CSpeed i) - (CSpeed j) = CSpeed (i - j) ;    (CSpeed i) * (CSpeed j) = CSpeed (i * j) ;    negate  (CSpeed i) = CSpeed (negate i) ;    abs     (CSpeed i) = CSpeed (abs    i) ;    signum  (CSpeed i) = CSpeed (signum i) ;    fromInteger x = CSpeed (fromInteger x) } ; instance Real CSpeed where {    toRational (CSpeed i) = toRational i } ; instance Read CSpeed where {    readsPrec p s = map (\(x, t) -> (CSpeed x, t)) (readsPrec p s) } ; instance Show CSpeed where {    showsPrec p (CSpeed x) = showsPrec p x } ; instance Enum CSpeed where {    succ           (CSpeed i)             = CSpeed (succ i) ;    pred           (CSpeed i)             = CSpeed (pred i) ;    toEnum               x           = CSpeed (toEnum x) ;    fromEnum       (CSpeed i)             = fromEnum i ;    enumFrom       (CSpeed i)             = map CSpeed (enumFrom i) ;    enumFromThen   (CSpeed i) (CSpeed j)       = map CSpeed (enumFromThen i j) ;    enumFromTo     (CSpeed i) (CSpeed j)       = map CSpeed (enumFromTo i j) ;    enumFromThenTo (CSpeed i) (CSpeed j) (CSpeed k) = map CSpeed (enumFromThenTo i j k) } ; instance Storable CSpeed where {    sizeOf    (CSpeed x)       = sizeOf x ;    alignment (CSpeed x)       = alignment x ;    peekElemOff a i       = liftM CSpeed (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CSpeed x) = pokeElemOff (castPtr a) i x } ; tyConCSpeed = mkTyCon "CSpeed"; instance Typeable CSpeed where { typeOf _ = mkTyConApp tyConCSpeed [] } ;


newtype CTcflag = CTcflag Word32 deriving (Eq, Ord) ; instance Num CTcflag where {    (CTcflag i) + (CTcflag j) = CTcflag (i + j) ;    (CTcflag i) - (CTcflag j) = CTcflag (i - j) ;    (CTcflag i) * (CTcflag j) = CTcflag (i * j) ;    negate  (CTcflag i) = CTcflag (negate i) ;    abs     (CTcflag i) = CTcflag (abs    i) ;    signum  (CTcflag i) = CTcflag (signum i) ;    fromInteger x = CTcflag (fromInteger x) } ; instance Real CTcflag where {    toRational (CTcflag i) = toRational i } ; instance Read CTcflag where {    readsPrec p s = map (\(x, t) -> (CTcflag x, t)) (readsPrec p s) } ; instance Show CTcflag where {    showsPrec p (CTcflag x) = showsPrec p x } ; instance Enum CTcflag where {    succ           (CTcflag i)             = CTcflag (succ i) ;    pred           (CTcflag i)             = CTcflag (pred i) ;    toEnum               x           = CTcflag (toEnum x) ;    fromEnum       (CTcflag i)             = fromEnum i ;    enumFrom       (CTcflag i)             = map CTcflag (enumFrom i) ;    enumFromThen   (CTcflag i) (CTcflag j)       = map CTcflag (enumFromThen i j) ;    enumFromTo     (CTcflag i) (CTcflag j)       = map CTcflag (enumFromTo i j) ;    enumFromThenTo (CTcflag i) (CTcflag j) (CTcflag k) = map CTcflag (enumFromThenTo i j k) } ; instance Storable CTcflag where {    sizeOf    (CTcflag x)       = sizeOf x ;    alignment (CTcflag x)       = alignment x ;    peekElemOff a i       = liftM CTcflag (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CTcflag x) = pokeElemOff (castPtr a) i x } ; tyConCTcflag = mkTyCon "CTcflag"; instance Typeable CTcflag where { typeOf _ = mkTyConApp tyConCTcflag [] } ; ; instance Bounded CTcflag where {    minBound = CTcflag minBound ;    maxBound = CTcflag maxBound } ; instance Integral CTcflag where {    (CTcflag i) `quot`    (CTcflag j) = CTcflag (i `quot` j) ;    (CTcflag i) `rem`     (CTcflag j) = CTcflag (i `rem`  j) ;    (CTcflag i) `div`     (CTcflag j) = CTcflag (i `div`  j) ;    (CTcflag i) `mod`     (CTcflag j) = CTcflag (i `mod`  j) ;    (CTcflag i) `quotRem` (CTcflag j) = let (q,r) = i `quotRem` j in (CTcflag q, CTcflag r) ;    (CTcflag i) `divMod`  (CTcflag j) = let (d,m) = i `divMod`  j in (CTcflag d, CTcflag m) ;    toInteger (CTcflag i)       = toInteger i } ; instance Bits CTcflag where {   (CTcflag x) .&.     (CTcflag y)   = CTcflag (x .&.   y) ;   (CTcflag x) .|.     (CTcflag y)   = CTcflag (x .|.   y) ;   (CTcflag x) `xor`   (CTcflag y)   = CTcflag (x `xor` y) ;   complement    (CTcflag x)   = CTcflag (complement x) ;   shift         (CTcflag x) n = CTcflag (shift x n) ;   rotate        (CTcflag x) n = CTcflag (rotate x n) ;   bit                 n = CTcflag (bit n) ;   setBit        (CTcflag x) n = CTcflag (setBit x n) ;   clearBit      (CTcflag x) n = CTcflag (clearBit x n) ;   complementBit (CTcflag x) n = CTcflag (complementBit x n) ;   testBit       (CTcflag x) n = testBit x n ;   bitSize       (CTcflag x)   = bitSize x ;   isSigned      (CTcflag x)   = isSigned x }


newtype CRLim = CRLim Word64 deriving (Eq, Ord) ; instance Num CRLim where {    (CRLim i) + (CRLim j) = CRLim (i + j) ;    (CRLim i) - (CRLim j) = CRLim (i - j) ;    (CRLim i) * (CRLim j) = CRLim (i * j) ;    negate  (CRLim i) = CRLim (negate i) ;    abs     (CRLim i) = CRLim (abs    i) ;    signum  (CRLim i) = CRLim (signum i) ;    fromInteger x = CRLim (fromInteger x) } ; instance Real CRLim where {    toRational (CRLim i) = toRational i } ; instance Read CRLim where {    readsPrec p s = map (\(x, t) -> (CRLim x, t)) (readsPrec p s) } ; instance Show CRLim where {    showsPrec p (CRLim x) = showsPrec p x } ; instance Enum CRLim where {    succ           (CRLim i)             = CRLim (succ i) ;    pred           (CRLim i)             = CRLim (pred i) ;    toEnum               x           = CRLim (toEnum x) ;    fromEnum       (CRLim i)             = fromEnum i ;    enumFrom       (CRLim i)             = map CRLim (enumFrom i) ;    enumFromThen   (CRLim i) (CRLim j)       = map CRLim (enumFromThen i j) ;    enumFromTo     (CRLim i) (CRLim j)       = map CRLim (enumFromTo i j) ;    enumFromThenTo (CRLim i) (CRLim j) (CRLim k) = map CRLim (enumFromThenTo i j k) } ; instance Storable CRLim where {    sizeOf    (CRLim x)       = sizeOf x ;    alignment (CRLim x)       = alignment x ;    peekElemOff a i       = liftM CRLim (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CRLim x) = pokeElemOff (castPtr a) i x } ; tyConCRlim = mkTyCon "CRLim"; instance Typeable CRLim where { typeOf _ = mkTyConApp tyConCRlim [] } ; ; instance Bounded CRLim where {    minBound = CRLim minBound ;    maxBound = CRLim maxBound } ; instance Integral CRLim where {    (CRLim i) `quot`    (CRLim j) = CRLim (i `quot` j) ;    (CRLim i) `rem`     (CRLim j) = CRLim (i `rem`  j) ;    (CRLim i) `div`     (CRLim j) = CRLim (i `div`  j) ;    (CRLim i) `mod`     (CRLim j) = CRLim (i `mod`  j) ;    (CRLim i) `quotRem` (CRLim j) = let (q,r) = i `quotRem` j in (CRLim q, CRLim r) ;    (CRLim i) `divMod`  (CRLim j) = let (d,m) = i `divMod`  j in (CRLim d, CRLim m) ;    toInteger (CRLim i)       = toInteger i } ; instance Bits CRLim where {   (CRLim x) .&.     (CRLim y)   = CRLim (x .&.   y) ;   (CRLim x) .|.     (CRLim y)   = CRLim (x .|.   y) ;   (CRLim x) `xor`   (CRLim y)   = CRLim (x `xor` y) ;   complement    (CRLim x)   = CRLim (complement x) ;   shift         (CRLim x) n = CRLim (shift x n) ;   rotate        (CRLim x) n = CRLim (rotate x n) ;   bit                 n = CRLim (bit n) ;   setBit        (CRLim x) n = CRLim (setBit x n) ;   clearBit      (CRLim x) n = CRLim (clearBit x n) ;   complementBit (CRLim x) n = CRLim (complementBit x n) ;   testBit       (CRLim x) n = testBit x n ;   bitSize       (CRLim x)   = bitSize x ;   isSigned      (CRLim x)   = isSigned x }


-- ToDo: blksize_t, clockid_t, blkcnt_t, fsblkcnt_t, fsfilcnt_t, id_t, key_t
-- suseconds_t, timer_t, useconds_t

-- Make an Fd type rather than using CInt everywhere
newtype Fd = Fd CInt deriving (Eq, Ord) ; instance Num Fd where {    (Fd i) + (Fd j) = Fd (i + j) ;    (Fd i) - (Fd j) = Fd (i - j) ;    (Fd i) * (Fd j) = Fd (i * j) ;    negate  (Fd i) = Fd (negate i) ;    abs     (Fd i) = Fd (abs    i) ;    signum  (Fd i) = Fd (signum i) ;    fromInteger x = Fd (fromInteger x) } ; instance Real Fd where {    toRational (Fd i) = toRational i } ; instance Read Fd where {    readsPrec p s = map (\(x, t) -> (Fd x, t)) (readsPrec p s) } ; instance Show Fd where {    showsPrec p (Fd x) = showsPrec p x } ; instance Enum Fd where {    succ           (Fd i)             = Fd (succ i) ;    pred           (Fd i)             = Fd (pred i) ;    toEnum               x           = Fd (toEnum x) ;    fromEnum       (Fd i)             = fromEnum i ;    enumFrom       (Fd i)             = map Fd (enumFrom i) ;    enumFromThen   (Fd i) (Fd j)       = map Fd (enumFromThen i j) ;    enumFromTo     (Fd i) (Fd j)       = map Fd (enumFromTo i j) ;    enumFromThenTo (Fd i) (Fd j) (Fd k) = map Fd (enumFromThenTo i j k) } ; instance Storable Fd where {    sizeOf    (Fd x)       = sizeOf x ;    alignment (Fd x)       = alignment x ;    peekElemOff a i       = liftM Fd (peekElemOff (castPtr a) i) ;    pokeElemOff a i (Fd x) = pokeElemOff (castPtr a) i x } ; tyConFd = mkTyCon "Fd"; instance Typeable Fd where { typeOf _ = mkTyConApp tyConFd [] } ; ; instance Bounded Fd where {    minBound = Fd minBound ;    maxBound = Fd maxBound } ; instance Integral Fd where {    (Fd i) `quot`    (Fd j) = Fd (i `quot` j) ;    (Fd i) `rem`     (Fd j) = Fd (i `rem`  j) ;    (Fd i) `div`     (Fd j) = Fd (i `div`  j) ;    (Fd i) `mod`     (Fd j) = Fd (i `mod`  j) ;    (Fd i) `quotRem` (Fd j) = let (q,r) = i `quotRem` j in (Fd q, Fd r) ;    (Fd i) `divMod`  (Fd j) = let (d,m) = i `divMod`  j in (Fd d, Fd m) ;    toInteger (Fd i)       = toInteger i } ; instance Bits Fd where {   (Fd x) .&.     (Fd y)   = Fd (x .&.   y) ;   (Fd x) .|.     (Fd y)   = Fd (x .|.   y) ;   (Fd x) `xor`   (Fd y)   = Fd (x `xor` y) ;   complement    (Fd x)   = Fd (complement x) ;   shift         (Fd x) n = Fd (shift x n) ;   rotate        (Fd x) n = Fd (rotate x n) ;   bit                 n = Fd (bit n) ;   setBit        (Fd x) n = Fd (setBit x n) ;   clearBit      (Fd x) n = Fd (clearBit x n) ;   complementBit (Fd x) n = Fd (complementBit x n) ;   testBit       (Fd x) n = testBit x n ;   bitSize       (Fd x)   = bitSize x ;   isSigned      (Fd x)   = isSigned x }

-- nicer names, and backwards compatibility with POSIX library:

type LinkCount      = CNlink


type UserID         = CUid


type GroupID        = CGid


type ByteCount      = CSize
type ClockTick      = CClock
type EpochTime      = CTime
type DeviceID       = CDev
type FileID         = CIno
type FileMode       = CMode
type ProcessID      = CPid
type FileOffset     = COff
type ProcessGroupID = CPid
type Limit	    = CLong

/* Machine generated file, do not modify */
#include <stdlib.h>
#include "HsFFI.h"
#include "HsBase.h"

static HugsAPI5 *hugs = 0;

#ifndef ENABLE_MACRO_INTERFACE
#undef my_execvpe
#endif

static void hugsprim_my_execvpe_1(HugsStackPtr);
static void hugsprim_my_execvpe_1(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsPtr arg2;
    HsPtr arg3;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getPtr();
    arg3 = hugs->getPtr();
    res1 = my_execvpe(arg1, arg2, arg3);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef pPrPr_disableITimers
#endif

static void hugsprim_pPrPr_disableITimers_0(HugsStackPtr);
static void hugsprim_pPrPr_disableITimers_0(HugsStackPtr hugs_root)
{
    pPrPr_disableITimers();
    
    hugs->returnIO(hugs_root,0);
}

static struct hugs_primitive hugs_primTable[] = {
    {"c_execvpe", 4, hugsprim_my_execvpe_1},
    {"pPrPr_disableITimers", 1, hugsprim_pPrPr_disableITimers_0},
};

static void hugs_primControl(int);
static void hugs_primControl(what)
int what; {
}

#ifdef STATIC_LINKAGE
#define initModule initSPInternals
#endif

static struct hugs_primInfo hugs_prims = { hugs_primControl, hugs_primTable, 0 };

#ifdef __cplusplus
extern "C" {
#endif
#ifndef __cplusplus
DLLEXPORT(int)  HugsAPIVersion(void);
#endif
DLLEXPORT(int)  HugsAPIVersion() {return (5);}
DLLEXPORT(void) initModule(HugsAPI5 *);
DLLEXPORT(void) initModule(HugsAPI5 *hugsAPI) {
    hugs = hugsAPI;
    hugs->registerPrims(&hugs_prims);
}
#ifdef __cplusplus
}
#endif

{-# OPTIONS_GHC -cpp -fffi #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  System.Process.Internals
-- Copyright   :  (c) The University of Glasgow 2004
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- Operations for creating and interacting with sub-processes.
--
-----------------------------------------------------------------------------

-- #hide
module System.Process.Internals (






	 pPrPr_disableITimers, c_execvpe,



	ignoreSignal, defaultSignal,








	withFilePathException, withCEnvironment
  ) where

import Prelude -- necessary to get dependencies right


import System.Posix.Types ( CPid )
import System.IO 	( Handle )





import System.Exit	( ExitCode )
import Data.Maybe	( fromMaybe )




import Hugs.Exception	( Exception(..), IOException(..) )


import Control.Concurrent
import Control.Exception ( handle, throwIO )
import Foreign.C
import Foreign












{-# CFILES cbits/execvpe.c  #-}


                                                                              
                                                                             

                         


                          


                              


                                 


                        


                                


                          


                            


                         


                           


                           


                         


                          


                         


                                


                                


                              


                           


                                


                          


                        


                          


                          


                          


                         


                          


                             


                                


                         


                          


                               


                         


                          


                       


                           


                          


                         


                          


                          


                            


                             


                                


                            


                             


                               


                          


                           


                            


                           


                          


                          


                           


                          


                           


                          


                          


                          


                               


                          


                         


                          


                          


                           


                            


                           


                             


                            


                          


                         


                              


                         


                                


                         


                            


                                


                                 


                                


                          


                                   


                              


                          


                           


                           


                         


                                


                            


                             


                                   


                          


                         


                          


                          


                         


                             


                                


                           


                          


                               


                         


                            


                           


                           


                          


                           


                           


                          


                          


                          


                          


                           


                           


                           


                           


                           


                           


                           


                          


                           


                           


                           


                           


                           


                          


                           


                           


                             


                           


                           


                             


                           


                           


                           


                               


                               


                                                        


                                                                                     


                                                                                    
                             

                                                         


                                                        


                                                        


                                                  


                                                   


                                                       


                                                      
                          

                                                       


                                                          


                                                      


                                                           


                                                      


                                                         


                                                         


                                                         


                                                   


                                                         


                                                       


                                                       


                                                         


                                                         


                                                         


                                                          


                                                         


                                                          


                                                               


                                                             


                                                           


                                                              


                                                            


                                                             
                              

                                                            


                                                           


                                                            


                                                              


                                                           


                                                          


                                                   


                                                       


                                                                                                         


                                                                                         
                        

                                                         


                                                        


                                                   


                                                        
                         

                                                         


                                                          
                           

                                                          
                           

                                  


                                   


                                                     
                         

                                     


                                     


                                        


                                      


                                       


                                      


                                      


                                      


                                    


                                         


                                         


                                     


                                          


                                       


                                        


                                      


                                      


                                          


                                       


                                      


                                            


                                             


                                       


                                        


                                        


                                         


                                       


                                      


                                          


                                          


                                              


                                             


                                              


                                                   


                                               


                                        


                                       
                         

                                                                              


                                              


                                                          


                                                          


                                               


                                            


                                           


                                                      


                                                                           


                                                            
                           

                                                   




                                                                       
                              

                                                 
                         

                                                            
                  

                                                       
                  

                                                
                  







































































-- ----------------------------------------------------------------------------



-- this function disables the itimer, which would otherwise cause confusing
-- signals to be sent to the new process.
foreign import ccall unsafe "pPrPr_disableITimers"
  pPrPr_disableITimers :: IO ()

foreign import ccall unsafe "my_execvpe"
  c_execvpe :: CString -> Ptr CString -> Ptr CString -> IO CInt
































































ignoreSignal  = 1 :: CLong
defaultSignal = 0 :: CLong
























































































































































































-- ----------------------------------------------------------------------------
-- Utils

withFilePathException :: FilePath -> IO a -> IO a
withFilePathException fpath act = handle mapEx act
  where
    mapEx (IOException (IOError h iot fun str _)) = ioError (IOError h iot fun str (Just fpath))
    mapEx e                                       = throwIO e


withCEnvironment :: [(String,String)] -> (Ptr CString  -> IO a) -> IO a
withCEnvironment env act =
  let env' = map (\(name, val) -> name ++ ('=':val)) env 
  in withMany withCString env' (\pEnv -> withArray0 nullPtr pEnv act)







 asm    dylinkÄ¿'` ` ` ````  ` |Òenv
memoryBase env	tableBase envabort  env___errno_location env_execve env_free  env_getenv env_malloc env_memcpy env
_setitimer env_sleep env_strchr env_strdup env_strlen envmemory Äenvtablep 
    A A ∫	_HugsAPIVersion __post_instantiate _hugs_primControl _hugsprim_my_execvpe_1  _hugsprim_pPrPr_disableITimers_0 _initModule _my_execvpe _pPrPr_disableITimers runPostSets 	
 #
æ	
 A # A‡Ä¿j  6 #   (∞   ^ # A‡Ä¿j( (D # A‡Ä¿j( (D # A‡Ä¿j( (D # A‡Ä¿j( (x    A# A‡Ä¿j( (†    A # A‡Ä¿j( († ÿ  A/	A !  !	A !A !A !A !A# A√ j"@ 
"E@AA"@ A::   A : A Aj  j" ! !A !A ! ! !
AA ! !A!@@@ AF@ 
E@! @ A6  ! ! ( @ ! !A6  ! ! 
A:	" A :   AjA ! 
,   
! 
A!# A» j!  !	     j"A/:   Aj   	  Aj 	jjA :   ! !	 ! ! !A! AF@@@ AH@ !@ 	  @@@@@@( Ak  ! 	! ! ! ! !
A! ! ! Aj" AH  !@ 	  @@@@@@( Ak  ! 	! ! ! ! !
A! ! !   ! 	! !A! ! !
A! (  !A !@ Aj! Aj"(   AtA "Aj" Aj Aj  # A  j6   	6# AÕ j    !  ! ! AF@  ! @ ! !A! E@A AL#!#Aj$ " A 6   A 6  A 6  A 6A   A A  A A  A  $P # #Aj6 # # (# Ajj6# # (# A$jj6# #Aj6# # (# A.jj6# #Aj6  # A‡ j$#AÄÄ¿j$ A  D        Z # T                                  c_execvpe pPrPr_disableITimers PATH . sh /bin/sh-----------------------------------------------------------------------------
-- |
-- Module      :  Text.PrettyPrint
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  portable
--
-- Re-export of "Text.PrettyPrint.HughesPJ" to provide a default
-- pretty-printing library.  Marked experimental at the moment; the 
-- default library might change at a later date.
--
-----------------------------------------------------------------------------

module Text.PrettyPrint ( 
 	module Text.PrettyPrint.HughesPJ
 ) where

import Prelude
import Text.PrettyPrint.HughesPJ
-----------------------------------------------------------------------------
-- |
-- Module      :  Text.Printf
-- Copyright   :  (c) Lennart Augustsson, 2004
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  lennart@augustsson.net
-- Stability   :  provisional
-- Portability :  portable
--
-- A C printf like formatter.
--
-----------------------------------------------------------------------------

module Text.Printf(
   printf, hPrintf,
   PrintfType, HPrintfType, PrintfArg, IsChar
) where

import Prelude
import Data.Array
import Data.Char
import Numeric(showEFloat, showFFloat, showGFloat)
import System.IO

-------------------

-- | Format a variable number of arguments with the C-style formatting string.
-- The return value is either 'String' or @('IO' a)@.
--
-- The format string consists of ordinary characters and /conversion
-- specifications/, which specify how to format one of the arguments
-- to printf in the output string.  A conversion specification begins with the
-- character @%@, followed by one or more of the following flags:
--
-- >    -      left adjust (default is right adjust)
-- >    0      pad with zeroes rather than spaces
--
-- followed optionally by a field width:
-- 
-- >    num    field width
-- >    *      as num, but taken from argument list
--
-- followed optionally by a precision:
--
-- >    .num   precision (number of decimal places)
--
-- and finally, a format character:
--
-- >    c      character               Char, Int, Integer
-- >    d      decimal                 Char, Int, Integer
-- >    o      octal                   Char, Int, Integer
-- >    x      hexadecimal             Char, Int, Integer
-- >    u      unsigned decimal        Char, Int, Integer
-- >    f      floating point          Float, Double
-- >    g      general format float    Float, Double
-- >    e      exponent format float   Float, Double
-- >    s      string                  String
--
-- Mismatch between the argument types and the format string will cause
-- an exception to be thrown at runtime.
--
-- Examples:
--
-- >   > printf "%d\n" (23::Int)
-- >   23
-- >   > printf "%s %s\n" "Hello" "World"
-- >   Hello World
-- >   > printf "%.2f\n" pi
-- >   3.14
--
printf :: (PrintfType r) => String -> r
printf fmt = spr fmt []

-- | Similar to 'printf', except that output is via the specified
-- 'Handle'.  The return type is restricted to @('IO' a)@.
hPrintf :: (HPrintfType r) => Handle -> String -> r
hPrintf hdl fmt = hspr hdl fmt []

-- |The 'PrintfType' class provides the variable argument magic for
-- 'printf'.  Its implementation is intentionally not visible from
-- this module. If you attempt to pass an argument of a type which
-- is not an instance of this class to 'printf' or 'hPrintf', then
-- the compiler will report it as a missing instance of 'PrintfArg'.
class PrintfType t where
    spr :: String -> [UPrintf] -> t

-- | The 'HPrintfType' class provides the variable argument magic for
-- 'hPrintf'.  Its implementation is intentionally not visible from
-- this module.
class HPrintfType t where
    hspr :: Handle -> String -> [UPrintf] -> t

{- not allowed in Haskell 98
instance PrintfType String where
    spr fmt args = uprintf fmt (reverse args)
-}
instance (IsChar c) => PrintfType [c] where
    spr fmt args = map fromChar (uprintf fmt (reverse args))

instance PrintfType (IO a) where
    spr fmt args = do
	putStr (uprintf fmt (reverse args))
	return undefined

instance HPrintfType (IO a) where
    hspr hdl fmt args = do
	hPutStr hdl (uprintf fmt (reverse args))
	return undefined

instance (PrintfArg a, PrintfType r) => PrintfType (a -> r) where
    spr fmt args = \ a -> spr fmt (toUPrintf a : args)

instance (PrintfArg a, HPrintfType r) => HPrintfType (a -> r) where
    hspr hdl fmt args = \ a -> hspr hdl fmt (toUPrintf a : args)

class PrintfArg a where
    toUPrintf :: a -> UPrintf

instance PrintfArg Char where
    toUPrintf c = UChar c

{- not allowed in Haskell 98
instance PrintfArg String where
    toUPrintf s = UString s
-}
instance (IsChar c) => PrintfArg [c] where
    toUPrintf s = UString (map toChar s)

instance PrintfArg Int where
    toUPrintf i = UInt i

instance PrintfArg Integer where
    toUPrintf i = UInteger i

instance PrintfArg Float where
    toUPrintf f = UFloat f

instance PrintfArg Double where
    toUPrintf d = UDouble d

class IsChar c where
    toChar :: c -> Char
    fromChar :: Char -> c

instance IsChar Char where
    toChar c = c
    fromChar c = c

-------------------

data UPrintf = UChar Char | UString String | UInt Int | UInteger Integer | UFloat Float | UDouble Double

uprintf :: String -> [UPrintf] -> String
uprintf ""       []       = ""
uprintf ""       (_:_)    = fmterr
uprintf ('%':'%':cs) us   = '%':uprintf cs us
uprintf ('%':_)  []       = argerr
uprintf ('%':cs) us@(_:_) = fmt cs us
uprintf (c:cs)   us       = c:uprintf cs us

fmt :: String -> [UPrintf] -> String
fmt cs us =
	let (width, prec, ladj, zero, cs', us') = getSpecs False False cs us
	    adjust (pre, str) = 
		let lstr = length str
		    lpre = length pre
		    fill = if lstr+lpre < width then take (width-(lstr+lpre)) (repeat (if zero then '0' else ' ')) else ""
		in  if ladj then pre ++ str ++ fill else if zero then pre ++ fill ++ str else fill ++ pre ++ str
        in
	case cs' of
	[]     -> fmterr
	c:cs'' ->
	    case us' of
	    []     -> argerr
	    u:us'' ->
		(case c of
		'c' -> adjust ("", [toEnum (toint u)])
		'd' -> adjust (fmti u)
		'x' -> adjust ("", fmtu 16 u)
		'o' -> adjust ("", fmtu 8  u)
		'u' -> adjust ("", fmtu 10 u)
		'e' -> adjust (dfmt' c prec u)
		'f' -> adjust (dfmt' c prec u)
		'g' -> adjust (dfmt' c prec u)
		's' -> adjust ("", tostr u)
		c   -> perror ("bad formatting char " ++ [c])
		 ) ++ uprintf cs'' us''

fmti (UInt i)     = if i < 0 then
			if i == -i then fmti (UInteger (toInteger i)) else ("-", itos (-i))
		    else
			("", itos i)
fmti (UInteger i) = if i < 0 then ("-", itos (-i)) else ("", itos i)
fmti (UChar c)    = fmti (UInt (fromEnum c))
fmti u		  = baderr

fmtu b (UInt i)     = if i < 0 then
			  if i == -i then itosb b (maxi - toInteger (i+1) - 1) else itosb b (maxi - toInteger (-i))
		      else
			  itosb b (toInteger i)
fmtu b (UInteger i) = itosb b i
fmtu b (UChar c)    = itosb b (toInteger (fromEnum c))
fmtu b u            = baderr

maxi :: Integer
maxi = (toInteger (maxBound::Int) + 1) * 2

toint (UInt i)     = i
toint (UInteger i) = toInt i
toint (UChar c)    = fromEnum c
toint u		   = baderr

tostr (UString s) = s
tostr u		  = baderr

itos n = 
	if n < 10 then 
	    [toEnum (fromEnum '0' + toInt n)]
	else
	    let (q, r) = quotRem n 10 in
	    itos q ++ [toEnum (fromEnum '0' + toInt r)]

chars = array (0,15) (zipWith (,) [0..] "0123456789abcdef")
itosb :: Integer -> Integer -> String
itosb b n = 
	if n < b then 
	    [chars!n]
	else
	    let (q, r) = quotRem n b in
	    itosb b q ++ [chars!r]

stoi :: Int -> String -> (Int, String)
stoi a (c:cs) | isDigit c = stoi (a*10 + fromEnum c - fromEnum '0') cs
stoi a cs                 = (a, cs)

getSpecs :: Bool -> Bool -> String -> [UPrintf] -> (Int, Int, Bool, Bool, String, [UPrintf])
getSpecs l z ('-':cs) us = getSpecs True z cs us
getSpecs l z ('0':cs) us = getSpecs l True cs us
getSpecs l z ('*':cs) us = 
        case us of
        [] -> argerr
        nu : us' ->
	    let n = toint nu
		(p, cs'', us'') =
		    case cs of
                    '.':'*':r -> case us' of { [] -> argerr; pu:us'' -> (toint pu, r, us'') }
		    '.':r     -> let (n, cs') = stoi 0 r in (n, cs', us')
		    _         -> (-1, cs, us')
	    in  (n, p, l, z, cs'', us'')
getSpecs l z ('.':cs) us =
	let (p, cs') = stoi 0 cs
	in  (0, p, l, z, cs', us)
getSpecs l z cs@(c:_) us | isDigit c =
	let (n, cs') = stoi 0 cs
	    (p, cs'') = case cs' of
			'.':r -> stoi 0 r
			_     -> (-1, cs')
	in  (n, p, l, z, cs'', us)
getSpecs l z cs       us = (0, -1, l, z, cs, us)

dfmt' c p (UDouble d) = dfmt c p d
dfmt' c p (UFloat f)  = dfmt c p f
dfmt' c p u           = baderr

dfmt c p d = 
	case (case c of 'e' -> showEFloat; 'f' -> showFFloat; 'g' -> showGFloat) 
               (if p < 0 then Nothing else Just p) d "" of
	'-':cs -> ("-", cs)
	cs     -> ("" , cs)

perror s = error ("Printf.printf: "++s)
fmterr = perror "formatting string ended prematurely"
argerr = perror "argument list ended prematurely"
baderr = perror "bad argument"

toInt :: (Integral a) => a -> Int
toInt x = fromInteger (toInteger x)
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Text.Read
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  non-portable (uses Text.ParserCombinators.ReadP)
--
-- Converting strings to values.
--
-- The "Text.Read" library is the canonical library to import for
-- 'Read'-class facilities.  For GHC only, it offers an extended and much
-- improved 'Read' class, which constitutes a proposed alternative to the 
-- Haskell 98 'Read'.  In particular, writing parsers is easier, and
-- the parsers are much more efficient.
--
-----------------------------------------------------------------------------

module Text.Read (
   -- * The 'Read' class
   Read(..),		-- The Read class
   ReadS, 		-- String -> Maybe (a,String)

   -- * Haskell 98 functions
   reads,		-- :: (Read a) => ReadS a
   read,		-- :: (Read a) => String -> a
   readParen, 		-- :: Bool -> ReadS a -> ReadS a
   lex,			-- :: ReadS String


   -- * New parsing functions
   module Text.ParserCombinators.ReadPrec,
   L.Lexeme(..),	
   lexP,		-- :: ReadPrec Lexeme
   parens,		-- :: ReadPrec a -> ReadPrec a






 ) where





import Text.ParserCombinators.ReadPrec
import qualified Text.Read.Lex as L



-- copied from GHC.Read

lexP :: ReadPrec L.Lexeme
lexP = lift L.lex

parens :: ReadPrec a -> ReadPrec a
parens p = optional
 where
  optional  = p +++ mandatory
  mandatory = do
    L.Punc "(" <- lexP
    x          <- reset optional
    L.Punc ")" <- lexP
    return x

{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Text.Show
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Converting values to readable strings:
-- the 'Show' class and associated functions.
--
-----------------------------------------------------------------------------

module Text.Show (
   ShowS,	 	-- String -> String
   Show(
      showsPrec,	-- :: Int -> a -> ShowS
      show,		-- :: a   -> String
      showList		-- :: [a] -> ShowS 
    ),
   shows,		-- :: (Show a) => a -> ShowS
   showChar,		-- :: Char -> ShowS
   showString,		-- :: String -> ShowS
   showParen,		-- :: Bool -> ShowS -> ShowS
   showListWith,	-- :: (a -> ShowS) -> [a] -> ShowS 
 ) where





-- | Show a list (using square brackets and commas), given a function
-- for showing elements.
showListWith :: (a -> ShowS) -> [a] -> ShowS 
showListWith = showList__


showList__ :: (a -> ShowS) ->  [a] -> ShowS
showList__ _     []     s = "[]" ++ s
showList__ showx (x:xs) s = '[' : showx x (showl xs)
  where
    showl []     = ']' : s
    showl (y:ys) = ',' : showx y (showl ys)

{-# OPTIONS_GHC -fglasgow-exts -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Text.ParserCombinators.ReadP
-- Copyright   :  (c) The University of Glasgow 2002
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  non-portable (local universal quantification)
--
-- This is a library of parser combinators, originally written by Koen Claessen.
-- It parses all alternatives in parallel, so it never keeps hold of 
-- the beginning of the input string, a common source of space leaks with
-- other parsers.  The '(+++)' choice combinator is genuinely commutative;
-- it makes no difference which branch is \"shorter\".

-----------------------------------------------------------------------------

module Text.ParserCombinators.ReadP
  ( 
  -- * The 'ReadP' type

  ReadP,      -- :: * -> *; instance Functor, Monad, MonadPlus



  
  -- * Primitive operations
  get,        -- :: ReadP Char
  look,       -- :: ReadP String
  (+++),      -- :: ReadP a -> ReadP a -> ReadP a
  (<++),      -- :: ReadP a -> ReadP a -> ReadP a
  gather,     -- :: ReadP a -> ReadP (String, a)
  
  -- * Other operations
  pfail,      -- :: ReadP a
  satisfy,    -- :: (Char -> Bool) -> ReadP Char
  char,       -- :: Char -> ReadP Char
  string,     -- :: String -> ReadP String
  munch,      -- :: (Char -> Bool) -> ReadP String
  munch1,     -- :: (Char -> Bool) -> ReadP String
  skipSpaces, -- :: ReadP ()
  choice,     -- :: [ReadP a] -> ReadP a
  count,      -- :: Int -> ReadP a -> ReadP [a]
  between,    -- :: ReadP open -> ReadP close -> ReadP a -> ReadP a
  option,     -- :: a -> ReadP a -> ReadP a
  optional,   -- :: ReadP a -> ReadP ()
  many,       -- :: ReadP a -> ReadP [a]
  many1,      -- :: ReadP a -> ReadP [a]
  skipMany,   -- :: ReadP a -> ReadP ()
  skipMany1,  -- :: ReadP a -> ReadP ()
  sepBy,      -- :: ReadP a -> ReadP sep -> ReadP [a]
  sepBy1,     -- :: ReadP a -> ReadP sep -> ReadP [a]
  endBy,      -- :: ReadP a -> ReadP sep -> ReadP [a]
  endBy1,     -- :: ReadP a -> ReadP sep -> ReadP [a]
  chainr,     -- :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
  chainl,     -- :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
  chainl1,    -- :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
  chainr1,    -- :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
  manyTill,   -- :: ReadP a -> ReadP end -> ReadP [a]
  
  -- * Running a parser
  ReadS,      -- :: *; = String -> [(a,String)]
  readP_to_S, -- :: ReadP a -> ReadS a
  readS_to_P, -- :: ReadS a -> ReadP a
  
  -- * Properties
  -- $properties
  )
 where

import Control.Monad( MonadPlus(..), sequence, liftM2 )








import Data.Char( isSpace )


infixr 5 +++, <++













-- ---------------------------------------------------------------------------
-- The P type
-- is representation type -- should be kept abstract

data P a
  = Get (Char -> P a)
  | Look (String -> P a)
  | Fail
  | Result a (P a)
  | Final [(a,String)] -- invariant: list is non-empty!

-- Monad, MonadPlus

instance Monad P where
  return x = Result x Fail

  (Get f)      >>= k = Get (\c -> f c >>= k)
  (Look f)     >>= k = Look (\s -> f s >>= k)
  Fail         >>= k = Fail
  (Result x p) >>= k = k x `mplus` (p >>= k)
  (Final r)    >>= k = final [ys' | (x,s) <- r, ys' <- run (k x) s]

  fail _ = Fail

instance MonadPlus P where
  mzero = Fail

  -- most common case: two gets are combined
  Get f1     `mplus` Get f2     = Get (\c -> f1 c `mplus` f2 c)
  
  -- results are delivered as soon as possible
  Result x p `mplus` q          = Result x (p `mplus` q)
  p          `mplus` Result x q = Result x (p `mplus` q)

  -- fail disappears
  Fail       `mplus` p          = p
  p          `mplus` Fail       = p

  -- two finals are combined
  -- final + look becomes one look and one final (=optimization)
  -- final + sthg else becomes one look and one final
  Final r    `mplus` Final t    = Final (r ++ t)
  Final r    `mplus` Look f     = Look (\s -> Final (r ++ run (f s) s))
  Final r    `mplus` p          = Look (\s -> Final (r ++ run p s))
  Look f     `mplus` Final r    = Look (\s -> Final (run (f s) s ++ r))
  p          `mplus` Final r    = Look (\s -> Final (run p s ++ r))

  -- two looks are combined (=optimization)
  -- look + sthg else floats upwards
  Look f     `mplus` Look g     = Look (\s -> f s `mplus` g s)
  Look f     `mplus` p          = Look (\s -> f s `mplus` p)
  p          `mplus` Look f     = Look (\s -> p `mplus` f s)

-- ---------------------------------------------------------------------------
-- The ReadP type


newtype ReadP a = R (forall b . (a -> P b) -> P b)





-- Functor, Monad, MonadPlus

instance Functor ReadP where
  fmap h (R f) = R (\k -> f (k . h))

instance Monad ReadP where
  return x  = R (\k -> k x)
  fail _    = R (\_ -> Fail)
  R m >>= f = R (\k -> m (\a -> let R m' = f a in m' k))

instance MonadPlus ReadP where
  mzero = pfail
  mplus = (+++)

-- ---------------------------------------------------------------------------
-- Operations over P

final :: [(a,String)] -> P a
-- Maintains invariant for Final constructor
final [] = Fail
final r  = Final r

run :: P a -> ReadS a
run (Get f)      (c:s) = run (f c) s
run (Look f)     s     = run (f s) s
run (Result x p) s     = (x,s) : run p s
run (Final r)    _     = r
run _            _     = []

-- ---------------------------------------------------------------------------
-- Operations over ReadP

get :: ReadP Char
-- ^ Consumes and returns the next character.
--   Fails if there is no input left.
get = R Get

look :: ReadP String
-- ^ Look-ahead: returns the part of the input that is left, without
--   consuming it.
look = R Look

pfail :: ReadP a
-- ^ Always fails.
pfail = R (\_ -> Fail)

(+++) :: ReadP a -> ReadP a -> ReadP a
-- ^ Symmetric choice.
R f1 +++ R f2 = R (\k -> f1 k `mplus` f2 k)


(<++) :: ReadP a -> ReadP a -> ReadP a



-- ^ Local, exclusive, left-biased choice: If left parser
--   locally produces any result at all, then right parser is
--   not used.














R f <++ q =
  do s <- look
     probe (f return) s 0
 where
  probe (Get f)        (c:s) n = probe (f c) s (n+1)
  probe (Look f)       s     n = probe (f s) s n
  probe p@(Result _ _) _     n = discard n >> R (p >>=)
  probe (Final r)      _     _ = R (Final r >>=)
  probe _              _     _ = q

  discard 0 = return ()
  discard n  = get >> discard (n-1)



gather :: ReadP a -> ReadP (String, a)



-- ^ Transforms a parser into one that does the same, but
--   in addition returns the exact characters read.
--   IMPORTANT NOTE: 'gather' gives a runtime error if its first argument
--   is built using any occurrences of readS_to_P. 
gather (R m) =
  R (\k -> gath id (m (\a -> return (\s -> k (s,a)))))  
 where
  gath l (Get f)      = Get (\c -> gath (l.(c:)) (f c))
  gath l Fail         = Fail
  gath l (Look f)     = Look (\s -> gath l (f s))
  gath l (Result k p) = k (l []) `mplus` gath l p
  gath l (Final r)    = error "do not use readS_to_P in gather!"

-- ---------------------------------------------------------------------------
-- Derived operations

satisfy :: (Char -> Bool) -> ReadP Char
-- ^ Consumes and returns the next character, if it satisfies the
--   specified predicate.
satisfy p = do c <- get; if p c then return c else pfail

char :: Char -> ReadP Char
-- ^ Parses and returns the specified character.
char c = satisfy (c ==)

string :: String -> ReadP String
-- ^ Parses and returns the specified string.
string this = do s <- look; scan this s
 where
  scan []     _               = do return this
  scan (x:xs) (y:ys) | x == y = do get; scan xs ys
  scan _      _               = do pfail

munch :: (Char -> Bool) -> ReadP String
-- ^ Parses the first zero or more characters satisfying the predicate.
munch p =
  do s <- look
     scan s
 where
  scan (c:cs) | p c = do get; s <- scan cs; return (c:s)
  scan _            = do return ""

munch1 :: (Char -> Bool) -> ReadP String
-- ^ Parses the first one or more characters satisfying the predicate.
munch1 p =
  do c <- get
     if p c then do s <- munch p; return (c:s) else pfail

choice :: [ReadP a] -> ReadP a
-- ^ Combines all parsers in the specified list.
choice []     = pfail
choice [p]    = p
choice (p:ps) = p +++ choice ps

skipSpaces :: ReadP ()
-- ^ Skips all whitespace.
skipSpaces =
  do s <- look
     skip s
 where
  skip (c:s) | isSpace c = do get; skip s
  skip _                 = do return ()

count :: Int -> ReadP a -> ReadP [a]
-- ^ @count n p@ parses @n@ occurrences of @p@ in sequence. A list of
--   results is returned.
count n p = sequence (replicate n p)

between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
-- ^ @between open close p@ parses @open@, followed by @p@ and finally
--   @close@. Only the value of @p@ is returned.
between open close p = do open
                          x <- p
                          close
                          return x

option :: a -> ReadP a -> ReadP a
-- ^ @option x p@ will either parse @p@ or return @x@ without consuming
--   any input.
option x p = p +++ return x

optional :: ReadP a -> ReadP ()
-- ^ @optional p@ optionally parses @p@ and always returns @()@.
optional p = (p >> return ()) +++ return ()

many :: ReadP a -> ReadP [a]
-- ^ Parses zero or more occurrences of the given parser.
many p = return [] +++ many1 p

many1 :: ReadP a -> ReadP [a]
-- ^ Parses one or more occurrences of the given parser.
many1 p = liftM2 (:) p (many p)

skipMany :: ReadP a -> ReadP ()
-- ^ Like 'many', but discards the result.
skipMany p = many p >> return ()

skipMany1 :: ReadP a -> ReadP ()
-- ^ Like 'many1', but discards the result.
skipMany1 p = p >> skipMany p

sepBy :: ReadP a -> ReadP sep -> ReadP [a]
-- ^ @sepBy p sep@ parses zero or more occurrences of @p@, separated by @sep@.
--   Returns a list of values returned by @p@.
sepBy p sep = sepBy1 p sep +++ return []

sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]
-- ^ @sepBy1 p sep@ parses one or more occurrences of @p@, separated by @sep@.
--   Returns a list of values returned by @p@.
sepBy1 p sep = liftM2 (:) p (many (sep >> p))

endBy :: ReadP a -> ReadP sep -> ReadP [a]
-- ^ @endBy p sep@ parses zero or more occurrences of @p@, separated and ended
--   by @sep@.
endBy p sep = many (do x <- p ; sep ; return x)

endBy1 :: ReadP a -> ReadP sep -> ReadP [a]
-- ^ @endBy p sep@ parses one or more occurrences of @p@, separated and ended
--   by @sep@.
endBy1 p sep = many1 (do x <- p ; sep ; return x)

chainr :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
-- ^ @chainr p op x@ parses zero or more occurrences of @p@, separated by @op@.
--   Returns a value produced by a /right/ associative application of all
--   functions returned by @op@. If there are no occurrences of @p@, @x@ is
--   returned.
chainr p op x = chainr1 p op +++ return x

chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
-- ^ @chainl p op x@ parses zero or more occurrences of @p@, separated by @op@.
--   Returns a value produced by a /left/ associative application of all
--   functions returned by @op@. If there are no occurrences of @p@, @x@ is
--   returned.
chainl p op x = chainl1 p op +++ return x

chainr1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
-- ^ Like 'chainr', but parses one or more occurrences of @p@.
chainr1 p op = scan
  where scan   = p >>= rest
        rest x = do f <- op
                    y <- scan
                    return (f x y)
                 +++ return x

chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
-- ^ Like 'chainl', but parses one or more occurrences of @p@.
chainl1 p op = p >>= rest
  where rest x = do f <- op
                    y <- p
                    rest (f x y)
                 +++ return x


manyTill :: ReadP a -> ReadP end -> ReadP [a]



-- ^ @manyTill p end@ parses zero or more occurrences of @p@, until @end@
--   succeeds. Returns a list of values returned by @p@.
manyTill p end = scan
  where scan = (end >> return []) <++ (liftM2 (:) p scan)

-- ---------------------------------------------------------------------------
-- Converting between ReadP and Read


readP_to_S :: ReadP a -> ReadS a



-- ^ Converts a parser into a Haskell ReadS-style function.
--   This is the main way in which you can \"run\" a 'ReadP' parser:
--   the expanded type is
-- @ readP_to_S :: ReadP a -> String -> [(a,String)] @
readP_to_S (R f) = run (f return)

readS_to_P :: ReadS a -> ReadP a
-- ^ Converts a Haskell ReadS-style function into a parser.
--   Warning: This introduces local backtracking in the resulting
--   parser, and therefore a possible inefficiency.
readS_to_P r =
  R (\k -> Look (\s -> final [bs'' | (a,s') <- r s, bs'' <- run (k a) s']))

-- ---------------------------------------------------------------------------
-- QuickCheck properties that hold for the combinators

{- $properties
The following are QuickCheck specifications of what the combinators do.
These can be seen as formal specifications of the behavior of the
combinators.

We use bags to give semantics to the combinators.

>  type Bag a = [a]

Equality on bags does not care about the order of elements.

>  (=~) :: Ord a => Bag a -> Bag a -> Bool
>  xs =~ ys = sort xs == sort ys

A special equality operator to avoid unresolved overloading
when testing the properties.

>  (=~.) :: Bag (Int,String) -> Bag (Int,String) -> Bool
>  (=~.) = (=~)

Here follow the properties:

>  prop_Get_Nil =
>    readP_to_S get [] =~ []
>
>  prop_Get_Cons c s =
>    readP_to_S get (c:s) =~ [(c,s)]
>
>  prop_Look s =
>    readP_to_S look s =~ [(s,s)]
>
>  prop_Fail s =
>    readP_to_S pfail s =~. []
>
>  prop_Return x s =
>    readP_to_S (return x) s =~. [(x,s)]
>
>  prop_Bind p k s =
>    readP_to_S (p >>= k) s =~.
>      [ ys''
>      | (x,s') <- readP_to_S p s
>      , ys''   <- readP_to_S (k (x::Int)) s'
>      ]
>
>  prop_Plus p q s =
>    readP_to_S (p +++ q) s =~.
>      (readP_to_S p s ++ readP_to_S q s)
>
>  prop_LeftPlus p q s =
>    readP_to_S (p <++ q) s =~.
>      (readP_to_S p s +<+ readP_to_S q s)
>   where
>    [] +<+ ys = ys
>    xs +<+ _  = xs
>
>  prop_Gather s =
>    forAll readPWithoutReadS $ \p -> 
>      readP_to_S (gather p) s =~
>	 [ ((pre,x::Int),s')
>	 | (x,s') <- readP_to_S p s
>	 , let pre = take (length s - length s') s
>	 ]
>
>  prop_String_Yes this s =
>    readP_to_S (string this) (this ++ s) =~
>      [(this,s)]
>
>  prop_String_Maybe this s =
>    readP_to_S (string this) s =~
>      [(this, drop (length this) s) | this `isPrefixOf` s]
>
>  prop_Munch p s =
>    readP_to_S (munch p) s =~
>      [(takeWhile p s, dropWhile p s)]
>
>  prop_Munch1 p s =
>    readP_to_S (munch1 p) s =~
>      [(res,s') | let (res,s') = (takeWhile p s, dropWhile p s), not (null res)]
>
>  prop_Choice ps s =
>    readP_to_S (choice ps) s =~.
>      readP_to_S (foldr (+++) pfail ps) s
>
>  prop_ReadS r s =
>    readP_to_S (readS_to_P r) s =~. r s
-}
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Text.ParserCombinators.ReadPrec
-- Copyright   :  (c) The University of Glasgow 2002
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  non-portable (uses Text.ParserCombinators.ReadP)
--
-- This library defines parser combinators for precedence parsing.

-----------------------------------------------------------------------------

module Text.ParserCombinators.ReadPrec
  ( 
  ReadPrec,      -- :: * -> *; instance Functor, Monad, MonadPlus
  
  -- * Precedences
  Prec,          -- :: *; = Int
  minPrec,       -- :: Prec; = 0

  -- * Precedence operations
  lift,          -- :: ReadP a -> ReadPrec a
  prec,          -- :: Prec -> ReadPrec a -> ReadPrec a
  step,          -- :: ReadPrec a -> ReadPrec a
  reset,         -- :: ReadPrec a -> ReadPrec a

  -- * Other operations
  -- | All are based directly on their similarly-named 'ReadP' counterparts.
  get,           -- :: ReadPrec Char
  look,          -- :: ReadPrec String
  (+++),         -- :: ReadPrec a -> ReadPrec a -> ReadPrec a
  (<++),         -- :: ReadPrec a -> ReadPrec a -> ReadPrec a
  pfail,         -- :: ReadPrec a
  choice,        -- :: [ReadPrec a] -> ReadPrec a

  -- * Converters
  readPrec_to_P, -- :: ReadPrec a       -> (Int -> ReadP a)
  readP_to_Prec, -- :: (Int -> ReadP a) -> ReadPrec a
  readPrec_to_S, -- :: ReadPrec a       -> (Int -> ReadS a)
  readS_to_Prec, -- :: (Int -> ReadS a) -> ReadPrec a
  )
 where


import Text.ParserCombinators.ReadP
  ( ReadP
  , ReadS
  , readP_to_S
  , readS_to_P
  )

import qualified Text.ParserCombinators.ReadP as ReadP
  ( get
  , look
  , (+++), (<++)
  , pfail
  )

import Control.Monad( MonadPlus(..) )





-- ---------------------------------------------------------------------------
-- The readPrec type

newtype ReadPrec a = P { unP :: Prec -> ReadP a }

-- Functor, Monad, MonadPlus

instance Functor ReadPrec where
  fmap h (P f) = P (\n -> fmap h (f n))

instance Monad ReadPrec where
  return x  = P (\_ -> return x)
  fail s    = P (\_ -> fail s)
  P f >>= k = P (\n -> do a <- f n; let P f' = k a in f' n)
  
instance MonadPlus ReadPrec where
  mzero = pfail
  mplus = (+++)

-- precedences
  
type Prec = Int

minPrec :: Prec
minPrec = 0

-- ---------------------------------------------------------------------------
-- Operations over ReadPrec

lift :: ReadP a -> ReadPrec a
-- ^ Lift a precedence-insensitive 'ReadP' to a 'ReadPrec'.
lift m = P (\_ -> m)

step :: ReadPrec a -> ReadPrec a
-- ^ Increases the precedence context by one.
step (P f) = P (\n -> f (n+1))

reset :: ReadPrec a -> ReadPrec a
-- ^ Resets the precedence context to zero.
reset (P f) = P (\n -> f minPrec)

prec :: Prec -> ReadPrec a -> ReadPrec a
-- ^ @(prec n p)@ checks whether the precedence context is 
--   less than or equal to @n@, and
--
--   * if not, fails
--
--   * if so, parses @p@ in context @n@.
prec n (P f) = P (\c -> if c <= n then f n else ReadP.pfail)

-- ---------------------------------------------------------------------------
-- Derived operations

get :: ReadPrec Char
-- ^ Consumes and returns the next character.
--   Fails if there is no input left.
get = lift ReadP.get

look :: ReadPrec String
-- ^ Look-ahead: returns the part of the input that is left, without
--   consuming it.
look = lift ReadP.look

(+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
-- ^ Symmetric choice.
P f1 +++ P f2 = P (\n -> f1 n ReadP.+++ f2 n)

(<++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
-- ^ Local, exclusive, left-biased choice: If left parser
--   locally produces any result at all, then right parser is
--   not used.
P f1 <++ P f2 = P (\n -> f1 n ReadP.<++ f2 n)

pfail :: ReadPrec a
-- ^ Always fails.
pfail = lift ReadP.pfail

choice :: [ReadPrec a] -> ReadPrec a
-- ^ Combines all parsers in the specified list.
choice ps = foldr (+++) pfail ps

-- ---------------------------------------------------------------------------
-- Converting between ReadPrec and Read

readPrec_to_P :: ReadPrec a -> (Int -> ReadP a)
readPrec_to_P (P f) = f

readP_to_Prec :: (Int -> ReadP a) -> ReadPrec a
readP_to_Prec f = P f

readPrec_to_S :: ReadPrec a -> (Int -> ReadS a)
readPrec_to_S (P f) n = readP_to_S (f n)

readS_to_Prec :: (Int -> ReadS a) -> ReadPrec a
readS_to_Prec f = P (\n -> readS_to_P (f n))
-----------------------------------------------------------------------------
-- |
-- Module      :  Text.PrettyPrint.HughesPJ
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- John Hughes's and Simon Peyton Jones's Pretty Printer Combinators
-- 
-- Based on /The Design of a Pretty-printing Library/
-- in Advanced Functional Programming,
-- Johan Jeuring and Erik Meijer (eds), LNCS 925
-- <http://www.cs.chalmers.se/~rjmh/Papers/pretty.ps>
--
-- Heavily modified by Simon Peyton Jones, Dec 96
--
-----------------------------------------------------------------------------

{-
Version 3.0     28 May 1997
  * Cured massive performance bug.  If you write

        foldl <> empty (map (text.show) [1..10000])

    you get quadratic behaviour with V2.0.  Why?  For just the same
    reason as you get quadratic behaviour with left-associated (++)
    chains.

    This is really bad news.  One thing a pretty-printer abstraction
    should certainly guarantee is insensivity to associativity.  It
    matters: suddenly GHC's compilation times went up by a factor of
    100 when I switched to the new pretty printer.

    I fixed it with a bit of a hack (because I wanted to get GHC back
    on the road).  I added two new constructors to the Doc type, Above
    and Beside:

         <> = Beside
         $$ = Above

    Then, where I need to get to a "TextBeside" or "NilAbove" form I
    "force" the Doc to squeeze out these suspended calls to Beside and
    Above; but in so doing I re-associate. It's quite simple, but I'm
    not satisfied that I've done the best possible job.  I'll send you
    the code if you are interested.

  * Added new exports:
        punctuate, hang
        int, integer, float, double, rational,
        lparen, rparen, lbrack, rbrack, lbrace, rbrace,

  * fullRender's type signature has changed.  Rather than producing a
    string it now takes an extra couple of arguments that tells it how
    to glue fragments of output together:

        fullRender :: Mode
                   -> Int                       -- Line length
                   -> Float                     -- Ribbons per line
                   -> (TextDetails -> a -> a)   -- What to do with text
                   -> a                         -- What to do at the end
                   -> Doc
                   -> a                         -- Result

    The "fragments" are encapsulated in the TextDetails data type:

        data TextDetails = Chr  Char
                         | Str  String
                         | PStr FAST_STRING

    The Chr and Str constructors are obvious enough.  The PStr
    constructor has a packed string (FAST_STRING) inside it.  It's
    generated by using the new "ptext" export.

    An advantage of this new setup is that you can get the renderer to
    do output directly (by passing in a function of type (TextDetails
    -> IO () -> IO ()), rather than producing a string that you then
    print.


Version 2.0     24 April 1997
  * Made empty into a left unit for <> as well as a right unit;
    it is also now true that
        nest k empty = empty
    which wasn't true before.

  * Fixed an obscure bug in sep that occassionally gave very weird behaviour

  * Added $+$

  * Corrected and tidied up the laws and invariants

======================================================================
Relative to John's original paper, there are the following new features:

1.  There's an empty document, "empty".  It's a left and right unit for 
    both <> and $$, and anywhere in the argument list for
    sep, hcat, hsep, vcat, fcat etc.

    It is Really Useful in practice.

2.  There is a paragraph-fill combinator, fsep, that's much like sep,
    only it keeps fitting things on one line until it can't fit any more.

3.  Some random useful extra combinators are provided.  
        <+> puts its arguments beside each other with a space between them,
            unless either argument is empty in which case it returns the other


        hcat is a list version of <>
        hsep is a list version of <+>
        vcat is a list version of $$

        sep (separate) is either like hsep or like vcat, depending on what fits

        cat  behaves like sep,  but it uses <> for horizontal conposition
        fcat behaves like fsep, but it uses <> for horizontal conposition

        These new ones do the obvious things:
                char, semi, comma, colon, space,
                parens, brackets, braces, 
                quotes, doubleQuotes

4.  The "above" combinator, $$, now overlaps its two arguments if the
    last line of the top argument stops before the first line of the
    second begins.

        For example:  text "hi" $$ nest 5 (text "there")
        lays out as
                        hi   there
        rather than
                        hi
                             there

        There are two places this is really useful

        a) When making labelled blocks, like this:
                Left ->   code for left
                Right ->  code for right
                LongLongLongLabel ->
                          code for longlonglonglabel
           The block is on the same line as the label if the label is
           short, but on the next line otherwise.

        b) When laying out lists like this:
                [ first
                , second
                , third
                ]
           which some people like.  But if the list fits on one line
           you want [first, second, third].  You can't do this with
           John's original combinators, but it's quite easy with the
           new $$.

        The combinator $+$ gives the original "never-overlap" behaviour.

5.      Several different renderers are provided:
                * a standard one
                * one that uses cut-marks to avoid deeply-nested documents 
                        simply piling up in the right-hand margin
                * one that ignores indentation (fewer chars output; good for machines)
                * one that ignores indentation and newlines (ditto, only more so)

6.      Numerous implementation tidy-ups
        Use of unboxed data types to speed up the implementation
-}

module Text.PrettyPrint.HughesPJ (

	-- * The document type
        Doc,            -- Abstract

	-- * Constructing documents
	-- ** Converting values into documents
        char, text, ptext,
        int, integer, float, double, rational,

	-- ** Simple derived documents
        semi, comma, colon, space, equals,
        lparen, rparen, lbrack, rbrack, lbrace, rbrace,

	-- ** Wrapping documents in delimiters
        parens, brackets, braces, quotes, doubleQuotes,

	-- ** Combining documents
        empty,
        (<>), (<+>), hcat, hsep, 
        ($$), ($+$), vcat, 
        sep, cat, 
        fsep, fcat, 
	nest,
        hang, punctuate,
        
	-- * Predicates on documents
	isEmpty,

	-- * Rendering documents

	-- ** Default rendering
	render, 

	-- ** Rendering with a particular style
	Style(..),
	style,
        renderStyle,

	-- ** General rendering
        fullRender,
        Mode(..), TextDetails(..),

  ) where


import Prelude

infixl 6 <> 
infixl 6 <+>
infixl 5 $$, $+$

-- ---------------------------------------------------------------------------
-- The interface

-- The primitive Doc values

isEmpty :: Doc    -> Bool;  -- ^ Returns 'True' if the document is empty

-- | The empty document, with no height and no width.
-- 'empty' is the identity for '<>', '<+>', '$$' and '$+$', and anywhere
-- in the argument list for 'sep', 'hcat', 'hsep', 'vcat', 'fcat' etc.
empty   :: Doc

semi	:: Doc;			-- ^ A ';' character
comma	:: Doc;			-- ^ A ',' character
colon	:: Doc;			-- ^ A ':' character
space	:: Doc;			-- ^ A space character
equals	:: Doc;			-- ^ A '=' character
lparen	:: Doc;			-- ^ A '(' character
rparen	:: Doc;			-- ^ A ')' character
lbrack	:: Doc;			-- ^ A '[' character
rbrack	:: Doc;			-- ^ A ']' character
lbrace	:: Doc;			-- ^ A '{' character
rbrace	:: Doc;			-- ^ A '}' character

-- | A document of height and width 1, containing a literal character.
char 	 :: Char     -> Doc

-- | A document of height 1 containing a literal string.
-- 'text' satisfies the following laws:
--
-- * @'text' s '<>' 'text' t = 'text' (s'++'t)@
--
-- * @'text' \"\" '<>' x = x@, if @x@ non-empty
--
-- The side condition on the last law is necessary because @'text' \"\"@
-- has height 1, while 'empty' has no height.
text	 :: String   -> Doc

-- | An obsolete function, now identical to 'text'.
ptext	 :: String   -> Doc

int      :: Int      -> Doc;	-- ^ @int n = text (show n)@
integer  :: Integer  -> Doc;	-- ^ @integer n = text (show n)@
float    :: Float    -> Doc;	-- ^ @float n = text (show n)@
double   :: Double   -> Doc;	-- ^ @double n = text (show n)@
rational :: Rational -> Doc;	-- ^ @rational n = text (show n)@

parens       :: Doc -> Doc; 	-- ^ Wrap document in @(...)@
brackets     :: Doc -> Doc;  	-- ^ Wrap document in @[...]@
braces	     :: Doc -> Doc;   	-- ^ Wrap document in @{...}@
quotes	     :: Doc -> Doc;	-- ^ Wrap document in @\'...\'@
doubleQuotes :: Doc -> Doc;	-- ^ Wrap document in @\"...\"@

-- Combining @Doc@ values

-- | Beside.
-- '<>' is associative, with identity 'empty'.
(<>)   :: Doc -> Doc -> Doc

-- | Beside, separated by space, unless one of the arguments is 'empty'.
-- '<+>' is associative, with identity 'empty'.
(<+>)  :: Doc -> Doc -> Doc

-- | Above, except that if the last line of the first argument stops
-- at least one position before the first line of the second begins,
-- these two lines are overlapped.  For example:
--
-- >    text "hi" $$ nest 5 (text "there")
--
-- lays out as
--
-- >    hi   there
--
-- rather than
--
-- >    hi
-- >         there
--
-- '$$' is associative, with identity 'empty', and also satisfies
--
-- * @(x '$$' y) '<>' z = x '$$' (y '<>' z)@, if @y@ non-empty.
--
($$)   :: Doc -> Doc -> Doc

-- | Above, with no overlapping.
-- '$+$' is associative, with identity 'empty'.
($+$)   :: Doc -> Doc -> Doc

hcat   :: [Doc] -> Doc;          -- ^List version of '<>'.
hsep   :: [Doc] -> Doc;          -- ^List version of '<+>'.
vcat   :: [Doc] -> Doc;          -- ^List version of '$$'.

cat    :: [Doc] -> Doc;          -- ^ Either 'hcat' or 'vcat'.
sep    :: [Doc] -> Doc;          -- ^ Either 'hsep' or 'vcat'.
fcat   :: [Doc] -> Doc;          -- ^ \"Paragraph fill\" version of 'cat'.
fsep   :: [Doc] -> Doc;          -- ^ \"Paragraph fill\" version of 'sep'.

-- | Nest (or indent) a document by a given number of positions
-- (which may also be negative).  'nest' satisfies the laws:
--
-- * @'nest' 0 x = x@
--
-- * @'nest' k ('nest' k' x) = 'nest' (k+k') x@
--
-- * @'nest' k (x '<>' y) = 'nest' k z '<>' 'nest' k y@
--
-- * @'nest' k (x '$$' y) = 'nest' k x '$$' 'nest' k y@
--
-- * @'nest' k 'empty' = 'empty'@
--
-- * @x '<>' 'nest' k y = x '<>' y@, if @x@ non-empty
--
-- The side condition on the last law is needed because
-- 'empty' is a left identity for '<>'.
nest   :: Int -> Doc -> Doc

-- GHC-specific ones.

-- | @hang d1 n d2 = sep [d1, nest n d2]@
hang :: Doc -> Int -> Doc -> Doc

-- | @punctuate p [d1, ... dn] = [d1 \<> p, d2 \<> p, ... dn-1 \<> p, dn]@
punctuate :: Doc -> [Doc] -> [Doc]


-- Displaying @Doc@ values. 

instance Show Doc where
  showsPrec prec doc cont = showDoc doc cont

-- | Renders the document as a string using the default 'style'.
render     :: Doc -> String

-- | The general rendering interface.
fullRender :: Mode			-- ^Rendering mode
           -> Int                       -- ^Line length
           -> Float                     -- ^Ribbons per line
           -> (TextDetails -> a -> a)   -- ^What to do with text
           -> a                         -- ^What to do at the end
           -> Doc			-- ^The document
           -> a                         -- ^Result

-- | Render the document as a string using a specified style.
renderStyle  :: Style -> Doc -> String

-- | A rendering style.
data Style
 = Style { mode           :: Mode     -- ^ The rendering mode
 	 , lineLength     :: Int      -- ^ Length of line, in chars
         , ribbonsPerLine :: Float    -- ^ Ratio of ribbon length to line length
         }

-- | The default style (@mode=PageMode, lineLength=100, ribbonsPerLine=1.5@).
style :: Style
style = Style { lineLength = 100, ribbonsPerLine = 1.5, mode = PageMode }

-- | Rendering mode.
data Mode = PageMode            -- ^Normal 
          | ZigZagMode          -- ^With zig-zag cuts
          | LeftMode            -- ^No indentation, infinitely long lines
          | OneLineMode         -- ^All on one line

-- ---------------------------------------------------------------------------
-- The Doc calculus

-- The Doc combinators satisfy the following laws:

{-
Laws for $$
~~~~~~~~~~~
<a1>    (x $$ y) $$ z   = x $$ (y $$ z)
<a2>    empty $$ x      = x
<a3>    x $$ empty      = x

        ...ditto $+$...

Laws for <>
~~~~~~~~~~~
<b1>    (x <> y) <> z   = x <> (y <> z)
<b2>    empty <> x      = empty
<b3>    x <> empty      = x

        ...ditto <+>...

Laws for text
~~~~~~~~~~~~~
<t1>    text s <> text t        = text (s++t)
<t2>    text "" <> x            = x, if x non-empty

Laws for nest
~~~~~~~~~~~~~
<n1>    nest 0 x                = x
<n2>    nest k (nest k' x)      = nest (k+k') x
<n3>    nest k (x <> y)         = nest k z <> nest k y
<n4>    nest k (x $$ y)         = nest k x $$ nest k y
<n5>    nest k empty            = empty
<n6>    x <> nest k y           = x <> y, if x non-empty

** Note the side condition on <n6>!  It is this that
** makes it OK for empty to be a left unit for <>.

Miscellaneous
~~~~~~~~~~~~~
<m1>    (text s <> x) $$ y = text s <> ((text "" <> x)) $$ 
                                         nest (-length s) y)

<m2>    (x $$ y) <> z = x $$ (y <> z)
        if y non-empty


Laws for list versions
~~~~~~~~~~~~~~~~~~~~~~
<l1>    sep (ps++[empty]++qs)   = sep (ps ++ qs)
        ...ditto hsep, hcat, vcat, fill...

<l2>    nest k (sep ps) = sep (map (nest k) ps)
        ...ditto hsep, hcat, vcat, fill...

Laws for oneLiner
~~~~~~~~~~~~~~~~~
<o1>    oneLiner (nest k p) = nest k (oneLiner p)
<o2>    oneLiner (x <> y)   = oneLiner x <> oneLiner y 

You might think that the following verion of <m1> would
be neater:

<3 NO>  (text s <> x) $$ y = text s <> ((empty <> x)) $$ 
                                         nest (-length s) y)

But it doesn't work, for if x=empty, we would have

        text s $$ y = text s <> (empty $$ nest (-length s) y)
                    = text s <> nest (-length s) y
-}

-- ---------------------------------------------------------------------------
-- Simple derived definitions

semi  = char ';'
colon = char ':'
comma = char ','
space = char ' '
equals = char '='
lparen = char '('
rparen = char ')'
lbrack = char '['
rbrack = char ']'
lbrace = char '{'
rbrace = char '}'

int      n = text (show n)
integer  n = text (show n)
float    n = text (show n)
double   n = text (show n)
rational n = text (show n)
-- SIGBJORN wrote instead:
-- rational n = text (show (fromRationalX n))

quotes p        = char '\'' <> p <> char '\''
doubleQuotes p  = char '"' <> p <> char '"'
parens p        = char '(' <> p <> char ')'
brackets p      = char '[' <> p <> char ']'
braces p        = char '{' <> p <> char '}'


hcat = foldr (<>)  empty
hsep = foldr (<+>) empty
vcat = foldr ($$)  empty

hang d1 n d2 = sep [d1, nest n d2]

punctuate p []     = []
punctuate p (d:ds) = go d ds
                   where
                     go d [] = [d]
                     go d (e:es) = (d <> p) : go e es

-- ---------------------------------------------------------------------------
-- The Doc data type

-- A Doc represents a *set* of layouts.  A Doc with
-- no occurrences of Union or NoDoc represents just one layout.

-- | The abstract type of documents.
-- The 'Show' instance is equivalent to using 'render'.
data Doc
 = Empty                                -- empty
 | NilAbove Doc                         -- text "" $$ x
 | TextBeside TextDetails !Int Doc      -- text s <> x  
 | Nest !Int Doc                        -- nest k x
 | Union Doc Doc                        -- ul `union` ur
 | NoDoc                                -- The empty set of documents
 | Beside Doc Bool Doc                  -- True <=> space between
 | Above  Doc Bool Doc                  -- True <=> never overlap

type RDoc = Doc         -- RDoc is a "reduced Doc", guaranteed not to have a top-level Above or Beside


reduceDoc :: Doc -> RDoc
reduceDoc (Beside p g q) = beside p g (reduceDoc q)
reduceDoc (Above  p g q) = above  p g (reduceDoc q)
reduceDoc p              = p


data TextDetails = Chr  Char
                 | Str  String
                 | PStr String
space_text = Chr ' '
nl_text    = Chr '\n'

{-
  Here are the invariants:
  
  * The argument of NilAbove is never Empty. Therefore
    a NilAbove occupies at least two lines.
  
  * The arugment of @TextBeside@ is never @Nest@.
  
  
  * The layouts of the two arguments of @Union@ both flatten to the same 
    string.
  
  * The arguments of @Union@ are either @TextBeside@, or @NilAbove@.
  
  * The right argument of a union cannot be equivalent to the empty set
    (@NoDoc@).  If the left argument of a union is equivalent to the
    empty set (@NoDoc@), then the @NoDoc@ appears in the first line.
  
  * An empty document is always represented by @Empty@.  It can't be
    hidden inside a @Nest@, or a @Union@ of two @Empty@s.
  
  * The first line of every layout in the left argument of @Union@ is
    longer than the first line of any layout in the right argument.
    (1) ensures that the left argument has a first line.  In view of
    (3), this invariant means that the right argument must have at
    least two lines.
-}

        -- Arg of a NilAbove is always an RDoc
nilAbove_ p = NilAbove p

        -- Arg of a TextBeside is always an RDoc
textBeside_ s sl p = TextBeside s sl p

        -- Arg of Nest is always an RDoc
nest_ k p = Nest k p

        -- Args of union are always RDocs
union_ p q = Union p q


-- Notice the difference between
-- 	   * NoDoc (no documents)
-- 	   * Empty (one empty document; no height and no width)
-- 	   * text "" (a document containing the empty string;
-- 		      one line high, but has no width)


-- ---------------------------------------------------------------------------
-- @empty@, @text@, @nest@, @union@

empty = Empty

isEmpty Empty = True
isEmpty _     = False

char  c = textBeside_ (Chr c) 1 Empty
text  s = case length s of {sl -> textBeside_ (Str s)  sl Empty}
ptext s = case length s of {sl -> textBeside_ (PStr s) sl Empty}

nest k  p = mkNest k (reduceDoc p)        -- Externally callable version

-- mkNest checks for Nest's invariant that it doesn't have an Empty inside it
mkNest k       _           | k `seq` False = undefined
mkNest k       (Nest k1 p) = mkNest (k + k1) p
mkNest k       NoDoc       = NoDoc
mkNest k       Empty       = Empty
mkNest 0       p           = p                  -- Worth a try!
mkNest k       p           = nest_ k p

-- mkUnion checks for an empty document
mkUnion Empty q = Empty
mkUnion p q     = p `union_` q

-- ---------------------------------------------------------------------------
-- Vertical composition @$$@

above_ :: Doc -> Bool -> Doc -> Doc
above_ p _ Empty = p
above_ Empty _ q = q
above_ p g q = Above p g q

p $$  q = above_ p False q
p $+$ q = above_ p True q

above :: Doc -> Bool -> RDoc -> RDoc
above (Above p g1 q1)  g2 q2 = above p g1 (above q1 g2 q2)
above p@(Beside _ _ _) g  q  = aboveNest (reduceDoc p) g 0 (reduceDoc q)
above p g q                  = aboveNest p             g 0 (reduceDoc q)

aboveNest :: RDoc -> Bool -> Int -> RDoc -> RDoc
-- Specfication: aboveNest p g k q = p $g$ (nest k q)

aboveNest _                   _ k _ | k `seq` False = undefined
aboveNest NoDoc               g k q = NoDoc
aboveNest (p1 `Union` p2)     g k q = aboveNest p1 g k q `union_` 
                                      aboveNest p2 g k q
                                
aboveNest Empty               g k q = mkNest k q
aboveNest (Nest k1 p)         g k q = nest_ k1 (aboveNest p g (k - k1) q)
                                  -- p can't be Empty, so no need for mkNest
                                
aboveNest (NilAbove p)        g k q = nilAbove_ (aboveNest p g k q)
aboveNest (TextBeside s sl p) g k q = k1 `seq` textBeside_ s sl rest
                                    where
                                      k1   = k - sl
                                      rest = case p of
                                                Empty -> nilAboveNest g k1 q
                                                other -> aboveNest  p g k1 q


nilAboveNest :: Bool -> Int -> RDoc -> RDoc
-- Specification: text s <> nilaboveNest g k q 
--              = text s <> (text "" $g$ nest k q)

nilAboveNest _ k _           | k `seq` False = undefined
nilAboveNest g k Empty       = Empty    -- Here's why the "text s <>" is in the spec!
nilAboveNest g k (Nest k1 q) = nilAboveNest g (k + k1) q

nilAboveNest g k q           | (not g) && (k > 0)        -- No newline if no overlap
                             = textBeside_ (Str (spaces k)) k q
                             | otherwise                        -- Put them really above
                             = nilAbove_ (mkNest k q)

-- ---------------------------------------------------------------------------
-- Horizontal composition @<>@

beside_ :: Doc -> Bool -> Doc -> Doc
beside_ p _ Empty = p
beside_ Empty _ q = q
beside_ p g q = Beside p g q

p <>  q = beside_ p False q
p <+> q = beside_ p True  q

beside :: Doc -> Bool -> RDoc -> RDoc
-- Specification: beside g p q = p <g> q
 
beside NoDoc               g q   = NoDoc
beside (p1 `Union` p2)     g q   = (beside p1 g q) `union_` (beside p2 g q)
beside Empty               g q   = q
beside (Nest k p)          g q   = nest_ k (beside p g q)       -- p non-empty
beside p@(Beside p1 g1 q1) g2 q2 
           {- (A `op1` B) `op2` C == A `op1` (B `op2` C)  iff op1 == op2 
                                                 [ && (op1 == <> || op1 == <+>) ] -}
         | g1 == g2              = beside p1 g1 (beside q1 g2 q2)
         | otherwise             = beside (reduceDoc p) g2 q2
beside p@(Above _ _ _)     g q   = beside (reduceDoc p) g q
beside (NilAbove p)        g q   = nilAbove_ (beside p g q)
beside (TextBeside s sl p) g q   = textBeside_ s sl rest
                               where
                                  rest = case p of
                                           Empty -> nilBeside g q
                                           other -> beside p g q


nilBeside :: Bool -> RDoc -> RDoc
-- Specification: text "" <> nilBeside g p 
--              = text "" <g> p

nilBeside g Empty      = Empty  -- Hence the text "" in the spec
nilBeside g (Nest _ p) = nilBeside g p
nilBeside g p          | g         = textBeside_ space_text 1 p
                       | otherwise = p

-- ---------------------------------------------------------------------------
-- Separate, @sep@, Hughes version

-- Specification: sep ps  = oneLiner (hsep ps)
--                         `union`
--                          vcat ps

sep = sepX True         -- Separate with spaces
cat = sepX False        -- Don't

sepX x []     = empty
sepX x (p:ps) = sep1 x (reduceDoc p) 0 ps


-- Specification: sep1 g k ys = sep (x : map (nest k) ys)
--                            = oneLiner (x <g> nest k (hsep ys))
--                              `union` x $$ nest k (vcat ys)

sep1 :: Bool -> RDoc -> Int -> [Doc] -> RDoc
sep1 g _                   k ys | k `seq` False = undefined
sep1 g NoDoc               k ys = NoDoc
sep1 g (p `Union` q)       k ys = sep1 g p k ys
                                  `union_`
                                  (aboveNest q False k (reduceDoc (vcat ys)))

sep1 g Empty               k ys = mkNest k (sepX g ys)
sep1 g (Nest n p)          k ys = nest_ n (sep1 g p (k - n) ys)

sep1 g (NilAbove p)        k ys = nilAbove_ (aboveNest p False k (reduceDoc (vcat ys)))
sep1 g (TextBeside s sl p) k ys = textBeside_ s sl (sepNB g p (k - sl) ys)

-- Specification: sepNB p k ys = sep1 (text "" <> p) k ys
-- Called when we have already found some text in the first item
-- We have to eat up nests

sepNB g (Nest _ p)  k ys  = sepNB g p k ys

sepNB g Empty k ys        = oneLiner (nilBeside g (reduceDoc rest))
                                `mkUnion` 
                            nilAboveNest False k (reduceDoc (vcat ys))
                          where
                            rest | g         = hsep ys
                                 | otherwise = hcat ys

sepNB g p k ys            = sep1 g p k ys

-- ---------------------------------------------------------------------------
-- @fill@

fsep = fill True
fcat = fill False

-- Specification: 
--   fill []  = empty
--   fill [p] = p
--   fill (p1:p2:ps) = oneLiner p1 <#> nest (length p1) 
--                                          (fill (oneLiner p2 : ps))
--                     `union`
--                      p1 $$ fill ps

fill g []     = empty
fill g (p:ps) = fill1 g (reduceDoc p) 0 ps


fill1 :: Bool -> RDoc -> Int -> [Doc] -> Doc
fill1 g _                   k ys | k `seq` False = undefined
fill1 g NoDoc               k ys = NoDoc
fill1 g (p `Union` q)       k ys = fill1 g p k ys
                                   `union_`
                                   (aboveNest q False k (fill g ys))

fill1 g Empty               k ys = mkNest k (fill g ys)
fill1 g (Nest n p)          k ys = nest_ n (fill1 g p (k - n) ys)

fill1 g (NilAbove p)        k ys = nilAbove_ (aboveNest p False k (fill g ys))
fill1 g (TextBeside s sl p) k ys = textBeside_ s sl (fillNB g p (k - sl) ys)

fillNB g _           k ys | k `seq` False = undefined
fillNB g (Nest _ p)  k ys  = fillNB g p k ys
fillNB g Empty k []        = Empty
fillNB g Empty k (y:ys)    = nilBeside g (fill1 g (oneLiner (reduceDoc y)) k1 ys)
                             `mkUnion` 
                             nilAboveNest False k (fill g (y:ys))
                           where
                             k1 | g         = k - 1
                                | otherwise = k

fillNB g p k ys            = fill1 g p k ys


-- ---------------------------------------------------------------------------
-- Selecting the best layout

best :: Mode
     -> Int             -- Line length
     -> Int             -- Ribbon length
     -> RDoc
     -> RDoc            -- No unions in here!

best OneLineMode w r p
  = get p
  where
    get Empty               = Empty
    get NoDoc               = NoDoc
    get (NilAbove p)        = nilAbove_ (get p)
    get (TextBeside s sl p) = textBeside_ s sl (get p)
    get (Nest k p)          = get p             -- Elide nest
    get (p `Union` q)       = first (get p) (get q)

best mode w r p
  = get w p
  where
    get :: Int          -- (Remaining) width of line
        -> Doc -> Doc
    get w _ | w==0 && False   = undefined
    get w Empty               = Empty
    get w NoDoc               = NoDoc
    get w (NilAbove p)        = nilAbove_ (get w p)
    get w (TextBeside s sl p) = textBeside_ s sl (get1 w sl p)
    get w (Nest k p)          = nest_ k (get (w - k) p)
    get w (p `Union` q)       = nicest w r (get w p) (get w q)

    get1 :: Int         -- (Remaining) width of line
         -> Int         -- Amount of first line already eaten up
         -> Doc         -- This is an argument to TextBeside => eat Nests
         -> Doc         -- No unions in here!

    get1 w _ _ | w==0 && False = undefined
    get1 w sl Empty               = Empty
    get1 w sl NoDoc               = NoDoc
    get1 w sl (NilAbove p)        = nilAbove_ (get (w - sl) p)
    get1 w sl (TextBeside t tl p) = textBeside_ t tl (get1 w (sl + tl) p)
    get1 w sl (Nest k p)          = get1 w sl p
    get1 w sl (p `Union` q)       = nicest1 w r sl (get1 w sl p) 
                                                   (get1 w sl q)

nicest w r p q = nicest1 w r 0 p q
nicest1 w r sl p q | fits ((w `minn` r) - sl) p = p
                   | otherwise                   = q

fits :: Int     -- Space available
     -> Doc
     -> Bool    -- True if *first line* of Doc fits in space available
 
fits n p    | n < 0 = False
fits n NoDoc               = False
fits n Empty               = True
fits n (NilAbove _)        = True
fits n (TextBeside _ sl p) = fits (n - sl) p

minn x y | x < y    = x
         | otherwise = y

-- @first@ and @nonEmptySet@ are similar to @nicest@ and @fits@, only simpler.
-- @first@ returns its first argument if it is non-empty, otherwise its second.

first p q | nonEmptySet p = p 
          | otherwise     = q

nonEmptySet NoDoc           = False
nonEmptySet (p `Union` q)      = True
nonEmptySet Empty              = True
nonEmptySet (NilAbove p)       = True           -- NoDoc always in first line
nonEmptySet (TextBeside _ _ p) = nonEmptySet p
nonEmptySet (Nest _ p)         = nonEmptySet p

-- @oneLiner@ returns the one-line members of the given set of @Doc@s.

oneLiner :: Doc -> Doc
oneLiner NoDoc               = NoDoc
oneLiner Empty               = Empty
oneLiner (NilAbove p)        = NoDoc
oneLiner (TextBeside s sl p) = textBeside_ s sl (oneLiner p)
oneLiner (Nest k p)          = nest_ k (oneLiner p)
oneLiner (p `Union` q)       = oneLiner p


-- ---------------------------------------------------------------------------
-- Displaying the best layout

renderStyle style doc 
  = fullRender (mode style)
               (lineLength style)
	       (ribbonsPerLine style)
	       string_txt
	       ""
	       doc

render doc       = showDoc doc ""
showDoc doc rest = fullRender PageMode 100 1.5 string_txt rest doc

string_txt (Chr c)   s  = c:s
string_txt (Str s1)  s2 = s1 ++ s2
string_txt (PStr s1) s2 = s1 ++ s2


fullRender OneLineMode _ _ txt end doc = easy_display space_text txt end (reduceDoc doc)
fullRender LeftMode    _ _ txt end doc = easy_display nl_text    txt end (reduceDoc doc)

fullRender mode line_length ribbons_per_line txt end doc
  = display mode line_length ribbon_length txt end best_doc
  where 
    best_doc = best mode hacked_line_length ribbon_length (reduceDoc doc)

    hacked_line_length, ribbon_length :: Int
    ribbon_length = round (fromIntegral line_length / ribbons_per_line)
    hacked_line_length = case mode of { ZigZagMode -> maxBound; other -> line_length }

display mode page_width ribbon_width txt end doc
  = case page_width - ribbon_width of { gap_width ->
    case gap_width `quot` 2 of { shift ->
    let
        lay k _            | k `seq` False = undefined
        lay k (Nest k1 p)  = lay (k + k1) p
        lay k Empty        = end
    
        lay k (NilAbove p) = nl_text `txt` lay k p
    
        lay k (TextBeside s sl p)
            = case mode of
                    ZigZagMode |  k >= gap_width
                               -> nl_text `txt` (
                                  Str (multi_ch shift '/') `txt` (
                                  nl_text `txt` (
                                  lay1 (k - shift) s sl p)))

                               |  k < 0
                               -> nl_text `txt` (
                                  Str (multi_ch shift '\\') `txt` (
                                  nl_text `txt` (
                                  lay1 (k + shift) s sl p )))

                    other -> lay1 k s sl p
    
        lay1 k _ sl _ | k+sl `seq` False = undefined
        lay1 k s sl p = Str (indent k) `txt` (s `txt` lay2 (k + sl) p)
    
        lay2 k _ | k `seq` False = undefined
        lay2 k (NilAbove p)        = nl_text `txt` lay k p
        lay2 k (TextBeside s sl p) = s `txt` (lay2 (k + sl) p)
        lay2 k (Nest _ p)          = lay2 k p
        lay2 k Empty               = end
    in
    lay 0 doc
    }}

cant_fail = error "easy_display: NoDoc"
easy_display nl_text txt end doc 
  = lay doc cant_fail
  where
    lay NoDoc               no_doc = no_doc
    lay (Union p q)         no_doc = {- lay p -} (lay q cant_fail)              -- Second arg can't be NoDoc
    lay (Nest k p)          no_doc = lay p no_doc
    lay Empty               no_doc = end
    lay (NilAbove p)        no_doc = nl_text `txt` lay p cant_fail      -- NoDoc always on first line
    lay (TextBeside s sl p) no_doc = s `txt` lay p no_doc

-- OLD version: we shouldn't rely on tabs being 8 columns apart in the output.
-- indent n | n >= 8 = '\t' : indent (n - 8)
--          | otherwise      = spaces n
indent n = spaces n

multi_ch 0 ch = ""
multi_ch n       ch = ch : multi_ch (n - 1) ch

-- (spaces n) generates a list of n spaces
--
-- It should never be called with 'n' < 0, but that can happen for reasons I don't understand
-- Here's a test case:
--	ncat x y = nest 4 $ cat [ x, y ]
--	d1 = foldl1 ncat $ take 50 $ repeat $ char 'a'
--	d2 = parens $  sep [ d1, text "+" , d1 ]
--	main = print d2
-- I don't feel motivated enough to find the Real Bug, so meanwhile we just test for n<=0
spaces n | n <= 0    = ""
	 | otherwise = ' ' : spaces (n - 1)

{- Comments from Johannes Waldmann about what the problem might be:

   In the example above, d2 and d1 are deeply nested, but `text "+"' is not, 
   so the layout function tries to "out-dent" it.
   
   when I look at the Doc values that are generated, there are lots of
   Nest constructors with negative arguments.  see this sample output of
   d1 (obtained with hugs, :s -u)
   
   tBeside (TextDetails_Chr 'a') 1 Doc_Empty) (Doc_NilAbove (Doc_Nest
   (-241) (Doc_TextBeside (TextDetails_Chr 'a') 1 Doc_Empty)))))
   (Doc_NilAbove (Doc_Nest (-236) (Doc_TextBeside (TextDetails_Chr 'a') 1
   (Doc_NilAbove (Doc_Nest (-5) (Doc_TextBeside (TextDetails_Chr 'a') 1
   Doc_Empty)))))))) (Doc_NilAbove (Doc_Nest (-231) (Doc_TextBeside
   (TextDetails_Chr 'a') 1 (Doc_NilAbove (Doc_Nest (-5) (Doc_TextBeside
   (TextDetails_Chr 'a') 1 (Doc_NilAbove (Doc_Nest (-5) (Doc_TextBeside
   (TextDetails_Chr 'a') 1 Doc_Empty))))))))))) (Doc_NilAbove (Doc_Nest
-}
{-# OPTIONS_GHC -fno-implicit-prelude #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Text.Read.Lex
-- Copyright   :  (c) The University of Glasgow 2002
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  non-portable (uses Text.ParserCombinators.ReadP)
--
-- The cut-down Haskell lexer, used by Text.Read
--
-----------------------------------------------------------------------------

module Text.Read.Lex
  -- lexing types
  ( Lexeme(..)  -- :: *; Show, Eq
  		
  -- lexer	
  , lex         -- :: ReadP Lexeme	Skips leading spaces
  , hsLex	-- :: ReadP String
  , lexChar	-- :: ReadP Char	Reads just one char, with H98 escapes
  
  , readIntP    -- :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
  , readOctP    -- :: Num a => ReadP a 
  , readDecP    -- :: Num a => ReadP a
  , readHexP    -- :: Num a => ReadP a
  )
 where

import Text.ParserCombinators.ReadP













import Prelude hiding ( lex )
import Data.Char( chr, ord, isSpace, isAlpha, isAlphaNum )
import Data.Ratio( Ratio, (%) )


import Hugs.Prelude( Ratio(..) )

import Data.Maybe
import Control.Monad

-- -----------------------------------------------------------------------------
-- Lexing types

-- ^ Haskell lexemes.
data Lexeme
  = Char   Char		-- ^ Character literal
  | String String	-- ^ String literal, with escapes interpreted
  | Punc   String 	-- ^ Punctuation or reserved symbol, e.g. @(@, @::@
  | Ident  String	-- ^ Haskell identifier, e.g. @foo@, @Baz@
  | Symbol String	-- ^ Haskell symbol, e.g. @>>@, @:%@
  | Int Integer		-- ^ Integer literal
  | Rat Rational	-- ^ Floating point literal
  | EOF
 deriving (Eq, Show)

-- -----------------------------------------------------------------------------
-- Lexing

lex :: ReadP Lexeme
lex = skipSpaces >> lexToken

hsLex :: ReadP String
-- ^ Haskell lexer: returns the lexed string, rather than the lexeme
hsLex = do skipSpaces 
	   (s,_) <- gather lexToken
	   return s

lexToken :: ReadP Lexeme
lexToken = lexEOF     +++
      	   lexLitChar +++ 
      	   lexString  +++ 
      	   lexPunc    +++ 
      	   lexSymbol  +++ 
      	   lexId      +++ 
      	   lexNumber


-- ----------------------------------------------------------------------
-- End of file
lexEOF :: ReadP Lexeme
lexEOF = do s <- look
	    guard (null s)
	    return EOF

-- ---------------------------------------------------------------------------
-- Single character lexemes

lexPunc :: ReadP Lexeme
lexPunc =
  do c <- satisfy isPuncChar
     return (Punc [c])
 where
  isPuncChar c = c `elem` ",;()[]{}`"

-- ----------------------------------------------------------------------
-- Symbols

lexSymbol :: ReadP Lexeme
lexSymbol =
  do s <- munch1 isSymbolChar
     if s `elem` reserved_ops then 
	return (Punc s)		-- Reserved-ops count as punctuation
      else
	return (Symbol s)
 where
  isSymbolChar c = c `elem` "!@#$%&*+./<=>?\\^|:-~"
  reserved_ops   = ["..", "::", "=", "\\", "|", "<-", "->", "@", "~", "=>"]

-- ----------------------------------------------------------------------
-- identifiers

lexId :: ReadP Lexeme
lexId = lex_nan <++ lex_id
  where
	-- NaN and Infinity look like identifiers, so
	-- we parse them first.  
    lex_nan = (string "NaN"      >> return (Rat notANumber)) +++
  	      (string "Infinity" >> return (Rat infinity))
  
    lex_id = do c <- satisfy isIdsChar
  		s <- munch isIdfChar
  		return (Ident (c:s))

  	  -- Identifiers can start with a '_'
    isIdsChar c = isAlpha c || c == '_'
    isIdfChar c = isAlphaNum c || c `elem` "_'"


infinity, notANumber :: Rational
infinity   = 1 :% 0
notANumber = 0 :% 0


-- ---------------------------------------------------------------------------
-- Lexing character literals

lexLitChar :: ReadP Lexeme
lexLitChar =
  do char '\''
     (c,esc) <- lexCharE
     guard (esc || c /= '\'')	-- Eliminate '' possibility
     char '\''
     return (Char c)

lexChar :: ReadP Char
lexChar = do { (c,_) <- lexCharE; return c }

lexCharE :: ReadP (Char, Bool)  -- "escaped or not"?
lexCharE =
  do c <- get
     if c == '\\'
       then do c <- lexEsc; return (c, True)
       else do return (c, False)
 where 
  lexEsc =
    lexEscChar
      +++ lexNumeric
        +++ lexCntrlChar
          +++ lexAscii
  
  lexEscChar =
    do c <- get
       case c of
         'a'  -> return '\a'
         'b'  -> return '\b'
         'f'  -> return '\f'
         'n'  -> return '\n'
         'r'  -> return '\r'
         't'  -> return '\t'
         'v'  -> return '\v'
         '\\' -> return '\\'
         '\"' -> return '\"'
         '\'' -> return '\''
         _    -> pfail
  
  lexNumeric =
    do base <- lexBaseChar <++ return 10
       n    <- lexInteger base
       guard (n <= toInteger (ord maxBound))
       return (chr (fromInteger n))

  lexCntrlChar =
    do char '^'
       c <- get
       case c of
         '@'  -> return '\^@'
         'A'  -> return '\^A'
         'B'  -> return '\^B'
         'C'  -> return '\^C'
         'D'  -> return '\^D'
         'E'  -> return '\^E'
         'F'  -> return '\^F'
         'G'  -> return '\^G'
         'H'  -> return '\^H'
         'I'  -> return '\^I'
         'J'  -> return '\^J'
         'K'  -> return '\^K'
         'L'  -> return '\^L'
         'M'  -> return '\^M'
         'N'  -> return '\^N'
         'O'  -> return '\^O'
         'P'  -> return '\^P'
         'Q'  -> return '\^Q'
         'R'  -> return '\^R'
         'S'  -> return '\^S'
         'T'  -> return '\^T'
         'U'  -> return '\^U'
         'V'  -> return '\^V'
         'W'  -> return '\^W'
         'X'  -> return '\^X'
         'Y'  -> return '\^Y'
         'Z'  -> return '\^Z'
         '['  -> return '\^['
         '\\' -> return '\^\'
         ']'  -> return '\^]'
         '^'  -> return '\^^'
         '_'  -> return '\^_'
         _    -> pfail

  lexAscii =
    do choice
         [ (string "SOH" >> return '\SOH') <++
	   (string "SO"  >> return '\SO') 
		-- \SO and \SOH need maximal-munch treatment
		-- See the Haskell report Sect 2.6

         , string "NUL" >> return '\NUL'
         , string "STX" >> return '\STX'
         , string "ETX" >> return '\ETX'
         , string "EOT" >> return '\EOT'
         , string "ENQ" >> return '\ENQ'
         , string "ACK" >> return '\ACK'
         , string "BEL" >> return '\BEL'
         , string "BS"  >> return '\BS'
         , string "HT"  >> return '\HT'
         , string "LF"  >> return '\LF'
         , string "VT"  >> return '\VT'
         , string "FF"  >> return '\FF'
         , string "CR"  >> return '\CR'
         , string "SI"  >> return '\SI'
         , string "DLE" >> return '\DLE'
         , string "DC1" >> return '\DC1'
         , string "DC2" >> return '\DC2'
         , string "DC3" >> return '\DC3'
         , string "DC4" >> return '\DC4'
         , string "NAK" >> return '\NAK'
         , string "SYN" >> return '\SYN'
         , string "ETB" >> return '\ETB'
         , string "CAN" >> return '\CAN'
         , string "EM"  >> return '\EM'
         , string "SUB" >> return '\SUB'
         , string "ESC" >> return '\ESC'
         , string "FS"  >> return '\FS'
         , string "GS"  >> return '\GS'
         , string "RS"  >> return '\RS'
         , string "US"  >> return '\US'
         , string "SP"  >> return '\SP'
         , string "DEL" >> return '\DEL'
         ]


-- ---------------------------------------------------------------------------
-- string literal

lexString :: ReadP Lexeme
lexString =
  do char '"'
     body id
 where
  body f =
    do (c,esc) <- lexStrItem
       if c /= '"' || esc
         then body (f.(c:))
         else let s = f "" in
	      return (String s)

  lexStrItem = (lexEmpty >> lexStrItem)
	       +++ lexCharE
  
  lexEmpty =
    do char '\\'
       c <- get
       case c of
         '&'           -> do return ()
         _ | isSpace c -> do skipSpaces; char '\\'; return ()
         _             -> do pfail

-- ---------------------------------------------------------------------------
--  Lexing numbers

type Base   = Int
type Digits = [Int]

lexNumber :: ReadP Lexeme
lexNumber 
  = lexHexOct  <++	-- First try for hex or octal 0x, 0o etc
			-- If that fails, try for a decimal number
    lexDecNumber 	-- Start with ordinary digits
		
lexHexOct :: ReadP Lexeme
lexHexOct
  = do	char '0'
	base <- lexBaseChar
	digits <- lexDigits base
	return (Int (val (fromIntegral base) 0 digits))

lexBaseChar :: ReadP Int
-- Lex a single character indicating the base; fail if not there
lexBaseChar = do { c <- get;
		   case c of
		   	'o' -> return 8
	           	'O' -> return 8
	           	'x' -> return 16
        	   	'X' -> return 16
	           	_   -> pfail } 

lexDecNumber :: ReadP Lexeme
lexDecNumber =
  do xs    <- lexDigits 10
     mFrac <- lexFrac <++ return Nothing
     mExp  <- lexExp  <++ return Nothing
     return (value xs mFrac mExp)
 where
  value xs mFrac mExp = valueFracExp (val 10 0 xs) mFrac mExp
  
  valueFracExp :: Integer -> Maybe Digits -> Maybe Integer 
	       -> Lexeme
  valueFracExp a Nothing Nothing	
    = Int a						-- 43
  valueFracExp a Nothing (Just exp)
    | exp >= 0  = Int (a * (10 ^ exp))			-- 43e7
    | otherwise = Rat (valExp (fromInteger a) exp)	-- 43e-7
  valueFracExp a (Just fs) mExp 
     = case mExp of
	 Nothing  -> Rat rat				-- 4.3
	 Just exp -> Rat (valExp rat exp)		-- 4.3e-4
     where
	rat :: Rational
	rat = fromInteger a + frac 10 0 1 fs

  valExp :: Rational -> Integer -> Rational
  valExp rat exp = rat * (10 ^^ exp)

lexFrac :: ReadP (Maybe Digits)
-- Read the fractional part; fail if it doesn't
-- start ".d" where d is a digit
lexFrac = do char '.'
	     frac <- lexDigits 10
	     return (Just frac)

lexExp :: ReadP (Maybe Integer)
lexExp = do char 'e' +++ char 'E'
            exp <- signedExp +++ lexInteger 10
	    return (Just exp)
 where
   signedExp 
     = do c <- char '-' +++ char '+'
          n <- lexInteger 10
          return (if c == '-' then -n else n)

lexDigits :: Int -> ReadP Digits
-- Lex a non-empty sequence of digits in specified base
lexDigits base =
  do s  <- look
     xs <- scan s id
     guard (not (null xs))
     return xs
 where
  scan (c:cs) f = case valDig base c of
                    Just n  -> do get; scan cs (f.(n:))
                    Nothing -> do return (f [])
  scan []     f = do return (f [])

lexInteger :: Base -> ReadP Integer
lexInteger base =
  do xs <- lexDigits base
     return (val (fromIntegral base) 0 xs)

val :: Num a => a -> a -> Digits -> a
-- val base y [d1,..,dn] = y ++ [d1,..,dn], as it were
val base y []     = y
val base y (x:xs) = y' `seq` val base y' xs
 where
  y' = y * base + fromIntegral x

frac :: Integral a => a -> a -> a -> Digits -> Ratio a
frac base a b []     = a % b
frac base a b (x:xs) = a' `seq` b' `seq` frac base a' b' xs
 where
  a' = a * base + fromIntegral x
  b' = b * base

valDig :: Num a => a -> Char -> Maybe Int
valDig 8 c
  | '0' <= c && c <= '7' = Just (ord c - ord '0')
  | otherwise            = Nothing

valDig 10 c = valDecDig c

valDig 16 c
  | '0' <= c && c <= '9' = Just (ord c - ord '0')
  | 'a' <= c && c <= 'f' = Just (ord c - ord 'a' + 10)
  | 'A' <= c && c <= 'F' = Just (ord c - ord 'A' + 10)
  | otherwise            = Nothing

valDecDig c
  | '0' <= c && c <= '9' = Just (ord c - ord '0')
  | otherwise            = Nothing

-- ----------------------------------------------------------------------
-- other numeric lexing functions

readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
readIntP base isDigit valDigit =
  do s <- munch1 isDigit
     return (val base 0 (map valDigit s))

readIntP' :: Num a => a -> ReadP a
readIntP' base = readIntP base isDigit valDigit
 where
  isDigit  c = maybe False (const True) (valDig base c)
  valDigit c = maybe 0     id           (valDig base c)

readOctP, readDecP, readHexP :: Num a => ReadP a
readOctP = readIntP' 8
readDecP = readIntP' 10
readHexP = readIntP' 16
-----------------------------------------------------------------------------
-- |
-- Module      :  Text.Show.Functions
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
-- 
-- Maintainer  :  libraries@haskell.org
-- Stability   :  provisional
-- Portability :  portable
--
-- Optional instance of 'Text.Show.Show' for functions:
--
-- > instance Show (a -> b) where
-- > 	showsPrec _ _ = showString \"\<function\>\"
--
-----------------------------------------------------------------------------

module Text.Show.Functions () where

import Prelude


instance Show (a -> b) where
	showsPrec _ _ = showString "<function>"

module Paths_cpphs (
	version,
	getBinDir, getLibDir, getDataDir, getLibexecDir,
	getDataFileName
	) where

import Data.Version

version = Version {versionBranch = [1,2], versionTags = []}

bindir     = "/usr/local/bin"
libdir     = "/usr/local/lib/hugs/packages/cpphs"
datadir    = "/usr/local/share/cpphs-1.2"
libexecdir = "/usr/local/libexec"

getBinDir, getLibDir, getDataDir, getLibexecDir :: IO FilePath
getBinDir = return bindir
getLibDir = return libdir
getDataDir = return datadir
getLibexecDir = return libexecdir

getDataFileName :: FilePath -> IO FilePath
getDataFileName name = return (datadir ++ "/" ++ name)
-----------------------------------------------------------------------------
-- |
-- Module      :  Language.Preprocessor.Cpphs
-- Copyright   :  2000-2006 Malcolm Wallace
-- Licence     :  LGPL
--
-- Maintainer  :  Malcolm Wallace <Malcolm.Wallace@cs.york.ac.uk>
-- Stability   :  experimental
-- Portability :  All
--
-- Include the interface that is exported
-----------------------------------------------------------------------------

module Language.Preprocessor.Cpphs (runCpphs, cppIfdef, macroPass, CpphsOption(..), parseOption)  where

import Language.Preprocessor.Cpphs.CppIfdef(cppIfdef)
import Language.Preprocessor.Cpphs.MacroPass(macroPass)
import Language.Preprocessor.Cpphs.RunCpphs(runCpphs)
import Language.Preprocessor.Cpphs.Options(CpphsOption(..), parseOption)
-- | Part of this code is from "Report on the Programming Language Haskell",
--   version 1.2, appendix C.
module Language.Preprocessor.Unlit (unlit) where

import Char

data Classified = Program String | Blank | Comment
                | Include Int String | Pre String

classify :: [String] -> [Classified]
classify []                = []
classify (('\\':x):xs) | x == "begin{code}" = Blank : allProg xs
   where allProg [] = []  -- Should give an error message,
                          -- but I have no good position information.
         allProg (('\\':x):xs) |  x == "end{code}" = Blank : classify xs
	 allProg (x:xs) = Program x:allProg xs
classify (('>':x):xs)      = Program (' ':x) : classify xs
classify (('#':x):xs)      = (case words x of
                                (line:file:_) | all isDigit line
                                   -> Include (read line) file
                                _  -> Pre x
                             ) : classify xs
classify (x:xs) | all isSpace x = Blank:classify xs
classify (x:xs)                 = Comment:classify xs

unclassify :: Classified -> String
unclassify (Program s) = s
unclassify (Pre s)     = '#':s
unclassify (Include i f) = '#':' ':show i ++ ' ':f
unclassify Blank       = ""
unclassify Comment     = ""

-- | 'unlit' takes a filename (for error reports), and transforms the
--   given string, to eliminate the literate comments from the program text.
unlit :: FilePath -> String -> String
unlit file lhs = (unlines
                 . map unclassify
                 . adjacent file (0::Int) Blank
                 . classify) (inlines lhs)

adjacent :: FilePath -> Int -> Classified -> [Classified] -> [Classified]
adjacent file 0 _             (x              :xs) = x : adjacent file 1 x xs -- force evaluation of line number
adjacent file n y@(Program _) (x@Comment      :xs) = error (message file n "program" "comment")
adjacent file n y@(Program _) (x@(Include i f):xs) = x: adjacent f    i     y xs
adjacent file n y@(Program _) (x@(Pre _)      :xs) = x: adjacent file (n+1) y xs
adjacent file n y@Comment     (x@(Program _)  :xs) = error (message file n "comment" "program")
adjacent file n y@Comment     (x@(Include i f):xs) = x: adjacent f    i     y xs
adjacent file n y@Comment     (x@(Pre _)      :xs) = x: adjacent file (n+1) y xs
adjacent file n y@Blank       (x@(Include i f):xs) = x: adjacent f    i     y xs
adjacent file n y@Blank       (x@(Pre _)      :xs) = x: adjacent file (n+1) y xs
adjacent file n _             (x@next         :xs) = x: adjacent file (n+1) x xs
adjacent file n _             []                   = []

message "\"\"" n p c = "Line "++show n++": "++p++ " line before "++c++" line.\n"
message []     n p c = "Line "++show n++": "++p++ " line before "++c++" line.\n"
message file   n p c = "In file " ++ file ++ " at line "++show n++": "++p++ " line before "++c++" line.\n"


-- Re-implementation of 'lines', for better efficiency (but decreased laziness).
-- Also, importantly, accepts non-standard DOS and Mac line ending characters.
inlines s = lines' s id
  where
  lines' []             acc = [acc []]
  lines' ('\^M':'\n':s) acc = acc [] : lines' s id	-- DOS
  lines' ('\^M':s)      acc = acc [] : lines' s id	-- MacOS
  lines' ('\n':s)       acc = acc [] : lines' s id	-- Unix
  lines' (c:s)          acc = lines' s (acc . (c:))

-----------------------------------------------------------------------------
-- |
-- Module      :  CppIfdef
-- Copyright   :  1999-2004 Malcolm Wallace
-- Licence     :  LGPL
-- 
-- Maintainer  :  Malcolm Wallace <Malcolm.Wallace@cs.york.ac.uk>
-- Stability   :  experimental
-- Portability :  All
--
-- Perform a cpp.first-pass, gathering \#define's and evaluating \#ifdef's.
-- and \#include's.
-----------------------------------------------------------------------------

module Language.Preprocessor.Cpphs.CppIfdef
  ( cppIfdef	-- :: FilePath -> [(String,String)] -> [String] -> Bool -> Bool
		--      -> String -> [(Posn,String)]
  ) where


import Language.Preprocessor.Cpphs.SymTab
import Text.ParserCombinators.HuttonMeijer
-- import HashDefine
import Language.Preprocessor.Cpphs.Position  (Posn,newfile,newline,newlines,cppline,newpos)
import Language.Preprocessor.Cpphs.ReadFirst (readFirst)
import Language.Preprocessor.Cpphs.Tokenise  (linesCpp,reslash)
import Char      (isDigit)
import Numeric   (readHex,readOct,readDec)
import System.IO.Unsafe (unsafePerformIO)
import IO        (hPutStrLn,stderr)

-- | Run a first pass of cpp, evaluating \#ifdef's and processing \#include's,
--   whilst taking account of \#define's and \#undef's as we encounter them.
cppIfdef :: FilePath		-- ^ File for error reports
	-> [(String,String)]	-- ^ Pre-defined symbols and their values
	-> [String]		-- ^ Search path for \#includes
	-> Bool			-- ^ Leave \#define and \#undef in output?
	-> Bool			-- ^ Place \#line droppings in output?
	-> String		-- ^ The input file content
	-> [(Posn,String)]	-- ^ The file after processing (in lines)
cppIfdef fp syms search leave locat =
    cpp posn defs search leave locat Keep . (cppline posn:) . linesCpp
  where
    posn = newfile fp
    defs = foldr insertST emptyST syms
-- Notice that the symbol table is a very simple one mapping strings
-- to strings.  This pass does not need anything more elaborate, in
-- particular it is not required to deal with any parameterised macros.


-- | Internal state for whether lines are being kept or dropped.
--   In @Drop n b@, @n@ is the depth of nesting, @b@ is whether
--   we have already succeeded in keeping some lines in a chain of
--   @elif@'s
data KeepState = Keep | Drop Int Bool

-- | Return just the list of lines that the real cpp would decide to keep.
cpp :: Posn -> SymTab String -> [String] -> Bool -> Bool -> KeepState
       -> [String] -> [(Posn,String)]
cpp _ _ _ _ _ _ [] = []

cpp p syms path leave ln Keep (l@('#':x):xs) =
    let ws = words x
        cmd = head ws
        sym = head (tail ws)
        rest = tail (tail ws)
        val  = maybe "1" id (un rest)
        un v = if null v then Nothing else Just (unwords v)
        down = if definedST sym syms then (Drop 1 False) else Keep
        up   = if definedST sym syms then Keep else (Drop 1 False)
        keep str = if gatherDefined p syms str then Keep else (Drop 1 False)
        skipn cpp' p' syms' path' ud xs' =
            let n = 1 + length (filter (=='\n') l) in
            (if leave then ((p,reslash l):) else (replicate n (p,"") ++)) $
            cpp' (newlines n p') syms' path' leave ln ud xs'
    in case cmd of
	"define" -> skipn cpp p (insertST (sym,val) syms) path Keep xs
	"undef"  -> skipn cpp p (deleteST sym syms) path Keep xs
	"ifndef" -> skipn cpp p syms path  down xs
	"ifdef"  -> skipn cpp p syms path  up   xs
	"if"     -> skipn cpp p syms path (keep (unwords (tail ws))) xs
	"else"   -> skipn cpp p syms path (Drop 1 False) xs
	"elif"   -> skipn cpp p syms path (Drop 1 True) xs
	"endif"  -> skipn cpp p syms path  Keep xs
	"pragma" -> skipn cpp p syms path  Keep xs
        ('!':_)  -> skipn cpp p syms path Keep xs	-- \#!runhs scripts
	"include"-> let (inc,content) =
	                  unsafePerformIO (readFirst (unwords (tail ws))
                                                     p path syms)
	            in
		    cpp p syms path leave ln Keep (("#line 1 "++show inc)
                                                  : linesCpp content
                                                  ++ cppline p :"": xs)
	"warning"-> unsafePerformIO $ do
                       hPutStrLn stderr (l++"\nin "++show p)
                       return $ skipn cpp p syms path Keep xs
	"error"  -> error (l++"\nin "++show p)
	"line"   | all isDigit sym
	         -> (if ln then ((p,l):) else id) $
                    cpp (newpos (read sym) (un rest) p)
                        syms path leave ln Keep xs
	n | all isDigit n
	         -> (if ln then ((p,l):) else id) $
	            cpp (newpos (read n) (un (tail ws)) p)
                        syms path leave ln Keep xs
          | otherwise
	         -> unsafePerformIO $ do
                       hPutStrLn stderr ("Warning: unknown directive #"++n
                                        ++"\nin "++show p)
                       return $
                         ((p,l): cpp (newline p) syms path leave ln Keep xs)

cpp p syms path leave ln (Drop n b) (('#':x):xs) =
    let ws = words x
        cmd = head ws
        delse    | n==1 && b = Drop 1 b
                 | n==1      = Keep
                 | otherwise = Drop n b
        dend     | n==1      = Keep
                 | otherwise = Drop (n-1) b
        keep str | n==1      = if not b && gatherDefined p syms str then Keep
                               else (Drop 1) b
                 | otherwise = Drop n b
        skipn cpp' p' syms' path' ud xs' =
                 let n' = 1 + length (filter (=='\n') x) in
                 replicate n' (p,"")
                 ++ cpp' (newlines n' p') syms' path' leave ln ud xs'
    in
    if      cmd == "ifndef" ||
            cmd == "if"     ||
            cmd == "ifdef"  then  skipn cpp p syms path (Drop (n+1) b) xs
    else if cmd == "elif"   then  skipn cpp p syms path
                                                  (keep (unwords (tail ws))) xs
    else if cmd == "else"   then  skipn cpp p syms path delse xs
    else if cmd == "endif"  then  skipn cpp p syms path dend xs
    else skipn cpp p syms path (Drop n b) xs
	-- define, undef, include, error, warning, pragma, line

cpp p syms path leave ln Keep (x:xs) =
    let p' = newline p in seq p' $
    (p,x):  cpp p' syms path leave ln Keep xs
cpp p syms path leave ln d@(Drop _ _) (_:xs) =
    let p' = newline p in seq p' $
    (p,""): cpp p' syms path leave ln d xs


----
gatherDefined :: Posn -> SymTab String -> String -> Bool
gatherDefined p st inp =
  case papply (parseBoolExp st) inp of
    []      -> error ("Cannot parse #if directive in file "++show p)
    [(b,_)] -> b
    _       -> error ("Ambiguous parse for #if directive in file "++show p)

parseBoolExp :: SymTab String -> Parser Bool
parseBoolExp st =
  do  a <- parseExp1 st
      skip (string "||")
      b <- first (skip (parseBoolExp st))
      return (a || b)
  +++
      parseExp1 st

parseExp1 :: SymTab String -> Parser Bool
parseExp1 st =
  do  a <- parseExp0 st
      skip (string "&&")
      b <- first (skip (parseExp1 st))
      return (a && b)
  +++
      parseExp0 st

parseExp0 :: SymTab String -> Parser Bool
parseExp0 st =
  do  skip (string "defined")
      sym <- bracket (skip (char '(')) (skip (many1 alphanum)) (skip (char ')'))
      return (definedST sym st)
  +++
  do  bracket (skip (char '(')) (parseBoolExp st) (skip (char ')'))
  +++
  do  skip (char '!')
      a <- parseExp0 st
      return (not a)
  +++
  do  sym1 <- skip (many1 alphanum)
      op <- parseOp st
      sym2 <- skip (many1 alphanum)
      let val1 = convert sym1 st
      let val2 = convert sym2 st
      return (op val1 val2)
  +++
  do  sym <- skip (many1 alphanum)
      case convert sym st of
        0 -> return False
        _ -> return True
  where
    convert sym st' =
      case lookupST sym st' of
        Nothing  -> safeRead sym
        (Just a) -> safeRead a
    safeRead s =
      case s of
        '0':'x':s' -> number readHex s'
        '0':'o':s' -> number readOct s'
        _          -> number readDec s
    number rd s =
      case rd s of
        []        -> 0 :: Integer
        ((n,_):_) -> n :: Integer

parseOp :: SymTab String -> Parser (Integer -> Integer -> Bool)
parseOp _ =
  do  skip (string ">=")
      return (>=)
  +++
  do  skip (char '>')
      return (>)
  +++
  do  skip (string "<=")
      return (<=)
  +++
  do  skip (char '<')
      return (<)
  +++
  do  skip (string "==")
      return (==)
  +++
  do  skip (string "!=")
      return (/=)
-----------------------------------------------------------------------------
-- |
-- Module      :  HashDefine
-- Copyright   :  2004 Malcolm Wallace
-- Licence     :  LGPL
--
-- Maintainer  :  Malcolm Wallace <Malcolm.Wallace@cs.york.ac.uk>
-- Stability   :  experimental
-- Portability :  All
--
-- What structures are declared in a \#define.
-----------------------------------------------------------------------------
 
module Language.Preprocessor.Cpphs.HashDefine
  ( HashDefine(..)
  , ArgOrText(..)
  , expandMacro
  , parseHashDefine
  ) where

import Char (isSpace)
import List (intersperse)

data HashDefine
	= LineDrop
		{ name :: String }
	| SymbolReplacement
		{ name		:: String
		, replacement	:: String
		, linebreaks    :: Int
		}
	| MacroExpansion
		{ name		:: String
		, arguments	:: [String]
		, expansion	:: [(ArgOrText,String)]
		, linebreaks    :: Int
		}
    deriving (Eq,Show)

-- | 'smart' constructor to avoid warnings from ghc (undefined fields)
symbolReplacement :: HashDefine
symbolReplacement =
    SymbolReplacement
	 { name=undefined, replacement=undefined, linebreaks=undefined }

-- | Macro expansion text is divided into sections, each of which is classified
--   as one of three kinds: a formal argument (Arg), plain text (Text),
--   or a stringised formal argument (Str).
data ArgOrText = Arg | Text | Str deriving (Eq,Show)

-- | Expand an instance of a macro.
--   Precondition: got a match on the macro name.
expandMacro :: HashDefine -> [String] -> Bool -> String
expandMacro macro parameters layout =
    let env = zip (arguments macro) parameters
        replace (Arg,s)  = maybe (error "formal param") id (lookup s env)
        replace (Str,s)  = maybe (error "formal param") str (lookup s env)
        replace (Text,s) = if layout then s else filter (/='\n') s
        str s = '"':s++"\""
    in
    concatMap replace (expansion macro)

-- | Parse a \#define, or \#undef, ignoring other \# directives
parseHashDefine :: Bool -> [String] -> Maybe HashDefine
parseHashDefine ansi def = (command . skip) def
  where
    skip xss@(x:xs) | all isSpace x = skip xs
                    | otherwise     = xss
    skip    []      = []
    command ("line":xs)   = Just (LineDrop ("#line"++concat xs))
    command ("define":xs) = Just (((define . skip) xs) { linebreaks=count def })
    command ("undef":xs)  = Just (((undef  . skip) xs) { linebreaks=count def })
    command _             = Nothing
    undef  (sym:_)   = symbolReplacement { name=sym, replacement=sym }
    define (sym:xs)  = case {-skip-} xs of
                           ("(":ys) -> (macroHead sym [] . skip) ys
                           ys       -> symbolReplacement
                                           { name=sym
                                           , replacement=chop (skip ys) }
    macroHead sym args (",":xs) = (macroHead sym args . skip) xs
    macroHead sym args (")":xs) = MacroExpansion
                                    { name =sym , arguments = reverse args
                                    , expansion = classifyRhs args (skip xs)
                                    , linebreaks = undefined }
    macroHead sym args (var:xs) = (macroHead sym (var:args) . skip) xs
    macroHead sym args []       = error ("incomplete macro definition:\n"
                                        ++"  #define "++sym++"("
                                        ++concat (intersperse "," args))
    classifyRhs args ("#":x:xs)
                          | ansi &&
                            x `elem` args    = (Str,x): classifyRhs args xs
    classifyRhs args ("##":xs)
                          | ansi             = classifyRhs args xs
    classifyRhs args (word:xs)
                          | word `elem` args = (Arg,word): classifyRhs args xs
                          | otherwise        = (Text,word): classifyRhs args xs
    classifyRhs _    []                      = []
    count = length . filter (=='\n') . concat
    chop  = concat . reverse . dropWhile (all isSpace) . reverse

-----------------------------------------------------------------------------
-- |
-- Module      :  MacroPass
-- Copyright   :  2004 Malcolm Wallace
-- Licence     :  LGPL
--
-- Maintainer  :  Malcolm Wallace <Malcolm.Wallace@cs.york.ac.uk>
-- Stability   :  experimental
-- Portability :  All
--
-- Perform a cpp.second-pass, accumulating \#define's and \#undef's,
-- whilst doing symbol replacement and macro expansion.
-----------------------------------------------------------------------------

module Language.Preprocessor.Cpphs.MacroPass
  ( macroPass
  , preDefine
  ) where

import Language.Preprocessor.Cpphs.HashDefine (HashDefine(..), expandMacro)
import Language.Preprocessor.Cpphs.Tokenise   (tokenise, WordStyle(..), parseMacroCall)
import Language.Preprocessor.Cpphs.SymTab     (SymTab, lookupST, insertST, emptyST)
import Language.Preprocessor.Cpphs.Position   (Posn, newfile, filename, lineno)
import System.IO.Unsafe (unsafePerformIO)
import Time       (getClockTime, toCalendarTime, formatCalendarTime)
import Locale     (defaultTimeLocale)

noPos :: Posn
noPos = newfile "preDefined"

-- | Walk through the document, replacing calls of macros with their expanded RHS.
macroPass :: [(String,String)]	-- ^ Pre-defined symbols and their values
          -> Bool		-- ^ Strip C-comments?
          -> Bool		-- ^ Accept \# and \## operators?
          -> Bool		-- ^ Retain layout in macros?
          -> Bool		-- ^ Input language (Haskell\/not)
          -> [(Posn,String)]	-- ^ The input file content
          -> String		-- ^ The file after processing
macroPass syms strip hashes layout language =
    safetail		-- to remove extra "\n" inserted below
    . concat
    . macroProcess layout language (preDefine hashes language syms)
    . tokenise strip hashes language
    . ((noPos,""):)	-- ensure recognition of "\n#" at start of file
  where
    safetail [] = []
    safetail (_:xs) = xs


-- | Turn command-line definitions (from @-D@) into 'HashDefine's.
preDefine :: Bool -> Bool -> [(String,String)] -> SymTab HashDefine
preDefine hashes lang defines =
    foldr (insertST.defval) emptyST defines
  where
    defval (s,d) =
        let (Cmd (Just hd):_) = tokenise True hashes lang
                                   [(noPos,"\n#define "++s++" "++d++"\n")]
        in (name hd, hd)


-- | Trundle through the document, one word at a time, using the WordStyle
--   classification introduced by 'tokenise' to decide whether to expand a
--   word or macro.  Encountering a \#define or \#undef causes that symbol to
--   be overwritten in the symbol table.  Any other remaining cpp directives
--   are discarded and replaced with blanks, except for \#line markers.
--   All valid identifiers are checked for the presence of a definition
--   of that name in the symbol table, and if so, expanded appropriately.
macroProcess :: Bool -> Bool -> SymTab HashDefine -> [WordStyle] -> [String]
macroProcess _ _ _         []                    = []
macroProcess y l st (Other x: ws)                = x:    macroProcess y l st ws
macroProcess y l st (Cmd Nothing: ws)            = "\n": macroProcess y l st ws
macroProcess y l st (Cmd (Just (LineDrop x)): ws)= "\n":x:macroProcess y l st ws
macroProcess layout lang st (Cmd (Just hd): ws)  =
    let n = 1 + linebreaks hd in
    replicate n "\n" ++ macroProcess layout lang (insertST (name hd, hd) st) ws
macroProcess layout lang st (Ident p x: ws) =
    case x of
      "__FILE__" -> show (filename p): macroProcess layout lang st ws
      "__LINE__" -> show (lineno p):   macroProcess layout lang st ws
      "__DATE__" -> formatCalendarTime defaultTimeLocale "\"%d %b %Y\""
                        (unsafePerformIO (getClockTime>>=toCalendarTime)):
                                       macroProcess layout lang st ws
      "__TIME__" -> formatCalendarTime defaultTimeLocale "\"%H:%M:%S\""
                        (unsafePerformIO (getClockTime>>=toCalendarTime)):
                                       macroProcess layout lang st ws
      _ ->
        case lookupST x st of
            Nothing -> x: macroProcess layout lang st ws
            Just hd ->
                case hd of
                    SymbolReplacement _ r _ ->
                        -- one-level expansion only:
                        -- r: macroProcess layout st ws
                        -- multi-level expansion:
                        let r' = if layout then r else filter (/='\n') r in
                        macroProcess layout lang st
                                     (tokenise True False lang [(p,r')]
                                      ++ ws)
                    MacroExpansion _ _ _ _  ->
                        case parseMacroCall ws of
                            Nothing -> x: macroProcess layout lang st ws
                            Just (args,ws') ->
                                if length args /= length (arguments hd) then
                                     x: macroProcess layout lang st ws
                                else -- one-level expansion only:
                                     -- expandMacro hd args layout:
                                     --         macroProcess layout st ws'
                                     -- multi-level expansion:
                                     macroProcess layout lang st
                                              (tokenise True False lang
                                                [(p,expandMacro hd args layout)]
                                               ++ ws')

-----------------------------------------------------------------------------
-- |
-- Module      :  Options
-- Copyright   :  2006 Malcolm Wallace
-- Licence     :  LGPL
--
-- Maintainer  :  Malcolm Wallace <Malcolm.Wallace@cs.york.ac.uk>
-- Stability   :  experimental
-- Portability :  All
--
-- This module deals with Cpphs options and parsing them
-----------------------------------------------------------------------------

module Language.Preprocessor.Cpphs.Options(CpphsOption(..), parseOption) where

import Maybe

data CpphsOption
    = CpphsNoMacro
    | CpphsNoLine
    | CpphsText
    | CpphsStrip
    | CpphsAnsi
    | CpphsLayout
    | CpphsUnlit
    | CpphsMacro (String,String)
    | CpphsPath String
      deriving (Eq, Show)
    
    
flags = [ ("--nomacro", CpphsNoMacro)
        , ("--noline",  CpphsNoLine)
        , ("--text",    CpphsText)
        , ("--strip",   CpphsStrip)
        , ("--hashes",  CpphsAnsi)
        , ("--layout",  CpphsLayout)
        , ("--unlit",   CpphsUnlit)
        ]


parseOption :: String -> Maybe CpphsOption
parseOption x | isJust a = Just $ fromJust a
    where a = lookup x flags

parseOption ('-':'D':xs) = Just $ CpphsMacro (s, if null d then "1" else tail d)
    where (s,d) = break (=='=') xs
    
parseOption ('-':'I':xs) = Just $ CpphsPath $ trail "/\\" xs

parseOption _ = Nothing

trail :: (Eq a) => [a] -> [a] -> [a]
trail xs = reverse . dropWhile (`elem`xs) . reverse

-----------------------------------------------------------------------------
-- |
-- Module      :  Position
-- Copyright   :  2000-2004 Malcolm Wallace
-- Licence     :  LGPL
--
-- Maintainer  :  Malcolm Wallace <Malcolm.Wallace@cs.york.ac.uk>
-- Stability   :  experimental
-- Portability :  All
--
-- Simple file position information, with recursive inclusion points.
-----------------------------------------------------------------------------

module Language.Preprocessor.Cpphs.Position
  ( Posn(..)
  , newfile
  , addcol, newline, tab, newlines, newpos
  , cppline
  , filename, lineno, directory
  ) where

-- | Source positions contain a filename, line, column, and an
--   inclusion point, which is itself another source position,
--   recursively.
data Posn = Pn String !Int !Int (Maybe Posn)
        deriving (Eq)

instance Show Posn where
      showsPrec _ (Pn f l c i) = showString f .
                                 showString "  at line " . shows l .
                                 showString " col " . shows c .
                                 ( case i of
                                    Nothing -> id
                                    Just p  -> showString "\n    used by  " .
                                               shows p )

-- | Constructor
newfile :: String -> Posn
newfile name = Pn name 1 1 Nothing

-- | Updates
addcol :: Int -> Posn -> Posn
addcol n (Pn f r c i) = Pn f r (c+n) i

newline, tab :: Posn -> Posn
--newline (Pn f r _ i) = Pn f (r+1) 1 i
newline (Pn f r _ i) = let r' = r+1 in r' `seq` Pn f r' 1 i
tab     (Pn f r c i) = Pn f r (((c`div`8)+1)*8) i

newlines :: Int -> Posn -> Posn
newlines n (Pn f r _ i) = Pn f (r+n) 1 i

newpos :: Int -> Maybe String -> Posn -> Posn
newpos r Nothing  (Pn f _ c i) = Pn f r c i
newpos r (Just ('"':f)) (Pn _ _ c i) = Pn (init f) r c i
newpos r (Just f)       (Pn _ _ c i) = Pn f r c i

-- | Projections

lineno    :: Posn -> Int
filename  :: Posn -> String
directory :: Posn -> FilePath

lineno    (Pn _ r _ _) = r
filename  (Pn f _ _ _) = f
directory (Pn f _ _ _) = dirname f


-- | cpp-style printing
cppline :: Posn -> String
cppline (Pn f r _ _) = "#line "++show r++" "++show f

                                                                                
-- | Strip non-directory suffix from file name (analogous to the shell
--   command of the same name).
dirname :: String -> String
dirname  = reverse . safetail . dropWhile (not.(`elem`"\\/")) . reverse
  where safetail [] = []
        safetail (_:x) = x

-----------------------------------------------------------------------------
-- |
-- Module      :  ReadFirst
-- Copyright   :  2004 Malcolm Wallace
-- Licence     :  LGPL
-- 
-- Maintainer  :  Malcolm Wallace <Malcolm.Wallace@cs.york.ac.uk>
-- Stability   :  experimental
-- Portability :  All
--
-- Read the first file that matches in a list of search paths.
-----------------------------------------------------------------------------

module Language.Preprocessor.Cpphs.ReadFirst
  ( readFirst
  ) where

import IO        (hPutStrLn, stderr)
import Directory (doesFileExist)
import List      (intersperse)
import Language.Preprocessor.Cpphs.Position  (Posn,directory)
import Language.Preprocessor.Cpphs.SymTab    (SymTab,lookupST)

-- | Attempt to read the given file from any location within the search path.
--   The first location found is returned, together with the file content.
--   (The directory of the calling file is always searched first, then
--    the current directory, finally any specified search path.)
readFirst :: String		-- ^ filename
	-> Posn			-- ^ inclusion point
	-> [String]		-- ^ search path
	-> SymTab String	-- ^ \#defined symbols
	-> IO ( FilePath
              , String
              )			-- ^ discovered filepath, and file contents

readFirst name demand path syms =
    try (cons dd (".":path))
  where
    dd = directory demand
    cons x xs = if null x then xs else x:xs
    realname = real name syms
    try [] = do
        hPutStrLn stderr ("Warning: Can't find file \""++realname
                         ++"\" in directories\n\t"
                         ++concat (intersperse "\n\t" (cons dd (".":path)))
                         ++"\n  Asked for by: "++show demand)
        return ("missing file: "++realname,"")
    try (p:ps) = do
        let file = p++'/':realname
        ok <- doesFileExist file
        if not ok then try ps
          else do content <- readFile file
                  return (file,content)

real :: String -> SymTab String -> String
real name syms = case name of
                   ('"':ns) -> init ns
                   ('<':ns) -> init ns
                   _        -> case lookupST name syms of
                                 Nothing -> name
                                 Just f  -> real f syms

{-
-- The main program for cpphs, a simple C pre-processor written in Haskell.

-- Copyright (c) 2004 Malcolm Wallace
-- This file is GPL, although the libraries it uses are either standard
-- Haskell'98 or distributed under the LGPL.
-}
module Language.Preprocessor.Cpphs.RunCpphs ( runCpphs ) where

import Language.Preprocessor.Cpphs.CppIfdef (cppIfdef)
import Language.Preprocessor.Cpphs.MacroPass(macroPass)
import Language.Preprocessor.Cpphs.Options(CpphsOption(..), parseOption)
import Language.Preprocessor.Unlit as Unlit (unlit)


runCpphs :: [CpphsOption] -> FilePath -> String -> IO String
runCpphs opts filename input = do
  let ds = [x | CpphsMacro x <- opts]
      is = [x | CpphsPath x <- opts]
      macro = not (CpphsNoMacro `elem` opts)
      locat = not (CpphsNoLine  `elem` opts)
      lang  = not (CpphsText    `elem` opts)
      strip =      CpphsStrip   `elem` opts
      ansi  =      CpphsAnsi    `elem` opts
      layout=      CpphsLayout  `elem` opts
      unlit =      CpphsUnlit   `elem` opts

  let pass1 = cppIfdef filename ds is macro locat input
      pass2 = macroPass ds strip ansi layout lang pass1
      result = if not macro then unlines (map snd pass1) else pass2
      pass3 = if unlit then Unlit.unlit filename result else result

  return pass3
-----------------------------------------------------------------------------
-- |
-- Module      :  SymTab
-- Copyright   :  2000-2004 Malcolm Wallace
-- Licence     :  LGPL
-- 
-- Maintainer  :  Malcolm Wallace <Malcolm.Wallace@cs.york.ac.uk>
-- Stability   :  Stable
-- Portability :  All
--
-- Symbol Table, based on index trees using a hash on the key.
--   Keys are always Strings.  Stored values can be any type.
-----------------------------------------------------------------------------

module Language.Preprocessor.Cpphs.SymTab
  ( SymTab
  , emptyST
  , insertST
  , deleteST
  , lookupST
  , definedST
  , IndTree
  ) where

-- | Symbol Table.  Stored values are polymorphic, but the keys are
--   always strings.
type SymTab v = IndTree [(String,v)]

emptyST   :: SymTab v
insertST  :: (String,v) -> SymTab v -> SymTab v
deleteST  :: String -> SymTab v -> SymTab v
lookupST  :: String -> SymTab v -> Maybe v
definedST :: String -> SymTab v -> Bool

emptyST           = itgen maxHash []
insertST (s,v) ss = itiap (hash s) ((s,v):)    ss id
deleteST  s    ss = itiap (hash s) (filter ((/=s).fst)) ss id
lookupST  s    ss = let vs = filter ((==s).fst) ((itind (hash s)) ss)
                    in if null vs then Nothing
                       else (Just . snd . head) vs
definedST s    ss = let vs = filter ((==s).fst) ((itind (hash s)) ss)
                    in (not . null) vs


----
-- | Index Trees (storing indexes at nodes).

data IndTree t = Leaf t | Fork Int (IndTree t) (IndTree t)
     deriving Show

itgen :: Int -> a -> IndTree a
itgen 1 x = Leaf x
itgen n x =
  let n' = n `div` 2
  in Fork n' (itgen n' x) (itgen (n-n') x)

itiap :: --Eval a =>
         Int -> (a->a) -> IndTree a -> (IndTree a -> b) -> b
itiap _ f (Leaf x)       k = let fx = f x in {-seq fx-} (k (Leaf fx))
itiap i f (Fork n lt rt) k =
  if i<n then
       itiap i f lt $ \lt' -> k (Fork n lt' rt)
  else itiap (i-n) f rt $ \rt' -> k (Fork n lt rt')

itind :: Int -> IndTree a -> a  
itind _ (Leaf x) = x
itind i (Fork n lt rt) = if i<n then itind i lt else itind (i-n) rt


----
-- Hash values

maxHash :: Int -- should be prime
maxHash = 101

class Hashable a where
    hashWithMax :: Int -> a -> Int
    hash        :: a -> Int
    hash = hashWithMax maxHash

instance Enum a => Hashable [a] where
    hashWithMax m = h 0
        where h a []     = a
              h a (c:cs) = h ((17*(fromEnum c)+19*a)`rem`m) cs

----
-----------------------------------------------------------------------------
-- |
-- Module      :  Tokenise
-- Copyright   :  2004 Malcolm Wallace
-- Licence     :  LGPL
--
-- Maintainer  :  Malcolm Wallace <Malcolm.Wallace@cs.york.ac.uk>
-- Stability   :  experimental
-- Portability :  All
--
-- The purpose of this module is to lex a source file (language
-- unspecified) into tokens such that cpp can recognise a replaceable
-- symbol or macro-use, and do the right thing.
-----------------------------------------------------------------------------

module Language.Preprocessor.Cpphs.Tokenise
  ( linesCpp
  , reslash
  , tokenise
  , WordStyle(..)
  , deWordStyle
  , parseMacroCall
  ) where

import Char
import Language.Preprocessor.Cpphs.HashDefine
import Language.Preprocessor.Cpphs.Position

-- | A Mode value describes whether to tokenise a la Haskell, or a la Cpp.
--   The main difference is that in Cpp mode we should recognise line
--   continuation characters.
data Mode = Haskell | Cpp

-- | linesCpp is, broadly speaking, Prelude.lines, except that
--   on a line beginning with a \#, line continuation characters are
--   recognised.  In a line continuation, the newline character is
--   preserved, but the backslash is not.
linesCpp :: String -> [String]
linesCpp  []                 = []
linesCpp (x:xs) | x=='#'     = tok Cpp     ['#'] xs
                | otherwise  = tok Haskell [] (x:xs)
  where
    tok Cpp   acc ('\\':'\n':ys)   = tok Cpp ('\n':acc) ys
    tok _     acc ('\n':'#':ys)    = reverse acc: tok Cpp ['#'] ys
    tok _     acc ('\n':ys)        = reverse acc: tok Haskell [] ys
    tok _     acc []               = reverse acc: []
    tok mode  acc (y:ys)           = tok mode (y:acc) ys

-- | Put back the line-continuation characters.
reslash :: String -> String
reslash ('\n':xs) = '\\':'\n':reslash xs
reslash (x:xs)    = x: reslash xs
reslash   []      = []

----
-- | Submodes are required to deal correctly with nesting of lexical
--   structures.
data SubMode = Any | Pred (Char->Bool) (Posn->String->WordStyle)
             | String Char | LineComment | NestComment Int
             | CComment

-- | Each token is classified as one of Ident, Other, or Cmd:
--   * Ident is a word that could potentially match a macro name.
--   * Cmd is a complete cpp directive (\#define etc).
--   * Other is anything else.
data WordStyle = Ident Posn String | Other String | Cmd (Maybe HashDefine)
  deriving (Eq,Show)
other _ s = Other s

deWordStyle :: WordStyle -> String
deWordStyle (Ident _ i) = i
deWordStyle (Other i)   = i
deWordStyle (Cmd _)     = "\n"

-- | tokenise is, broadly-speaking, Prelude.words, except that:
--    * the input is already divided into lines
--    * each word-like "token" is categorised as one of {Ident,Other,Cmd}
--    * \#define's are parsed and returned out-of-band using the Cmd variant
--    * All whitespace is preserved intact as tokens.
--    * C-comments are converted to white-space (depending on first param)
--    * Parens and commas are tokens in their own right.
--    * Any cpp line continuations are respected.
--   No errors can be raised.
--   The inverse of tokenise is (concatMap deWordStyle).
tokenise :: Bool -> Bool -> Bool -> [(Posn,String)] -> [WordStyle]
tokenise _     _    _     [] = []
tokenise strip ansi lang ((pos,str):pos_strs) =
    (if lang then haskell else plaintext) Any [] pos pos_strs str
 where
    -- rules to lex Haskell
  haskell :: SubMode -> String -> Posn -> [(Posn,String)]
             -> String -> [WordStyle]
  haskell Any acc p ls ('\n':'#':xs)      = emit acc $  -- emit "\n" $
                                            cpp Any haskell [] [] p ls xs
    -- warning: non-maximal munch on comment
  haskell Any acc p ls ('-':'-':xs)       = emit acc $
                                            haskell LineComment "--" p ls xs
  haskell Any acc p ls ('{':'-':xs)       = emit acc $
                                            haskell (NestComment 0) "-{" p ls xs
  haskell Any acc p ls ('/':'*':xs)|strip = emit acc $
                                            haskell CComment "  " p ls xs
  haskell Any acc p ls ('"':xs)           = emit acc $
                                            haskell (String '"') ['"'] p ls xs
  haskell Any acc p ls ('\'':xs)          = emit acc $
                                            haskell (String '\'') "'" p ls xs
  haskell Any acc p ls (x:xs) | single x  = emit acc $ emit [x] $
                                            haskell Any [] p ls xs
  haskell Any acc p ls (x:xs) | space x   = emit acc $
                                            haskell (Pred space other) [x]
                                                                        p ls xs
  haskell Any acc p ls (x:xs) | symbol x  = emit acc $
                                            haskell (Pred symbol other) [x]
                                                                        p ls xs
 -- haskell Any [] p ls (x:xs) | ident0 x  = id $
  haskell Any acc p ls (x:xs) | ident0 x  = emit acc $
                                            haskell (Pred ident1 Ident) [x]
                                                                        p ls xs
  haskell Any acc p ls (x:xs)             = haskell Any (x:acc) p ls xs

  haskell pre@(Pred pred ws) acc p ls (x:xs)
                        | pred x    = haskell pre (x:acc) p ls xs
                        | otherwise = ws p (reverse acc):
                                      haskell Any [] p ls (x:xs)
  haskell (Pred _ ws) acc p [] []   = ws p (reverse acc): []
  haskell (String c) acc p ls ('\\':x:xs)
                        | x=='\\'   = haskell (String c) ('\\':'\\':acc) p ls xs
                        | x==c      = haskell (String c) (c:'\\':acc) p ls xs
  haskell (String c) acc p ls (x:xs)
                        | x==c      = emit (c:acc) $ haskell Any [] p ls xs
                        | otherwise = haskell (String c) (x:acc) p ls xs
  haskell LineComment acc p ls xs@('\n':_) = emit acc $ haskell Any [] p ls xs
  haskell LineComment acc p ls (x:xs)      = haskell LineComment (x:acc) p ls xs
  haskell (NestComment n) acc p ls ('{':'-':xs)
                                    = haskell (NestComment (n+1))
                                                            ("-{"++acc) p ls xs
  haskell (NestComment 0) acc p ls ('-':'}':xs)
                                    = emit ("}-"++acc) $ haskell Any [] p ls xs
  haskell (NestComment n) acc p ls ('-':'}':xs)
                                    = haskell (NestComment (n-1))
                                                            ("}-"++acc) p ls xs
  haskell (NestComment n) acc p ls (x:xs) = haskell (NestComment n) (x:acc)
                                                                        p ls xs
  haskell CComment acc p ls ('*':'/':xs)  = emit ("  "++acc) $
                                            haskell Any [] p ls xs
  haskell CComment acc p ls (_:xs)        = haskell CComment (' ':acc) p ls xs
  haskell mode acc _ ((p,l):ls) []        = haskell mode acc p ls ('\n':l)
  haskell _    acc _ [] []                = emit acc $ []

  -- rules to lex Cpp
  cpp :: SubMode -> (SubMode -> String -> Posn -> [(Posn,String)]
                     -> String -> [WordStyle])
         -> String -> [String] -> Posn -> [(Posn,String)]
         -> String -> [WordStyle]
  cpp mode next word line pos remaining input =
    lexcpp mode word line remaining input
   where
    lexcpp Any w l ls ('/':'*':xs)   = lexcpp (NestComment 0) "" (w*/*l) ls xs
    lexcpp Any w l ls ('/':'/':xs)   = lexcpp LineComment "  " (w*/*l) ls xs
    lexcpp Any w l ((p,l'):ls) ('\\':[])  = cpp Any next [] ("\n":w*/*l) p ls l'
    lexcpp Any w l ls ('\\':'\n':xs) = lexcpp Any [] ("\n":w*/*l) ls xs
    lexcpp Any w l ls xs@('\n':_)    = Cmd (parseHashDefine ansi
                                                           (reverse (w*/*l))):
                                       next Any [] pos ls xs
 -- lexcpp Any w l ls ('"':xs)     = lexcpp (String '"') ['"'] (w*/*l) ls xs
 -- lexcpp Any w l ls ('\'':xs)    = lexcpp (String '\'') "'"  (w*/*l) ls xs
    lexcpp Any w l ls ('"':xs)       = lexcpp Any [] ("\"":(w*/*l)) ls xs
    lexcpp Any w l ls ('\'':xs)      = lexcpp Any [] ("'": (w*/*l)) ls xs
    lexcpp Any [] l ls (x:xs)
                    | ident0 x  = lexcpp (Pred ident1 Ident) [x] l ls xs
 -- lexcpp Any w l ls (x:xs) | ident0 x  = lexcpp (Pred ident1 Ident) [x] (w*/*l) ls xs
    lexcpp Any w l ls (x:xs)
                    | single x  = lexcpp Any [] ([x]:w*/*l) ls xs
                    | space x   = lexcpp (Pred space other) [x] (w*/*l) ls xs
                    | symbol x  = lexcpp (Pred symbol other) [x] (w*/*l) ls xs
                    | otherwise = lexcpp Any (x:w) l ls xs
    lexcpp pre@(Pred pred _) w l ls (x:xs)
                    | pred x    = lexcpp pre (x:w) l ls xs
                    | otherwise = lexcpp Any [] (w*/*l) ls (x:xs)
    lexcpp      (Pred _ _) w l [] []      = lexcpp Any [] (w*/*l) [] "\n"
    lexcpp (String c) w l ls ('\\':x:xs)
                    | x=='\\'   = lexcpp (String c) ('\\':'\\':w) l ls xs
                    | x==c      = lexcpp (String c) (c:'\\':w) l ls xs
    lexcpp (String c) w l ls (x:xs)
                    | x==c      = lexcpp Any [] ((c:w)*/*l) ls xs
                    | otherwise = lexcpp (String c) (x:w) l ls xs
    lexcpp LineComment w l ((p,l'):ls) ('\\':[])
                             = cpp LineComment next [] (('\n':w)*/*l) pos ls l'
    lexcpp LineComment w l ls ('\\':'\n':xs)
                                = lexcpp LineComment [] (('\n':w)*/*l) ls xs
    lexcpp LineComment w l ls xs@('\n':_) = lexcpp Any w l ls xs
    lexcpp LineComment w l ls (_:xs)      = lexcpp LineComment (' ':w) l ls xs
    lexcpp (NestComment _) w l ls ('*':'/':xs)
                                          = lexcpp Any [] (w*/*l) ls xs
    lexcpp (NestComment n) w l ls (_:xs)  = lexcpp (NestComment n) (' ':w) l
                                                                        ls xs
    lexcpp mode w l ((p,l'):ls) []        = cpp mode next w l pos ls ('\n':l')
    lexcpp _    _ _ []          []        = []

    -- rules to lex non-Haskell, non-cpp text
  plaintext :: SubMode -> String -> Posn -> [(Posn,String)]
            -> String -> [WordStyle]
  plaintext Any acc p ls ('\n':'#':xs)  = emit acc $  -- emit "\n" $
                                          cpp Any plaintext [] [] p ls xs
  plaintext Any acc p ls ('/':'*':xs)|strip = emit acc $
                                              plaintext CComment "  " p ls xs
  plaintext Any acc p ls (x:xs) | single x  = emit acc $ emit [x] $
                                              plaintext Any [] p ls xs
  plaintext Any acc p ls (x:xs) | space x   = emit acc $
                                              plaintext (Pred space other) [x]
                                                                        p ls xs
  plaintext Any acc p ls (x:xs) | ident0 x  = emit acc $
                                              plaintext (Pred ident1 Ident) [x]
                                                                        p ls xs
  plaintext Any acc p ls (x:xs)             = plaintext Any (x:acc) p ls xs
  plaintext pre@(Pred pred ws) acc p ls (x:xs)
                                | pred x    = plaintext pre (x:acc) p ls xs
                                | otherwise = ws p (reverse acc):
                                              plaintext Any [] p ls (x:xs)
  plaintext (Pred _ ws) acc p [] []         = ws p (reverse acc): []
  plaintext CComment acc p ls ('*':'/':xs)  = emit ("  "++acc) $
                                              plaintext Any [] p ls xs
  plaintext CComment acc p ls (_:xs)    = plaintext CComment (' ':acc) p ls xs
  plaintext mode acc _ ((p,l):ls) []    = plaintext mode acc p ls ('\n':l)
  plaintext _    acc _ [] []            = emit acc $ []

  -- predicates for lexing Haskell.
  ident0 x = isAlpha x    || x `elem` "_`"
  ident1 x = isAlphaNum x || x `elem` "'_`"
  symbol x = x `elem` ":!#$%&*+./<=>?@\\^|-~"
  single x = x `elem` "(),[];{}"
  space  x = x `elem` " \t"
  -- emit a token (if there is one) from the accumulator
  emit ""  = id
  emit xs  = (Other (reverse xs):)
  -- add a reversed word to the accumulator
  "" */* l = l
  w */* l  = reverse w : l


-- | Parse a possible macro call, returning argument list and remaining input
parseMacroCall :: [WordStyle] -> Maybe ([String],[WordStyle])
parseMacroCall = call . skip
  where
    skip (Other x:xs) | all isSpace x = skip xs
    skip xss                          = xss
    call (Other "(":xs)   = (args (0::Int) [] [] . skip) xs
    call _                = Nothing
    args 0 w acc (Other ",":xs)   = args 0 [] (addone w acc) (skip xs)
    args n w acc (Other "(":xs)   = args (n+1) ("(":w) acc xs
    args 0 w acc (Other ")":xs)   = Just (reverse (addone w acc), xs)
    args n w acc (Other ")":xs)   = args (n-1) (")":w) acc xs
    args n w acc (Ident _ var:xs) = args n (var:w) acc xs
    args n w acc (Other var:xs)   = args n (var:w) acc xs
    args _ _ _   _                = Nothing
    addone w acc = concat (reverse (dropWhile (all isSpace) w)): acc

-----------------------------------------------------------------------------
-- |
-- Module      :  ParseLib
-- Copyright   :  ...
-- Copyright   :  Graham Hutton (University of Nottingham), Erik Meijer (University of Utrecht)
-- 
-- Maintainer  :  Malcolm Wallace <Malcolm.Wallace@cs.york.ac.uk>
-- Stability   :  Stable
-- Portability :  All
--
--                  A LIBRARY OF MONADIC PARSER COMBINATORS
-- 
--                               29th July 1996
-- 
--                  Graham Hutton               Erik Meijer
--             University of Nottingham    University of Utrecht
-- 
-- This Haskell script defines a library of parser combinators, and is
-- taken from sections 1-6 of our article "Monadic Parser Combinators".
-- Some changes to the library have been made in the move from Gofer
-- to Haskell:
-- 
--    * Do notation is used in place of monad comprehension notation;
-- 
--    * The parser datatype is defined using "newtype", to avoid the overhead
--      of tagging and untagging parsers with the P constructor.
-----------------------------------------------------------------------------


module Text.ParserCombinators.HuttonMeijer
   (Parser(..), item, first, papply, (+++), sat, {-tok,-} many, many1,
    sepby, sepby1, chainl,
    chainl1, chainr, chainr1, ops, bracket, char, digit, lower, upper,
    letter, alphanum, string, ident, nat, int, spaces, comment, junk,
    skip, token, natural, integer, symbol, identifier) where

import Char
import Monad

infixr 5 +++

type Token = Char

---------------------------------------------------------
-- | The parser monad

newtype Parser a   = P ([Token] -> [(a,[Token])])

instance Functor Parser where
   -- map         :: (a -> b) -> (Parser a -> Parser b)
   fmap f (P p)    = P (\inp -> [(f v, out) | (v,out) <- p inp])

instance Monad Parser where
   -- return      :: a -> Parser a
   return v        = P (\inp -> [(v,inp)])

   -- >>=         :: Parser a -> (a -> Parser b) -> Parser b
   (P p) >>= f     = P (\inp -> concat [papply (f v) out | (v,out) <- p inp])

   -- fail        :: String -> Parser a
   fail _          = P (\_ -> [])

instance MonadPlus Parser where
   -- mzero       :: Parser a
   mzero           = P (\_ -> [])

   -- mplus       :: Parser a -> Parser a -> Parser a
   (P p) `mplus` (P q)  = P (\inp -> (p inp ++ q inp))

-- ------------------------------------------------------------
-- * Other primitive parser combinators
-- ------------------------------------------------------------

item               :: Parser Token
item                = P (\inp -> case inp of
                                   []     -> []
                                   (x:xs) -> [(x,xs)])

first             :: Parser a -> Parser a
first (P p)        = P (\inp -> case p inp of
                                   []    -> []
                                   (x:_) -> [x])

papply            :: Parser a -> [Token] -> [(a,[Token])]
papply (P p) inp   = p inp

-- ------------------------------------------------------------
-- * Derived combinators
-- ------------------------------------------------------------

(+++)             :: Parser a -> Parser a -> Parser a
p +++ q            = first (p `mplus` q)

sat               :: (Token -> Bool) -> Parser Token
sat p              = do {x <- item; if p x then return x else mzero}

--tok               :: Token -> Parser Token
--tok t              = do {x <- item; if t==snd x then return t else mzero}

many              :: Parser a -> Parser [a]
many p             = many1 p +++ return []
--many p           = force (many1 p +++ return [])

many1             :: Parser a -> Parser [a]
many1 p            = do {x <- p; xs <- many p; return (x:xs)}

sepby             :: Parser a -> Parser b -> Parser [a]
p `sepby` sep      = (p `sepby1` sep) +++ return []

sepby1            :: Parser a -> Parser b -> Parser [a]
p `sepby1` sep     = do {x <- p; xs <- many (do {sep; p}); return (x:xs)}

chainl            :: Parser a -> Parser (a -> a -> a) -> a -> Parser a
chainl p op v      = (p `chainl1` op) +++ return v

chainl1           :: Parser a -> Parser (a -> a -> a) -> Parser a
p `chainl1` op     = do {x <- p; rest x}
                     where
                        rest x = do {f <- op; y <- p; rest (f x y)}
                                 +++ return x

chainr            :: Parser a -> Parser (a -> a -> a) -> a -> Parser a
chainr p op v      = (p `chainr1` op) +++ return v

chainr1           :: Parser a -> Parser (a -> a -> a) -> Parser a
p `chainr1` op     = do {x <- p; rest x}
                     where
                        rest x = do {f <- op; y <- p `chainr1` op; return (f x y)}
                                 +++ return x

ops               :: [(Parser a, b)] -> Parser b
ops xs             = foldr1 (+++) [do {p; return op} | (p,op) <- xs]

bracket           :: Parser a -> Parser b -> Parser c -> Parser b
bracket open p close = do {open; x <- p; close; return x}

-- ------------------------------------------------------------
-- * Useful parsers
-- ------------------------------------------------------------

char              :: Char -> Parser Char
char x             = sat (\y -> x == y)

digit             :: Parser Char
digit              = sat isDigit

lower             :: Parser Char
lower              = sat isLower

upper             :: Parser Char
upper              = sat isUpper

letter            :: Parser Char
letter             = sat isAlpha

alphanum          :: Parser Char
alphanum           = sat isAlphaNum +++ char '_'

string            :: String -> Parser String
string ""          = return ""
string (x:xs)      = do {char x; string xs; return (x:xs)}

ident             :: Parser String
ident              = do {x <- lower; xs <- many alphanum; return (x:xs)}

nat               :: Parser Int
nat                = do {x <- digit; return (fromEnum x - fromEnum '0')} `chainl1` return op
                     where
                        m `op` n = 10*m + n

int               :: Parser Int
int                = do {char '-'; n <- nat; return (-n)} +++ nat

-- ------------------------------------------------------------
-- * Lexical combinators
-- ------------------------------------------------------------

spaces            :: Parser ()
spaces             = do {many1 (sat isSpace); return ()}

comment           :: Parser ()
--comment            = do {string "--"; many (sat (\x -> x /= '\n')); return ()}
--comment            = do 
--                       _ <- string "--"
--                       _ <- many (sat (\x -> x /= '\n'))
--                       return ()
comment            = do
                       bracket (string "/*") (many item) (string "*/")
                       return ()

junk              :: Parser ()
junk               = do {many (spaces +++ comment); return ()}

skip              :: Parser a -> Parser a
skip p             = do {junk; p}

token             :: Parser a -> Parser a
token p            = do {v <- p; junk; return v}

-- ------------------------------------------------------------
-- * Token parsers
-- ------------------------------------------------------------

natural           :: Parser Int
natural            = token nat

integer           :: Parser Int
integer            = token int

symbol            :: String -> Parser String
symbol xs          = token (string xs)

identifier        :: [String] -> Parser String
identifier ks      = token (do {x <- ident;
                                if not (elem x ks) then return x
                                else return mzero})

------------------------------------------------------------------------------
module Array (
    module Ix,  -- export all of Ix for convenience
    Array, array, listArray, (!), bounds, indices, elems, assocs, 
    accumArray, (//), accum, ixmap
  ) where

import Ix
import Data.Array
module Bits (module Data.Bits) where
import Data.Bits

module CError (module Foreign.C.Error) where
import Foreign.C.Error
module CForeign ( module Foreign.C ) where
import Foreign.C
module CPUTime (
    getCPUTime, cpuTimePrecision 
  ) where

import System.CPUTime
module CString (module Foreign.C.String) where
import Foreign.C.String
module CTypes (module Foreign.C.Types) where
import Foreign.C.Types
module Char (
    isAscii, isLatin1, isControl, isPrint, isSpace, isUpper, isLower, 
    isAlpha, isDigit, isOctDigit, isHexDigit, isAlphaNum, 
    digitToInt, intToDigit,
    toUpper, toLower,
    ord, chr,
    readLitChar, showLitChar, lexLitChar,

-- ...and what the Prelude exports
    Char, String
  ) where

import Data.Char
module Complex (
    Complex((:+)), realPart, imagPart, conjugate, 
    mkPolar, cis, polar, magnitude, phase 
  ) where

import Data.Complex
module Directory (
    Permissions( Permissions, readable, writable, executable, searchable ), 
    createDirectory, removeDirectory, removeFile, 
    renameDirectory, renameFile, getDirectoryContents,
    getCurrentDirectory, setCurrentDirectory,
    doesFileExist, doesDirectoryExist,
    getPermissions, setPermissions,
    getModificationTime 
  ) where

import System.Directory
module ForeignPtr (module Foreign.ForeignPtr) where
import Foreign.ForeignPtr
module IO (
    Handle, HandlePosn,
    IOMode(ReadMode,WriteMode,AppendMode,ReadWriteMode),
    BufferMode(NoBuffering,LineBuffering,BlockBuffering),
    SeekMode(AbsoluteSeek,RelativeSeek,SeekFromEnd),
    stdin, stdout, stderr, 
    openFile, hClose, hFileSize, hIsEOF, isEOF,
    hSetBuffering, hGetBuffering, hFlush, 
    hGetPosn, hSetPosn, hSeek, 
    hWaitForInput, hReady, hGetChar, hGetLine, hLookAhead, hGetContents, 
    hPutChar, hPutStr, hPutStrLn, hPrint,
    hIsOpen, hIsClosed, hIsReadable, hIsWritable, hIsSeekable,
    isAlreadyExistsError, isDoesNotExistError, isAlreadyInUseError, 
    isFullError, isEOFError,
    isIllegalOperation, isPermissionError, isUserError, 
    ioeGetErrorString, ioeGetHandle, ioeGetFileName,
    try, bracket, bracket_,

    -- ...and what the Prelude exports
    IO, FilePath, IOError, ioError, userError, catch, interact,
    putChar, putStr, putStrLn, print, getChar, getLine, getContents,
    readFile, writeFile, appendFile, readIO, readLn
  ) where

import System.IO
import System.IO.Error

-- | The 'bracket' function captures a common allocate, compute, deallocate
-- idiom in which the deallocation step must occur even in the case of an
-- error during computation. This is similar to try-catch-finally in Java.
--
-- This version handles only IO errors, as defined by Haskell 98.
-- The version of @bracket@ in "Control.Exception" handles all exceptions,
-- and should be used instead.

bracket        :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
bracket before after m = do
        x  <- before
        rs <- try (m x)
        after x
        case rs of
           Right r -> return r
           Left  e -> ioError e

-- | A variant of 'bracket' where the middle computation doesn't want @x@.
--
-- This version handles only IO errors, as defined by Haskell 98.
-- The version of @bracket_@ in "Control.Exception" handles all exceptions,
-- and should be used instead.

bracket_        :: IO a -> (a -> IO b) -> IO c -> IO c
bracket_ before after m = do
         x  <- before
         rs <- try m
         after x
         case rs of
            Right r -> return r
            Left  e -> ioError e
module Int ( module Data.Int ) where
import Data.Int
module Ix (
    Ix(range, index, inRange), rangeSize
  ) where

import Data.Ix
Code derived from the document "Report on the Programming Language
Haskell 98", is distributed under the following license:

  Copyright (c) 2002 Simon Peyton Jones

  The authors intend this Report to belong to the entire Haskell
  community, and so we grant permission to copy and distribute it for
  any purpose, provided that it is reproduced in its entirety,
  including this Notice.  Modified versions of this Report may also be
  copied and distributed for any purpose, provided that the modified
  version is clearly presented as such, and that it does not claim to
  be a definition of the Haskell 98 Language.

-----------------------------------------------------------------------------

Code derived from the document "The Haskell 98 Foreign Function
Interface, An Addendum to the Haskell 98 Report" is distributed under
the following license:

  Copyright (c) 2002 Manuel M. T. Chakravarty

  The authors intend this Report to belong to the entire Haskell
  community, and so we grant permission to copy and distribute it for
  any purpose, provided that it is reproduced in its entirety,
  including this Notice.  Modified versions of this Report may also be
  copied and distributed for any purpose, provided that the modified
  version is clearly presented as such, and that it does not claim to
  be a definition of the Haskell 98 Foreign Function Interface.
module List (
    elemIndex, elemIndices,
    find, findIndex, findIndices,
    nub, nubBy, delete, deleteBy, (\\), deleteFirstsBy,
    union, unionBy, intersect, intersectBy,
    intersperse, transpose, partition, group, groupBy,
    inits, tails, isPrefixOf, isSuffixOf,
    mapAccumL, mapAccumR,
    sort, sortBy, insert, insertBy, maximumBy, minimumBy,
    genericLength, genericTake, genericDrop,
    genericSplitAt, genericIndex, genericReplicate,
    zip4, zip5, zip6, zip7,
    zipWith4, zipWith5, zipWith6, zipWith7,
    unzip4, unzip5, unzip6, unzip7, unfoldr,

    -- ...and what the Prelude exports
    -- []((:), []), -- This is built-in syntax
    map, (++), concat, filter,
    head, last, tail, init, null, length, (!!),
    foldl, foldl1, scanl, scanl1, foldr, foldr1, scanr, scanr1,
    iterate, repeat, replicate, cycle,
    take, drop, splitAt, takeWhile, dropWhile, span, break,
    lines, words, unlines, unwords, reverse, and, or,
    any, all, elem, notElem, lookup,
    sum, product, maximum, minimum, concatMap, 
    zip, zip3, zipWith, zipWith3, unzip, unzip3
  ) where

import Data.List hiding (foldl')
module Locale (
    TimeLocale(..), defaultTimeLocale
  ) where

import System.Locale ( 
	-- just the bits that are specified by Haskell 98
	TimeLocale(TimeLocale,wDays,months,amPm,dateTimeFmt,
		   dateFmt,timeFmt,time12Fmt),
        defaultTimeLocale
    )
module MarshalAlloc (module Foreign.Marshal.Alloc) where
import Foreign.Marshal.Alloc
module MarshalArray (module Foreign.Marshal.Array) where
import Foreign.Marshal.Array
module MarshalError (
  	module Foreign.Marshal.Error,
	IOErrorType,
	mkIOError,
	alreadyExistsErrorType,
	doesNotExistErrorType,
	alreadyInUseErrorType,
	fullErrorType,
	eofErrorType,
	illegalOperationErrorType,
	permissionErrorType,
	userErrorType,
	annotateIOError
  ) where

import System.IO.Error
import Foreign.Marshal.Error
module MarshalUtils (module Foreign.Marshal.Utils) where
import Foreign.Marshal.Utils
module Maybe (
    isJust, isNothing,
    fromJust, fromMaybe, listToMaybe, maybeToList,
    catMaybes, mapMaybe,

    -- ...and what the Prelude exports
    Maybe(Nothing, Just),
    maybe
  ) where

import Data.Maybe
module Monad (
    MonadPlus(mzero, mplus),
    join, guard, when, unless, ap,
    msum,
    filterM, mapAndUnzipM, zipWithM, zipWithM_, foldM, 
    liftM, liftM2, liftM3, liftM4, liftM5,

    -- ...and what the Prelude exports
    Monad((>>=), (>>), return, fail),
    Functor(fmap),
    mapM, mapM_, sequence, sequence_, (=<<), 
  ) where

import Control.Monad
module Paths_haskell98 (
	version,
	getBinDir, getLibDir, getDataDir, getLibexecDir,
	getDataFileName
	) where

import Data.Version

version = Version {versionBranch = [1,0], versionTags = []}

bindir     = "/usr/local/bin"
libdir     = "/usr/local/lib/hugs/packages/haskell98"
datadir    = "/usr/local/share/haskell98-1.0"
libexecdir = "/usr/local/libexec"

getBinDir, getLibDir, getDataDir, getLibexecDir :: IO FilePath
getBinDir = return bindir
getLibDir = return libdir
getDataDir = return datadir
getLibexecDir = return libexecdir

getDataFileName :: FilePath -> IO FilePath
getDataFileName name = return (datadir ++ "/" ++ name)
module Ptr (module Foreign.Ptr) where
import Foreign.Ptr
module Random (
   RandomGen(next, split, genRange),
   StdGen, mkStdGen,
   Random( random,   randomR, randoms,  randomRs, randomIO, randomRIO ),
   getStdRandom, getStdGen, setStdGen, newStdGen
  ) where

import System.Random
module Ratio (
    Ratio, Rational, (%), numerator, denominator, approxRational
  ) where

import Data.Ratio
module StablePtr (module Foreign.StablePtr) where
import Foreign.StablePtr
module Storable (module Foreign.Storable) where
import Foreign.Storable
module System (
    ExitCode(ExitSuccess,ExitFailure),
    getArgs, getProgName, getEnv, system, exitWith, exitFailure
  ) where

import System.Exit
import System.Environment
import System.Cmd
module Time (
    ClockTime, 
    Month(January,February,March,April,May,June,
          July,August,September,October,November,December),
    Day(Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday),
    CalendarTime(CalendarTime, ctYear, ctMonth, ctDay, ctHour, ctMin,
    		 ctSec, ctPicosec, ctWDay, ctYDay, ctTZName, ctTZ, ctIsDST),
    TimeDiff(TimeDiff, tdYear, tdMonth, tdDay, tdHour,
 	     tdMin, tdSec, tdPicosec),
    getClockTime, addToClockTime, diffClockTimes,
    toCalendarTime, toUTCTime, toClockTime,
    calendarTimeToString, formatCalendarTime 
  ) where

import System.Time
module Word ( module Data.Word ) where
import Data.Word
-- Empty module to serve as the default current module.
module Hugs where
module Paths_hugsbase (
	version,
	getBinDir, getLibDir, getDataDir, getLibexecDir,
	getDataFileName
	) where

import Data.Version

version = Version {versionBranch = [1,0], versionTags = []}

bindir     = "/usr/local/bin"
libdir     = "/usr/local/lib/hugs/packages/hugsbase"
datadir    = "/usr/local/share/hugsbase-1.0"
libexecdir = "/usr/local/libexec"

getBinDir, getLibDir, getDataDir, getLibexecDir :: IO FilePath
getBinDir = return bindir
getLibDir = return libdir
getDataDir = return datadir
getLibexecDir = return libexecdir

getDataFileName :: FilePath -> IO FilePath
getDataFileName name = return (datadir ++ "/" ++ name)
-----------------------------------------------------------------------------
-- Standard Library: Array operations
--
-- Suitable for use with Hugs 98
-----------------------------------------------------------------------------

module Hugs.Array ( 
    module Data.Ix,  -- export all of Ix 
    unsafeIndex,

    Array, array, listArray, (!), bounds, indices, elems, assocs, 
    accumArray, (//), accum, ixmap,
    unsafeArray, unsafeAt, unsafeReplace, unsafeAccum, unsafeAccumArray
    ) where

import Data.Ix
import Hugs.Prelude( unsafeIndex )

infixl 9  !, //

data Array a b -- Arrays are implemented as a primitive type

array          :: Ix a => (a,a) -> [(a,b)] -> Array a b
listArray      :: Ix a => (a,a) -> [b] -> Array a b
(!)	       :: Ix a => Array a b -> a -> b
bounds         :: Ix a => Array a b -> (a,a)
indices        :: Ix a => Array a b -> [a]
elems          :: Ix a => Array a b -> [b]
assocs	       :: Ix a => Array a b -> [(a,b)]
(//)           :: Ix a => Array a b -> [(a,b)] -> Array a b
accum          :: Ix a => (b -> c -> b) -> Array a b -> [(a,c)] -> Array a b
accumArray     :: Ix a => (b -> c -> b) -> b -> (a,a) -> [(a,c)] -> Array a b
ixmap	       :: (Ix a, Ix b) => (a,a) -> (a -> b) -> Array b c -> Array a c

primitive primArray :: (a,a) -> Int -> [(Int,b)] -> Array a b
primitive primUpdate :: [(Int,b)] -> Array a b -> Array a b
primitive primAccum :: [(Int,c)] -> Array a b -> (b -> c -> b) -> Array a b
primitive primAccumArray
    :: (a,a) -> Int -> (b -> c -> b) -> b -> [(Int,c)] -> Array a b
primitive primSubscript :: Array a b -> Int -> b

primitive primBounds :: Array a b -> (a,a)
primitive primElems  :: Array a b -> [b]
primitive primAmap   :: (b -> c) -> Array a b -> Array a c

unsafeArray :: Ix i => (i,i) -> [(Int, e)] -> Array i e
unsafeArray bnds	= primArray bnds (rangeSize bnds)

unsafeAt :: Ix i => Array i e -> Int -> e
unsafeAt		= primSubscript

unsafeReplace :: Ix i => Array i e -> [(Int, e)] -> Array i e
unsafeReplace iarr ies	= primUpdate ies iarr

unsafeAccum :: Ix i => (e -> a -> e) -> Array i e -> [(Int, a)] -> Array i e
unsafeAccum f iarr ies	= primAccum ies iarr f

unsafeAccumArray :: Ix i => (e -> a -> e) -> e -> (i,i) -> [(Int, a)] -> Array i e
unsafeAccumArray f z bnds = primAccumArray bnds (rangeSize bnds) f z

indexAll :: Ix i => (i,i) -> [(i, a)] -> [(Int, a)]
indexAll bnds ivs = [(index bnds i,v) | (i,v) <- ivs]

array bnds          = unsafeArray bnds . indexAll bnds
listArray bnds vs   = unsafeArray bnds (zip [0..rangeSize bnds-1] vs)
arr!i               = unsafeAt arr (index (bounds arr) i)
bounds              = primBounds
indices	            = range . bounds
elems               = primElems
assocs a            = zip (indices a) (elems a)
accumArray f z bnds = unsafeAccumArray f z bnds . indexAll bnds
a // ivs            = unsafeReplace a (indexAll (bounds a) ivs)
accum f a ivs       = unsafeAccum f a (indexAll (bounds a) ivs)
ixmap bnds f arr =
    unsafeArray bnds [(unsafeIndex bnds i, arr ! f i) | i <- range bnds]

instance (Ix a) => Functor (Array a) where
    fmap = primAmap

instance (Ix a, Eq b) => Eq (Array a b) where
    a == a'   =   assocs a == assocs a'

instance (Ix a, Ord b) => Ord (Array a b) where
    a <= a'   =   assocs a <= assocs a'

instance  (Ix a, Show a, Show b) => Show (Array a b)  where
    showsPrec p a = showParen (p > 9) (
		    showString "array " .
		    shows (bounds a) . showChar ' ' .
		    shows (assocs a)                  )

instance  (Ix a, Read a, Read b) => Read (Array a b)  where
    readsPrec p = readParen (p > 9)
	     (\r -> [(array b as, u) | ("array",s) <- lex r,
				       (b,t)       <- reads s,
				       (as,u)      <- reads t   ])

-----------------------------------------------------------------------------
module Hugs.Bits where

primitive primAndInt        :: Int -> Int -> Int
primitive primOrInt         :: Int -> Int -> Int
primitive primXorInt        :: Int -> Int -> Int
primitive primComplementInt :: Int -> Int
primitive primShiftInt      :: Int -> Int -> Int
primitive primBitInt        :: Int -> Int
primitive primTestInt       :: Int -> Int -> Bool
-- Mutable and immutable byte arrays (identical internally), usable for
-- unboxed arrays, and built from FFI primitives.

module Hugs.ByteArray (
	MutableByteArray,
	newMutableByteArray, readMutableByteArray, writeMutableByteArray,
	ByteArray,
	unsafeFreezeMutableByteArray, thawByteArray, readByteArray
    ) where

import Data.Word		( Word8 )
import Foreign.ForeignPtr	( ForeignPtr,
				  mallocForeignPtrBytes, withForeignPtr )
import Foreign.Marshal.Utils	( copyBytes )
import Foreign.Ptr		( castPtr )
import Foreign.Storable		( Storable( peekElemOff, pokeElemOff ))

import Hugs.IOExts		( unsafeCoerce )
import Hugs.ST			( ST, unsafeRunST )

-- This implementation is based on the principle that the FFI primitives
-- used, though declared as IO actions, actually only manipulate local
-- state, and thus could have been declared in the strict ST monad:
--
--	mallocForeignPtrBytes :: Int -> ST s (STForeignPtr s a)
--	withForeignPtr :: STForeignPtr s a -> (STPtr s a -> ST s b) -> ST s b
--	copyBytes :: STPtr s a -> STPtr s a -> Int -> ST s ()
--	castPtr :: STPtr s a -> STPtr s b
--	peekElemOff :: Storable a => STPtr s a -> Int -> ST s a
--	pokeElemOff :: Storable a => STPtr s a -> Int -> a -> ST s ()
--
-- (where STPtr s and STForeignPtr s are just like Ptr and ForeignPtr,
-- but confined to the region s)
--
-- Since the strict ST monad has the same representation as the IO monad,
-- we are justified in coercing such actions to the ST monad.

-- This conversion may be safely applied to computations that manipulate
-- only local state, but will give a runtime error if the IO action does
-- any concurrency.
specialIOToST :: IO a -> ST s a
specialIOToST = unsafeCoerce

type BytePtr = ForeignPtr Word8

data MutableByteArray s = MutableByteArray !Int !BytePtr

newMutableByteArray :: Int -> ST s (MutableByteArray s)
newMutableByteArray size = do
    fp <- specialIOToST (mallocForeignPtrBytes size)
    return (MutableByteArray size fp)

readMutableByteArray :: Storable e => MutableByteArray s -> Int -> ST s e
readMutableByteArray (MutableByteArray _ fp) i =
    specialIOToST $ withForeignPtr fp $ \a -> peekElemOff (castPtr a) i

writeMutableByteArray :: Storable e => MutableByteArray s -> Int -> e -> ST s ()
writeMutableByteArray (MutableByteArray _ fp) i e =
    specialIOToST $ withForeignPtr fp $ \a -> pokeElemOff (castPtr a) i e

data ByteArray = ByteArray !Int !BytePtr

-- Don't change the MutableByteArray after calling this.
unsafeFreezeMutableByteArray :: MutableByteArray s -> ST s ByteArray
unsafeFreezeMutableByteArray (MutableByteArray size fp) =
    return (ByteArray size fp)

thawByteArray :: ByteArray -> ST s (MutableByteArray s)
thawByteArray (ByteArray size fp) = specialIOToST $ do
    fp' <- mallocForeignPtrBytes size
    withForeignPtr fp $ \p ->
	withForeignPtr fp' $ \p' ->
	copyBytes p' p size
    return (MutableByteArray size fp')

-- This one is safe because ByteArrays are immutable
-- (cf. unsafeFreezeMutableByteArray)
readByteArray :: Storable a => ByteArray -> Int -> a
readByteArray (ByteArray _ fp) i = unsafeRunST $ specialIOToST $
    withForeignPtr fp $ \p -> peekElemOff (castPtr p) i
----------------------------------------------------------------
-- This is a simple implementation of Cordy Hall's assertions
-- (for performance debugging).
--
-- NB These primitives are an _experimental_ feature which may be
--    removed in future versions of Hugs.
--    They can only be used if hugs was configured with the
--    "--enable-internal-prims" flag.
--
-- These primitives mostly break referential transparency - but you're
-- only supposed to use them for debugging purposes.
----------------------------------------------------------------

module Hugs.CVHAssert(
	Test, Action, 
	assert,
	isEvaluated,
	pointerEqual
	) where

import Hugs.Internals(
	ptrEq,
	Name,   nameInfo,
	Cell,   getCell, cellPtrEq,
	CellKind(..), classifyCell,
	)
import Hugs.IOExts(
	unsafePerformIO
	)

----------------------------------------------------------------
-- High level operations
----------------------------------------------------------------

type Test a   = a -> Bool
type Action a = a -> IO ()

assert :: Test a -> Action a -> a -> a
assert test action x = 
  unsafePerformIO (if test x then return () else action x)
  `seq`
  x 

isEvaluated :: a -> Bool
isEvaluated x = unsafePerformIO (
  isEvaluatedCell (getCell x)
  )

representationSize :: a -> Int
representationSize x = unsafePerformIO (do 
  cells <- cellsOf (getCell x) []
  return (cellSize * length cells)
  )

pointerEqual :: a -> a -> Bool
pointerEqual = ptrEq

----------------------------------------------------------------
-- Utilities
----------------------------------------------------------------

isEvaluatedCell :: Cell -> IO Bool
isEvaluatedCell cell = do
  kind <- classifyCell False cell

  case kind of
    Apply fun args -> do 
		    funkind <- classifyCell False fun
                    case funkind of
                      Fun nm    -> return (nameArity nm > length args)
                      _         -> return True
    _            -> return True

arityOf :: Cell -> IO Int
arityOf cell = do
  kind <- classifyCell False cell

  case kind of
    Apply fun args -> do 
		    funarity <- arityOf fun
		    return (funarity - length args)

    Fun   nm -> return (nameArity nm)
    Con   nm -> return (nameArity nm)
    Tuple i  -> return i
    _            -> return 0


nameArity :: Name -> Int
nameArity nm = case nameInfo nm of (arity,_,_) -> arity

-- list cells occurring in Cell
cellsOf :: Cell -> [Cell] -> IO [Cell]

cellsOf cell seen 
  | cell `elemCell` seen 
  = return seen
  | otherwise
  = do
      let seen' = cell:seen

      kind <- classifyCell False cell

      case kind of
	Apply f xs -> do
			    seen'' <- cellsOf f seen'
			    cellsOf' xs seen''
	Fun     _  -> return seen'
	Con     _  -> return seen'
	Tuple   _  -> return seen'
	Int     _  -> return seen'
	Integer _  -> return seen'
	Float   _  -> return seen'
	Char    _  -> return seen'
	Prim    _  -> return seen'
	Error   _  -> return seen'	-- we could argue about this one

cellsOf' :: [Cell] -> [Cell] -> IO [Cell]
cellsOf' []     seen = return seen
cellsOf' (x:xs) seen = do seen' <- cellsOf x seen
                          cellsOf' xs seen'

elemCell :: Cell -> [Cell] -> Bool
x `elemCell` []     = False
x `elemCell` (y:ys) = x `cellPtrEq` y || x `elemCell` ys

cellSize :: Int
cellSize = 8

----------------------------------------------------------------
module Hugs.Char (
    isAscii, isLatin1, isControl, isPrint, isSpace, isUpper, isLower,
    isAlpha, isDigit, isOctDigit, isHexDigit, isAlphaNum,
    intToDigit,
    toUpper, toLower, toTitle,
    ord, chr,
    readLitChar, showLitChar, lexLitChar,
    primUniGenCat
    ) where

import Hugs.Prelude(
    isSpace, isUpper, isLower,
    isAlpha, isDigit, isOctDigit, isHexDigit, isAlphaNum,
    readLitChar, showLitChar, lexLitChar)

-- The Hugs Char type covers only the ISO 8859-1 (Latin-1) subset of Unicode,
-- i.e. '\0' to '\xff'.

-- Character-testing operations (some others are in Hugs.Prelude)
isAscii, isLatin1, isControl :: Char -> Bool

isAscii c                =  c < '\x80'

isLatin1 c               =  c <= '\xff'

isControl c              =  c < ' ' || c >= '\DEL' && c <= '\x9f'

primitive isPrint        :: Char -> Bool

-- Digit conversion operations
intToDigit               :: Int -> Char
intToDigit i
  | i >= 0  && i <=  9   =  toEnum (fromEnum '0' + i)
  | i >= 10 && i <= 15   =  toEnum (fromEnum 'a' + i - 10)
  | otherwise            =  error "Char.intToDigit: not a digit"

-- Case-changing operations
primitive toUpper        :: Char -> Char
primitive toLower        :: Char -> Char
primitive toTitle        :: Char -> Char

-- Character code functions
ord                      :: Char -> Int
ord                      =  fromEnum

chr                      :: Int  -> Char
chr                      =  toEnum

-- Unicode character classification
primitive primUniGenCat  :: Char -> Int
-----------------------------------------------------------------------------
-- This implements Concurrent Haskell's "MVar"s as described in the paper
--
--   "Concurrent Haskell"
--   Simon Peyton Jones, Andrew Gordon and Sigbjorn Finne.
--   In Proceedings of the ACM Symposium on Principles of Programming
--   Languages,St Petersburg Beach, Florida, January 1996. 
--   http://www.dcs.gla.ac.uk/fp/authors/Simon_Peyton_Jones/
--     concurrent-haskell.ps
--
-- except that we have made the following name changes for compatability
-- with GHC 2.05.
--
--   newMVar  -> newEmptyMVar
--
-- There is one significant difference between this implementation and
-- GHC 2.05: 
--
-- o GHC uses preemptive multitasking.
-- 
--   Context switches can occur at any time (except if you call a C
--   function (like "getchar") which blocks the entire process while
--   waiting for input.
-- 
-- o Hugs uses cooperative multitasking.  
-- 
--   Context switches only occur when you use one of the primitives
--   defined in this module.  This means that programs such as:
-- 
--     main = forkIO (write 'a') >> write 'b'
-- 	where
-- 	 write c = putChar c >> write c
-- 
--   will print either "aaaaaaaaaaaaaa..." or "bbbbbbbbbbbb..."
--   instead of some random interleaving of 'a's and 'b's.
-- 
-- Cooperative multitasking is sufficient for writing coroutines and simple
-- graphical user interfaces but the usual assumptions of fairness don't
-- apply and Channel.getChanContents cannot be implemented.
-----------------------------------------------------------------------------
module Hugs.ConcBase(
	forkIO,
	MVar,
	newEmptyMVar, newMVar, takeMVar, tryTakeMVar, putMVar, tryPutMVar,
	isEmptyMVar,
        yield
	) where

import Hugs.Prelude(
	IO(..), IOResult(..), threadToIOResult,
	Exception(..), catchException, blockIO)
import Hugs.IORef

----------------------------------------------------------------
-- The interface
----------------------------------------------------------------

forkIO       :: IO () -> IO () -- Spawn a thread
yield        :: IO ()

newEmptyMVar :: IO (MVar a)
newMVar      :: a -> IO (MVar a)
takeMVar     :: MVar a -> IO a
putMVar      :: MVar a -> a -> IO ()
tryPutMVar   :: MVar a -> a -> IO Bool
tryTakeMVar  :: MVar a -> IO (Maybe a)

isEmptyMVar :: MVar a -> IO Bool

----------------------------------------------------------------
-- Implementation
----------------------------------------------------------------

kill :: IO a
kill = IO (\ s -> Hugs_DeadThread)

yield = IO (\ s -> Hugs_YieldThread (s ()))

-- add the continuation to the runnable list, and continue
continueIO :: IOResult -> IO ()
continueIO cc = IO (\ s -> Hugs_ForkThread (s ()) cc)

-- The thread is scheduled immediately and runs with its own success/error
-- continuations.
forkIO m = continueIO (threadToIOResult (m `catchException` forkExnHandler))

forkExnHandler :: Exception -> IO a
forkExnHandler e = do
    putStr "\nThread raised exception: "
    putStr (show e)
    putStr "\n"           
    kill

newtype MVar a = MkMVar (IORef (MVarState a)) deriving Eq
data MVarState a
  = Full a [(a,()->IOResult)]
	-- a value and a list of value-thread pairs blocked waiting
	-- to write to the MVar.
	-- The ()-> part of the thread is because blocked threads have
	-- to be functions. :-(
  | Empty [a -> IOResult]
	-- no value, just a list of threads waiting to receive a value

newEmptyMVar = fmap MkMVar (newIORef (Empty []))

newMVar x    = fmap MkMVar (newIORef (Full x []))

takeMVar (MkMVar v) = do
  state <- readIORef v
  case state of
    Full a [] -> do
      writeIORef v (Empty [])
      return a
    Full a ((a',t):ts) -> do
      writeIORef v (Full a' ts)
      continueIO (t ())		-- reschedule t
      return a
    Empty cs ->
      blockIO (\cc -> writeIORef v (Empty (cs ++ [cc])))

-- tryTakeMVar is a non-blocking takeMVar
tryTakeMVar (MkMVar v) = do
  state <- readIORef v
  case state of
    Full a [] -> do
      writeIORef v (Empty [])
      return (Just a)
    Full a ((a',t):ts) -> do
      writeIORef v (Full a' ts)
      continueIO (t ())		-- reschedule t
      return (Just a)
    Empty cs ->
      return Nothing

putMVar (MkMVar v) a = do
  state <- readIORef v
  case state of
    Full a' ts ->
      blockIO (\cc -> writeIORef v (Full a' (ts++[(a,cc)])))
    Empty [] ->
      writeIORef v (Full a [])
    Empty (c:cs) -> do
      writeIORef v (Empty cs)
      continueIO (c a)		-- reschedule the blocked thread

tryPutMVar (MkMVar v) a = do
  state <- readIORef v
  case state of
    Full _ _ ->
      return False
    Empty [] -> do
      writeIORef v (Full a [])
      return True
    Empty (c:cs) -> do
      writeIORef v (Empty cs)
      continueIO (c a)		-- reschedule the blocked thread
      return True

{- 
 Low-level op. for checking whether an MVar is filled-in or not.
 Notice that the boolean value returned  is just a snapshot of
 the state of the MVar. By the time you get to react on its result,
 the MVar may have been filled (or emptied) - so be extremely
 careful when using this operation.  

 Use tryTakeMVar instead if possible.

 If you can re-work your abstractions to avoid having to
 depend on isEmptyMVar, then you're encouraged to do so,
 i.e., consider yourself warned about the imprecision in
 general of isEmptyMVar :-)
-}
isEmptyMVar (MkMVar v) = do
  state <- readIORef v
  case state of
    Full _ _ -> return False
    Empty _  -> return True

-----------------------------------------------------------------------------

--
-- Hugs98 implementation of the Haskell 98 module, Directory.
--
module Hugs.Directory
	( Permissions ( readable     -- :: Permissions -> Bool
	              , writable     -- :: Permissions -> Bool
		      , executable   -- :: Permissions -> Bool
		      , searchable   -- :: Permissions -> Bool
		      )
	   -- instances: Eq, Ord, Read, Show
	, createDirectory	     -- :: FilePath -> IO ()

	, removeDirectory            -- :: FilePath -> IO ()
	, removeFile                 -- :: FilePath -> IO ()

	, renameDirectory            -- :: FilePath -> FilePath -> IO ()
	, renameFile		     -- :: FilePath -> FilePath -> IO ()

	, getDirectoryContents       -- :: FilePath -> IO [FilePath]

	, getCurrentDirectory        -- :: IO FilePath
	, setCurrentDirectory        -- :: FilePath -> IO ()

	, doesFileExist	             -- :: FilePath -> IO Bool
	, doesDirectoryExist	     -- :: FilePath -> IO Bool

	, getPermissions	     -- :: FilePath -> IO Permissions
	, setPermissions	     -- :: FilePath -> Permissions -> IO ()

	, getModificationTime 	     -- :: FilePath -> IO ClockTime
	) where

import System.Time ( ClockTime(..) )

data Permissions
 = Permissions 
   { readable     :: Bool
   , writable     :: Bool
   , executable   :: Bool
   , searchable   :: Bool
   } deriving (Eq, Ord, Read, Show)

{-
 This module is really just a wrapper for various directory
 and file-related system calls.
-}
primitive createDirectory :: FilePath -> IO ()

primitive removeFile :: FilePath -> IO ()
primitive removeDirectory :: FilePath -> IO ()

primitive renameFile :: FilePath -> FilePath -> IO ()
primitive renameDirectory :: FilePath -> FilePath -> IO ()

primitive setCurrentDirectory :: FilePath -> IO ()
primitive getCurrentDirectory :: IO FilePath

primitive doesDirectoryExist :: FilePath -> IO Bool
primitive doesFileExist :: FilePath -> IO Bool

getPermissions :: FilePath -> IO Permissions
getPermissions fpath = do
    (r,w,e,s) <- getPerms fpath
    return (Permissions{readable=r,writable=w,executable=e,searchable=s})

setPermissions :: FilePath -> Permissions -> IO ()
setPermissions fpath perms = 
  setPerms fpath (readable perms)
  		 (writable perms)
		 (executable perms)
		 (searchable perms)

primitive getPerms :: FilePath -> IO (Bool,Bool,Bool,Bool)
primitive setPerms :: FilePath -> Bool -> Bool -> Bool -> Bool -> IO ()

getDirectoryContents :: FilePath -> IO [FilePath]
getDirectoryContents fpath = do
  ls <- getDirContents fpath
    -- it is easiest for the primitive to create the
    -- list of entries in the order in which they're
    -- read, so the resulting list will be back to front.
    -- Hence, list reversal is needed.
  return (reverse ls)

primitive getDirContents :: FilePath -> IO [FilePath]

getModificationTime :: FilePath -> IO ClockTime
getModificationTime fPath = do
  x <- getModTime fPath
  return (TOD (fromIntegral x) 0)

primitive getModTime :: FilePath -> IO Int
module Hugs.Dynamic(module Data.Dynamic, coerceDynamic, runDyn) where

import Data.Dynamic

coerceDynamic :: Typeable a => Dynamic -> a
coerceDynamic d = fromDyn d def
  where def = error ("coerceDynamic: expecting " ++ show (toDyn def) ++
			" found " ++ show d)

runDyn :: Dynamic -> IO ()
runDyn = coerceDynamic
/* Machine generated file, do not modify */
#include <stdlib.h>
#include "HsFFI.h"

static HugsAPI5 *hugs = 0;
#include "emscripten.h"

#ifndef ENABLE_MACRO_INTERFACE
#undef emscripten_run_script
#endif

static void hugsprim_emscripten_run_script_0(HugsStackPtr);
static void hugsprim_emscripten_run_script_0(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    arg1 = hugs->getPtr();
    emscripten_run_script(arg1);
    
    hugs->returnIO(hugs_root,0);
}

static struct hugs_primitive hugs_primTable[] = {
    {"emscripten_run_script", 2, hugsprim_emscripten_run_script_0},
};

static void hugs_primControl(int);
static void hugs_primControl(what)
int what; {
}

#ifdef STATIC_LINKAGE
#define initModule initHEmscripten
#endif

static struct hugs_primInfo hugs_prims = { hugs_primControl, hugs_primTable, 0 };

#ifdef __cplusplus
extern "C" {
#endif
#ifndef __cplusplus
DLLEXPORT(int)  HugsAPIVersion(void);
#endif
DLLEXPORT(int)  HugsAPIVersion() {return (5);}
DLLEXPORT(void) initModule(HugsAPI5 *);
DLLEXPORT(void) initModule(HugsAPI5 *hugsAPI) {
    hugs = hugsAPI;
    hugs->registerPrims(&hugs_prims);
}
#ifdef __cplusplus
}
#endif

{-# LANGUAGE ForeignFunctionInterface #-}
module Hugs.Emscripten where
import Foreign.C.String
import Hugs.Prelude
-- void emscripten_run_script(const char *script) 
foreign import ccall "emscripten.h" emscripten_run_script :: CString -> IO ()
 asm    dylink¿Ä¿` ` ` `  ` |jenv
memoryBase env	tableBase envabort  env_emscripten_run_script  envmemory Äenvtablep    A A |_HugsAPIVersion __post_instantiate _hugs_primControl !_hugsprim_emscripten_run_script_0 _initModule runPostSets 	
 #
Æ A # A∞Ä¿j  6 #   (∞   + # A∞Ä¿j( (D   A # A∞Ä¿j( († 6 # #Aj6 # # (# Ajj6# # (# Ajj6# #Aj6 # A0j$#AÄÄ¿j$ A  D        3 # -                       emscripten_run_script-- This is a cut-down version of GHC's Exception module
--
-- The main difference is that Hugs does not throw asynchronous
-- exceptions, in particular heap and stack overflow and ctrl-C.
-- Indeed, it is not entirely clear what to do in response to ctrl-C.

module Hugs.Exception(
        Exception(..),
	IOException(..),
	ArithException(..),
	ArrayException(..),
	AsyncException(..),

	catchException,		-- :: IO a -> (Exception -> IO a) -> IO a

	-- Throwing exceptions

	throwIO,		-- :: Exception -> IO a
	throw,			-- :: Exception -> a

	evaluate,		-- :: a -> IO a

	-- Async exception control

        block,			-- :: IO a -> IO a
        unblock,		-- :: IO a -> IO a
  ) where

import Hugs.Prelude

instance Eq Exception where
  ArithException e1   == ArithException e2   = e1 == e2
  ArrayException e1   == ArrayException e2   = e1 == e2
  AssertionFailed e1  == AssertionFailed e2  = e1 == e2
  AsyncException e1   == AsyncException e2   = e1 == e2
  BlockedOnDeadMVar   == BlockedOnDeadMVar   = True
  Deadlock            == Deadlock            = True
  DynException _      == DynException _      = False -- incomparable
  ErrorCall e1        == ErrorCall e2        = e1 == e2
  ExitException e1    == ExitException e2    = e1 == e2
  IOException e1      == IOException e2      = e1 == e2
  NoMethodError e1    == NoMethodError e2    = e1 == e2
  NonTermination      == NonTermination      = True
  PatternMatchFail e1 == PatternMatchFail e2 = e1 == e2
  RecConError e1      == RecConError e2      = e1 == e2
  RecSelError e1      == RecSelError e2      = e1 == e2
  RecUpdError e1      == RecUpdError e2      = e1 == e2
  _                   == _                   = False

----------------------------------------------------------------
-- Primitive throw and catch
----------------------------------------------------------------

throwIO :: Exception -> IO a
throwIO exn = IO (\ s -> throw exn)

evaluate :: a -> IO a
evaluate x = IO (\ s -> x `seq` s x)

----------------------------------------------------------------
-- dummy implementations of block and unblock
----------------------------------------------------------------

block, unblock :: IO a -> IO a
block   m = m
unblock m = m

----------------------------------------------------------------
-- End
----------------------------------------------------------------
module Hugs.ForeignPtr
        ( 
	  ForeignPtr             -- abstract, instance of: Eq
	, FinalizerPtr
	, FinalizerEnvPtr
        , newForeignPtr_         -- :: Ptr a -> IO (ForeignPtr a)
        , addForeignPtrFinalizer -- :: FinalizerPtr a -> ForeignPtr a -> IO ()
	, addForeignPtrFinalizerEnv -- :: FinalizerEnvPtr env a -> Ptr env ->
				    --    ForeignPtr a -> IO ()
	, unsafeForeignPtrToPtr	 -- :: ForeignPtr a -> Ptr a
	, touchForeignPtr        -- :: ForeignPtr a -> IO ()
	, castForeignPtr	 -- :: ForeignPtr a -> ForeignPtr b
        ) 
	where

import Hugs.Prelude		( ForeignPtr )
import Foreign.Ptr		( Ptr, FunPtr )

-- data ForeignPtr a -- defined in Prelude.hs

type FinalizerPtr        a = FunPtr (           Ptr a -> IO ())
type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())

primitive newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
primitive addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()
primitive addForeignPtrFinalizerEnv ::
		FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()
primitive touchForeignPtr :: ForeignPtr a -> IO ()
primitive unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a
primitive castForeignPtr "primUnsafeCoerce" :: ForeignPtr a -> ForeignPtr b
----------------------------------------------------------------
-- A "generic" (or "polymorphic") print function in Haskell
-- This is very heavily based on the code in printer.c
-- (Together with the decompiler and error catching primitives,
-- this might make a good base on which to build a debugger?)
--
-- NB This library is an _experimental_ feature which may be
--    removed in future versions of Hugs.
--    It can only be used if Hugs was configured with the
--    "--enable-internal--prims" flag.
----------------------------------------------------------------

module Hugs.GenericPrint(
        printError, 
        outputString, 
        print
        ) where

import Prelude hiding (print)

import Hugs.Internals(
        Name, nameInfo, nameString,
        Cell, getCell,
        CellKind(..), classifyCell,
        )

import Hugs.IOExts( unsafePerformIO )
import Hugs.Array
import Data.Char( showLitChar, isAlpha )
import Data.List( intersperse )

----------------------------------------------------------------
-- The top-level print routine 
----------------------------------------------------------------

printError   :: Cell -> IO ()
outputString :: String -> IO ()
print        :: a -> IO ()

printError err = do
  putStr "\nProgram error: " 
  printDBadRedex err 
  putStr "\n"

outputString s = outputStr (getCell s)

print x        = print' True (getCell x)

----------------------------------------------------------------

printBadRedex err = do
  putChar '{' 
  print' False err 
  putChar '}'

printDBadRedex err = do
  kind <- classifyCell False err
  case kind of
    Apply fun args -> do
      funkind <- classifyCell False fun
      case (funkind, args) of
        (Fun nm, [msg]) | nm == nameError ->
          outputStr msg
        _ -> printBadRedex err
    _ -> printBadRedex err

outputStr :: Cell -> IO ()
outputStr xs = do
  kind <- hugsClassifyCell True xs
  case kind of
    Apply fun args ->
      hugsClassifyCell True fun >>= \ funkind ->
      case (funkind, args) of
      (Con nm, [y,ys]) | nm == nameCons ->
        hugsClassifyCell True y >>= \ ykind ->
        case ykind of
        Char c ->
          putChar c >>
          outputStr ys
        Error err ->
          printBadRedex err >>
          outputStr ys
        _ ->
          printBadRedex y >>
          outputStr ys
      (Error err, _) ->
        printBadRedex err
      _ ->
        printBadRedex xs
    Con nm | nm == nameNil ->
        return ()
    Error err ->
        printBadRedex err
    _ ->
        printBadRedex xs

print' :: Bool -> Cell -> IO ()
print' strict x = printCell strict min_prec x

--ToDo: combine with sprint (if possible)
lprint :: Bool -> Cell -> Cell -> IO ()
lprint strict x xs =
  printCell strict min_prec x >>
  hugsClassifyCell strict xs >>= \ kind ->
  case kind of
  Apply fun args ->
      hugsClassifyCell strict fun >>= \ funkind ->
        case (funkind, args) of
        (Con nm, [y,ys]) | nm == nameCons ->
          putStr ", " >>
          lprint strict y ys
        (Error err, _) ->
          printBadRedex err
        _ ->
          putStr "] ++ " >>
          printBadRedex xs
  Con nm | nm == nameNil ->
          putChar ']'
  Error err ->
          printBadRedex err
  _ ->
          putStr "] ++ " >>
          printBadRedex xs

sprint :: Bool -> Char -> Cell -> IO ()
sprint strict c xs =
  putStr (showLitChar c "") >>
  hugsClassifyCell strict xs >>= \ kind ->
  case kind of
  Apply fun args ->
      hugsClassifyCell strict fun >>= \ funkind ->
        case (funkind, args) of
        (Con nm, [y,ys]) | nm == nameCons ->
          hugsClassifyCell strict y >>= \ ykind ->
          case ykind of
          Char c -> sprint strict c ys
          _      -> lprint False y ys
        _ ->
          putStr "\" ++ " >>
          printBadRedex xs
  Con nm | nm == nameNil ->
          putChar '"'
  _ ->
          putStr "\" ++ " >>
          printBadRedex xs

printCell :: Bool -> Int -> Cell -> IO ()
printCell strict d x =
  hugsClassifyCell strict x >>= \ kind ->
  case kind of
  Apply fun args ->
      hugsClassifyCell strict fun >>= \ funkind ->
      case funkind of
      Con nm ->
        case args of
          [x,xs] | nm == nameCons
            -> hugsClassifyCell strict x >>= \ xkind ->
               case xkind of
               Char c -> putChar '"' >> sprint strict c xs
               _      -> putChar '[' >> lprint strict x xs

          [x] | assoc /= 'A'
            -> printParen True (
                 printCell strict (fun_prec-1) x >>
                 putChar ' ' >>
                 putStr (asOp nameStr)
               )

          (x1:x2:xs) | assoc /= 'A'
            -> printParen (not (null xs) && d >= fun_prec) (
                 printParen (d <= p) (do
                   printCell strict lp x1
                   putChar ' '           
                   putStr (asOp nameStr) 
                   putChar ' '           
                   printCell strict rp x2
                   ) >>
                 mapM_ (\ arg ->
                   putChar ' ' >>
                   printCell strict p arg
                 ) xs
                 )

          xs
            -> printParen (not (null xs) && d >= fun_prec) (
                 -- test that xs is nonNull should be redundant but
                 -- no harm being robust
                 putStr (asVar nameStr)       >>
                 mapM_ (\arg ->
                   putChar ' ' >>
                   printCell strict fun_prec arg
                 ) xs
                 )
         where
          (arity, p, assoc) = nameInfo nm
          nameStr = nameString nm

          -- from Appendix E2 of Haskell 1.2 report
          lp = if assoc == 'L' then p else p+1
          rp = if assoc == 'R' then p else p+1
        
      Fun nm ->
        printParen (d >= fun_prec) (
          putStr (asVar nameStr)       >>
          mapM_ (\arg ->
            putChar ' ' >>
            -- switch to lazy printing!
            printCell False fun_prec arg
          ) args
          )
       where
        nameStr = nameString nm
      
      Tuple arity ->
        printParen (not (null extra) && d >= fun_prec) (
          printParen True (
            for__ fields (\ field ->
              printCell strict min_prec field
            ) (putChar ',') >>
            -- Haskell's syntax makes it impossible to construct an
            -- incomplete tuple - but let's play safe!
            mapM_ (\_ ->
              putChar ','
            ) [numArgs+1..arity]
          ) >>
          -- Haskell's type system makes extra arguments impossible
          -- - but let's play safe!
          mapM_ (\ arg ->
            putChar ' ' >>
            printCell strict fun_prec arg
          ) extra
        )
       where
        (fields, extra) = splitAt arity args

      Error err ->
          printBadRedex err

      _
        -> printParen (not (null args) && d >= fun_prec) (
             printCell strict fun_prec fun   >>
             mapM_ (\arg ->
               putChar ' ' >>
               printCell strict fun_prec arg
             ) args
             )
     where
        numArgs = length args

  Fun nm ->
    putStr (asVar (nameString nm))

  Con nm ->
    putStr (asVar (nameString nm))

  Tuple arity ->
    putStr ('(' : replicate arity ',' ++ ")")

  Int x ->
    putStr (show x)

  Integer x ->
    putStr (show x)

  Float x ->
    putStr (show x)

  Char x ->
    putStr ('\'' : showLitChar x "\'")

  Prim prim ->
    putStr prim

  Error err ->
    printBadRedex err

----------------------------------------------------------------
-- Cell/Name utilities
----------------------------------------------------------------

nameCons    =  cellName (:)
nameNil     =  cellName []
nameError   =  cellName error

-- Here's something VERY subtle.
-- We use classifyCell instead of hugsClassifyCell because
-- otherwise, this gets put in the same dependency class as everything
-- else and the lack of polymorphic recursion bites us.
-- (Using classifyCell is equally good here because it wont fail.)
cellName :: a -> Name
cellName x = unsafePerformIO (
  classifyCell True (getCell x) >>= \ kind ->
  case kind of
  Fun nm -> return nm
  Con nm -> return nm
  )

-- This implements the error-handling policy:
hugsClassifyCell :: Bool -> Cell -> IO CellKind
hugsClassifyCell strict obj =
  classifyCell strict obj >>= \ kind ->
  case kind of
  Error err ->
    if failOnError then
      exitWith (printError err)
    else
      return kind
  _ ->
    return kind

----------------------------------------------------------------
-- Utilities
----------------------------------------------------------------

for__ :: Monad m => [a] -> (a -> m ()) -> m () -> m ()
for__ xs f inc = sequence_ $ intersperse inc $ map f xs

min_prec, max_prec, fun_prec :: Int
min_prec = 0
max_prec = 9
fun_prec = max_prec+2

asOp str
 | isOp str  = str
 | otherwise = '`' : str ++ "`"

asVar str
 | isOp str  = '(' : str ++ ")"
 | otherwise = str

isOp (c:_) = not (isAlpha c || c == '[')
isOp _     = False

printParen :: Bool -> IO () -> IO ()
printParen True m  = putChar '(' >> m >> putChar ')'
printParen False m = m

----------------------------------------------------------------
-- Missing primitives
----------------------------------------------------------------

-- In Hugs0, this accessed the value of the :set -f" flag
failOnError :: Bool
failOnError = True

-- In Hugs0, this executed the action and terminated the current evaluation
exitWith :: IO () -> IO a
exitWith m = m >> error "{exitWith}"

----------------------------------------------------------------
-----------------------------------------------------------------------------
-- Standard Library: IO operations, beyond those included in the prelude
--
-- Suitable for use with Hugs 98
-----------------------------------------------------------------------------

module Hugs.IO (
    Handle,          -- instances: Eq, Show.
    HandlePosn,      -- instances: Eq, Show.
    
    IOMode(ReadMode,WriteMode,AppendMode,ReadWriteMode),
    BufferMode(NoBuffering,LineBuffering,BlockBuffering),
    SeekMode(AbsoluteSeek,RelativeSeek,SeekFromEnd),
    
    stdin, stdout, stderr,  -- :: Handle
    openFile,		    -- :: FilePath -> IOMode -> IO Handle
    hClose, 		    -- :: Handle -> IO ()

    hFileSize,		    -- :: Handle -> IO Integer

    hIsEOF,                 -- :: Handle -> IO Bool
    isEOF,                  -- :: IO Bool

    hSetBuffering,          -- :: Handle -> BufferMode -> IO ()
    hGetBuffering,          -- :: Handle -> IO BufferMode

    hFlush,                 -- :: Handle -> IO ()
    hGetPosn,		    -- :: Handle -> IO HandlePosn
    hSetPosn,               -- :: HandlePosn -> IO ()
    hSeek,                  -- :: Handle -> SeekMode -> Integer -> IO ()
    hTell,                  -- :: Handle -> IO Integer

    hLookAhead,             -- :: Handle -> IO Char

    hWaitForInput,          -- :: Handle -> Int -> IO Bool

    hGetChar,               -- :: Handle -> IO Char
    hGetLine,               -- :: Handle -> IO String
    hGetContents,           -- :: Handle -> IO String

    hPutChar,               -- :: Handle -> Char -> IO ()
    hPutStr,                -- :: Handle -> String -> IO ()

    hIsOpen,		    -- :: Handle -> IO Bool
    hIsClosed,		    -- :: Handle -> IO Bool
    hIsReadable,            -- :: Handle -> IO Bool
    hIsWritable,            -- :: Handle -> IO Bool
    hIsSeekable,            -- :: Handle -> IO Bool

    -- Non-standard extensions 
    handleToFd,             -- :: Handle -> IO Int
    openFd                  -- :: Int -> Bool -> IOMode -> Bool -> IO Handle
    ) where

import Hugs.Prelude	( Handle, IOMode(..), stdin, stdout, stderr )
import Hugs.Prelude	( openFile, hClose, hPutChar, hPutStr )
import Hugs.Prelude	( hGetContents, hGetChar, hGetLine )
import Hugs.Prelude	( Ix(..) )
import System.IO.Error

-- data Handle

data BufferMode  =  NoBuffering | LineBuffering 
                 |  BlockBuffering (Maybe Int)
                    deriving (Eq, Ord, Read, Show)
data SeekMode    =  AbsoluteSeek | RelativeSeek | SeekFromEnd
                    deriving (Eq, Ord, Ix, Bounded, Enum, Read, Show)

primitive hFileSize   :: Handle -> IO Integer

primitive hIsEOF      :: Handle -> IO Bool

isEOF               :: IO Bool
isEOF                = hIsEOF stdin

hSetBuffering       :: Handle  -> BufferMode -> IO ()
hSetBuffering h bMode = 
  case bMode of
    NoBuffering   -> hSetBuff h 0 0
    LineBuffering -> hSetBuff h 1 0
    BlockBuffering (Just x) -> hSetBuff h 2 x
    BlockBuffering _        -> hSetBuff h 2 0

primitive hSetBuff  :: Handle -> Int -> Int -> IO ()

hGetBuffering       :: Handle  -> IO BufferMode
hGetBuffering h = do
  (k, sz) <- hGetBuff h
  case k of
    1 -> return NoBuffering
    2 -> return LineBuffering
    3 -> return (BlockBuffering (Just sz))
     -- fatal - never to happen.
    _ -> error "IO.hGetBuffering: unknown buffering mode"

primitive hGetBuff :: Handle -> IO (Int,Int)

primitive hFlush   :: Handle -> IO ()

data HandlePosn = HandlePosn Handle Int deriving Eq

instance Show HandlePosn where
   showsPrec p (HandlePosn h pos) = 
        showsPrec p h . showString " at position " . shows pos

hGetPosn :: Handle -> IO HandlePosn
hGetPosn h = do
  p <- hGetPosnPrim h
  return (HandlePosn h p)

hTell :: Handle -> IO Integer
hTell h = do
  p <- hGetPosnPrim h
  return (toInteger p)

primitive hGetPosnPrim :: Handle -> IO Int

hSetPosn :: HandlePosn -> IO ()
hSetPosn (HandlePosn h p) = hSetPosnPrim h p

primitive hSetPosnPrim  :: Handle -> Int -> IO () 

hSeek :: Handle -> SeekMode -> Integer -> IO () 
hSeek h sMode int 
 | int >  fromIntegral (maxBound :: Int) ||
   int <  fromIntegral (minBound :: Int) =
   ioError (userError ("IO.hSeek: seek offset out of supported range"))
 | otherwise = 
   hSeekPrim h (fromEnum sMode) ((fromIntegral int)::Int)
  
primitive hSeekPrim :: Handle -> Int -> Int -> IO () 

primitive hWaitForInput :: Handle -> Int -> IO Bool

primitive hLookAhead    :: Handle -> IO Char

primitive hIsOpen,    
   	  hIsClosed,  
   	  hIsReadable,
   	  hIsWritable,
	  hIsSeekable :: Handle -> IO Bool

-----------------------------------------------------------------------------

-- Extract the file descriptor from a Handle, closing the Handle
primitive handleToFd :: Handle -> IO Int

--
-- Creating a handle from a file descriptor/socket.
--
primitive openFd    :: Int    -- file descriptor
		    -> Bool   -- True => it's a socket.
		    -> IOMode -- what mode to open the handle in.
		    -> Bool   -- binary?
		    -> IO Handle
-----------------------------------------------------------------------------
-- Mutable arrays in the IO monad:
--
-- Suitable for use with Hugs 98.
-----------------------------------------------------------------------------

module Hugs.IOArray
	( IOArray			-- instance of: Eq, Typeable
	, newIOArray
	, boundsIOArray
	, readIOArray
	, writeIOArray
	, freezeIOArray
	, thawIOArray
	, unsafeFreezeIOArray
	, unsafeReadIOArray
	, unsafeWriteIOArray
	) where

import Hugs.Array

-----------------------------------------------------------------------------

data IOArray ix elt -- implemented as an internal primitive

newIOArray          :: Ix ix => (ix,ix) -> elt -> IO (IOArray ix elt)
boundsIOArray       :: Ix ix => IOArray ix elt -> (ix, ix)
readIOArray         :: Ix ix => IOArray ix elt -> ix -> IO elt
writeIOArray        :: Ix ix => IOArray ix elt -> ix -> elt -> IO ()
thawIOArray         :: Ix ix => Array ix elt -> IO (IOArray ix elt)
freezeIOArray       :: Ix ix => IOArray ix elt -> IO (Array ix elt)
unsafeFreezeIOArray :: Ix ix => IOArray ix elt -> IO (Array ix elt)

unsafeReadIOArray   :: Ix i => IOArray i e -> Int -> IO e
unsafeReadIOArray    = primReadArr

unsafeWriteIOArray  :: Ix i => IOArray i e -> Int -> e -> IO ()
unsafeWriteIOArray   = primWriteArr

newIOArray bs e      = primNewArr bs (rangeSize bs) e
boundsIOArray a      = primBounds a
readIOArray a i      = unsafeReadIOArray a (index (boundsIOArray a) i)
writeIOArray a i e   = unsafeWriteIOArray a (index (boundsIOArray a) i) e
thawIOArray arr      = do a <- newIOArray (bounds arr) err
			  let fillin []          = return a
			      fillin((ix,v):ixs) = do writeIOArray a ix v
                                                      fillin ixs
                          fillin (assocs arr)
                       where err =  error "thawArray: element not overwritten"

freezeIOArray a      = primFreeze a
unsafeFreezeIOArray  = freezeIOArray  -- not as fast as GHC

instance Eq (IOArray ix elt) where
  (==) = eqIOArray

primitive primNewArr   "IONewArr"
          :: (a,a) -> Int -> b -> IO (IOArray a b)
primitive primReadArr  "IOReadArr"
          :: IOArray a b -> Int -> IO b
primitive primWriteArr "IOWriteArr"
          :: IOArray a b -> Int -> b -> IO ()
primitive primFreeze   "IOFreeze"
          :: IOArray a b -> IO (Array a b)
primitive primBounds   "IOBounds"
          :: IOArray a b -> (a,a)
primitive eqIOArray    "IOArrEq"
          :: IOArray a b -> IOArray a b -> Bool

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- IO monad extensions:
--
-- Suitable for use with Hugs 98.
-----------------------------------------------------------------------------

module Hugs.IOExts
	( unsafePerformIO	-- :: IO a -> a
	, unsafeInterleaveIO	-- :: IO a -> IO a

	, performGC

	, IOModeEx(..)	      	-- instance (Eq, Read, Show)
	, openFileEx	      	-- :: FilePath -> IOModeEx -> IO Handle

	, unsafePtrEq
	, unsafePtrToInt
	, unsafeCoerce
	
	  -- backward compatibility with IOExtensions
	, readBinaryFile        -- :: FilePath -> IO String
	, writeBinaryFile       -- :: FilePath -> String -> IO ()
	, appendBinaryFile      -- :: FilePath -> String -> IO ()
	, openBinaryFile        -- :: FilePath -> IOMode -> IO Handle

	, hSetBinaryMode	-- :: Handle -> Bool -> IO ()
	, hPutBuf	        -- :: Handle -> Ptr a -> Int -> IO ()
	, hGetBuf	        -- :: Handle -> Ptr a -> Int -> IO Int

	, argv                  -- :: [String]

	-- Terminal operations
	, hIsTerminalDevice	-- :: Handle -> IO Bool
	, hGetEcho		-- :: Handle -> IO Bool
	, hSetEcho		-- :: Handle -> Bool -> IO ()
	) where

import Hugs.Prelude
import Hugs.IO
import Hugs.System ( getArgs )
import Hugs.Ptr ( Ptr )

-----------------------------------------------------------------------------

primitive performGC "primGC" :: IO ()

unsafePerformIO :: IO a -> a
unsafePerformIO m = valueOf (basicIORun m)

unsafeInterleaveIO :: IO a -> IO a
unsafeInterleaveIO m = IO (\ s -> s (unsafePerformIO m))

primitive unsafePtrEq    :: a -> a -> Bool
primitive unsafePtrToInt :: a -> Int

primitive unsafeCoerce "primUnsafeCoerce" :: a -> b

valueOf :: IOFinished a -> a
valueOf (Finished_Return a) = a
valueOf _ = error "IOExts.valueOf: thread failed"	-- shouldn't happen

-----------------------------------------------------------------------------
-- Binary files 
-----------------------------------------------------------------------------
data IOModeEx 
 = BinaryMode IOMode
 | TextMode   IOMode
   deriving (Eq, Read, Show)

openFileEx :: FilePath -> IOModeEx -> IO Handle
openFileEx fp m = 
  case m of
    BinaryMode m -> openBinaryFile fp m
    TextMode m   -> openFile fp m

argv :: [String]
argv = unsafePerformIO getArgs

writeBinaryFile		:: FilePath -> String -> IO ()
writeBinaryFile		 = writeBinaryFile' WriteMode

appendBinaryFile	:: FilePath -> String -> IO ()
appendBinaryFile	 = writeBinaryFile' AppendMode

writeBinaryFile'	:: IOMode -> FilePath -> String -> IO ()
writeBinaryFile' mode name s = do
  h <- openBinaryFile name mode
  catchException (hPutStr h s) (\e -> hClose h >> throw e)
  hClose h

readBinaryFile		:: FilePath -> IO String
readBinaryFile name	 = openBinaryFile name ReadMode >>= hGetContents

primitive openBinaryFile         :: FilePath -> IOMode -> IO Handle

primitive hSetBinaryMode	 :: Handle -> Bool -> IO ()
primitive hPutBuf	    	 :: Handle -> Ptr a -> Int -> IO ()
primitive hGetBuf	    	 :: Handle -> Ptr a -> Int -> IO Int

primitive hIsTerminalDevice	 :: Handle -> IO Bool
primitive hGetEcho		 :: Handle -> IO Bool
primitive hSetEcho		 :: Handle -> Bool -> IO ()
module Hugs.IORef
	( IORef		      -- abstract, instance of: Eq
        , newIORef	      -- :: a -> IO (IORef a)
        , readIORef	      -- :: IORef a -> IO a
        , writeIORef	      -- :: IORef a -> a -> IO ()
	) where

data IORef a        -- mutable variables containing values of type a

primitive newIORef   "newRef" :: a -> IO (IORef a)
primitive readIORef  "getRef" :: IORef a -> IO a
primitive writeIORef "setRef" :: IORef a -> a -> IO ()
primitive eqIORef    "eqRef"  :: IORef a -> IORef a -> Bool

instance Eq (IORef a) where
    (==) = eqIORef
----------------------------------------------------------------------------
-- Signed Integers
-- Suitable for use with Hugs 98 on 32 bit systems.
-----------------------------------------------------------------------------

module Hugs.Int
	( Int8
	, Int16
	, Int32
	, Int64
	-- plus Eq, Ord, Num, Bounded, Real, Integral, Ix, Enum, Read,
	--  Show and Bits instances for each of Int8, Int16 and Int32
	) where

import Hugs.Prelude ( Int8, Int16, Int32, Int64,
		      boundedSucc, boundedPred,
                      boundedEnumFrom, boundedEnumFromTo,
                      boundedEnumFromThen, boundedEnumFromThenTo )
import Hugs.Prelude ( Ix(..) )
import Hugs.Prelude ( (%) )
import Hugs.Prelude ( readDec )
import Hugs.Prelude ( Num(fromInt), Integral(toInt) )
import Hugs.Numeric ( showInt )
import Hugs.Bits
import Data.Bits

-----------------------------------------------------------------------------
-- Int8
-----------------------------------------------------------------------------

primitive int8ToInt "primInt8ToInt" :: Int8 -> Int
primitive intToInt8 "primIntToInt8" :: Int -> Int8

instance Eq  Int8     where (==)    = binop (==)
instance Ord Int8     where compare = binop compare

instance Num Int8 where
    x + y         = intToInt8 (binop (+) x y)
    x - y         = intToInt8 (binop (-) x y)
    negate        = intToInt8 . negate . int8ToInt
    x * y         = intToInt8 (binop (*) x y)
    abs           = absReal
    signum        = signumReal
    fromInteger   = intToInt8 . fromInteger
    fromInt       = intToInt8

instance Bounded Int8 where
    minBound = 0x80
    maxBound = 0x7f

instance Real Int8 where
    toRational x = toInteger x % 1

instance Integral Int8 where
    x `div` y     = intToInt8  (binop div x y)
    x `quot` y    = intToInt8  (binop quot x y)
    x `rem` y     = intToInt8  (binop rem x y)
    x `mod` y     = intToInt8  (binop mod x y)
    x `quotRem` y = to2 (binop quotRem x y)
    toInteger     = toInteger . int8ToInt
    toInt         = int8ToInt

instance Ix Int8 where
    range (m,n)          = [m..n]
    unsafeIndex (m,_) i  = toInt (i - m)
    inRange (m,n) i      = m <= i && i <= n

instance Enum Int8 where
    succ             = boundedSucc
    pred             = boundedPred
    toEnum           = fromInt
    fromEnum         = toInt
    enumFrom         = boundedEnumFrom
    enumFromThen     = boundedEnumFromThen

instance Read Int8 where
    readsPrec p s = [ (intToInt8 x,r) | (x,r) <- readsPrec p s ]

instance Show Int8 where
    showsPrec p = showsPrec p . int8ToInt

instance Bits Int8 where
  x .&. y       = intToInt8 (binop (.&.) x y)
  x .|. y       = intToInt8 (binop (.|.) x y)
  x `xor` y     = intToInt8 (binop xor x y)
  complement    = intToInt8 . complement . int8ToInt
  x `shift` i   = intToInt8 (int8ToInt x `shift` i)
  rotate        = rotateSigned
  bit           = intToInt8 . bit
  setBit x i    = intToInt8 (setBit (int8ToInt x) i)
  clearBit x i  = intToInt8 (clearBit (int8ToInt x) i)
  complementBit x i = intToInt8 (complementBit (int8ToInt x) i)
  testBit x i   = testBit (int8ToInt x) i
  bitSize  _    = 8
  isSigned _    = True

-----------------------------------------------------------------------------
-- Int16
-----------------------------------------------------------------------------

primitive int16ToInt "primInt16ToInt" :: Int16 -> Int
primitive intToInt16 "primIntToInt16" :: Int -> Int16

instance Eq  Int16     where (==)    = binop (==)
instance Ord Int16     where compare = binop compare

instance Num Int16 where
    x + y         = intToInt16 (binop (+) x y)
    x - y         = intToInt16 (binop (-) x y)
    negate        = intToInt16 . negate . int16ToInt
    x * y         = intToInt16 (binop (*) x y)
    abs           = absReal
    signum        = signumReal
    fromInteger   = intToInt16 . fromInteger
    fromInt       = intToInt16

instance Bounded Int16 where
    minBound = 0x8000
    maxBound = 0x7fff

instance Real Int16 where
    toRational x = toInteger x % 1

instance Integral Int16 where
    x `div` y     = intToInt16  (binop div x y)
    x `quot` y    = intToInt16  (binop quot x y)
    x `rem` y     = intToInt16  (binop rem x y)
    x `mod` y     = intToInt16  (binop mod x y)
    x `quotRem` y = to2 (binop quotRem x y)
    toInteger     = toInteger . int16ToInt
    toInt         = int16ToInt

instance Ix Int16 where
    range (m,n)          = [m..n]
    unsafeIndex (m,_) i  = toInt (i - m)
    inRange (m,n) i      = m <= i && i <= n

instance Enum Int16 where
    succ             = boundedSucc
    pred             = boundedPred
    toEnum           = fromInt
    fromEnum         = toInt
    enumFrom         = boundedEnumFrom
    enumFromThen     = boundedEnumFromThen

instance Read Int16 where
    readsPrec p s = [ (intToInt16 x,r) | (x,r) <- readsPrec p s ]

instance Show Int16 where
    showsPrec p = showsPrec p . int16ToInt

instance Bits Int16 where
  x .&. y       = intToInt16 (binop (.&.) x y)
  x .|. y       = intToInt16 (binop (.|.) x y)
  x `xor` y     = intToInt16 (binop xor x y)
  complement    = intToInt16 . complement . int16ToInt
  x `shift` i   = intToInt16 (int16ToInt x `shift` i)
  rotate        = rotateSigned
  bit           = intToInt16 . bit
  setBit x i    = intToInt16 (setBit (int16ToInt x) i)
  clearBit x i  = intToInt16 (clearBit (int16ToInt x) i)
  complementBit x i = intToInt16 (complementBit (int16ToInt x) i)
  testBit x i   = testBit (int16ToInt x) i
  bitSize  _    = 16
  isSigned _    = True

-----------------------------------------------------------------------------
-- Int32
-----------------------------------------------------------------------------

primitive int32ToInt "primInt32ToInt" :: Int32 -> Int
primitive intToInt32 "primIntToInt32" :: Int -> Int32

instance Eq  Int32 where (==)    = binop (==)
instance Ord Int32 where compare = binop compare

instance Num Int32 where
    x + y         = intToInt32 (binop (+) x y)
    x - y         = intToInt32 (binop (-) x y)
    negate        = intToInt32 . negate . int32ToInt
    x * y         = intToInt32 (binop (*) x y)
    abs           = absReal
    signum        = signumReal
    fromInteger   = intToInt32 . fromInteger
    fromInt       = intToInt32

instance Bounded Int32 where
    minBound = intToInt32 minBound
    maxBound = intToInt32 maxBound

instance Real Int32 where
    toRational x = toInteger x % 1

instance Integral Int32 where
    x `div` y     = intToInt32 (binop div x y)
    x `quot` y    = intToInt32 (binop quot x y)
    x `rem` y     = intToInt32 (binop rem x y)
    x `mod` y     = intToInt32 (binop mod x y)
    x `quotRem` y = to2 (binop quotRem x y)
    toInteger     = toInteger . int32ToInt
    toInt         = int32ToInt

instance Ix Int32 where
    range (m,n)          = [m..n]
    unsafeIndex (m,_) i  = toInt (i - m)
    inRange (m,n) i      = m <= i && i <= n

instance Enum Int32 where
    succ             = boundedSucc
    pred             = boundedPred
    toEnum           = fromInt
    fromEnum         = toInt
    enumFrom         = boundedEnumFrom
    enumFromThen     = boundedEnumFromThen

instance Read Int32 where
    readsPrec p s = [ (intToInt32 x,r) | (x,r) <- readsPrec p s ]

instance Show Int32 where
    showsPrec p = showsPrec p . int32ToInt

instance Bits Int32 where
    x .&. y       = intToInt32 (binop (.&.) x y)
    x .|. y       = intToInt32 (binop (.|.) x y)
    x `xor` y     = intToInt32 (binop xor x y)
    complement    = intToInt32 . complement . int32ToInt
    x `shift` i   = intToInt32 (int32ToInt x `shift` i)
    rotate        = rotateSigned
    bit           = intToInt32 . bit
    setBit x i    = intToInt32 (setBit (int32ToInt x) i)
    clearBit x i  = intToInt32 (clearBit (int32ToInt x) i)
    complementBit x i = intToInt32 (complementBit (int32ToInt x) i)
    testBit x i   = testBit (int32ToInt x) i
    bitSize  _    = 32
    isSigned _    = True

-----------------------------------------------------------------------------
-- Int64
-----------------------------------------------------------------------------

-- Assume a 2s-complement representation, and that this function
-- separates the top 32 bits from the lower 32.

primitive int64ToInt32 "primInt64ToInt32" :: Int64 -> (Int32,Int32)
primitive int32ToInt64 "primInt32ToInt64" :: Int32 -> Int32 -> Int64

integerToI64 :: Integer -> Int64
integerToI64 x = case x `divMod` 0x100000000 of
    (hi,lo) -> int32ToInt64 (fromInteger hi) (fromInteger lo)

i64ToInteger :: Int64 -> Integer
i64ToInteger x = case int64ToInt32 x of
    (hi,lo) -> (if lo<0 then toInteger hi+1 else toInteger hi)*0x100000000 +
	toInteger lo

instance Eq Int64 where
    x == y = int64ToInt32 x == int64ToInt32 y

instance Ord Int64 where
    compare x y = compare (toInteger x) (toInteger y)

instance Bounded Int64 where
    minBound = int32ToInt64 minBound 0
    maxBound = int32ToInt64 maxBound (-1)

instance Show Int64 where
    showsPrec p = showsPrec p . toInteger

instance Read Int64 where
    readsPrec p s = [ (fromInteger x,r) | (x,r) <- readDec s ]

instance Num Int64 where
    x + y         = fromInteger (toInteger x + toInteger y)
    x - y         = fromInteger (toInteger x - toInteger y)
    x * y         = fromInteger (toInteger x * toInteger y)
    abs           = absReal
    signum        = signumReal
    fromInteger   = integerToI64

instance Real Int64 where
    toRational x = toInteger x % 1

instance Ix Int64 where
    range (m,n)          = [m..n]
    unsafeIndex (m,_) i  = toInt (i - m)
    inRange (m,n) i      = m <= i && i <= n

instance Enum Int64 where
    succ             = boundedSucc
    pred             = boundedPred
    toEnum           = fromInt
    fromEnum         = toInt

    enumFrom x       = enumFromTo x maxBound
    enumFromTo x y   = map fromInteger [toInteger x .. toInteger y]
    enumFromThen     = boundedEnumFromThen
    enumFromThenTo x y z =
                       map fromInteger [toInteger x, toInteger y .. toInteger z]

instance Integral Int64 where
    x `quotRem` y = (fromInteger q, fromInteger r)
	where (q,r) = toInteger x `quotRem` toInteger y
    toInteger     = i64ToInteger

instance Bits Int64 where
    x .&. y       = liftBinary (.&.) x y
    x .|. y       = liftBinary (.|.) x y
    x `xor` y     = liftBinary xor x y
    complement    = liftUnary complement
    x `shift` i   = fromInteger (toInteger x `shift` i)
    rotate        = rotateSigned
    bit i | i `mod` 64 < 32 = int32ToInt64 0 (bit i)
          | otherwise       = int32ToInt64 (bit i) 0
    bitSize  _    = 64
    isSigned _    = True

liftBinary :: (Int32 -> Int32 -> Int32) -> Int64 -> Int64 -> Int64
liftBinary op x y = int32ToInt64 (op xhi yhi) (op xlo ylo)
	where	(xhi,xlo) = int64ToInt32 x
		(yhi,ylo) = int64ToInt32 y

liftUnary :: (Int32 -> Int32) -> Int64 -> Int64
liftUnary op x = int32ToInt64 (op xhi) (op xlo)
	where	(xhi,xlo) = int64ToInt32 x

rotateSigned :: (Bits a, Ord a) => a -> Int -> a
rotateSigned x i | i<0 && x<0
                        = let left = i+bitSize x in
                          ((x `shift` i) .&. complement ((-1) `shift` left))
                          .|. (x `shift` left)
                 | i<0  = (x `shift` i) .|. (x `shift` (i+bitSize x))
                 | i==0 = x
                 | i>0  = (x `shift` i) .|. (x `shift` (i-bitSize x))

-----------------------------------------------------------------------------
-- End of exported definitions
--
-- The remainder of this file consists of definitions which are only
-- used in the implementation.
-----------------------------------------------------------------------------

binop :: Integral int => (Int -> Int -> a) -> (int -> int -> a)
binop op x y = toInt x `op` toInt y

from :: Integral int => int -> Int
from = toInt

to :: Num int => Int -> int
to = fromInt

to2 :: Num int => (Int, Int) -> (int, int)
to2 (x,y) = (fromInt x, fromInt y)

-----------------------------------------------------------------------------
-- Code copied from the Prelude
-----------------------------------------------------------------------------

absReal x    | x >= 0    = x
	     | otherwise = -x

signumReal x | x == 0    =  0
	     | x > 0     =  1
	     | otherwise = -1

-----------------------------------------------------------------------------
-- End
-----------------------------------------------------------------------------
----------------------------------------------------------------
-- Primitives for accessing Hugs internals.
--
-- NB These primitives are an _experimental_ feature which may be
--    removed in future versions of Hugs.
--    They can only be used if hugs was configured with the
--    "--enable-internal-prims" flag.
--
-- The primitives defined in this module provide the means with
-- which to implement simple error-recovery and debugging facilities
-- in Haskell.  
--
-- The error catching primitive only works if the "failOnError" flag 
-- is FALSE - ie Hugs was invoked with the "-f" flag.
--
-- Despite appearances, these primitives are referentially transparent
-- (with the exception of the rarely used pointer equality operations)
-- (The proof is really neat - but there just isn't enough space in the margin)
----------------------------------------------------------------

module Hugs.Internals(
	ptrEq,

	Name,
	  nameString,
	  nameInfo,
	  nameEq,
	Cell,
	  getCell,
	  cellPtrEq,
	CellKind(..),
	  classifyCell,

	catchError,

	Addr,
          nameCode,
	Instr(..),
	  instrAt, instrsAt,

	) where

import Hugs.Prelude hiding ( Addr )

----------------------------------------------------------------
-- pointer equality
----------------------------------------------------------------

-- breaks referential transparency - use with care
primitive ptrEq "unsafePtrEq" :: a -> a -> Bool


----------------------------------------------------------------
-- Name
----------------------------------------------------------------

data Name
-- newtype Name = Name Int

-- returns (arity, precedence, associativity)
primitive nameInfo       :: Name -> (Int, Int, Char)
primitive nameString     :: Name -> String
primitive nameEq         :: Name -> Name -> Bool

instance Show Name where
  showsPrec _ nm = showString (nameString nm)

instance Eq Name where
  (==) = nameEq


----------------------------------------------------------------
-- Cell
-- Note: cellPtrEq breaks referential transparency - use with care
----------------------------------------------------------------

data Cell

primitive getCell                  :: a -> Cell
primitive cellPtrEq                :: Cell -> Cell -> Bool
primitive catchError "catchError2" :: a -> Either Cell a

instance Show Cell where 
  showsPrec _ _ = showString "{Cell}"

----------------------------------------------------------------
-- CellType
----------------------------------------------------------------

data CellKind       
  = Apply   Cell [Cell]
  | Fun     Name    
  | Con     Name    
  | Tuple   Int         
  | Int     Int         
  | Integer Integer   
  | Float   Float       
  | Double  Double       
  | Char    Char        
  | Prim    String      
  | Error   Cell  
  deriving (Show)

primitive classifyCell :: Bool -> Cell -> IO CellKind

----------------------------------------------------------------
-- Addr
----------------------------------------------------------------

newtype Addr  = Addr  Int deriving (Eq, Show)

s :: Addr -> Addr
s (Addr a) = Addr (a+1)

primitive nameCode    :: Name -> Addr
primitive intAt       :: Addr -> Int
primitive floatAt     :: Addr -> Float
primitive doubleAt    :: Addr -> Double
primitive cellAt      :: Addr -> Cell
primitive nameAt      :: Addr -> Name
primitive textAt      :: Addr -> String
primitive addrAt      :: Addr -> Addr
primitive bytecodeAt :: Addr -> Bytecode


----------------------------------------------------------------
-- Bytecode
----------------------------------------------------------------

newtype Bytecode = Bytecode Int deriving (Eq, Show)

iLOAD    = Bytecode 0
iCELL	 = Bytecode 1
iCHAR	 = Bytecode 2
iINT	 = Bytecode 3
iFLOAT	 = Bytecode 4
iSTRING	 = Bytecode 5
iMKAP	 = Bytecode 6
iUPDATE	 = Bytecode 7
iUPDAP	 = Bytecode 8
iEVAL	 = Bytecode 9
iRETURN	 = Bytecode 10
iTEST	 = Bytecode 11
iGOTO	 = Bytecode 12
iSETSTK	 = Bytecode 13
iROOT	 = Bytecode 14
iDICT	 = Bytecode 15
iFAIL	 = Bytecode 16
iALLOC	 = Bytecode 17
iSLIDE	 = Bytecode 18
iSTAP	 = Bytecode 19
iTABLE	 = Bytecode 20
iLEVAL	 = Bytecode 21
iRUPDAP	 = Bytecode 22
iRUPDATE = Bytecode 23

data Instr 
  = LOAD    Int
  | CELL    Cell
  | CHAR    Char
  | INT	    Int    
  | FLOAT   Float   	  
  | DOUBLE  Double
  | STRING  String  	  
  | MKAP    Int   
  | UPDATE  Int  	  
  | UPDAP   Int  	  
  | EVAL    	   
  | RETURN  	   
  | TEST    Name Addr
  | GOTO    Addr  	  
  | SETSTK  Int  	  
  | ROOT    Int  	  
  | DICT    Int
  | FAIL    	   
  | ALLOC   Int
  | SLIDE   Int	   
  | STAP    	   
  | TABLE   	   
  | LEVAL   Int	   
  | RUPDAP  	   
  | RUPDATE 
  deriving (Show)

instrAt :: Addr -> (Instr, Addr)
instrAt pc = case bytecodeAt pc of 
  i | i == iLOAD    -> (LOAD    (intAt   (s pc)), s (s pc))
  i | i == iCELL    -> (CELL    (cellAt  (s pc)), s (s pc))
  i | i == iCHAR    -> (CHAR    (toEnum (intAt (s pc))), s (s pc))
  i | i == iINT     -> (INT     (intAt   (s pc)), s (s pc))
  i | i == iFLOAT   -> (FLOAT   (floatAt (s pc)), s (s pc))
  i | i == iSTRING  -> (STRING  (textAt  (s pc)), s (s pc))
  i | i == iMKAP    -> (MKAP    (intAt   (s pc)), s (s pc))
  i | i == iUPDATE  -> (UPDATE  (intAt   (s pc)), s (s pc))
  i | i == iUPDAP   -> (UPDAP   (intAt   (s pc)), s (s pc))
  i | i == iEVAL    -> (EVAL                    , s pc)
  i | i == iRETURN  -> (RETURN                  , s pc)
  i | i == iTEST    -> (TEST    (nameAt  (s pc)) (addrAt (s (s (pc)))), s (s (s pc)))
  i | i == iGOTO    -> (GOTO    (addrAt  (s pc)), s (s pc))
  i | i == iSETSTK  -> (SETSTK  (intAt   (s pc)), s (s pc))
  i | i == iROOT    -> (ROOT    (intAt   (s pc)), s (s pc))
  i | i == iDICT    -> (DICT    (intAt   (s pc)), s (s pc))
  i | i == iFAIL    -> (FAIL                    , s pc)
  i | i == iALLOC   -> (ALLOC   (intAt   (s pc)), s (s pc))
  i | i == iSLIDE   -> (SLIDE   (intAt   (s pc)), s (s pc))
  i | i == iSTAP    -> (STAP                    , s pc)
  i | i == iTABLE   -> (TABLE                   , s pc)
  i | i == iLEVAL   -> (LEVAL   (intAt   (s pc)), s (s pc))
  i | i == iRUPDAP  -> (RUPDAP                  , s pc)
  i | i == iRUPDATE -> (RUPDATE                 , s pc)

-- list of instructions starting at given address
instrsAt :: Addr -> [Instr]
instrsAt pc = let (i, pc')  = instrAt pc in i : instrsAt pc'


----------------------------------------------------------------



----------------------------------------------------------------
-- tests
----------------------------------------------------------------

-- test1, test2 :: Either Cell Int
-- 
-- test1 = catchError (error "foo")
-- test2 = catchError 1
-- 
-- 
-- test3, test4, test5 :: Int
-- 
-- test3 = myCatch (1+error "foo") 2
-- test4 = myCatch 1 (error "bar")
-- test5 = myCatch (error "foo") (error "bar")
-- 
-- 
-- test6, test7, test8, test9 :: IO ()
-- 
-- test6 = printString "abcdefg"
-- test7 = printString (error "a" : "bcdefg")
-- test8 = printString ("abc" ++ error "defg")
-- test9 = printString (error "a" : "bc" ++ error "defg")
-- 
-- -- if an error occurs, replace it with a default (hopefully error-free) value
-- myCatch :: a -> a -> a
-- myCatch x deflt = case catchError x of
-- 		   Right x' -> x'
-- 		   Left _   -> deflt
-- 
-- -- lazily print a string - catching any errors as necessary
-- printString :: String -> IO ()
-- printString str =
--   case catchError str of
--   Left _       -> putStr "<error>"
--   Right []     -> return ()
--   Right (c:cs) -> case catchError c of
-- 		     Left _   -> putStr "<error>" >> printString cs
-- 		     Right c' -> putChar c' >> printString cs



-----------------------------------------------------------------------------
-- Lazy State Thread module
-- 
-- This library provides support for both lazy and strict state threads,
-- as described in the PLDI '94 paper by John Launchbury and Simon Peyton
-- Jones.  In addition to the monad ST, it also provides mutable variables
-- STRef and mutable arrays STArray.  It is identical to the ST module
-- except that the ST instance is lazy.
--
-- Suitable for use with Hugs 98.
-----------------------------------------------------------------------------

module Hugs.LazyST 
	( ST
	, runST
	, unsafeInterleaveST
	, fixST 

	, lazyToStrictST
	, strictToLazyST
	) where

import qualified Hugs.ST as ST
import Control.Monad   

-----------------------------------------------------------------------------

newtype ST s a = ST (State s -> (a, State s))

unST :: ST s a -> State s -> (a, State s)
unST (ST f) = f

runST :: (forall s. ST s a) -> a
runST m = fst (unST m S)

unsafeInterleaveST :: ST s a -> ST s a
unsafeInterleaveST (ST m) = return (fst (m S))

fixST :: (a -> ST s a) -> ST s a
fixST f = ST (\s -> let (x,s') = unST (f x) s in (x,s'))

instance Functor (ST s) where
    fmap = liftM

instance Monad (ST s) where
    return a = ST (\s -> (a, s))
    ST m >>= f = ST (\S -> let (a,s') = m S in unST (f a) s')
    -- ST m >>= f = ST (\s -> let (a,s') = m s in unST (f a) s')

-----------------------------------------------------------------------------

data State s = S

-----------------------------------------------------------------------------

lazyToStrictST :: ST s a -> ST.ST s a
lazyToStrictST (ST m) = ST.ST (\k -> case m S of (a,S) -> k a)

strictToLazyST :: ST.ST s a -> ST s a
strictToLazyST (ST.ST m) = ST (\S -> m delay)
--	\s -> let (a',s') = case s of S -> m (\a -> (a,S)) in (a',s'))

delay :: a -> (a, State s)
delay a = (a,S)

-----------------------------------------------------------------------------
{-----------------------------------------------------------------------------

                   A LIBRARY OF MEMOIZATION COMBINATORS

                            15th September 1999

	                         Byron Cook
			            OGI

This Hugs module implements several flavors of memoization functions,
as described in Haskell Workshop 1997.
-----------------------------------------------------------------------------}

module Hugs.Memo(
        memo,  
        memoN,  
        memoFix,
        memoFixN,
        cache, 
        cacheN, 
        cacheFix,
        cacheFixN
        ) where

import Hugs.ST
-- import Hugs.IOExts (unsafePtrEq)
-- import Debug.Trace (trace)

memo      :: (a -> b) -> (a -> b)
memoN     :: Int -> (a -> b) -> (a -> b)
memoFix   :: ((a -> b) -> (a -> b)) -> (a -> b)
memoFixN  :: Int -> ((a -> b) -> (a -> b)) -> (a -> b)
cache     :: (a -> b) -> (a -> b)
cacheN    :: Int -> (a -> b) -> (a -> b)
cacheFix  :: ((a -> b) -> (a -> b)) -> (a -> b)
cacheFixN :: Int -> ((a -> b) -> (a -> b)) -> (a -> b)

----------------------------------------------------------------
-- Memoization Functions (memo-tables are hash-tables)
----------------------------------------------------------------
memo          = memoN defaultSize 
memoN         = mkMemo eql hash 

memoFix       = memoFixN defaultSize 
memoFixN n f  = let g = f h
                    h = memoN n g
                in g

----------------------------------------------------------------
-- Caching Functions (memo-tables are caches)
----------------------------------------------------------------
cache          = cacheN defaultSize
cacheN         = mkCache eql hash
cacheFix       = cacheFixN defaultSize
cacheFixN n f  = let g = f h
                     h = cacheN n g
                 in g

----------------------------------------------------------------
-- Type synonyms
----------------------------------------------------------------
type TaintedEq a   = a -> a -> ST Mem Bool
type HashTable a b = STArray Mem Int [(a,b)]
type Cache a b     = STArray Mem Int (Maybe (a,b))
type HashSize      = Int
type HashFunc a    = a -> ST Mem Int
type Mem           = ()


----------------------------------------------------------------
-- Foundation functions
----------------------------------------------------------------
defaultSize :: HashSize
defaultSize = 40

memoize :: ST Mem t -> (t -> a -> b -> ST Mem b) -> 
           (a -> b) -> a -> b
memoize new access f = {-trace "memoize" $-} unsafeRunST $ do 
  t <- new
  return (\x -> unsafeRunST $ access t x (f x))


mkMemo  :: TaintedEq a -> HashFunc a -> Int -> (a -> c) -> (a -> c)
mkCache :: TaintedEq a -> HashFunc a -> Int -> (a -> c) -> (a -> c)

mkCache e h sz = memoize (newCache sz) (accessCache e h sz)
mkMemo  e h sz = memoize (newHash sz)  (accessHash e  h sz)


----------------------------------------------------------------
-- Hash and Cache Tables
----------------------------------------------------------------
accessHash  :: TaintedEq a ->  
               HashFunc a -> 
               Int -> 
               HashTable a b -> 
               a -> b -> ST Mem b

accessHash equal h sz table x v = do 
  hv' <- h x
  let hv = hv' `mod` sz
  l <- readSTArray table hv
  find l l hv
 where find l [] hv = {-trace "miss " $-} do
         u <- writeSTArray table  hv ((x,v):l) 
         case u of {() -> return v}
       find l ((x',v'):xs) hv = do
         a <- equal x x'
         if a then {-trace "hit "-} (return $ v')
          else find l xs hv

newHash :: Int -> ST Mem (HashTable a b)
newHash n = newSTArray (0,n) []


accessCache  :: TaintedEq a ->
                HashFunc a ->
                Int ->
                Cache a b ->
                a -> b -> ST Mem b

accessCache equal h sz table x v = do 
  hv' <- h x 
  let hv = hv' `mod` sz 
  l <-  readSTArray table hv
  case l of
     Nothing      -> do u <- writeSTArray table hv (Just (x,v))
                        case u of {() -> return v}
     Just (x',y)  -> do e <- equal x' x
                        if e then return y
                         else do u <- writeSTArray table hv (Just (x,v))
                                 case u of {() -> return v}

newCache :: Int -> ST Mem (Cache a b)
newCache n = newSTArray (0,n) Nothing

------------------------------------------------------------------
-- These functions are bad --- dont pay attention to them

-- lisp style eql --- as described in "Lazy-memo functions"
primitive eql "IOEql" :: a -> a -> ST Mem Bool
-- a `eql` b = return (a `unsafePtrEq` b)

-- hash based on addresses (or values if the arg is a base type)
primitive hash "IOHash" :: a -> ST Mem Int

------------------------------------------------------------------
-----------------------------------------------------------------------------
-- Standard Library: Numeric operations
--
-- Suitable for use with Hugs 98
-----------------------------------------------------------------------------

module Hugs.Numeric
	( fromRat 	-- :: (RealFloat a) => Rational -> a

	, showEFloat	-- :: (RealFloat a) => Maybe Int -> a -> ShowS
	, showFFloat	-- :: (RealFloat a) => Maybe Int -> a -> ShowS
	, showGFloat	-- :: (RealFloat a) => Maybe Int -> a -> ShowS
	, showFloat	-- :: (RealFloat a) => a -> ShowS

	, floatToDigits -- :: (RealFloat a) => Integer -> a -> ([Int], Int)
	
	, showInt       -- :: Integral a => a -> ShowS
	, showSigned    -- :: Real a => (a -> ShowS) -> Int -> a -> ShowS
	) where

import Data.Char   ( intToDigit )
import Data.Ratio  ( (%), numerator, denominator )
import Hugs.Array  ( (!), Array, array )

-- This converts a rational to a floating.  This should be used in the
-- Fractional instances of Float and Double.

fromRat :: (RealFloat a) => Rational -> a
fromRat x 
 | x == 0    = encodeFloat 0 0    -- Handle exceptional cases
 | x < 0     = -fromRat' (-x)     -- first.
 | otherwise = fromRat' x

-- Conversion process:
-- Scale the rational number by the RealFloat base until
-- it lies in the range of the mantissa (as used by decodeFloat/encodeFloat).
-- Then round the rational to an Integer and encode it with the exponent
-- that we got from the scaling.
-- To speed up the scaling process we compute the log2 of the number to get
-- a first guess of the exponent.
fromRat' :: (RealFloat a) => Rational -> a
fromRat' x = r
  where b = floatRadix r
        p = floatDigits r
        (minExp0, _) = floatRange r
        minExp = minExp0 - p            -- the real minimum exponent
        xMin = toRational (expt b (p-1))
        xMax = toRational (expt b p)
        p0 = (integerLogBase b (numerator x) -
              integerLogBase b (denominator x) - p) `max` minExp
        f = if p0 < 0 then 1 % expt b (-p0) else expt b p0 % 1
        (x', p') = scaleRat (toRational b) minExp xMin xMax p0 (x / f)
        r = encodeFloat (round x') p'

-- Scale x until xMin <= x < xMax, or p (the exponent) <= minExp.
scaleRat :: Rational -> Int -> Rational -> Rational -> 
             Int -> Rational -> (Rational, Int)
scaleRat b minExp xMin xMax p x
 | p <= minExp = (x,p)
 | x >= xMax   = scaleRat b minExp xMin xMax (p+1) (x/b)
 | x <  xMin   = scaleRat b minExp xMin xMax (p-1) (x*b)
 | otherwise   = (x, p)

-- Exponentiation with a cache for the most common numbers.
minExpt = 0::Int
maxExpt = 1100::Int
expt :: Integer -> Int -> Integer
expt base n =
    if base == 2 && n >= minExpt && n <= maxExpt then
        expts!n
    else
        base^n

expts :: Array Int Integer
expts = array (minExpt,maxExpt) [(n,2^n) | n <- [minExpt .. maxExpt]]

-- Compute the (floor of the) log of i in base b.
-- Simplest way would be just divide i by b until it's smaller then b,
-- but that would be very slow!  We are just slightly more clever.
integerLogBase :: Integer -> Integer -> Int
integerLogBase b i =
     if i < b then
        0
     else
        -- Try squaring the base first to cut down the number of divisions.
        let l = 2 * integerLogBase (b*b) i
            doDiv :: Integer -> Int -> Int
            doDiv i l = if i < b then l else doDiv (i `div` b) (l+1)
        in  doDiv (i `div` (b^l)) l

-- Misc utilities to show integers and floats

showEFloat     :: (RealFloat a) => Maybe Int -> a -> ShowS
showFFloat     :: (RealFloat a) => Maybe Int -> a -> ShowS
showGFloat     :: (RealFloat a) => Maybe Int -> a -> ShowS
showFloat      :: (RealFloat a) => a -> ShowS

showEFloat d x =  showString (formatRealFloat FFExponent d x)
showFFloat d x =  showString (formatRealFloat FFFixed d x)
showGFloat d x =  showString (formatRealFloat FFGeneric d x)
showFloat      =  showGFloat Nothing 

-- These are the format types.  This type is not exported.

data FFFormat = FFExponent | FFFixed | FFGeneric

formatRealFloat :: (RealFloat a) => FFFormat -> Maybe Int -> a -> String
formatRealFloat fmt decs x 
  | isNaN      x = "NaN"
  | isInfinite x = if x < 0 then "-Infinity" else "Infinity"
  | x < 0 || isNegativeZero x = '-' : doFmt fmt (floatToDigits (toInteger base) (-x))
  | otherwise    = doFmt fmt (floatToDigits (toInteger base) x)
  where base = 10

        doFmt fmt (is, e) =
            let ds = map intToDigit is
            in  case fmt of
                FFGeneric -> 
                    doFmt (if e < 0 || e > 7 then FFExponent else FFFixed)
                          (is, e)
                FFExponent ->
                    case decs of
                    Nothing ->
                        case ds of
			 "0"    -> "0.0e0"
                         [d]   -> d : ".0e" ++ show (e-1)
                         d:ds  -> d : '.' : ds ++ 'e':show (e-1)
                    Just dec ->
                        let dec' = max dec 1 in
                        case is of
                         [0] -> '0':'.':take dec' (repeat '0') ++ "e0"
                         _ ->
                          let (ei, is') = roundTo base (dec'+1) is
                              d:ds = map intToDigit
                                         (if ei > 0 then init is' else is')
                          in d:'.':ds  ++ "e" ++ show (e-1+ei)
                FFFixed ->
                  case decs of
                    Nothing 
		     | e > 0 -> take e (ds ++ repeat '0')
		     	        ++ '.' : mk0 (drop e ds)
		     | otherwise -> '0' : '.' : mk0 (replicate (-e) '0' ++ ds)
                    Just dec ->
                        let dec' = max dec 0 in
                        if e >= 0 then
                            let (ei, is') = roundTo base (dec' + e) is
                                (ls, rs) = splitAt (e+ei) (map intToDigit is')
                            in  mk0 ls ++ mkdot0 rs
                        else
                            let (ei, is') = roundTo base dec'
                                              (replicate (-e) 0 ++ is)
                                d : ds = map intToDigit
                                            (if ei > 0 then is' else 0:is')
                            in  d : mkdot0 ds
		  where
		    mk0 "" = "0"     -- Used to ensure we print 34.0, not 34.
	       	    mk0 s  = s       -- and 0.34 not .34
    
    		    mkdot0 "" = ""   -- Used to ensure we print 34, not 34.
		    mkdot0 s  = '.' : s

roundTo :: Int -> Int -> [Int] -> (Int, [Int])
roundTo base d is = case f d is of
                v@(0, is) -> v
                (1, is)   -> (1, 1 : is)
  where b2 = base `div` 2
        f n [] = (0, replicate n 0)
        f 0 (i:_) = (if i >= b2 then 1 else 0, [])
        f d (i:is) = 
            let (c, ds) = f (d-1) is
                i' = c + i
            in  if i' == base then (1, 0:ds) else (0, i':ds)

--
-- Based on "Printing Floating-Point Numbers Quickly and Accurately"
-- by R.G. Burger and R. K. Dybvig, in PLDI 96.
-- This version uses a much slower logarithm estimator.  It should be improved.

-- This function returns a list of digits (Ints in [0..base-1]) and an
-- exponent.

floatToDigits :: (RealFloat a) => Integer -> a -> ([Int], Int)

floatToDigits _ 0 = ([0], 0)
floatToDigits base x =
    let (f0, e0) = decodeFloat x
        (minExp0, _) = floatRange x
        p = floatDigits x
        b = floatRadix x
        minExp = minExp0 - p            -- the real minimum exponent
        -- Haskell requires that f be adjusted so denormalized numbers
        -- will have an impossibly low exponent.  Adjust for this.
	f :: Integer
	e :: Int
        (f, e) = let n = minExp - e0
                 in  if n > 0 then (f0 `div` (b^n), e0+n) else (f0, e0)

        (r, s, mUp, mDn) =
           if e >= 0 then
               let be = b^e in
               if f == b^(p-1) then
                   (f*be*b*2, 2*b, be*b, b)
               else
                   (f*be*2, 2, be, be)
           else
               if e > minExp && f == b^(p-1) then
                   (f*b*2, b^(-e+1)*2, b, 1)
               else
                   (f*2, b^(-e)*2, 1, 1)
        k = 
            let k0 =
                    if b==2 && base==10 then
                        -- logBase 10 2 is slightly bigger than 3/10 so
                        -- the following will err on the low side.  Ignoring
                        -- the fraction will make it err even more.
                        -- Haskell promises that p-1 <= logBase b f < p.
                        (p - 1 + e0) * 3 `div` 10
                    else
                        ceiling ((log (fromInteger (f+1)) + 
                                 fromIntegral e * log (fromInteger b)) / 
                                  log (fromInteger base))
                fixup n =
                    if n >= 0 then
                        if r + mUp <= expt base n * s then n else fixup (n+1)
                    else
                        if expt base (-n) * (r + mUp) <= s then n
                                                           else fixup (n+1)
            in  fixup k0

        gen ds rn sN mUpN mDnN =
            let (dn, rn') = (rn * base) `divMod` sN
                mUpN' = mUpN * base
                mDnN' = mDnN * base
            in  case (rn' < mDnN', rn' + mUpN' > sN) of
                (True,  False) -> dn : ds
                (False, True)  -> dn+1 : ds
                (True,  True)  -> if rn' * 2 < sN then dn : ds else dn+1 : ds
                (False, False) -> gen (dn:ds) rn' sN mUpN' mDnN'
        rds =
            if k >= 0 then
                gen [] r (s * expt base k) mUp mDn
            else
                let bk = expt base (-k)
                in  gen [] (r * bk) s (mUp * bk) (mDn * bk)
    in  (map fromIntegral (reverse rds), k)

-- -----------------------------------------------------------------------------
-- Showing

-- showInt is used for positive numbers only
showInt    :: Integral a => a -> ShowS
showInt n r | n < 0 = error "Numeric.showInt: can't show negative numbers"
            | otherwise =
              let (n',d) = quotRem n 10
		  r'     = toEnum (fromEnum '0' + fromIntegral d) : r
	      in  if n' == 0 then r' else showInt n' r'

showSigned    :: Real a => (a -> ShowS) -> Int -> a -> ShowS
showSigned showPos p x = if x < 0 then showParen (p > 6)
						 (showChar '-' . showPos (-x))
				  else showPos x

module Hugs.Observe (observe, bkpt, setBkpt) where

primitive observe :: String -> a -> a
primitive bkpt    :: String -> a -> a
primitive setBkpt :: String -> Bool -> IO ()
{----------------------------------------------------------------------------
__   __ __  __  ____   ___    _______________________________________________
||   || ||  || ||  || ||__    Hugs 98: The Nottingham and Yale Haskell system
||___|| ||__|| ||__||  __||   Copyright (c) 1994-1999
||---||         ___||         World Wide Web: http://haskell.org/hugs
||   ||                       Report bugs to: hugs-bugs@haskell.org
||   || Version: February 1999_______________________________________________

 This is the Hugs 98 Standard Prelude, based very closely on the Standard
 Prelude for Haskell 98.

 WARNING: This file is an integral part of the Hugs source code.  Changes to
 the definitions in this file without corresponding modifications in other
 parts of the program may cause the interpreter to fail unexpectedly.  Under
 normal circumstances, you should not attempt to modify this file in any way!

-----------------------------------------------------------------------------
 The Hugs 98 system is Copyright (c) Mark P Jones, Alastair Reid, the
 Yale Haskell Group, and the OGI School of Science & Engineering at OHSU,
 1994-2003, All rights reserved.  It is distributed as free software under
 the license in the file "License", which is included in the distribution.
----------------------------------------------------------------------------}

module Hugs.Prelude (
--  module PreludeList,
    map, (++), concat, filter,
    head, last, tail, init, null, length, (!!),
    foldl, foldl1, scanl, scanl1, foldr, foldr1, scanr, scanr1,
    iterate, repeat, replicate, cycle,
    take, drop, splitAt, takeWhile, dropWhile, span, break,
    lines, words, unlines, unwords, reverse, and, or,
    any, all, elem, notElem, lookup,
    sum, product, maximum, minimum, concatMap, 
    zip, zip3, zipWith, zipWith3, unzip, unzip3,
--  module PreludeText, 
    ReadS, ShowS,
    Read(readsPrec, readList),
    Show(show, showsPrec, showList),
    reads, shows, read, lex,
    showChar, showString, readParen, showParen,
--  module PreludeIO,
    FilePath, IOError, ioError, userError, catch,
    putChar, putStr, putStrLn, print,
    getChar, getLine, getContents, interact,
    readFile, writeFile, appendFile, readIO, readLn,
--  module Ix,
    Ix(range, index, unsafeIndex, inRange, rangeSize),
--  module Char,
    isSpace, isUpper, isLower,
    isAlpha, isDigit, isOctDigit, isHexDigit, isAlphaNum,
    readLitChar, showLitChar, lexLitChar,
--  module Numeric
    readSigned, readInt,
    readDec, readOct, readHex, readSigned,
    readFloat, lexDigits, 
--  module Ratio,
    Ratio((:%)), (%), numerator, denominator,
--  Non-standard exports
    IO(..), IOResult(..),
    IOException(..), IOErrorType(..),
    Exception(..),
    ArithException(..), ArrayException(..), AsyncException(..),
    ExitCode(..),
    FunPtr, Ptr, Addr,
    Word, StablePtr, ForeignObj, ForeignPtr,
    Int8, Int16, Int32, Int64,
    Word8, Word16, Word32, Word64,
    Handle, Object,
    basicIORun, blockIO, IOFinished(..),
    threadToIOResult,
    catchException, throw,
    Dynamic(..), TypeRep(..), Key(..), TyCon(..), Obj,

    IOMode(..),
    stdin, stdout, stderr,
    openFile,
    hClose,
    hGetContents, hGetChar, hGetLine,
    hPutChar, hPutStr,

    Bool(False, True),
    Maybe(Nothing, Just),
    Either(Left, Right),
    Ordering(LT, EQ, GT),
    Char, String, Int, Integer, Float, Double, Rational, IO,
--  List type: []((:), [])
    (:),
--  Tuple types: (,), (,,), etc.
--  Trivial type: ()
--  Functions: (->)
    Rec, emptyRec, EmptyRow, -- non-standard, should only be exported if TREX
    Eq((==), (/=)),
    Ord(compare, (<), (<=), (>=), (>), max, min),
    Enum(succ, pred, toEnum, fromEnum, enumFrom, enumFromThen,
         enumFromTo, enumFromThenTo),
    Bounded(minBound, maxBound),
--  Num((+), (-), (*), negate, abs, signum, fromInteger),
    Num((+), (-), (*), negate, abs, signum, fromInteger, fromInt),
    Real(toRational),
--  Integral(quot, rem, div, mod, quotRem, divMod, toInteger),
    Integral(quot, rem, div, mod, quotRem, divMod, toInteger, toInt),
--  Fractional((/), recip, fromRational),
    Fractional((/), recip, fromRational, fromDouble),
    Floating(pi, exp, log, sqrt, (**), logBase, sin, cos, tan,
             asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh),
    RealFrac(properFraction, truncate, round, ceiling, floor),
    RealFloat(floatRadix, floatDigits, floatRange, decodeFloat,
              encodeFloat, exponent, significand, scaleFloat, isNaN,
              isInfinite, isDenormalized, isIEEE, isNegativeZero, atan2),
    Monad((>>=), (>>), return, fail),
    Functor(fmap),
    mapM, mapM_, sequence, sequence_, (=<<),
    maybe, either,
    (&&), (||), not, otherwise,
    subtract, even, odd, gcd, lcm, (^), (^^), 
    fromIntegral, realToFrac,
    fst, snd, curry, uncurry, id, const, (.), flip, ($), until,
    asTypeOf, error, undefined,
    seq, ($!),

    boundedSucc,
    boundedPred,
    boundedEnumFrom,
    boundedEnumFromTo,
    boundedEnumFromThen,
    boundedEnumFromThenTo
  ) where

-- Standard value bindings {Prelude} ----------------------------------------

infixr 9  .
infixl 9  !!
infixr 8  ^, ^^, **
infixl 7  *, /, `quot`, `rem`, `div`, `mod`, :%, %
infixl 6  +, -
--infixr 5  :    -- this fixity declaration is hard-wired into Hugs
infixr 5  ++
infix  4  ==, /=, <, <=, >=, >, `elem`, `notElem`
infixr 3  &&
infixr 2  ||
infixl 1  >>, >>=
infixr 1  =<<
infixr 0  $, $!, `seq`

-- Equality and Ordered classes ---------------------------------------------

class Eq a where
    (==), (/=) :: a -> a -> Bool

    -- Minimal complete definition: (==) or (/=)
    x == y      = not (x/=y)
    x /= y      = not (x==y)

class (Eq a) => Ord a where
    compare                :: a -> a -> Ordering
    (<), (<=), (>=), (>)   :: a -> a -> Bool
    max, min               :: a -> a -> a

    -- Minimal complete definition: (<=) or compare
    -- using compare can be more efficient for complex types
    compare x y | x==y      = EQ
		| x<=y      = LT
		| otherwise = GT

    x <= y                  = compare x y /= GT
    x <  y                  = compare x y == LT
    x >= y                  = compare x y /= LT
    x >  y                  = compare x y == GT

    max x y   | x <= y      = y
	      | otherwise   = x
    min x y   | x <= y      = x
	      | otherwise   = y

class Bounded a where
    minBound, maxBound :: a
    -- Minimal complete definition: All

-- Numeric classes ----------------------------------------------------------

class (Eq a, Show a) => Num a where
    (+), (-), (*)  :: a -> a -> a
    negate         :: a -> a
    abs, signum    :: a -> a
    fromInteger    :: Integer -> a
    fromInt        :: Int -> a

    -- Minimal complete definition: All, except negate or (-)
    x - y           = x + negate y
    fromInt         = fromIntegral
    negate x        = 0 - x

class (Num a, Ord a) => Real a where
    toRational     :: a -> Rational

class (Real a, Enum a) => Integral a where
    quot, rem, div, mod :: a -> a -> a
    quotRem, divMod     :: a -> a -> (a,a)
    toInteger           :: a -> Integer
    toInt               :: a -> Int

    -- Minimal complete definition: quotRem and toInteger
    n `quot` d           = q where (q,r) = quotRem n d
    n `rem` d            = r where (q,r) = quotRem n d
    n `div` d            = q where (q,r) = divMod n d
    n `mod` d            = r where (q,r) = divMod n d
    divMod n d           = if signum r == - signum d then (q-1, r+d) else qr
			   where qr@(q,r) = quotRem n d
    toInt                = toInt . toInteger

class (Num a) => Fractional a where
    (/)          :: a -> a -> a
    recip        :: a -> a
    fromRational :: Rational -> a
    fromDouble   :: Double -> a

    -- Minimal complete definition: fromRational and ((/) or recip)
    recip x       = 1 / x
    fromDouble    = fromRational . fromDouble
    x / y         = x * recip y


class (Fractional a) => Floating a where
    pi                  :: a
    exp, log, sqrt      :: a -> a
    (**), logBase       :: a -> a -> a
    sin, cos, tan       :: a -> a
    asin, acos, atan    :: a -> a
    sinh, cosh, tanh    :: a -> a
    asinh, acosh, atanh :: a -> a

    -- Minimal complete definition: pi, exp, log, sin, cos, sinh, cosh,
    --				    asinh, acosh, atanh
    pi                   = 4 * atan 1
    x ** y               = exp (log x * y)
    logBase x y          = log y / log x
    sqrt x               = x ** 0.5
    tan x                = sin x / cos x
    sinh x               = (exp x - exp (-x)) / 2
    cosh x               = (exp x + exp (-x)) / 2
    tanh x               = sinh x / cosh x
    asinh x              = log (x + sqrt (x*x + 1))
    acosh x              = log (x + sqrt (x*x - 1))
    atanh x              = (log (1 + x) - log (1 - x)) / 2

class (Real a, Fractional a) => RealFrac a where
    properFraction   :: (Integral b) => a -> (b,a)
    truncate, round  :: (Integral b) => a -> b
    ceiling, floor   :: (Integral b) => a -> b

    -- Minimal complete definition: properFraction
    truncate x        = m where (m,_) = properFraction x

    round x           = let (n,r) = properFraction x
			    m     = if r < 0 then n - 1 else n + 1
			in case signum (abs r - 0.5) of
			    -1 -> n
			    0  -> if even n then n else m
			    1  -> m

    ceiling x         = if r > 0 then n + 1 else n
			where (n,r) = properFraction x

    floor x           = if r < 0 then n - 1 else n
			where (n,r) = properFraction x

class (RealFrac a, Floating a) => RealFloat a where
    floatRadix       :: a -> Integer
    floatDigits      :: a -> Int
    floatRange       :: a -> (Int,Int)
    decodeFloat      :: a -> (Integer,Int)
    encodeFloat      :: Integer -> Int -> a
    exponent         :: a -> Int
    significand      :: a -> a
    scaleFloat       :: Int -> a -> a
    isNaN, isInfinite, isDenormalized, isNegativeZero, isIEEE
		     :: a -> Bool
    atan2	     :: a -> a -> a

    -- Minimal complete definition: All, except exponent, signficand,
    --				    scaleFloat, atan2
    exponent x        = if m==0 then 0 else n + floatDigits x
			where (m,n) = decodeFloat x
    significand x     = encodeFloat m (- floatDigits x)
			where (m,_) = decodeFloat x
    scaleFloat k x    = encodeFloat m (n+k)
			where (m,n) = decodeFloat x
    atan2 y x
      | x>0           = atan (y/x)
      | x==0 && y>0   = pi/2
      | x<0 && y>0    = pi + atan (y/x)
      | (x<=0 && y<0) ||
        (x<0 && isNegativeZero y) ||
        (isNegativeZero x && isNegativeZero y)
		      = - atan2 (-y) x
      | y==0 && (x<0 || isNegativeZero x)
		      = pi    -- must be after the previous test on zero y
      | x==0 && y==0  = y     -- must be after the other double zero tests
      | otherwise     = x + y -- x or y is a NaN, return a NaN (via +)

-- Numeric functions --------------------------------------------------------

subtract       :: Num a => a -> a -> a
subtract        = flip (-)

even, odd        :: (Integral a) => a -> Bool
even n           =  n `rem` 2 == 0
odd              =  not . even

gcd            :: Integral a => a -> a -> a
gcd 0 0         = error "Prelude.gcd: gcd 0 0 is undefined"
gcd x y         = gcd' (abs x) (abs y)
		  where gcd' x 0 = x
			gcd' x y = gcd' y (x `rem` y)

lcm            :: (Integral a) => a -> a -> a
lcm _ 0         = 0
lcm 0 _         = 0
lcm x y         = abs ((x `quot` gcd x y) * y)

(^)            :: (Num a, Integral b) => a -> b -> a
x ^ 0           = 1
x ^ n  | n > 0  = f x (n-1) x
		  where f _ 0 y = y
			f x n y = g x n where
				  g x n | even n    = g (x*x) (n`quot`2)
					| otherwise = f x (n-1) (x*y)
_ ^ _           = error "Prelude.^: negative exponent"

(^^)           :: (Fractional a, Integral b) => a -> b -> a
x ^^ n          = if n >= 0 then x ^ n else recip (x^(-n))

fromIntegral   :: (Integral a, Num b) => a -> b
fromIntegral    = fromInteger . toInteger

realToFrac     :: (Real a, Fractional b) => a -> b
realToFrac      = fromRational . toRational

-- Index and Enumeration classes --------------------------------------------

class (Ord a) => Ix a where
    range                :: (a,a) -> [a]
	-- The unchecked variant unsafeIndex is non-standard, but useful
    index, unsafeIndex   :: (a,a) -> a -> Int
    inRange              :: (a,a) -> a -> Bool
    rangeSize            :: (a,a) -> Int

	-- Must specify one of index, unsafeIndex
    index b i | inRange b i = unsafeIndex b i
              | otherwise   = error "Ix.index: index out of range"
    unsafeIndex b i = index b i

    rangeSize b@(_l,h) | inRange b h = unsafeIndex b h + 1
                       | otherwise   = 0
	-- NB: replacing "inRange b h" by  "l <= u"
	-- fails if the bounds are tuples.  For example,
	-- 	(1,2) <= (2,1)
	-- but the range is nevertheless empty
	--	range ((1,2),(2,1)) = []

class Enum a where
    succ, pred           :: a -> a
    toEnum               :: Int -> a
    fromEnum             :: a -> Int
    enumFrom             :: a -> [a]              -- [n..]
    enumFromThen         :: a -> a -> [a]         -- [n,m..]
    enumFromTo           :: a -> a -> [a]         -- [n..m]
    enumFromThenTo       :: a -> a -> a -> [a]    -- [n,n'..m]

    -- Minimal complete definition: toEnum, fromEnum
    succ                  = toEnum . (1+)       . fromEnum
    pred                  = toEnum . subtract 1 . fromEnum
    enumFrom x            = map toEnum [ fromEnum x ..]
    enumFromTo x y        = map toEnum [ fromEnum x .. fromEnum y ]
    enumFromThen x y      = map toEnum [ fromEnum x, fromEnum y ..]
    enumFromThenTo x y z  = map toEnum [ fromEnum x, fromEnum y .. fromEnum z ]

-- Read and Show classes ------------------------------------------------------

type ReadS a = String -> [(a,String)]
type ShowS   = String -> String

class Read a where
    readsPrec :: Int -> ReadS a
    readList  :: ReadS [a]

    -- Minimal complete definition: readsPrec
    readList   = readParen False (\r -> [pr | ("[",s) <- lex r,
					      pr      <- readl s ])
		 where readl  s = [([],t)   | ("]",t) <- lex s] ++
				  [(x:xs,u) | (x,t)   <- reads s,
					      (xs,u)  <- readl' t]
		       readl' s = [([],t)   | ("]",t) <- lex s] ++
				  [(x:xs,v) | (",",t) <- lex s,
					      (x,u)   <- reads t,
					      (xs,v)  <- readl' u]

class Show a where
    show      :: a -> String
    showsPrec :: Int -> a -> ShowS
    showList  :: [a] -> ShowS

    -- Minimal complete definition: show or showsPrec
    show x          = showsPrec 0 x ""
    showsPrec _ x s = show x ++ s
    showList []     = showString "[]"
    showList (x:xs) = showChar '[' . shows x . showl xs
		      where showl []     = showChar ']'
			    showl (x:xs) = showChar ',' . shows x . showl xs

-- Monad classes ------------------------------------------------------------

class Functor f where
    fmap :: (a -> b) -> (f a -> f b)

class Monad m where
    return :: a -> m a
    (>>=)  :: m a -> (a -> m b) -> m b
    (>>)   :: m a -> m b -> m b
    fail   :: String -> m a

    -- Minimal complete definition: (>>=), return
    p >> q  = p >>= \ _ -> q
    fail s  = error s

sequence       :: Monad m => [m a] -> m [a]
sequence []     = return []
sequence (c:cs) = do x  <- c
		     xs <- sequence cs
		     return (x:xs)

sequence_        :: Monad m => [m a] -> m ()
sequence_         = foldr (>>) (return ())

mapM             :: Monad m => (a -> m b) -> [a] -> m [b]
mapM f            = sequence . map f

mapM_            :: Monad m => (a -> m b) -> [a] -> m ()
mapM_ f           = sequence_ . map f

(=<<)            :: Monad m => (a -> m b) -> m a -> m b
f =<< x           = x >>= f

-- Evaluation and strictness ------------------------------------------------

primitive seq           :: a -> b -> b

primitive ($!) "strict" :: (a -> b) -> a -> b
-- f $! x                = x `seq` f x

-- Trivial type -------------------------------------------------------------

-- data () = () deriving (Eq, Ord, Ix, Enum, Read, Show, Bounded)

instance Eq () where
    () == ()  =  True

instance Ord () where
    compare () () = EQ

instance Ix () where
    range ((),())      = [()]
    index ((),()) ()   = 0
    inRange ((),()) () = True

instance Enum () where
    toEnum 0           = ()
    fromEnum ()        = 0
    enumFrom ()        = [()]

instance Read () where
    readsPrec p = readParen False (\r -> [((),t) | ("(",s) <- lex r,
						   (")",t) <- lex s ])

instance Show () where
    showsPrec p () = showString "()"

instance Bounded () where
    minBound = ()
    maxBound = ()

-- Boolean type -------------------------------------------------------------

data Bool    = False | True
	       deriving (Eq, Ord, Ix, Enum, Read, Show, Bounded)

(&&), (||)  :: Bool -> Bool -> Bool
False && x   = False
True  && x   = x
False || x   = x
True  || x   = True

not         :: Bool -> Bool
not True     = False
not False    = True

otherwise   :: Bool
otherwise    = True

-- Character type -----------------------------------------------------------

data Char               -- builtin datatype of ISO Latin characters
type String = [Char]    -- strings are lists of characters

primitive primEqChar    :: Char -> Char -> Bool
primitive primCmpChar   :: Char -> Char -> Ordering

instance Eq Char  where (==)    = primEqChar
instance Ord Char where compare = primCmpChar

primitive primCharToInt :: Char -> Int
primitive primIntToChar :: Int -> Char

instance Enum Char where
    toEnum           = primIntToChar
    fromEnum         = primCharToInt
    enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Char)]
    enumFromThen     = boundedEnumFromThen

instance Ix Char where
    range (c,c')      = [c..c']
    unsafeIndex (c,_) i = fromEnum i - fromEnum c
    inRange (c,c') i  = c <= i && i <= c'

instance Read Char where
    readsPrec p      = readParen False
			    (\r -> [(c,t) | ('\'':s,t) <- lex r,
					    (c,"\'")   <- readLitChar s ])
    readList = readParen False (\r -> [(l,t) | ('"':s, t) <- lex r,
					       (l,_)      <- readl s ])
	       where readl ('"':s)      = [("",s)]
		     readl ('\\':'&':s) = readl s
		     readl s            = [(c:cs,u) | (c ,t) <- readLitChar s,
						      (cs,u) <- readl t ]
instance Show Char where
    showsPrec p '\'' = showString "'\\''"
    showsPrec p c    = showChar '\'' . showLitChar c . showChar '\''

    showList cs   = showChar '"' . showl cs
		    where showl ""       = showChar '"'
			  showl ('"':cs) = showString "\\\"" . showl cs
			  showl (c:cs)   = showLitChar c . showl cs

instance Bounded Char where
    minBound = '\0'
    maxBound = primMaxChar

primitive primMaxChar :: Char

isSpace, isDigit :: Char -> Bool

isSpace c              =  c == ' '  ||
			  c == '\t' ||
			  c == '\n' ||
			  c == '\r' ||
			  c == '\f' ||
			  c == '\v' ||
			  c == '\xa0'

isDigit c              =  c >= '0'   &&  c <= '9'

primitive isUpper      :: Char -> Bool
primitive isLower      :: Char -> Bool
primitive isAlpha      :: Char -> Bool
primitive isAlphaNum   :: Char -> Bool

-- Maybe type ---------------------------------------------------------------

data Maybe a = Nothing | Just a
	       deriving (Eq, Ord, Read, Show)

maybe             :: b -> (a -> b) -> Maybe a -> b
maybe n f Nothing  = n
maybe n f (Just x) = f x

instance Functor Maybe where
    fmap f Nothing  = Nothing
    fmap f (Just x) = Just (f x)

instance Monad Maybe where
    Just x  >>= k = k x
    Nothing >>= k = Nothing
    return        = Just
    fail s        = Nothing

-- Either type --------------------------------------------------------------

data Either a b = Left a | Right b
		  deriving (Eq, Ord, Read, Show)

either              :: (a -> c) -> (b -> c) -> Either a b -> c
either l r (Left x)  = l x
either l r (Right y) = r y

-- Ordering type ------------------------------------------------------------

data Ordering = LT | EQ | GT
		deriving (Eq, Ord, Ix, Enum, Read, Show, Bounded)

-- Lists --------------------------------------------------------------------

-- data [a] = [] | a : [a] deriving (Eq, Ord)

instance Eq a => Eq [a] where
    []     == []     =  True
    (x:xs) == (y:ys) =  x==y && xs==ys
    _      == _      =  False

instance Ord a => Ord [a] where
    compare []     (_:_)  = LT
    compare []     []     = EQ
    compare (_:_)  []     = GT
    compare (x:xs) (y:ys) = primCompAux x y (compare xs ys)

instance Functor [] where
    fmap = map

instance Monad [ ] where
    (x:xs) >>= f = f x ++ (xs >>= f)
    []     >>= f = []
    return x     = [x]
    fail s       = []

instance Read a => Read [a]  where
    readsPrec p = readList

instance Show a => Show [a]  where
    showsPrec p = showList

-- Tuples -------------------------------------------------------------------

-- data (a,b) = (a,b) deriving (Eq, Ord, Ix, Read, Show)
-- etc..

-- Standard Integral types --------------------------------------------------

data Int      -- builtin datatype of fixed size integers
data Integer  -- builtin datatype of arbitrary size integers

primitive primEqInt      :: Int -> Int -> Bool
primitive primCmpInt     :: Int -> Int -> Ordering
primitive primEqInteger  :: Integer -> Integer -> Bool
primitive primCmpInteger :: Integer -> Integer -> Ordering

instance Eq  Int     where (==)    = primEqInt
instance Eq  Integer where (==)    = primEqInteger
instance Ord Int     where compare = primCmpInt
instance Ord Integer where compare = primCmpInteger

primitive primPlusInt,
	  primMinusInt,
	  primMulInt	   :: Int -> Int -> Int
primitive primNegInt	   :: Int -> Int
primitive primIntegerToInt :: Integer -> Int

instance Num Int where
    (+)           = primPlusInt
    (-)           = primMinusInt
    negate        = primNegInt
    (*)           = primMulInt
    abs           = absReal
    signum        = signumReal
    fromInteger   = primIntegerToInt
    fromInt x     = x

primitive primMinInt, primMaxInt :: Int

instance Bounded Int where
    minBound = primMinInt
    maxBound = primMaxInt

primitive primPlusInteger,
	  primMinusInteger,
	  primMulInteger   :: Integer -> Integer -> Integer
primitive primNegInteger   :: Integer -> Integer
primitive primIntToInteger :: Int -> Integer

instance Num Integer where
    (+)           = primPlusInteger
    (-)           = primMinusInteger
    negate        = primNegInteger
    (*)           = primMulInteger
    abs           = absReal
    signum        = signumReal
    fromInteger x = x
    fromInt       = primIntToInteger

absReal x    | x >= 0    = x
	     | otherwise = -x

signumReal x | x == 0    =  0
	     | x > 0     =  1
	     | otherwise = -1

instance Real Int where
    toRational x = toInteger x % 1

instance Real Integer where
    toRational x = x % 1

primitive primDivInt,
	  primQuotInt,
	  primRemInt,
	  primModInt  :: Int -> Int -> Int
primitive primQrmInt  :: Int -> Int -> (Int,Int)

instance Integral Int where
    div       = primDivInt
    quot      = primQuotInt
    rem       = primRemInt
    mod       = primModInt
    quotRem   = primQrmInt
    toInteger = primIntToInteger
    toInt x   = x

primitive primQrmInteger  :: Integer -> Integer -> (Integer,Integer)

instance Integral Integer where
    quotRem     = primQrmInteger
    toInteger x = x
    toInt       = primIntegerToInt

instance Ix Int where
    range (m,n)          = [m..n]
    unsafeIndex (m,_) i  = i - m
    inRange (m,n) i      = m <= i && i <= n

instance Ix Integer where
    range (m,n)          = [m..n]
    unsafeIndex (m,_) i  = toInt (i - m)
    inRange (m,n) i      = m <= i && i <= n

instance Enum Int where
    succ           = boundedSucc
    pred           = boundedPred
    toEnum         = id
    fromEnum       = id
    enumFrom       = boundedEnumFrom
    enumFromTo     = boundedEnumFromTo
    enumFromThen   = boundedEnumFromThen
    enumFromThenTo = boundedEnumFromThenTo

boundedSucc, boundedPred :: (Num a, Bounded a, Enum a) => a -> a
boundedSucc x
  | x == maxBound = error "succ: applied to maxBound"
  | otherwise     = x+1
boundedPred x
  | x == minBound = error "pred: applied to minBound"
  | otherwise     = x-1

boundedEnumFrom       :: (Ord a, Bounded a, Enum a) => a -> [a]
boundedEnumFromTo     :: (Ord a, Bounded a, Enum a) => a -> a -> [a]
boundedEnumFromThenTo :: (Ord a, Num a, Bounded a, Enum a) => a -> a -> a -> [a]
boundedEnumFromThen   :: (Ord a, Bounded a, Enum a) => a -> a -> [a]

boundedEnumFrom n     = takeWhile1 (/= maxBound) (iterate succ n)
boundedEnumFromTo n m = takeWhile (<= m) (boundedEnumFrom n)
boundedEnumFromThen n m =
    enumFromThenTo n m (if n <= m then maxBound else minBound)
boundedEnumFromThenTo n n' m
  | n' >= n   = if n <= m then takeWhile1 (<= m - delta) ns else []
  | otherwise = if n >= m then takeWhile1 (>= m - delta) ns else []
 where
  delta = n'-n
  ns = iterate (+delta) n

-- takeWhile and one more
takeWhile1 :: (a -> Bool) -> [a] -> [a]
takeWhile1 p (x:xs) = x : if p x then takeWhile1 p xs else []

instance Enum Integer where
    succ x         = x + 1
    pred x         = x - 1

    toEnum         = primIntToInteger
    fromEnum       = primIntegerToInt
    enumFrom       = numericEnumFrom
    enumFromThen   = numericEnumFromThen
    enumFromTo n m = takeWhile (<= m) (numericEnumFrom n)
    enumFromThenTo n n' m = takeWhile p (numericEnumFromThen n n')
                                where p | n' >= n   = (<= m)
                                        | otherwise = (>= m)

numericEnumFrom        :: Num a => a -> [a]
numericEnumFromThen    :: Num a => a -> a -> [a]
numericEnumFromTo      :: (Ord a, Fractional a) => a -> a -> [a]
numericEnumFromThenTo  :: (Ord a, Fractional a) => a -> a -> a -> [a]
numericEnumFrom n            = iterate' (+1) n
numericEnumFromThen n m      = iterate' (+(m-n)) n
numericEnumFromTo n m        = takeWhile (<= m+1/2) (numericEnumFrom n)
numericEnumFromThenTo n n' m = takeWhile p (numericEnumFromThen n n')
                               where p | n' >= n   = (<= m + (n'-n)/2)
                                       | otherwise = (>= m + (n'-n)/2)

iterate' :: (a -> a) -> a -> [a]	-- strict version of iterate
iterate' f x = x : (iterate' f $! f x)

primitive primShowsInt :: Int -> Int -> ShowS

instance Read Int where
    readsPrec p = readSigned readDec

instance Show Int where
    showsPrec   = primShowsInt

primitive primShowsInteger :: Int -> Integer -> ShowS

instance Read Integer where
    readsPrec p = readSigned readDec

instance Show Integer where
    showsPrec   = primShowsInteger

-- Standard Floating types --------------------------------------------------

data Float     -- builtin datatype of single precision floating point numbers
data Double    -- builtin datatype of double precision floating point numbers

primitive primEqFloat   :: Float -> Float -> Bool
primitive primCmpFloat  :: Float -> Float -> Ordering
primitive primEqDouble  :: Double -> Double -> Bool
primitive primCmpDouble :: Double -> Double -> Ordering

instance Eq  Float  where (==) = primEqFloat
instance Eq  Double where (==) = primEqDouble

instance Ord Float  where compare = primCmpFloat
instance Ord Double where compare = primCmpDouble

primitive primPlusFloat,
	  primMinusFloat,
	  primMulFloat       :: Float -> Float -> Float
primitive primNegFloat       :: Float -> Float
primitive primIntToFloat     :: Int -> Float
primitive primIntegerToFloat :: Integer -> Float

instance Num Float where
    (+)           = primPlusFloat
    (-)           = primMinusFloat
    negate        = primNegFloat
    (*)           = primMulFloat
    abs           = absReal
    signum        = signumReal
    fromInteger   = primIntegerToFloat
    fromInt       = primIntToFloat

primitive primPlusDouble,
	  primMinusDouble,
	  primMulDouble       :: Double -> Double -> Double
primitive primNegDouble       :: Double -> Double
primitive primIntToDouble     :: Int -> Double
primitive primIntegerToDouble :: Integer -> Double

instance Num Double where
    (+)         = primPlusDouble
    (-)         = primMinusDouble
    negate      = primNegDouble
    (*)         = primMulDouble
    abs         = absReal
    signum      = signumReal
    fromInteger = primIntegerToDouble
    fromInt     = primIntToDouble

instance Real Float where
    toRational = floatToRational

instance Real Double where
    toRational = doubleToRational

-- Calls to these functions are optimised when passed as arguments to
-- fromRational.
floatToRational  :: Float  -> Rational
doubleToRational :: Double -> Rational
floatToRational  x = realFloatToRational x 
doubleToRational x = realFloatToRational x

realFloatToRational x = (m%1)*(b%1)^^n
			where (m,n) = decodeFloat x
			      b     = floatRadix x

primitive primDivFloat      :: Float -> Float -> Float
primitive primDoubleToFloat :: Double -> Float
primitive primFloatToDouble :: Float -> Double	-- used by runtime optimizer

instance Fractional Float where
    (/)          = primDivFloat
    fromRational = primRationalToFloat
    fromDouble   = primDoubleToFloat

primitive primDivDouble :: Double -> Double -> Double

instance Fractional Double where
    (/)          = primDivDouble
    fromRational = primRationalToDouble
    fromDouble x = x

-- These primitives are equivalent to (and are defined using) 
-- rationalTo{Float,Double}.  The difference is that they test to see
-- if their argument is of the form (fromDouble x) - which allows a much
-- more efficient implementation.
primitive primRationalToFloat  :: Rational -> Float
primitive primRationalToDouble :: Rational -> Double

-- These functions are used by Hugs - don't change their types.
rationalToFloat  :: Rational -> Float
rationalToDouble :: Rational -> Double
rationalToFloat  = rationalToRealFloat
rationalToDouble = rationalToRealFloat

rationalToRealFloat x = x'
 where x'    = f e
       f e   = if e' == e then y else f e'
	       where y      = encodeFloat (round (x * (1%b)^^e)) e
		     (_,e') = decodeFloat y
       (_,e) = decodeFloat (fromInteger (numerator x) `asTypeOf` x'
			     / fromInteger (denominator x))
       b     = floatRadix x'

primitive primSinFloat,  primAsinFloat, primCosFloat,
	  primAcosFloat, primTanFloat,  primAtanFloat,
	  primLogFloat,  primExpFloat,  primSqrtFloat :: Float -> Float

instance Floating Float where
    exp   = primExpFloat
    log   = primLogFloat
    sqrt  = primSqrtFloat
    sin   = primSinFloat
    cos   = primCosFloat
    tan   = primTanFloat
    asin  = primAsinFloat
    acos  = primAcosFloat
    atan  = primAtanFloat

primitive primSinDouble,  primAsinDouble, primCosDouble,
	  primAcosDouble, primTanDouble,  primAtanDouble,
	  primLogDouble,  primExpDouble,  primSqrtDouble :: Double -> Double

instance Floating Double where
    exp   = primExpDouble
    log   = primLogDouble
    sqrt  = primSqrtDouble
    sin   = primSinDouble
    cos   = primCosDouble
    tan   = primTanDouble
    asin  = primAsinDouble
    acos  = primAcosDouble
    atan  = primAtanDouble

instance RealFrac Float where
    properFraction = floatProperFraction

instance RealFrac Double where
    properFraction = floatProperFraction

floatProperFraction x
   | n >= 0      = (fromInteger m * fromInteger b ^ n, 0)
   | otherwise   = (fromInteger w, encodeFloat r n)
		   where (m,n) = decodeFloat x
			 b     = floatRadix x
			 (w,r) = quotRem m (b^(-n))

primitive primFloatRadix  :: Integer
primitive primFloatDigits :: Int
primitive primFloatMinExp,
          primFloatMaxExp :: Int
primitive primFloatEncode :: Integer -> Int -> Float
primitive primFloatDecode :: Float -> (Integer, Int)

instance RealFloat Float where
    floatRadix  _ = primFloatRadix
    floatDigits _ = primFloatDigits
    floatRange  _ = (primFloatMinExp, primFloatMaxExp)
    encodeFloat = primFloatEncode
    decodeFloat = primFloatDecode
    isNaN       _ = False
    isInfinite  _ = False
    isDenormalized _ = False
    isNegativeZero _ = False
    isIEEE      _ = False

primitive primDoubleRadix  :: Integer
primitive primDoubleDigits :: Int
primitive primDoubleMinExp,
          primDoubleMaxExp :: Int
primitive primDoubleEncode :: Integer -> Int -> Double
primitive primDoubleDecode :: Double -> (Integer, Int)

instance RealFloat Double where
    floatRadix  _ = primDoubleRadix
    floatDigits _ = primDoubleDigits
    floatRange  _ = (primDoubleMinExp, primDoubleMaxExp)
    encodeFloat   = primDoubleEncode
    decodeFloat   = primDoubleDecode
    isNaN       _ = False
    isInfinite  _ = False
    isDenormalized _ = False
    isNegativeZero _ = False
    isIEEE      _ = False

instance Enum Float where
    succ x                = x+1
    pred x                = x-1
    toEnum		  = primIntToFloat
    fromEnum		  = fromInteger . truncate   -- may overflow
    enumFrom		  = numericEnumFrom
    enumFromThen	  = numericEnumFromThen
    enumFromTo		  = numericEnumFromTo
    enumFromThenTo	  = numericEnumFromThenTo

instance Enum Double where
    succ x                = x+1
    pred x                = x-1
    toEnum		  = primIntToDouble
    fromEnum		  = fromInteger . truncate   -- may overflow
    enumFrom		  = numericEnumFrom
    enumFromThen	  = numericEnumFromThen
    enumFromTo		  = numericEnumFromTo
    enumFromThenTo	  = numericEnumFromThenTo

primitive primShowsFloat :: Int -> Float -> ShowS

instance Read Float where
    readsPrec p = readSigned readFloat

-- Note that showFloat in Numeric isn't used here
instance Show Float where
    showsPrec   = primShowsFloat

primitive primShowsDouble :: Int -> Double -> ShowS

instance Read Double where
    readsPrec p = readSigned readFloat

-- Note that showFloat in Numeric isn't used here
instance Show Double where
    showsPrec   = primShowsDouble

-- Some standard functions --------------------------------------------------

fst            :: (a,b) -> a
fst (x,_)       = x

snd            :: (a,b) -> b
snd (_,y)       = y

curry          :: ((a,b) -> c) -> (a -> b -> c)
curry f x y     = f (x,y)

uncurry        :: (a -> b -> c) -> ((a,b) -> c)
uncurry f p     = f (fst p) (snd p)

id             :: a -> a
id    x         = x

const          :: a -> b -> a
const k _       = k

(.)            :: (b -> c) -> (a -> b) -> (a -> c)
(f . g) x       = f (g x)

flip           :: (a -> b -> c) -> b -> a -> c
flip f x y      = f y x

($)            :: (a -> b) -> a -> b
f $ x           = f x

until          :: (a -> Bool) -> (a -> a) -> a -> a
until p f x     = if p x then x else until p f (f x)

asTypeOf       :: a -> a -> a
asTypeOf        = const

error          :: String -> a
error s         = throw (ErrorCall s)

undefined      :: a
undefined       = error "Prelude.undefined"

-- Standard functions on rational numbers {PreludeRatio} --------------------

data Integral a => Ratio a = !a :% !a deriving (Eq)
type Rational              = Ratio Integer

(%)                       :: Integral a => a -> a -> Ratio a
x % y                      = reduce (x * signum y) (abs y)

reduce                    :: Integral a => a -> a -> Ratio a
reduce x y | y == 0        = error "Ratio.%: zero denominator"
	   | otherwise     = (x `quot` d) :% (y `quot` d)
			     where d = gcd x y

numerator, denominator    :: Integral a => Ratio a -> a
numerator (x :% y)         = x
denominator (x :% y)       = y

instance Integral a => Ord (Ratio a) where
    compare (x:%y) (x':%y') = compare (x*y') (x'*y)

instance Integral a => Num (Ratio a) where
    (x:%y) + (x':%y') = reduce (x*y' + x'*y) (y*y')
    (x:%y) * (x':%y') = reduce (x*x') (y*y')
    negate (x :% y)   = negate x :% y
    abs (x :% y)      = abs x :% y
    signum (x :% y)   = signum x :% 1
    fromInteger x     = fromInteger x :% 1
    fromInt           = intToRatio

-- Hugs optimises code of the form fromRational (intToRatio x)
intToRatio :: Integral a => Int -> Ratio a
intToRatio x = fromInt x :% 1

instance Integral a => Real (Ratio a) where
    toRational (x:%y) = toInteger x :% toInteger y

instance Integral a => Fractional (Ratio a) where
    (x:%y) / (x':%y')   = (x*y') % (y*x')
    recip (x:%y)        = y % x
    fromRational (x:%y) = fromInteger x :% fromInteger y
    fromDouble 		= doubleToRatio

-- Hugs optimises code of the form fromRational (doubleToRatio x)
-- Since this function is private, and only used to convert floating point
-- literals, it yields a decimal fraction, hopefully the one the user
-- specified in the first place (but some precision may be lost).  A real
-- Haskell implementation would use Rational to represent these literals.
doubleToRatio :: Integral a => Double -> Ratio a
doubleToRatio x
	    | n>=0      = (round (x / fromInteger pow) * fromInteger pow) % 1
	    | otherwise = fromRational (round (x * fromInteger denom) % denom)
			  where (m,n) = decodeFloat x
				n_dec = ceiling (logBase 10 (encodeFloat 1 n))
				denom = 10 ^ (-n_dec)
				pow   = 10 ^ n_dec

instance Integral a => RealFrac (Ratio a) where
    properFraction (x:%y) = (fromIntegral q, r:%y)
			    where (q,r) = quotRem x y

instance Integral a => Enum (Ratio a) where
    succ x         = x+1
    pred x         = x-1
    toEnum         = fromInt
    fromEnum       = fromInteger . truncate   -- may overflow
    enumFrom       = numericEnumFrom
    enumFromTo     = numericEnumFromTo
    enumFromThen   = numericEnumFromThen
    enumFromThenTo = numericEnumFromThenTo

instance (Read a, Integral a) => Read (Ratio a) where
    readsPrec p = readParen (p > 7)
			    (\r -> [(x%y,u) | (x,s)   <- readsPrec 8 r,
					      ("%",t) <- lex s,
					      (y,u)   <- readsPrec 8 t ])

instance Integral a => Show (Ratio a) where
    showsPrec p (x:%y) = showParen (p > 7)
			     (showsPrec 8 x . showString " % " . showsPrec 8 y)

-- Standard list functions {PreludeList} ------------------------------------

head             :: [a] -> a
head (x:_)        = x

last             :: [a] -> a
last [x]          = x
last (_:xs)       = last xs

tail             :: [a] -> [a]
tail (_:xs)       = xs

init             :: [a] -> [a]
init [x]          = []
init (x:xs)       = x : init xs

null             :: [a] -> Bool
null []           = True
null (_:_)        = False

(++)             :: [a] -> [a] -> [a]
[]     ++ ys      = ys
(x:xs) ++ ys      = x : (xs ++ ys)

map              :: (a -> b) -> [a] -> [b]
map f xs          = [ f x | x <- xs ]

filter           :: (a -> Bool) -> [a] -> [a]
filter p xs       = [ x | x <- xs, p x ]

concat           :: [[a]] -> [a]
concat            = foldr (++) []

length           :: [a] -> Int
length            = foldl' (\n _ -> n + 1) 0

(!!)             :: [a] -> Int -> a
xs     !! n | n<0 = error "Prelude.!!: negative index"
[]     !! _       = error "Prelude.!!: index too large"
(x:_)  !! 0       = x
(_:xs) !! n       = xs !! (n-1)

foldl            :: (a -> b -> a) -> a -> [b] -> a
foldl f z []      = z
foldl f z (x:xs)  = foldl f (f z x) xs

foldl'           :: (a -> b -> a) -> a -> [b] -> a
foldl' f a []     = a
foldl' f a (x:xs) = (foldl' f $! f a x) xs

foldl1           :: (a -> a -> a) -> [a] -> a
foldl1 f (x:xs)   = foldl f x xs

scanl            :: (a -> b -> a) -> a -> [b] -> [a]
scanl f q xs      = q : (case xs of
			 []   -> []
			 x:xs -> scanl f (f q x) xs)

scanl1           :: (a -> a -> a) -> [a] -> [a]
scanl1 _ []       = []
scanl1 f (x:xs)   = scanl f x xs

foldr            :: (a -> b -> b) -> b -> [a] -> b
foldr f z []      = z
foldr f z (x:xs)  = f x (foldr f z xs)

foldr1           :: (a -> a -> a) -> [a] -> a
foldr1 f [x]      = x
foldr1 f (x:xs)   = f x (foldr1 f xs)

scanr            :: (a -> b -> b) -> b -> [a] -> [b]
scanr f q0 []     = [q0]
scanr f q0 (x:xs) = f x q : qs
		    where qs@(q:_) = scanr f q0 xs

scanr1           :: (a -> a -> a) -> [a] -> [a]
scanr1 f []       = []
scanr1 f [x]      = [x]
scanr1 f (x:xs)   = f x q : qs
		    where qs@(q:_) = scanr1 f xs

iterate          :: (a -> a) -> a -> [a]
iterate f x       = x : iterate f (f x)

repeat           :: a -> [a]
repeat x          = xs where xs = x:xs

replicate        :: Int -> a -> [a]
replicate n x     = take n (repeat x)

cycle            :: [a] -> [a]
cycle []          = error "Prelude.cycle: empty list"
cycle xs          = xs' where xs'=xs++xs'

take                :: Int -> [a] -> [a]
take n _  | n <= 0  = []
take _ []           = []
take n (x:xs)       = x : take (n-1) xs

drop                :: Int -> [a] -> [a]
drop n xs | n <= 0  = xs
drop _ []           = []
drop n (_:xs)       = drop (n-1) xs

splitAt               :: Int -> [a] -> ([a], [a])
splitAt n xs | n <= 0 = ([],xs)
splitAt _ []          = ([],[])
splitAt n (x:xs)      = (x:xs',xs'') where (xs',xs'') = splitAt (n-1) xs

takeWhile           :: (a -> Bool) -> [a] -> [a]
takeWhile p []       = []
takeWhile p (x:xs)
	 | p x       = x : takeWhile p xs
	 | otherwise = []

dropWhile           :: (a -> Bool) -> [a] -> [a]
dropWhile p []       = []
dropWhile p xs@(x:xs')
	 | p x       = dropWhile p xs'
	 | otherwise = xs

span, break         :: (a -> Bool) -> [a] -> ([a],[a])
span p []            = ([],[])
span p xs@(x:xs')
	 | p x       = (x:ys, zs)
	 | otherwise = ([],xs)
                       where (ys,zs) = span p xs'
break p              = span (not . p)

lines     :: String -> [String]
lines ""   = []
lines s    = let (l,s') = break ('\n'==) s
             in l : case s' of []      -> []
                               (_:s'') -> lines s''

words     :: String -> [String]
words s    = case dropWhile isSpace s of
		  "" -> []
		  s' -> w : words s''
			where (w,s'') = break isSpace s'

unlines   :: [String] -> String
unlines []      = []
unlines (l:ls)  = l ++ '\n' : unlines ls

unwords   :: [String] -> String
unwords []	=  ""
unwords [w]	= w
unwords (w:ws)	= w ++ ' ' : unwords ws

reverse   :: [a] -> [a]
reverse    = foldl (flip (:)) []

and, or   :: [Bool] -> Bool
and        = foldr (&&) True
or         = foldr (||) False

any, all  :: (a -> Bool) -> [a] -> Bool
any p      = or  . map p
all p      = and . map p

elem, notElem    :: Eq a => a -> [a] -> Bool
elem              = any . (==)
notElem           = all . (/=)

lookup           :: Eq a => a -> [(a,b)] -> Maybe b
lookup k []       = Nothing
lookup k ((x,y):xys)
      | k==x      = Just y
      | otherwise = lookup k xys

sum, product     :: Num a => [a] -> a
sum               = foldl' (+) 0
product           = foldl' (*) 1

maximum, minimum :: Ord a => [a] -> a
maximum           = foldl1 max
minimum           = foldl1 min

concatMap        :: (a -> [b]) -> [a] -> [b]
concatMap f       = concat . map f

zip              :: [a] -> [b] -> [(a,b)]
zip               = zipWith  (\a b -> (a,b))

zip3             :: [a] -> [b] -> [c] -> [(a,b,c)]
zip3              = zipWith3 (\a b c -> (a,b,c))

zipWith                  :: (a->b->c) -> [a]->[b]->[c]
zipWith z (a:as) (b:bs)   = z a b : zipWith z as bs
zipWith _ _      _        = []

zipWith3                 :: (a->b->c->d) -> [a]->[b]->[c]->[d]
zipWith3 z (a:as) (b:bs) (c:cs)
			  = z a b c : zipWith3 z as bs cs
zipWith3 _ _ _ _          = []

unzip                    :: [(a,b)] -> ([a],[b])
unzip                     = foldr (\(a,b) ~(as,bs) -> (a:as, b:bs)) ([], [])

unzip3                   :: [(a,b,c)] -> ([a],[b],[c])
unzip3                    = foldr (\(a,b,c) ~(as,bs,cs) -> (a:as,b:bs,c:cs))
				  ([],[],[])

-- PreludeText ----------------------------------------------------------------

reads        :: Read a => ReadS a
reads         = readsPrec 0

shows        :: Show a => a -> ShowS
shows         = showsPrec 0

read         :: Read a => String -> a
read s        =  case [x | (x,t) <- reads s, ("","") <- lex t] of
		      [x] -> x
		      []  -> error "Prelude.read: no parse"
		      _   -> error "Prelude.read: ambiguous parse"

showChar     :: Char -> ShowS
showChar      = (:)

showString   :: String -> ShowS
showString    = (++)

showParen    :: Bool -> ShowS -> ShowS
showParen b p = if b then showChar '(' . p . showChar ')' else p

showField    :: Show a => String -> a -> ShowS
showField m@(c:_) v
  | isAlpha c || c == '_' = showString m . showString " = " . shows v
  | otherwise = showChar '(' . showString m . showString ") = " . shows v

readParen    :: Bool -> ReadS a -> ReadS a
readParen b g = if b then mandatory else optional
		where optional r  = g r ++ mandatory r
		      mandatory r = [(x,u) | ("(",s) <- lex r,
					     (x,t)   <- optional s,
					     (")",u) <- lex t    ]

readField    :: Read a => String -> ReadS a
readField m s0 = [ r | (t,  s1) <- readFieldName m s0,
                       ("=",s2) <- lex s1,
                       r        <- reads s2 ]

readFieldName :: String -> ReadS String
readFieldName m@(c:_) s0
  | isAlpha c || c == '_' = [ (f,s1) | (f,s1) <- lex s0, f == m ]
  | otherwise = [ (f,s3) | ("(",s1) <- lex s0,
			   (f,s2)   <- lex s1, f == m,
			   (")",s3) <- lex s2 ]

lex                    :: ReadS String
lex ""                  = [("","")]
lex (c:s) | isSpace c   = lex (dropWhile isSpace s)
lex ('\'':s)            = [('\'':ch++"'", t) | (ch,'\'':t)  <- lexLitChar s,
					       ch /= "'"                ]
lex ('"':s)             = [('"':str, t)      | (str,t) <- lexString s]
			  where
			  lexString ('"':s) = [("\"",s)]
			  lexString s = [(ch++str, u)
						| (ch,t)  <- lexStrItem s,
						  (str,u) <- lexString t  ]

			  lexStrItem ('\\':'&':s) = [("\\&",s)]
			  lexStrItem ('\\':c:s) | isSpace c
			      = [("",t) | '\\':t <- [dropWhile isSpace s]]
			  lexStrItem s            = lexLitChar s

lex (c:s) | isSym c     = [(c:sym,t)         | (sym,t) <- [span isSym s]]
          | isAlpha c   = [(c:nam,t)         | (nam,t) <- [span isIdChar s]]
             -- '_' can be the start of a single char or a name/id.
          | c == '_'    = case span isIdChar s of 
                            ([],_) -> [([c],s)]
                            (nm,t) -> [((c:nm),t)]
          | isSingle c  = [([c],s)]
          | isDigit c   = [(c:ds++fe,t)      | (ds,s)  <- [span isDigit s],
                                               (fe,t)  <- lexFracExp s     ]
          | otherwise   = []    -- bad character
		where
		isSingle c  =  c `elem` ",;()[]{}_`"
		isSym c     =  c `elem` "!@#$%&*+./<=>?\\^|:-~"
		isIdChar c  =  isAlphaNum c || c `elem` "_'"

		lexFracExp ('.':c:cs) | isDigit c 
                            = [('.':ds++e,u) | (ds,t) <- lexDigits (c:cs),
					       (e,u)  <- lexExp t    ]
		lexFracExp s       = lexExp s

		lexExp (e:s) | e `elem` "eE"
			 = [(e:c:ds,u) | (c:t)  <- [s], c `elem` "+-",
						   (ds,u) <- lexDigits t] ++
			   [(e:ds,t)   | (ds,t) <- lexDigits s]
		lexExp s = [("",s)]

lexDigits               :: ReadS String
lexDigits               =  nonnull isDigit

nonnull                 :: (Char -> Bool) -> ReadS String
nonnull p s             =  [(cs,t) | (cs@(_:_),t) <- [span p s]]

lexLitChar          :: ReadS String
lexLitChar ""       =  []
lexLitChar (c:s)
 | c /= '\\'        =  [([c],s)]
 | otherwise        =  map (prefix '\\') (lexEsc s)
 where
   lexEsc (c:s)     | c `elem` "abfnrtv\\\"'" = [([c],s)]
   lexEsc ('^':c:s) | c >= '@' && c <= '_'    = [(['^',c],s)]
    -- Numeric escapes
   lexEsc ('o':s)  = [prefix 'o' (span isOctDigit s)]
   lexEsc ('x':s)  = [prefix 'x' (span isHexDigit s)]
   lexEsc s@(c:_) 
     | isDigit c   = [span isDigit s]  
     | isUpper c   = case [(mne,s') | (c, mne) <- table,
	 	        ([],s') <- [lexmatch mne s]] of
                       (pr:_) -> [pr]
	               []     -> []
   lexEsc _        = []

   table = ('\DEL',"DEL") : asciiTab
   prefix c (t,s) = (c:t, s)

isOctDigit c  =  c >= '0' && c <= '7'
isHexDigit c  =  isDigit c || c >= 'A' && c <= 'F'
			   || c >= 'a' && c <= 'f'

lexmatch                   :: (Eq a) => [a] -> [a] -> ([a],[a])
lexmatch (x:xs) (y:ys) | x == y  =  lexmatch xs ys
lexmatch xs     ys               =  (xs,ys)

asciiTab = zip ['\NUL'..' ']
	   ["NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
	    "BS",  "HT",  "LF",  "VT",  "FF",  "CR",  "SO",  "SI",
	    "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB",
	    "CAN", "EM",  "SUB", "ESC", "FS",  "GS",  "RS",  "US",
	    "SP"]

readLitChar            :: ReadS Char
readLitChar ('\\':s)    = readEsc s
 where
       readEsc ('a':s)  = [('\a',s)]
       readEsc ('b':s)  = [('\b',s)]
       readEsc ('f':s)  = [('\f',s)]
       readEsc ('n':s)  = [('\n',s)]
       readEsc ('r':s)  = [('\r',s)]
       readEsc ('t':s)  = [('\t',s)]
       readEsc ('v':s)  = [('\v',s)]
       readEsc ('\\':s) = [('\\',s)]
       readEsc ('"':s)  = [('"',s)]
       readEsc ('\'':s) = [('\'',s)]
       readEsc ('^':c:s) | c >= '@' && c <= '_'
			= [(toEnum (fromEnum c - fromEnum '@'), s)]
       readEsc s@(d:_) | isDigit d
			= [(toEnum n, t) | (n,t) <- readDec s]
       readEsc ('o':s)  = [(toEnum n, t) | (n,t) <- readOct s]
       readEsc ('x':s)  = [(toEnum n, t) | (n,t) <- readHex s]
       readEsc s@(c:_) | isUpper c
			= let table = ('\DEL',"DEL") : asciiTab
			  in case [(c,s') | (c, mne) <- table,
					    ([],s') <- [lexmatch mne s]]
			     of (pr:_) -> [pr]
				[]     -> []
       readEsc _        = []
readLitChar (c:s)       = [(c,s)]

showLitChar               :: Char -> ShowS
showLitChar c | c > '\DEL' = showChar '\\' .
			     protectEsc isDigit (shows (fromEnum c))
showLitChar '\DEL'         = showString "\\DEL"
showLitChar '\\'           = showString "\\\\"
showLitChar c | c >= ' '   = showChar c
showLitChar '\a'           = showString "\\a"
showLitChar '\b'           = showString "\\b"
showLitChar '\f'           = showString "\\f"
showLitChar '\n'           = showString "\\n"
showLitChar '\r'           = showString "\\r"
showLitChar '\t'           = showString "\\t"
showLitChar '\v'           = showString "\\v"
showLitChar '\SO'          = protectEsc ('H'==) (showString "\\SO")
showLitChar c              = showString ('\\' : snd (asciiTab!!fromEnum c))

protectEsc p f             = f . cont
 where cont s@(c:_) | p c  = "\\&" ++ s
       cont s              = s

-- Unsigned readers for various bases
readDec, readOct, readHex :: Integral a => ReadS a
readDec = readInt 10 isDigit    (\ d -> fromEnum d - fromEnum_0)
readOct = readInt  8 isOctDigit (\ d -> fromEnum d - fromEnum_0)
readHex = readInt 16 isHexDigit hex
	    where hex d = fromEnum d - (if isDigit d then fromEnum_0
				       else fromEnum (if isUpper d then 'A' else 'a') - 10)

fromEnum_0 :: Int
fromEnum_0 = fromEnum '0'

-- readInt reads a string of digits using an arbitrary base.  
-- Leading minus signs must be handled elsewhere.

readInt :: Integral a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
readInt radix isDig digToInt s =
    [(foldl1 (\n d -> n * radix + d) (map (fromIntegral . digToInt) ds), r)
	| (ds,r) <- nonnull isDig s ]

readSigned:: Real a => ReadS a -> ReadS a
readSigned readPos = readParen False read'
		     where read' r  = read'' r ++
				      [(-x,t) | ("-",s) <- lex r,
						(x,t)   <- read'' s]
			   read'' r = [(n,s)  | (str,s) <- lex r,
						(n,"")  <- readPos str]


-- This floating point reader uses a less restrictive syntax for floating
-- point than the Haskell lexer.  The `.' is optional.
readFloat     :: RealFrac a => ReadS a
readFloat r    = [(fromRational ((n%1)*10^^(k-d)),t) | (n,d,s) <- readFix r,
						       (k,t)   <- readExp s] ++
                 [ (0/0, t) | ("NaN",t)      <- lex r] ++
                 [ (1/0, t) | ("Infinity",t) <- lex r]
		 where readFix r = [(read (ds++ds'), length ds', t)
					| (ds, d) <- lexDigits r
                                        , (ds',t) <- lexFrac d   ]

                       lexFrac ('.':s) = lexDigits s
		       lexFrac s       = [("",s)]

		       readExp (e:s) | e `elem` "eE" = readExp' s
		       readExp s                     = [(0,s)]

		       readExp' ('-':s) = [(-k,t) | (k,t) <- readDec s]
		       readExp' ('+':s) = readDec s
		       readExp' s       = readDec s

----------------------------------------------------------------
-- Exception datatype and operations
----------------------------------------------------------------

data Exception
  = ArithException      ArithException
  | ArrayException      ArrayException
  | AssertionFailed     String
  | AsyncException      AsyncException
  | BlockedOnDeadMVar
  | Deadlock
  | DynException        Dynamic
  | ErrorCall           String
  | ExitException       ExitCode
  | IOException 	IOException	-- IO exceptions (from 'ioError')
  | NoMethodError       String
  | NonTermination
  | PatternMatchFail    String
  | RecConError         String
  | RecSelError         String
  | RecUpdError         String

instance Show Exception where
  showsPrec _ (ArithException e)  = shows e
  showsPrec _ (ArrayException e)  = shows e
  showsPrec _ (AssertionFailed s) = showException "assertion failed" s
  showsPrec _ (AsyncException e)  = shows e
  showsPrec _ BlockedOnDeadMVar   = showString "thread blocked indefinitely"
  showsPrec _ Deadlock            = showString "<<deadlock>>"
  showsPrec _ (DynException _)    = showString "unknown exception"
  showsPrec _ (ErrorCall s)       = showString s
  showsPrec _ (ExitException err) = showString "exit: " . shows err
  showsPrec _ (IOException err)	  = shows err
  showsPrec _ (NoMethodError s)   = showException "undefined member" s
  showsPrec _ NonTermination	  = showString "<<loop>>"
  showsPrec _ (PatternMatchFail s) = showException "pattern match failure" s
  showsPrec _ (RecConError s)     = showException "undefined field" s
  showsPrec _ (RecSelError s)     = showException "select of missing field" s
  showsPrec _ (RecUpdError s)     = showException "update of missing field" s

data ArithException
  = Overflow
  | Underflow
  | LossOfPrecision
  | DivideByZero
  | Denormal
  deriving (Eq, Ord)

instance Show ArithException where
  showsPrec _ Overflow        = showString "arithmetic overflow"
  showsPrec _ Underflow       = showString "arithmetic underflow"
  showsPrec _ LossOfPrecision = showString "loss of precision"
  showsPrec _ DivideByZero    = showString "divide by zero"
  showsPrec _ Denormal        = showString "denormal"

data ArrayException
  = IndexOutOfBounds    String
  | UndefinedElement    String
  deriving (Eq, Ord)

instance Show ArrayException where
  showsPrec _ (IndexOutOfBounds s) =
    showException "array index out of range" s
  showsPrec _ (UndefinedElement s) =
    showException "undefined array element" s

data AsyncException
  = StackOverflow
  | HeapOverflow
  | ThreadKilled
  deriving (Eq, Ord)

instance Show AsyncException where
  showsPrec _ StackOverflow   = showString "stack overflow"
  showsPrec _ HeapOverflow    = showString "heap overflow"
  showsPrec _ ThreadKilled    = showString "thread killed"

showException :: String -> String -> ShowS
showException tag msg =
  showString tag . (if null msg then id else showString ": " . showString msg)

data ExitCode = ExitSuccess | ExitFailure Int
                deriving (Eq, Ord, Read, Show)

-- data type describing IOErrors / exceptions.
type IOError = IOException

data IOException
  = IOError
      { ioe_handle      :: Maybe Handle   -- the handle used by the action
					  -- flagging the error
      , ioe_type        :: IOErrorType    -- what kind of (std) error
      , ioe_location    :: String         -- location of the error
      , ioe_description :: String         -- error-specific string
      , ioe_filename    :: Maybe FilePath -- the resource involved.
      } 
      deriving (Eq)

data IOErrorType
  = AlreadyExists
  | NoSuchThing
  | ResourceBusy
  | ResourceExhausted
  | EOF
  | IllegalOperation
  | PermissionDenied
  | UserError
     -- GHC compatibility
  | ProtocolError
  | UnsupportedOperation
  | OtherError
     -- DOTNET only
  | DotNetException
    deriving (Eq)

instance Show IOErrorType where
  show x = 
    case x of
      AlreadyExists     -> "already exists"
      NoSuchThing       -> "does not exist"
      ResourceBusy      -> "resource busy"
      ResourceExhausted -> "resource exhausted"
      EOF               -> "end of file"
      IllegalOperation  -> "illegal operation"
      PermissionDenied  -> "permission denied"
      UserError         -> "user error"
      ProtocolError     -> "protocol error"
      UnsupportedOperation -> "unsupported operation"
      OtherError        -> "failed"
      DotNetException   -> ".NET exception"

instance Show IOException where
  showsPrec p (IOError hdl iot loc s fn) =
    (case fn of
       Nothing -> case hdl of
		      Nothing -> id
		      Just h  -> showsPrec p h . showString ": "
       Just name -> showString name . showString ": ") .
    (case loc of
       "" -> id
       _  -> showString loc . showString ": ") .
    showsPrec p iot .
    (case s of
       "" -> id
       _  -> showString " (" . showString s . showString ")")

-- Monadic I/O: --------------------------------------------------------------

--data IO a             -- builtin datatype of IO actions

type FilePath = String  -- file pathnames are represented by strings

primitive primbindIO		 :: IO a -> (a -> IO b) -> IO b
primitive primretIO		 :: a -> IO a

ioError :: IOError -> IO a
ioError e = IO (\ s -> throw (IOException e))

userError :: String -> IOError
userError str = IOError Nothing UserError "" str Nothing

catch :: IO a -> (IOError -> IO a) -> IO a
catch m h = catchException m $ \e -> case e of
		IOException err -> h err
		_ -> throw e

putChar   :: Char -> IO ()
putChar    = hPutChar stdout

putStr    :: String -> IO ()
putStr     = hPutStr stdout

print     :: Show a => a -> IO ()
print      = putStrLn . show

putStrLn  :: String -> IO ()
putStrLn s = do putStr s
		putChar '\n'

getChar   :: IO Char
getChar    = hGetChar stdin

getContents :: IO String
getContents  = hGetContents stdin

getLine   :: IO String
getLine    = hGetLine stdin

hGetLine :: Handle -> IO String
hGetLine h = do 
  c <- hGetChar h
  hGetLine' c
  where
   hGetLine' '\n' = return ""
   hGetLine' c = do
     cs <- getRest
     return (c:cs)
   getRest = do
     c <- catch (hGetChar h) $ \ ex ->
	if isEOFError ex then return '\n' else ioError ex
     hGetLine' c
   isEOFError ex = ioe_type ex == EOF	-- defined in System.IO.Error

-- raises an exception instead of an error
readIO          :: Read a => String -> IO a
readIO s         = case [x | (x,t) <- reads s, ("","") <- lex t] of
                        [x] -> return x
                        []  -> ioError (userError "PreludeIO.readIO: no parse")
                        _   -> ioError (userError 
                                       "PreludeIO.readIO: ambiguous parse")

readLn          :: Read a => IO a
readLn           = do l <- getLine
                      r <- readIO l
                      return r

data IOMode      =  ReadMode | WriteMode | AppendMode | ReadWriteMode
                    deriving (Eq, Ord, Ix, Bounded, Enum, Read, Show)

writeFile	:: FilePath -> String -> IO ()
writeFile        = writeFile' WriteMode

appendFile	:: FilePath -> String -> IO ()
appendFile       = writeFile' AppendMode

writeFile'      :: IOMode -> FilePath -> String -> IO ()
writeFile' mode name s = do
  h <- openFile name mode
  catchException (hPutStr h s) (\e -> hClose h >> throw e)
  hClose h

readFile	:: FilePath -> IO String
readFile name    = openFile name ReadMode >>= hGetContents

interact  :: (String -> String) -> IO ()
interact f = getContents >>= (putStr . f)

primitive stdin       :: Handle
primitive stdout      :: Handle
primitive stderr      :: Handle
primitive openFile    :: FilePath -> IOMode -> IO Handle
primitive hClose      :: Handle -> IO ()
primitive hGetContents :: Handle -> IO String
primitive hGetChar    :: Handle -> IO Char
primitive hPutChar    :: Handle -> Char -> IO ()
primitive hPutStr     :: Handle -> String -> IO ()

instance Functor IO where
    fmap f x = x >>= (return . f)

instance Monad IO where
    (>>=)  = primbindIO
    return = primretIO
    
    fail s = ioError (userError s)

-- Hooks for primitives: -----------------------------------------------------
-- Do not mess with these!

data FunPtr a -- builtin datatype of C function pointers
data Ptr a    -- builtin datatype of C pointers
data Addr     -- builtin datatype of C pointers (deprecated)
data Word     -- builtin datatype of unsigned ints (deprecated)
data Int8
data Int16
data Int32
data Int64
data Word8
data Word16
data Word32
data Word64
data ForeignObj  -- builtin datatype of C pointers with finalizers (deprecated)
data ForeignPtr a -- builtin datatype of C pointers with finalizers
data StablePtr a
data Handle

data Object a -- builtin datatype of external object references.
              -- (needed as primitive since they're supported in FFI decls.)

instance Eq Handle where (==) = primEqHandle
primitive primEqHandle :: Handle -> Handle -> Bool

instance Show Handle where
    showsPrec _ h = case primGetHandleNumber h of
	0 -> showString "<stdin>"
	1 -> showString "<stdout>"
	2 -> showString "<stderr>"
	_ -> showString "<handle>"

primitive primGetHandleNumber :: Handle -> Int

primitive unsafeCoerce "primUnsafeCoerce" :: a -> b

data Dynamic = Dynamic TypeRep Obj

data TypeRep = TypeRep !Key TyCon [TypeRep]

instance Eq TypeRep where
  (TypeRep k1 _ _) == (TypeRep k2 _ _) = k1 == k2

data TyCon = TyCon !Key String

instance Eq TyCon where
  (TyCon t1 _) == (TyCon t2 _) = t1 == t2

newtype Key = Key Int deriving( Eq )

data Obj = Obj

toObj :: a -> Obj
toObj   = unsafeCoerce

fromObj :: Obj -> a
fromObj = unsafeCoerce

newtype IO a = IO ((a -> IOResult) -> IOResult)

data IOResult 
  = Hugs_ExitWith    Int
  | Hugs_Catch       IOResult (Exception -> IOResult) (Obj -> IOResult)
  | Hugs_ForkThread  IOResult IOResult
  | Hugs_DeadThread
  | Hugs_YieldThread IOResult
  | Hugs_Return      Obj
  | Hugs_BlockThread (Obj -> IOResult) ((Obj -> IOResult) -> IOResult) 

data IOFinished a
  = Finished_ExitWith Int
  | Finished_Return   a

primitive throw "primThrowException" :: Exception -> a
primitive primCatchException :: a -> Either Exception a

catchException :: IO a -> (Exception -> IO a) -> IO a
catchException (IO m) k = IO $ \ s ->
  Hugs_Catch (m hugsReturn)
             (\ e -> case (k e) of { IO k' -> k' s })
             (s . fromObj)

hugsReturn :: a -> IOResult
hugsReturn x = Hugs_Return (toObj x)

-- reify current thread, execute 'm <thread>' and switch to next thread
blockIO :: ((a -> IOResult) -> IO ()) -> IO a
blockIO m = IO (\ s -> Hugs_BlockThread (s . fromObj) m')
 where
  m' k = threadToIOResult (m (k . toObj))

hugsIORun  :: IO a -> Either Int a
hugsIORun m = 
  case basicIORun (runAndShowError m) of
    Finished_ExitWith i -> Left i
    Finished_Return   a -> Right a
 where
  runAndShowError :: IO a -> IO a
  runAndShowError m = m `catchException` exceptionHandler
  exceptionHandler :: Exception -> IO a
  exceptionHandler (ExitException ExitSuccess) = primExitWith 0
  exceptionHandler (ExitException (ExitFailure n)) = primExitWith n
  exceptionHandler err = runAndShowError $ do
	putChar '\n'
	putStr "Program error: "
	putStrLn (show err)
	primExitWith 1

basicIORun :: IO a -> IOFinished a
basicIORun (IO m) = loop [m hugsReturn]

threadToIOResult :: IO a -> IOResult
threadToIOResult (IO m) = m (const Hugs_DeadThread)

-- This is the queue of *runnable* threads.
-- There may be blocked threads attached to MVars
-- An important invariant is that at most one thread will result in
-- Hugs_Return - and its Obj value has type \alpha
loop :: [IOResult] -> IOFinished a
loop []                      = error "no more threads (deadlock?)"
loop [Hugs_Return   a]       = Finished_Return (fromObj a)
loop (Hugs_Return   a:r)     = loop (r ++ [Hugs_Return a])
loop (Hugs_Catch m f s:r)    = loop (hugs_catch m f s : r)
loop (Hugs_ExitWith i:_)     = Finished_ExitWith i
loop (Hugs_DeadThread:r)     = loop r
loop (Hugs_ForkThread a b:r) = loop (a:b:r)
loop (Hugs_YieldThread a:r)  = loop (r ++ [a])
loop (Hugs_BlockThread a b:r)= loop (b a : r)
loop _                       = error "Fatal error in Hugs scheduler"

hugs_catch :: IOResult -> (Exception -> IOResult) -> (Obj -> IOResult) -> IOResult
hugs_catch m f s = case primCatchException (catch' m) of
  Left  exn                   -> f exn
  Right (Hugs_Return a)       -> s a
  Right (Hugs_ForkThread a b) -> Hugs_ForkThread (Hugs_Catch a f s) b
  Right (Hugs_YieldThread a)  -> Hugs_YieldThread (Hugs_Catch a f s)
  Right (Hugs_BlockThread a b)-> Hugs_BlockThread (\x -> Hugs_Catch (a x) f s) b
  Right r                     -> r
 where
  catch' :: IOResult -> IOResult
  catch' (Hugs_Catch m' f' s') = catch' (hugs_catch m' f' s')
  catch' x                     = x

primExitWith     :: Int -> IO a
primExitWith c    = IO (\ s -> Hugs_ExitWith c)

primCompAux      :: Ord a => a -> a -> Ordering -> Ordering
primCompAux x y o = case compare x y of EQ -> o; LT -> LT; GT -> GT

primPmInt        :: Num a => Int -> a -> Bool
primPmInt n x     = fromInt n == x

primPmInteger    :: Num a => Integer -> a -> Bool
primPmInteger n x = fromInteger n == x

primPmFlt        :: Fractional a => Double -> a -> Bool
primPmFlt n x     = fromDouble n == x

-- The following primitives are only needed if (n+k) patterns are enabled:
primPmNpk        :: Integral a => Int -> a -> Maybe a
primPmNpk n x     = if n'<=x then Just (x-n') else Nothing
		    where n' = fromInt n

primPmSub        :: Integral a => Int -> a -> a
primPmSub n x     = x - fromInt n

-- Trex
emptyRec :: Rec EmptyRow
emptyRec = EmptyRec

-- End of Hugs standard prelude ----------------------------------------------
-----------------------------------------------------------------------------
-- Machine Addresses:
-- Suitable for use with Hugs 98 on 32 bit machines.
-----------------------------------------------------------------------------
module Hugs.Ptr
	( Ptr
	, nullPtr          -- :: Ptr a
 	, plusPtr          -- :: Ptr a -> Int -> Ptr b
        , castPtr          -- :: Ptr a -> Ptr b
	, alignPtr         -- :: Ptr a -> Int -> Ptr a
	, minusPtr         -- :: Ptr a -> Ptr b -> Int
	-- instance Eq   (Ptr a)
	-- instance Ord  (Ptr a)
	-- instance Show (Ptr a)

        , FunPtr
	, nullFunPtr        -- :: FunPtr a
	, castFunPtr        -- :: FunPtr a -> FunPtr b
	, castFunPtrToPtr   -- :: FunPtr a -> Ptr b
	, castPtrToFunPtr   -- :: Ptr a -> FunPtr b
        , freeHaskellFunPtr -- :: FunPtr a -> IO ()
	-- instance Eq   (FunPtr a)
	-- instance Ord  (FunPtr a)
	-- instance Show (FunPtr a)
	) where

import Hugs.Prelude ( Ptr, FunPtr )

-- data Ptr a -- in Hugs.Prelude

instance Eq   (Ptr a) where (==)      = primEqPtr
instance Ord  (Ptr a) where compare   = primCmpPtr
instance Show (Ptr a) where showsPrec = primShowsPtr

primitive nullPtr                    :: Ptr a
primitive plusPtr                    :: Ptr a -> Int -> Ptr b
primitive alignPtr                   :: Ptr a -> Int -> Ptr a
primitive minusPtr                   :: Ptr a -> Ptr b -> Int
primitive castPtr "primUnsafeCoerce" :: Ptr a -> Ptr b
primitive primShowsPtr               :: Int -> Ptr a -> ShowS
primitive primEqPtr                  :: Ptr a -> Ptr a -> Bool
primitive primCmpPtr                 :: Ptr a -> Ptr a -> Ordering

-- data FunPtr a -- in Hugs.Prelude

instance Eq   (FunPtr a) where (==)      = primEqFPtr
instance Ord  (FunPtr a) where compare   = primCmpFPtr
instance Show (FunPtr a) where showsPrec = primShowsFPtr

primitive nullFunPtr    "nullPtr"       :: FunPtr a
primitive primShowsFPtr "primShowsPtr"  :: Int -> FunPtr a -> ShowS
primitive primEqFPtr    "primEqPtr"     :: FunPtr a -> FunPtr a -> Bool
primitive primCmpFPtr   "primCmpPtr"    :: FunPtr a -> FunPtr a -> Ordering
primitive castFunPtr "primUnsafeCoerce" :: FunPtr a -> FunPtr b
primitive castFunPtrToPtr "primUnsafeCoerce" :: FunPtr a -> Ptr b
primitive castPtrToFunPtr "primUnsafeCoerce" :: Ptr a -> FunPtr b
primitive freeHaskellFunPtr             :: FunPtr a -> IO ()

-----------------------------------------------------------------------------
module Hugs.Quote(Quote, quote, trim) where

import Data.List
import Data.Ratio(Ratio)

class Quote a where
    quote :: a -> String

instance Quote Char where
    quote c = [c]

instance Quote String where
    quote = id

instance Quote Bool where
    quote = show

instance Show a => Quote (Maybe a) where
    quote = show

instance Quote Int where
    quote = show

instance Quote Integer where
    quote = show

instance Quote Float where
    quote = show

instance Quote Double where
    quote = show

instance Integral a => Quote (Ratio a) where
    quote = show

-- trims off leading whitespace up to a common prefix,
-- making it easy to layout here docs indented so that
-- are not visually confusing (especially if you are doing
-- something like using here docs to generate Haskell code)

trim s = unlines' ls'
  where ls  = lines' s
	ls' = map (trimoff 0 n) ls
	n = case filter (/= 0) $ map (whitecount 0) ls of
	      [] -> 0
	      xs -> minimum xs

-- like the prelude functions, but preserve (lack of) trailing newline
lines' s    = let (l,s') = break ('\n'==) s
	      in l : case s' of []      -> []
				(_:s'') -> lines' s''
unlines' ss = concat $ intersperse "\n" ss

whitecount n []        = n
whitecount n (' ':cs)  = whitecount (n + 1) cs
whitecount n ('\t':cs) = whitecount (8 * ((n + 8) `div` 8)) cs
whitecount n _         = n

trimoff n m [] = []
trimoff n m cs | n >= m = cs
trimoff n m (' ' :cs) = trimoff (n + 1) m cs
trimoff n m ('\t':cs) = trimoff (8 * ((n + 8) `div` 8)) m cs
trimoff n m cs        = cs
-----------------------------------------------------------------------------
-- Strict State Thread module
-- 
-- This library provides support for strict state threads, as described
-- in the PLDI '94 paper by John Launchbury and Simon Peyton Jones.
-- In addition to the monad ST, it also provides mutable variables STRef
-- and mutable arrays STArray.
--
-- Suitable for use with Hugs 98.
-----------------------------------------------------------------------------

module Hugs.ST 
	( ST(..)
	, runST
	, unsafeRunST
	, RealWorld
	, stToIO
	, unsafeIOToST
	, unsafeSTToIO

	, STRef
	  -- instance Eq (STRef s a)
	, newSTRef
	, readSTRef
	, writeSTRef 

        , STArray
          -- instance Eq (STArray s ix elt)
        , newSTArray
        , boundsSTArray
        , readSTArray
        , writeSTArray
        , thawSTArray
        , freezeSTArray
        , unsafeFreezeSTArray

	, unsafeReadSTArray
	, unsafeWriteSTArray
	) where

import Hugs.Prelude(IO(..))
import Hugs.Array(Array,Ix(index,rangeSize),bounds,elems)
import Hugs.IOExts(unsafePerformIO, unsafeCoerce)
import Control.Monad   

-----------------------------------------------------------------------------

-- The ST representation generalizes that of IO (cf. Hugs.Prelude),
-- so it can use IO primitives that manipulate local state.

newtype ST s a = ST (forall r. (a -> r) -> r)

data RealWorld = RealWorld

primitive thenStrictST "primbindIO" :: ST s a -> (a -> ST s b) -> ST s b
primitive returnST     "primretIO"  :: a -> ST s a

unST                :: ST s a -> (a -> r) -> r
unST (ST f)          = f

runST               :: (forall s. ST s a) -> a
runST m              = unST m id

unsafeRunST         :: ST s a -> a
unsafeRunST m        = unST m id

stToIO              :: ST RealWorld a -> IO a
stToIO (ST f)        = IO f

unsafeIOToST        :: IO a -> ST s a
unsafeIOToST         = unsafePerformIO . liftM returnST

unsafeSTToIO        :: ST s a -> IO a
unsafeSTToIO         = stToIO . unsafeCoerce

instance Functor (ST s) where
    fmap = liftM

instance Monad (ST s) where
    (>>=)  = thenStrictST
    return = returnST

-----------------------------------------------------------------------------

data STRef s a   -- implemented as an internal primitive

primitive newSTRef   "newRef"     :: a -> ST s (STRef s a)
primitive readSTRef  "getRef"     :: STRef s a -> ST s a
primitive writeSTRef "setRef"     :: STRef s a -> a -> ST s ()
primitive eqSTRef    "eqRef"      :: STRef s a -> STRef s a -> Bool

instance Eq (STRef s a) where (==) = eqSTRef

-----------------------------------------------------------------------------

data STArray s ix elt -- implemented as an internal primitive

newSTArray          :: Ix ix => (ix,ix) -> elt -> ST s (STArray s ix elt)
boundsSTArray       :: Ix ix => STArray s ix elt -> (ix, ix)
readSTArray         :: Ix ix => STArray s ix elt -> ix -> ST s elt
writeSTArray        :: Ix ix => STArray s ix elt -> ix -> elt -> ST s ()
thawSTArray         :: Ix ix => Array ix elt -> ST s (STArray s ix elt)
freezeSTArray       :: Ix ix => STArray s ix elt -> ST s (Array ix elt)
unsafeFreezeSTArray :: Ix ix => STArray s ix elt -> ST s (Array ix elt)

unsafeReadSTArray   :: Ix i => STArray s i e -> Int -> ST s e
unsafeReadSTArray    = primReadArr

unsafeWriteSTArray  :: Ix i => STArray s i e -> Int -> e -> ST s ()
unsafeWriteSTArray   = primWriteArr

newSTArray bs e      = primNewArr bs (rangeSize bs) e
boundsSTArray a      = primBounds a
readSTArray a i      = unsafeReadSTArray a (index (boundsSTArray a) i)
writeSTArray a i e   = unsafeWriteSTArray a (index (boundsSTArray a) i) e
thawSTArray arr      = do
		       stArr <- newSTArray (bounds arr) err
		       sequence_ (zipWith (unsafeWriteSTArray stArr)
						[0..] (elems arr))
		       return stArr
 where
  err = error "thawArray: element not overwritten" -- shouldnae happen
freezeSTArray a      = primFreeze a
unsafeFreezeSTArray  = freezeSTArray  -- not as fast as GHC

instance Eq (STArray s ix elt) where
  (==) = eqSTArray

primitive primNewArr   "IONewArr"
          :: (a,a) -> Int -> b -> ST s (STArray s a b)
primitive primReadArr  "IOReadArr"
          :: STArray s a b -> Int -> ST s b
primitive primWriteArr "IOWriteArr"
          :: STArray s a b -> Int -> b -> ST s ()
primitive primFreeze   "IOFreeze"
          :: STArray s a b -> ST s (Array a b)
primitive primBounds   "IOBounds"
          :: STArray s a b -> (a,a)
primitive eqSTArray    "IOArrEq"
          :: STArray s a b -> STArray s a b -> Bool

-----------------------------------------------------------------------------
module Hugs.Stable where 

data StableName a -- abstract

primitive makeStableName   :: a -> IO (StableName a)
primitive deRefStableName  :: StableName a -> a
primitive hashStableName   :: StableName a -> Int
primitive eqStableName	   :: StableName a -> StableName a -> Bool

instance Eq (StableName a) where
    (==) = eqStableName
module Hugs.StablePtr( StablePtr, module Hugs.StablePtr ) where

import Hugs.Prelude( StablePtr, Ptr )

-- recently renamed
newStablePtr = makeStablePtr 

primitive makeStablePtr      :: a -> IO (StablePtr a)
primitive deRefStablePtr     :: StablePtr a -> IO a
primitive freeStablePtr      :: StablePtr a -> IO ()
primitive castStablePtrToPtr :: StablePtr a -> Ptr ()
primitive castPtrToStablePtr :: Ptr () -> StablePtr a

/* Machine generated file, do not modify */
#include <stdlib.h>
#include "HsFFI.h"

static HugsAPI5 *hugs = 0;
#include "Storable_aux.h"

#ifndef ENABLE_MACRO_INTERFACE
#undef writeWord64OffPtr
#endif

static void hugsprim_writeWord64OffPtr_29(HugsStackPtr);
static void hugsprim_writeWord64OffPtr_29(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsWord64 arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getWord64();
    writeWord64OffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef writeWord32OffPtr
#endif

static void hugsprim_writeWord32OffPtr_28(HugsStackPtr);
static void hugsprim_writeWord32OffPtr_28(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsWord32 arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getWord32();
    writeWord32OffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef writeWord16OffPtr
#endif

static void hugsprim_writeWord16OffPtr_27(HugsStackPtr);
static void hugsprim_writeWord16OffPtr_27(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsWord16 arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getWord16();
    writeWord16OffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef writeWord8OffPtr
#endif

static void hugsprim_writeWord8OffPtr_26(HugsStackPtr);
static void hugsprim_writeWord8OffPtr_26(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsWord8 arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getWord8();
    writeWord8OffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef writeInt64OffPtr
#endif

static void hugsprim_writeInt64OffPtr_25(HugsStackPtr);
static void hugsprim_writeInt64OffPtr_25(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsInt64 arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getInt64();
    writeInt64OffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef writeInt32OffPtr
#endif

static void hugsprim_writeInt32OffPtr_24(HugsStackPtr);
static void hugsprim_writeInt32OffPtr_24(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsInt32 arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getInt32();
    writeInt32OffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef writeInt16OffPtr
#endif

static void hugsprim_writeInt16OffPtr_23(HugsStackPtr);
static void hugsprim_writeInt16OffPtr_23(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsInt16 arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getInt16();
    writeInt16OffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef writeInt8OffPtr
#endif

static void hugsprim_writeInt8OffPtr_22(HugsStackPtr);
static void hugsprim_writeInt8OffPtr_22(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsInt8 arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getInt8();
    writeInt8OffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef writeStablePtrOffPtr
#endif

static void hugsprim_writeStablePtrOffPtr_21(HugsStackPtr);
static void hugsprim_writeStablePtrOffPtr_21(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsStablePtr arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getStablePtr4();
    writeStablePtrOffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef writeDoubleOffPtr
#endif

static void hugsprim_writeDoubleOffPtr_20(HugsStackPtr);
static void hugsprim_writeDoubleOffPtr_20(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsDouble arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getDouble();
    writeDoubleOffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef writeFloatOffPtr
#endif

static void hugsprim_writeFloatOffPtr_19(HugsStackPtr);
static void hugsprim_writeFloatOffPtr_19(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsFloat arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getFloat();
    writeFloatOffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef writeFunPtrOffPtr
#endif

static void hugsprim_writeFunPtrOffPtr_18(HugsStackPtr);
static void hugsprim_writeFunPtrOffPtr_18(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsFunPtr arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getFunPtr();
    writeFunPtrOffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef writePtrOffPtr
#endif

static void hugsprim_writePtrOffPtr_17(HugsStackPtr);
static void hugsprim_writePtrOffPtr_17(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsPtr arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getPtr();
    writePtrOffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef writeCharOffPtr
#endif

static void hugsprim_writeCharOffPtr_16(HugsStackPtr);
static void hugsprim_writeCharOffPtr_16(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsChar arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getChar();
    writeCharOffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef writeIntOffPtr
#endif

static void hugsprim_writeIntOffPtr_15(HugsStackPtr);
static void hugsprim_writeIntOffPtr_15(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsInt arg3;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    arg3 = hugs->getInt();
    writeIntOffPtr(arg1, arg2, arg3);
    
    hugs->returnIO(hugs_root,0);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readWord64OffPtr
#endif

static void hugsprim_readWord64OffPtr_14(HugsStackPtr);
static void hugsprim_readWord64OffPtr_14(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsWord64 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readWord64OffPtr(arg1, arg2);
    hugs->putWord64(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readWord32OffPtr
#endif

static void hugsprim_readWord32OffPtr_13(HugsStackPtr);
static void hugsprim_readWord32OffPtr_13(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsWord32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readWord32OffPtr(arg1, arg2);
    hugs->putWord32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readWord16OffPtr
#endif

static void hugsprim_readWord16OffPtr_12(HugsStackPtr);
static void hugsprim_readWord16OffPtr_12(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsWord16 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readWord16OffPtr(arg1, arg2);
    hugs->putWord16(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readWord8OffPtr
#endif

static void hugsprim_readWord8OffPtr_11(HugsStackPtr);
static void hugsprim_readWord8OffPtr_11(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsWord8 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readWord8OffPtr(arg1, arg2);
    hugs->putWord8(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readInt64OffPtr
#endif

static void hugsprim_readInt64OffPtr_10(HugsStackPtr);
static void hugsprim_readInt64OffPtr_10(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsInt64 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readInt64OffPtr(arg1, arg2);
    hugs->putInt64(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readInt32OffPtr
#endif

static void hugsprim_readInt32OffPtr_9(HugsStackPtr);
static void hugsprim_readInt32OffPtr_9(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsInt32 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readInt32OffPtr(arg1, arg2);
    hugs->putInt32(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readInt16OffPtr
#endif

static void hugsprim_readInt16OffPtr_8(HugsStackPtr);
static void hugsprim_readInt16OffPtr_8(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsInt16 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readInt16OffPtr(arg1, arg2);
    hugs->putInt16(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readInt8OffPtr
#endif

static void hugsprim_readInt8OffPtr_7(HugsStackPtr);
static void hugsprim_readInt8OffPtr_7(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsInt8 res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readInt8OffPtr(arg1, arg2);
    hugs->putInt8(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readStablePtrOffPtr
#endif

static void hugsprim_readStablePtrOffPtr_6(HugsStackPtr);
static void hugsprim_readStablePtrOffPtr_6(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsStablePtr res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readStablePtrOffPtr(arg1, arg2);
    hugs->putStablePtr4(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readDoubleOffPtr
#endif

static void hugsprim_readDoubleOffPtr_5(HugsStackPtr);
static void hugsprim_readDoubleOffPtr_5(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsDouble res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readDoubleOffPtr(arg1, arg2);
    hugs->putDouble(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readFloatOffPtr
#endif

static void hugsprim_readFloatOffPtr_4(HugsStackPtr);
static void hugsprim_readFloatOffPtr_4(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsFloat res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readFloatOffPtr(arg1, arg2);
    hugs->putFloat(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readFunPtrOffPtr
#endif

static void hugsprim_readFunPtrOffPtr_3(HugsStackPtr);
static void hugsprim_readFunPtrOffPtr_3(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsFunPtr res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readFunPtrOffPtr(arg1, arg2);
    hugs->putFunPtr(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readPtrOffPtr
#endif

static void hugsprim_readPtrOffPtr_2(HugsStackPtr);
static void hugsprim_readPtrOffPtr_2(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsPtr res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readPtrOffPtr(arg1, arg2);
    hugs->putPtr(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readCharOffPtr
#endif

static void hugsprim_readCharOffPtr_1(HugsStackPtr);
static void hugsprim_readCharOffPtr_1(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsChar res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readCharOffPtr(arg1, arg2);
    hugs->putChar(res1);
    hugs->returnIO(hugs_root,1);
}

#ifndef ENABLE_MACRO_INTERFACE
#undef readIntOffPtr
#endif

static void hugsprim_readIntOffPtr_0(HugsStackPtr);
static void hugsprim_readIntOffPtr_0(HugsStackPtr hugs_root)
{
    HsPtr arg1;
    HsInt arg2;
    HsInt res1;
    arg1 = hugs->getPtr();
    arg2 = hugs->getInt();
    res1 = readIntOffPtr(arg1, arg2);
    hugs->putInt(res1);
    hugs->returnIO(hugs_root,1);
}

static struct hugs_primitive hugs_primTable[] = {
    {"writeWord64OffPtr", 4, hugsprim_writeWord64OffPtr_29},
    {"writeWord32OffPtr", 4, hugsprim_writeWord32OffPtr_28},
    {"writeWord16OffPtr", 4, hugsprim_writeWord16OffPtr_27},
    {"writeWord8OffPtr", 4, hugsprim_writeWord8OffPtr_26},
    {"writeInt64OffPtr", 4, hugsprim_writeInt64OffPtr_25},
    {"writeInt32OffPtr", 4, hugsprim_writeInt32OffPtr_24},
    {"writeInt16OffPtr", 4, hugsprim_writeInt16OffPtr_23},
    {"writeInt8OffPtr", 4, hugsprim_writeInt8OffPtr_22},
    {"writeStablePtrOffPtr", 4, hugsprim_writeStablePtrOffPtr_21},
    {"writeDoubleOffPtr", 4, hugsprim_writeDoubleOffPtr_20},
    {"writeFloatOffPtr", 4, hugsprim_writeFloatOffPtr_19},
    {"writeFunPtrOffPtr", 4, hugsprim_writeFunPtrOffPtr_18},
    {"writePtrOffPtr", 4, hugsprim_writePtrOffPtr_17},
    {"writeCharOffPtr", 4, hugsprim_writeCharOffPtr_16},
    {"writeIntOffPtr", 4, hugsprim_writeIntOffPtr_15},
    {"readWord64OffPtr", 3, hugsprim_readWord64OffPtr_14},
    {"readWord32OffPtr", 3, hugsprim_readWord32OffPtr_13},
    {"readWord16OffPtr", 3, hugsprim_readWord16OffPtr_12},
    {"readWord8OffPtr", 3, hugsprim_readWord8OffPtr_11},
    {"readInt64OffPtr", 3, hugsprim_readInt64OffPtr_10},
    {"readInt32OffPtr", 3, hugsprim_readInt32OffPtr_9},
    {"readInt16OffPtr", 3, hugsprim_readInt16OffPtr_8},
    {"readInt8OffPtr", 3, hugsprim_readInt8OffPtr_7},
    {"readStablePtrOffPtr", 3, hugsprim_readStablePtrOffPtr_6},
    {"readDoubleOffPtr", 3, hugsprim_readDoubleOffPtr_5},
    {"readFloatOffPtr", 3, hugsprim_readFloatOffPtr_4},
    {"readFunPtrOffPtr", 3, hugsprim_readFunPtrOffPtr_3},
    {"readPtrOffPtr", 3, hugsprim_readPtrOffPtr_2},
    {"readCharOffPtr", 3, hugsprim_readCharOffPtr_1},
    {"readIntOffPtr", 3, hugsprim_readIntOffPtr_0},
};

static void hugs_primControl(int);
static void hugs_primControl(what)
int what; {
}

#ifdef STATIC_LINKAGE
#define initModule initHStorable
#endif

static struct hugs_primInfo hugs_prims = { hugs_primControl, hugs_primTable, 0 };

#ifdef __cplusplus
extern "C" {
#endif
#ifndef __cplusplus
DLLEXPORT(int)  HugsAPIVersion(void);
#endif
DLLEXPORT(int)  HugsAPIVersion() {return (5);}
DLLEXPORT(void) initModule(HugsAPI5 *);
DLLEXPORT(void) initModule(HugsAPI5 *hugsAPI) {
    hugs = hugsAPI;
    hugs->registerPrims(&hugs_prims);
}
#ifdef __cplusplus
}
#endif

module Hugs.Storable where

import Hugs.Prelude
import Hugs.Ptr (castPtr)

{-# CFILES Hugs/Storable_aux.c #-}

foreign import ccall unsafe "Storable_aux.h" readIntOffPtr       :: Ptr Int           -> Int -> IO Int
foreign import ccall unsafe "Storable_aux.h" readCharOffPtr      :: Ptr Char          -> Int -> IO Char
foreign import ccall unsafe "Storable_aux.h" readPtrOffPtr       :: Ptr (Ptr a)       -> Int -> IO (Ptr a)
foreign import ccall unsafe "Storable_aux.h" readFunPtrOffPtr    :: Ptr (FunPtr a)    -> Int -> IO (FunPtr a)
foreign import ccall unsafe "Storable_aux.h" readFloatOffPtr     :: Ptr Float         -> Int -> IO Float
foreign import ccall unsafe "Storable_aux.h" readDoubleOffPtr    :: Ptr Double        -> Int -> IO Double
foreign import ccall unsafe "Storable_aux.h" readStablePtrOffPtr :: Ptr (StablePtr a) -> Int -> IO (StablePtr a)
foreign import ccall unsafe "Storable_aux.h" readInt8OffPtr      :: Ptr Int8          -> Int -> IO Int8
foreign import ccall unsafe "Storable_aux.h" readInt16OffPtr     :: Ptr Int16         -> Int -> IO Int16
foreign import ccall unsafe "Storable_aux.h" readInt32OffPtr     :: Ptr Int32         -> Int -> IO Int32
foreign import ccall unsafe "Storable_aux.h" readInt64OffPtr     :: Ptr Int64         -> Int -> IO Int64
foreign import ccall unsafe "Storable_aux.h" readWord8OffPtr     :: Ptr Word8         -> Int -> IO Word8
foreign import ccall unsafe "Storable_aux.h" readWord16OffPtr    :: Ptr Word16        -> Int -> IO Word16
foreign import ccall unsafe "Storable_aux.h" readWord32OffPtr    :: Ptr Word32        -> Int -> IO Word32
foreign import ccall unsafe "Storable_aux.h" readWord64OffPtr    :: Ptr Word64        -> Int -> IO Word64

foreign import ccall unsafe "Storable_aux.h" writeIntOffPtr       :: Ptr Int           -> Int -> Int         -> IO ()
foreign import ccall unsafe "Storable_aux.h" writeCharOffPtr      :: Ptr Char          -> Int -> Char        -> IO ()
foreign import ccall unsafe "Storable_aux.h" writePtrOffPtr       :: Ptr (Ptr a)       -> Int -> Ptr a       -> IO ()
foreign import ccall unsafe "Storable_aux.h" writeFunPtrOffPtr    :: Ptr (FunPtr a)    -> Int -> FunPtr a    -> IO ()
foreign import ccall unsafe "Storable_aux.h" writeFloatOffPtr     :: Ptr Float         -> Int -> Float       -> IO ()
foreign import ccall unsafe "Storable_aux.h" writeDoubleOffPtr    :: Ptr Double        -> Int -> Double      -> IO ()
foreign import ccall unsafe "Storable_aux.h" writeStablePtrOffPtr :: Ptr (StablePtr a) -> Int -> StablePtr a -> IO ()
foreign import ccall unsafe "Storable_aux.h" writeInt8OffPtr      :: Ptr Int8          -> Int -> Int8        -> IO ()
foreign import ccall unsafe "Storable_aux.h" writeInt16OffPtr     :: Ptr Int16         -> Int -> Int16       -> IO ()
foreign import ccall unsafe "Storable_aux.h" writeInt32OffPtr     :: Ptr Int32         -> Int -> Int32       -> IO ()
foreign import ccall unsafe "Storable_aux.h" writeInt64OffPtr     :: Ptr Int64         -> Int -> Int64       -> IO ()
foreign import ccall unsafe "Storable_aux.h" writeWord8OffPtr     :: Ptr Word8         -> Int -> Word8       -> IO ()
foreign import ccall unsafe "Storable_aux.h" writeWord16OffPtr    :: Ptr Word16        -> Int -> Word16      -> IO ()
foreign import ccall unsafe "Storable_aux.h" writeWord32OffPtr    :: Ptr Word32        -> Int -> Word32      -> IO ()
foreign import ccall unsafe "Storable_aux.h" writeWord64OffPtr    :: Ptr Word64        -> Int -> Word64      -> IO ()

-- Special treatment for Word:
-- it's not a foreign type, but we want an instance of Storable.

readWordOffPtr :: Ptr Word -> Int -> IO Word
readWordOffPtr p n = do
	i <- readIntOffPtr (castPtr p) n
	return (primIntToWord i)

writeWordOffPtr :: Ptr Word -> Int -> Word -> IO ()
writeWordOffPtr p n w = writeIntOffPtr (castPtr p) n (primWordToInt w)

primitive primIntToWord :: Int -> Word
primitive primWordToInt :: Word -> Int
 asm    dylinkÄá¿ L` ` ` ` |` }`| `} ` ``} `}`| `|` `  qenv
memoryBase env	tableBase envabort  envsetTempRet0  envgetTempRet0 envmemory Äenvtablep  32                                	
A A ‘A_HugsAPIVersion __post_instantiate 1_hugs_primControl _hugsprim_readCharOffPtr_1 "_hugsprim_readDoubleOffPtr_5 _hugsprim_readFloatOffPtr_4 _hugsprim_readFunPtrOffPtr_3  _hugsprim_readInt16OffPtr_8 _hugsprim_readInt32OffPtr_9 _hugsprim_readInt64OffPtr_10 _hugsprim_readInt8OffPtr_7 _hugsprim_readIntOffPtr_0 #_hugsprim_readPtrOffPtr_2 !_hugsprim_readStablePtrOffPtr_6 _hugsprim_readWord16OffPtr_12 _hugsprim_readWord32OffPtr_13 _hugsprim_readWord64OffPtr_14 _hugsprim_readWord8OffPtr_11 _hugsprim_writeCharOffPtr_16 _hugsprim_writeDoubleOffPtr_20 _hugsprim_writeFloatOffPtr_19 _hugsprim_writeFunPtrOffPtr_18 _hugsprim_writeInt16OffPtr_23 _hugsprim_writeInt32OffPtr_24 _hugsprim_writeInt64OffPtr_25 
_hugsprim_writeInt8OffPtr_22 _hugsprim_writeIntOffPtr_15 _hugsprim_writePtrOffPtr_17 !_hugsprim_writeStablePtrOffPtr_21 _hugsprim_writeWord16OffPtr_27 _hugsprim_writeWord32OffPtr_28 _hugsprim_writeWord64OffPtr_29 _hugsprim_writeWord8OffPtr_26 	_initModule _readCharOffPtr %_readDoubleOffPtr )_readFloatOffPtr 3_readFunPtrOffPtr %_readInt16OffPtr -_readInt32OffPtr %_readInt64OffPtr /_readInt8OffPtr +_readIntOffPtr %_readPtrOffPtr %_readStablePtrOffPtr %_readWord16OffPtr -_readWord32OffPtr %_readWord64OffPtr /_readWord8OffPtr +_writeCharOffPtr $_writeDoubleOffPtr (_writeFloatOffPtr 4_writeFunPtrOffPtr $_writeInt16OffPtr ,_writeInt32OffPtr $_writeInt64OffPtr ._writeInt8OffPtr *_writeIntOffPtr $_writePtrOffPtr $_writeStablePtrOffPtr $_writeWord16OffPtr ,_writeWord32OffPtr $_writeWord64OffPtr ._writeWord8OffPtr *runPostSets 0	& # 2	
 !"#
‡2 A # AÜ¿j  6 #   (∞   O # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( (@ .  A # AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( (< $  A # AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( (8 ,  A # AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( (4 *  A # AÜ¿j( († O # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( (0 .  A # AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( (, $  A # AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( (( ,  A # AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( ($ *  A # AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( (  $  A # AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( ( (  A # AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( ( &  A # AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( (H $  A # AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( (D $  A # AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( ( $  A # AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( # AÜ¿j( ( $  A # AÜ¿j( († P # AÜ¿j( (D # AÜ¿j( ( /# AÜ¿j( (å   A# AÜ¿j( († N # AÜ¿j( (D # AÜ¿j( ( %# AÜ¿j( (à    A# AÜ¿j( († N # AÜ¿j( (D # AÜ¿j( ( -# AÜ¿j( (Ñ    A# AÜ¿j( († N # AÜ¿j( (D # AÜ¿j( ( +# AÜ¿j( (Ä    A# AÜ¿j( († O # AÜ¿j( (D # AÜ¿j( ( /# AÜ¿j( (|   A# AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( %# AÜ¿j( (x    A# AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( -# AÜ¿j( (t    A# AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( +# AÜ¿j( (p    A# AÜ¿j( († N # AÜ¿j( (D # AÜ¿j( ( %# AÜ¿j( (ú    A# AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( )# AÜ¿j( (d   A# AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( '# AÜ¿j( (`   A# AÜ¿j( († N # AÜ¿j( (D # AÜ¿j( ( %# AÜ¿j( (î    A# AÜ¿j( († N # AÜ¿j( (D # AÜ¿j( ( %# AÜ¿j( (ê    A# AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( %# AÜ¿j( (h    A# AÜ¿j( († M # AÜ¿j( (D # AÜ¿j( ( %# AÜ¿j( (T    A# AÜ¿j( (†     Atj 6     Atj(     Atj 8     Atj*     Atj 9     Atj+     j :  
    j,      Atj ;     Atj.    Atj" 6   6    Atj" ( !  ( É # #Aj6 # # (# Ajj6# # (# AÙjj6# #Aj6# # (# AÜjj6# #Aj6 # # ($# Aòjj6$# #Aj6,# # (0# A™jj60# #Aj68# # (<# Aªjj6<# #Aj6D# # (H# AÃjj6H# #Aj6P# # (T# A›jj6T# #Aj6\# # (`# AÓjj6`# #A	j6h# # (l# A˛jj6l# #A
j6t# # (x# Aìjj6x# #Aj6Ä# # (Ñ# A•jj6Ñ# #Aj6å# # (ê# A∂jj6ê# #Aj6ò# # (ú# A»jj6ú# #Aj6§# # (®# A◊jj6®# #Aj6∞# # (¥# AÁjj6¥# #Aj6º# # (¿# Aˆjj6¿# #Aj6»# # (Ã# Aájj6Ã# #Aj6‘# # (ÿ# Aòjj6ÿ# #Aj6‡# # (‰# A©jj6‰# #Aj6Ï# # (# Aπjj6# #Aj6¯# # (¸# A…jj6¸# #Aj6Ñ# # (à# AŸjj6à# #Aj6ê# # (î# AÈjj6î# #Aj6ú# # (†# A¯jj6†# #Aj6®# # (¨# Aåjj6¨# #Aj6¥# # (∏# Aùjj6∏# #Aj6¿# # (ƒ# A≠jj6ƒ# #Aj6Ã# # (–# Aæjj6–# #Aj6ÿ# # (‹# AÃjj6‹# #Aj6‰# # (Ë# A€jj6Ë# #Aj6 # Aj$#AÄÄ¿j$0 A  D        	    'ª     ∂&Ô # Ë                                                                                                                                                                                                                                                                                                                                                      writeWord64OffPtr writeWord32OffPtr writeWord16OffPtr writeWord8OffPtr writeInt64OffPtr writeInt32OffPtr writeInt16OffPtr writeInt8OffPtr writeStablePtrOffPtr writeDoubleOffPtr writeFloatOffPtr writeFunPtrOffPtr writePtrOffPtr writeCharOffPtr writeIntOffPtr readWord64OffPtr readWord32OffPtr readWord16OffPtr readWord8OffPtr readInt64OffPtr readInt32OffPtr readInt16OffPtr readInt8OffPtr readStablePtrOffPtr readDoubleOffPtr readFloatOffPtr readFunPtrOffPtr readPtrOffPtr readCharOffPtr readIntOffPtr-----------------------------------------------------------------------------
-- Standard Library: System operations
--
-- Note: on Windows 9x, system always yields ExitSuccess.
--
-- Suitable for use with Hugs 98
-----------------------------------------------------------------------------

module Hugs.System (
	getArgs, getProgName, withArgs, withProgName, getEnv,
	system
	) where

import Hugs.Prelude( ExitCode(..), catchException, throw )

-- In interpretive mode, the initial values of these two are [] and "Hugs",
-- but they can be (temporarily) changed using withArgs and withProgName.
primitive getArgs     "primGetArgs"     :: IO [String]
primitive getProgName "primGetProgName" :: IO String

primitive setArgs     "primSetArgs"     :: [String] -> IO ()
primitive setProgName "primSetProgName" :: String -> IO ()

-- Run an action with a value temporarily overridden
-- (a special case of Control.Exception.bracket)
with :: IO a -> (a -> IO ()) -> a -> IO b -> IO b
with getVal setVal newVal act = do
    oldVal <- getVal
    setVal newVal
    r <- act `catchException` \e -> setVal oldVal >> throw e
    setVal oldVal
    return r

withArgs :: [String] -> IO a -> IO a
withArgs = with getArgs setArgs

withProgName :: String -> IO a -> IO a
withProgName = with getProgName setProgName

primitive getEnv            :: String -> IO String

system                      :: String -> IO ExitCode
system s                     = do r <- primSystem s
                                  return (toExitCode r)

primitive primSystem        :: String -> IO Int

toExitCode                  :: Int -> ExitCode
toExitCode 0                 = ExitSuccess
toExitCode n                 = ExitFailure n

-----------------------------------------------------------------------------
--
-- Time primitives for Hugs98.
--
module Hugs.Time
	( getClockTimePrim
	, toCalTimePrim
	, toClockTimePrim

	, getCPUTime		-- :: IO Integer
	, clockTicks		-- :: Int
	) where

primitive getClockTimePrim :: IO (Int,Int)
primitive toCalTimePrim ::
	Int -> Int -> IO (Int,Int,Int,Int,Int,Int,Int,Int,Int,String,Int)
primitive toClockTimePrim ::
	Int -> Int -> Int -> Int -> Int -> Int -> Int -> IO Int

picoSec :: Integer
picoSec = 1000000000000 -- 10^12

getCPUTime :: IO Integer
getCPUTime = do
   (usec, unsec, ssec, snsec) <- getCPUUsage
   return (picoSec * fromIntegral usec  +
   	   1000    * fromIntegral unsec + 
	   picoSec * fromIntegral ssec  + 
	   1000    * fromIntegral snsec)
	   
primitive getCPUUsage  :: IO (Int,Int,Int,Int)
primitive clockTicks   :: Int
-----------------------------------------------------------------------------
-- Trex utilities:  Functions to compare and show record values
--
-- Warning: This file is an integral part of the TREX implementation, and
-- should not be modified without corresponding changes in the interpreter.
--
-- Suitable for use with Hugs 98, if compiled with TREX support.
-----------------------------------------------------------------------------

module Hugs.Trex( Rec, emptyRec, EmptyRow,
	ShowRecRow(..), EqRecRow(..), insertField ) where

import Hugs.Prelude ( Rec, emptyRec, EmptyRow )

-- Code for equalities:

instance EqRecRow r => Eq (Rec r) where
  r == s = eqFields (eqRecRow r s)
           where eqFields = and . map snd

class EqRecRow r where
  eqRecRow :: Rec r -> Rec r -> [(String,Bool)]

instance EqRecRow EmptyRow where
  eqRecRow _ _ = []


-- Code for showing values:

instance ShowRecRow r => Show (Rec r) where
  showsPrec d = showFields . showRecRow
   where
    showFields   :: [(String, ShowS)] -> ShowS
    showFields [] = showString "emptyRec"
    showFields xs = showChar '(' . foldr1 comma (map fld xs) . showChar ')'
     where comma a b = a . showString ", " . b
           fld (s,v) = showString s . showString " = " . v

class ShowRecRow r where
  showRecRow :: Rec r -> [(String, ShowS)]

instance ShowRecRow EmptyRow where
  showRecRow _ = []


-- General utility:

insertField       :: String -> v -> [(String, v)] -> [(String, v)]
insertField n v fs = {- case fs of
                       []     -> [(n,v)]
                       (r:rs) -> if n <= fst r
                                   then (n,v):fs
                                   else r : insertField n v rs -}
                     bef ++ [(n,v)] ++ aft
 where (bef,aft) = span (\r -> n > fst r) fs

-----------------------------------------------------------------------------

-- A first cut at implementing the (key,value) form of Weak pointers.
--
-- Notes (please refer to the draft specification for background):
--
--  - Programmers using weak pointers should call runFinalizer at
--    regular intervals to ensure that finalizers are scheduled for
--    execution.  This implementation provides functions runFinalizer,
--    finalizerWaiting, and runAllFinalizers to provide programmers with
--    control over the execution of finalizers.  None of these functions
--    are part of the current specification.
--
-- Tested with Hugs 98.

module Hugs.Weak(Weak,
	    mkWeak, deRefWeak, finalize, replaceFinalizer,
	    runFinalizer, finalizerWaiting, runAllFinalizers ) where

data Weak a

primitive mkWeak    :: k -> v -> Maybe (IO ()) -> IO (Weak v)
primitive deRefWeak :: Weak v -> IO (Maybe v)
primitive replaceFinalizer :: Weak v -> Maybe (IO ()) -> IO (Maybe (IO ()))
primitive finalize  :: Weak v -> IO ()
primitive weakPtrEq :: Weak a -> Weak a -> Bool

instance Eq (Weak a) where
  (==) = weakPtrEq

primitive runFinalizer     :: IO ()
primitive finalizerWaiting :: IO Bool

runAllFinalizers    :: IO ()
runAllFinalizers     = do waiting <- finalizerWaiting
			  if waiting then do runFinalizer
					     runAllFinalizers
				     else return ()

{- for testing purposes
primitive gc "primGC" :: IO ()

-- not a CAF!
test z = do
  { let k = [z]		-- use a list so we're sure it's heap allocated
  ; print k		-- this makes sure x is in whnf
  ; w <- mkWeak k "value" (Just (putStrLn ("Finalizer for "++show k)))
			-- note that the finalizer uses the key, but
			-- this shouldn't keep the weak ptr alive!
  ; showWeakPtr w
  ; gc
  ; print k		-- this makes sure k is still alive after the GC
  ; showWeakPtr w	-- so it's probably still alive here
  ; gc
  ; showWeakPtr w	-- but ought to be dead by here
  }

showWeakPtr :: Show a => Weak a -> IO ()
showWeakPtr w = do
  { x <- deRefWeak w
  ; print x
  }

-}

-- End of module Weak
-----------------------------------------------------------------------------
-- Unsigned Integers
-- Suitable for use with Hugs 98 on 32 bit systems.
-----------------------------------------------------------------------------
module Hugs.Word
	( Word
	, Word8
	, Word16
	, Word32
	, Word64
	) where

import Hugs.Prelude ( Word, Word8, Word16, Word32, Word64,
                      boundedSucc, boundedPred,
		      boundedEnumFrom, boundedEnumFromTo,
		      boundedEnumFromThen, boundedEnumFromThenTo )
import Hugs.Prelude ( Ix(..) )
import Hugs.Prelude ( (%) )
import Hugs.Prelude ( readDec )
import Hugs.Prelude ( Num(fromInt), Integral(toInt) )
import Hugs.Numeric ( showInt )
import Data.Bits
import Data.Int

-----------------------------------------------------------------------------
-- Word
-----------------------------------------------------------------------------

instance Eq  Word     where (==)    = primEqWord
instance Ord Word     where compare = primCmpWord

instance Num Word where
    (+)           = primPlusWord
    (-)           = primMinusWord
    negate        = primNegateWord
    (*)           = primMulWord
    abs           = absReal
    signum        = signumReal
    fromInteger   = primIntegerToWord
    fromInt       = primIntToWord

instance Bounded Word where
    minBound = 0
    maxBound = primMaxWord

instance Real Word where
    toRational x = toInteger x % 1

instance Integral Word where
    div       = primDivWord
    quot      = primQuotWord
    rem       = primRemWord
    mod       = primModWord
    quotRem   = primQrmWord
    divMod    = quotRem
    toInteger = primWordToInteger
    toInt     = primWordToInt

instance Ix Word where
    range (m,n)          = [m..n]
    unsafeIndex (m,_) i  = toInt (i - m)
    inRange (m,n) i      = m <= i && i <= n

instance Enum Word where
    succ           = boundedSucc
    pred           = boundedPred
    toEnum         = primIntToWord
    fromEnum       = primWordToInt

    enumFrom       = boundedEnumFrom
    enumFromTo     = boundedEnumFromTo
    enumFromThen   = boundedEnumFromThen
    enumFromThenTo = boundedEnumFromThenTo

instance Read Word where
    readsPrec p   = readDec

instance Show Word where
    showsPrec p   = showInt  -- a particularily counterintuitive name!

instance Bits Word where
    (.&.)         = primAndWord
    (.|.)         = primOrWord
    xor           = primXorWord
    complement    = primComplementWord
    shift         = primShiftWord
    rotate        = primRotateWord (bitSize (0::Word))
    bit           = primBitWord
    setBit x i    = x .|. bit i
    clearBit x i  = x .&. complement (bit i)
    complementBit x i = x `xor` bit i
    testBit       = primTestWord
    bitSize  _    = bitSize (0::Int)
    isSigned _    = False

-----------------------------------------------------------------------------
-- Word8
-----------------------------------------------------------------------------

instance Eq  Word8     where (==)    = binop (==)
instance Ord Word8     where compare = binop compare

instance Num Word8 where
    x + y         = to (binop (+) x y)
    x - y         = to (binop (-) x y)
    negate        = to . negate . from
    x * y         = to (binop (*) x y)
    abs           = absReal
    signum        = signumReal
    fromInteger   = to . primIntegerToWord
    fromInt       = to . primIntToWord

instance Bounded Word8 where
    minBound = 0
    maxBound = 0xff

instance Real Word8 where
    toRational x = toInteger x % 1

instance Integral Word8 where
    x `div` y     = to  (binop div x y)
    x `quot` y    = to  (binop quot x y)
    x `rem` y     = to  (binop rem x y)
    x `mod` y     = to  (binop mod x y)
    x `quotRem` y = to2 (binop quotRem x y)
    divMod        = quotRem
    toInteger     = toInteger . from
    toInt         = toInt . from

instance Ix Word8 where
    range (m,n)          = [m..n]
    unsafeIndex (m,_) i  = toInt (i - m)
    inRange (m,n) i      = m <= i && i <= n

instance Enum Word8 where
    succ          = boundedSucc
    pred          = boundedPred
    toEnum        = fromInt
    fromEnum      = toInt
    enumFrom      = boundedEnumFrom
    enumFromThen  = boundedEnumFromThen

instance Read Word8 where
    readsPrec p   = readDec

instance Show Word8 where
    showsPrec p   = showInt  -- a particularily counterintuitive name!

instance Bits Word8 where
    x .&. y       = to (binop (.&.) x y)
    x .|. y       = to (binop (.|.) x y)
    x `xor` y     = to (binop xor x y)
    complement    = to . complement . from
    x `shift` i   = to (from x `shift` i)
    x `rotate` i  = to (from x `rot` i)
      where rot = primRotateWord 8
    bit           = to . bit
    setBit x i    = to (setBit (from x) i)
    clearBit x i  = to (clearBit (from x) i)
    complementBit x i = to (complementBit (from x) i)
    testBit x i   = testBit (from x) i
    bitSize  _    = 8
    isSigned _    = False

-----------------------------------------------------------------------------
-- Word16
-----------------------------------------------------------------------------

instance Eq  Word16     where (==)    = binop (==)
instance Ord Word16     where compare = binop compare

instance Num Word16 where
    x + y         = to (binop (+) x y)
    x - y         = to (binop (-) x y)
    negate        = to . negate . from
    x * y         = to (binop (*) x y)
    abs           = absReal
    signum        = signumReal
    fromInteger   = to . primIntegerToWord
    fromInt       = to . primIntToWord

instance Bounded Word16 where
    minBound = 0
    maxBound = 0xffff

instance Real Word16 where
    toRational x  = toInteger x % 1

instance Integral Word16 where
    x `div` y     = to  (binop div x y)
    x `quot` y    = to  (binop quot x y)
    x `rem` y     = to  (binop rem x y)
    x `mod` y     = to  (binop mod x y)
    x `quotRem` y = to2 (binop quotRem x y)
    divMod        = quotRem
    toInteger     = toInteger . from
    toInt         = toInt . from

instance Ix Word16 where
    range (m,n)          = [m..n]
    unsafeIndex (m,_) i  = toInt (i - m)
    inRange (m,n) i      = m <= i && i <= n

instance Enum Word16 where
    succ          = boundedSucc
    pred          = boundedPred
    toEnum        = fromInt
    fromEnum      = toInt
    enumFrom      = boundedEnumFrom
    enumFromThen  = boundedEnumFromThen

instance Read Word16 where
    readsPrec p   = readDec

instance Show Word16 where
    showsPrec p   = showInt  -- a particularily counterintuitive name!

instance Bits Word16 where
    x .&. y       = to (binop (.&.) x y)
    x .|. y       = to (binop (.|.) x y)
    x `xor` y     = to (binop xor x y)
    complement    = to . complement . from
    x `shift` i   = to (from x `shift` i)
    x `rotate` i  = to (from x `rot` i)
      where rot = primRotateWord 16
    bit           = to . bit
    setBit x i    = to (setBit (from x) i)
    clearBit x i  = to (clearBit (from x) i)
    complementBit x i = to (complementBit (from x) i)
    testBit x i   = testBit (from x) i
    bitSize  _    = 16
    isSigned _    = False

-----------------------------------------------------------------------------
-- Word32
-----------------------------------------------------------------------------

instance Eq  Word32     where (==)    = binop (==)
instance Ord Word32     where compare = binop compare

instance Num Word32 where
    x + y         = to (binop (+) x y)
    x - y         = to (binop (-) x y)
    negate        = to . negate . from
    x * y         = to (binop (*) x y)
    abs           = absReal
    signum        = signumReal
    fromInteger   = to . primIntegerToWord
    fromInt       = to . primIntToWord

instance Bounded Word32 where
    minBound = 0
    maxBound = 0xffffffff

instance Real Word32 where
    toRational x  = toInteger x % 1

instance Integral Word32 where
    x `div` y     = to  (binop div x y)
    x `quot` y    = to  (binop quot x y)
    x `rem` y     = to  (binop rem x y)
    x `mod` y     = to  (binop mod x y)
    x `quotRem` y = to2 (binop quotRem x y)
    divMod        = quotRem
    toInteger     = toInteger . from
    toInt         = toInt . from

instance Ix Word32 where
    range (m,n)          = [m..n]
    unsafeIndex (m,_) i  = toInt (i - m)
    inRange (m,n) i      = m <= i && i <= n

instance Enum Word32 where
    succ          = boundedSucc
    pred          = boundedPred
    toEnum        = fromInt
    fromEnum      = toInt
    enumFrom      = boundedEnumFrom
    enumFromThen  = boundedEnumFromThen
    enumFromTo    = boundedEnumFromTo
    enumFromThenTo = boundedEnumFromThenTo

instance Read Word32 where
    readsPrec p   = readDec

instance Show Word32 where
    showsPrec p   = showInt  -- a particularily counterintuitive name!

instance Bits Word32 where
    x .&. y       = to (binop (.&.) x y)
    x .|. y       = to (binop (.|.) x y)
    x `xor` y     = to (binop xor x y)
    complement    = to . complement . from
    x `shift` i   = to (from x `shift` i)
    x `rotate` i  = to (from x `rot` i)
      where rot = primRotateWord 32
    bit           = to . bit
    setBit x i    = to (setBit (from x) i)
    clearBit x i  = to (clearBit (from x) i)
    complementBit x i = to (complementBit (from x) i)
    testBit x i   = testBit (from x) i
    bitSize  _    = 32
    isSigned _    = False

-----------------------------------------------------------------------------
-- Word64
-----------------------------------------------------------------------------

primitive word64ToWord32 "primWord64ToWord32" :: Word64 -> (Word32,Word32)
primitive word32ToWord64 "primWord32ToWord64" :: Word32 -> Word32 -> Word64

integerToW64 :: Integer -> Word64
integerToW64 x = case x `divMod` 0x100000000 of
	(hi,lo) -> word32ToWord64 (fromInteger hi) (fromInteger lo)

w64ToInteger :: Word64 -> Integer
w64ToInteger x = case word64ToWord32 x of
	(hi,lo) -> toInteger hi * 0x100000000 + toInteger lo

instance Eq Word64 where
    x == y = word64ToWord32 x == word64ToWord32 y

instance Ord Word64 where
    compare x y = compare (word64ToWord32 x) (word64ToWord32 y)

instance Bounded Word64 where
    minBound = word32ToWord64 minBound minBound
    maxBound = word32ToWord64 maxBound maxBound

instance Show Word64 where
    showsPrec p = showInt . toInteger

instance Read Word64 where
    readsPrec p s = [ (fromInteger x,r) | (x,r) <- readDec s ]

instance Num Word64 where
    x + y         = fromInteger (toInteger x + toInteger y)
    x - y         = fromInteger (toInteger x - toInteger y)
    x * y         = fromInteger (toInteger x * toInteger y)
    abs           = absReal
    signum        = signumReal
    fromInteger   = integerToW64

instance Real Word64 where
    toRational x = toInteger x % 1

instance Ix Word64 where
    range (m,n)          = [m..n]
    unsafeIndex (m,_) i  = toInt (i - m)
    inRange (m,n) i      = m <= i && i <= n

instance Enum Word64 where
    succ             = boundedSucc
    pred             = boundedPred
    toEnum           = fromInt
    fromEnum         = toInt

    enumFrom x       = enumFromTo x maxBound
    enumFromTo x y   = map fromInteger [toInteger x .. toInteger y]
    enumFromThen     = boundedEnumFromThen
    enumFromThenTo x y z =
                       map fromInteger [toInteger x, toInteger y .. toInteger z]

instance Integral Word64 where
    x `quotRem` y = (fromInteger q, fromInteger r)
	where (q,r) = toInteger x `quotRem` toInteger y
    toInteger     = w64ToInteger

instance Bits Word64 where
    x .&. y       = liftBinary (.&.) x y
    x .|. y       = liftBinary (.|.) x y
    x `xor` y     = liftBinary xor x y
    complement    = liftUnary complement
    x `shift` i   = fromInteger ((toInteger x `shift` i) `mod`
				 0x10000000000000000)
    x `rotate` i  | i<0  = (x `shift` i) .|. (x `shift` (i+bitSize x))
		  | i==0 = x
		  | i>0  = (x `shift` i) .|. (x `shift` (i-bitSize x))
    bit i | i `mod` 64 < 32 = word32ToWord64 0 (bit i)
          | otherwise       = word32ToWord64 (bit i) 0
    bitSize  _    = 64
    isSigned _    = False

liftBinary :: (Word32 -> Word32 -> Word32) -> Word64 -> Word64 -> Word64
liftBinary op x y = word32ToWord64 (op xhi yhi) (op xlo ylo)
	where	(xhi,xlo) = word64ToWord32 x
		(yhi,ylo) = word64ToWord32 y

liftUnary :: (Word32 -> Word32) -> Word64 -> Word64
liftUnary op x = word32ToWord64 (op xhi) (op xlo)
	where	(xhi,xlo) = word64ToWord32 x

-----------------------------------------------------------------------------
-- End of exported definitions
--
-- The remainder of this file consists of definitions which are only
-- used in the implementation.
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Coercions - used to make the instance declarations more uniform
-----------------------------------------------------------------------------

primitive word8ToWord "primWord8ToWord" :: Word8  -> Word
primitive wordToWord8 "primWordToWord8" :: Word -> Word8

primitive word16ToWord "primWord16ToWord" :: Word16 -> Word
primitive wordToWord16 "primWordToWord16" :: Word -> Word16

primitive word32ToWord "primWord32ToWord" :: Word32 -> Word
primitive wordToWord32 "primWordToWord32" :: Word -> Word32

class Coerce a where
    to   :: Word -> a
    from :: a -> Word

instance Coerce Word8 where
    from = word8ToWord
    to   = wordToWord8

instance Coerce Word16 where
    from = word16ToWord
    to   = wordToWord16

instance Coerce Word32 where
    from = word32ToWord
    to   = wordToWord32

binop :: Coerce word => (Word -> Word -> a) -> (word -> word -> a)
binop op x y = from x `op` from y

to2 :: Coerce word => (Word, Word) -> (word, word)
to2 (x,y) = (to x, to y)

-----------------------------------------------------------------------------
-- primitives
-----------------------------------------------------------------------------

primitive primEqWord        :: Word -> Word -> Bool
primitive primCmpWord       :: Word -> Word -> Ordering
primitive primPlusWord,
	  primMinusWord,
	  primMulWord	    :: Word -> Word -> Word
primitive primNegateWord    :: Word -> Word
primitive primIntToWord     :: Int -> Word
primitive primIntegerToWord :: Integer -> Word
primitive primMaxWord       :: Word
primitive primDivWord,
	  primQuotWord,
	  primRemWord,
	  primModWord       :: Word -> Word -> Word
primitive primQrmWord       :: Word -> Word -> (Word,Word)
primitive primWordToInt     :: Word -> Int
primitive primWordToInteger :: Word -> Integer
primitive primAndWord       :: Word -> Word -> Word
primitive primOrWord        :: Word -> Word -> Word
primitive primXorWord       :: Word -> Word -> Word
primitive primComplementWord:: Word -> Word
primitive primShiftWord     :: Word -> Int -> Word
primitive primRotateWord    :: Int -> Word -> Int -> Word
primitive primBitWord       :: Int -> Word
primitive primTestWord      :: Word -> Int -> Bool

-----------------------------------------------------------------------------
-- Code copied from the Prelude
-----------------------------------------------------------------------------

absReal x    | x >= 0    = x
	     | otherwise = -x

signumReal x | x == 0    =  0
	     | x > 0     =  1
	     | otherwise = -1

-----------------------------------------------------------------------------
-- End
-----------------------------------------------------------------------------
# This file has been generated by travis-meta-yaml 0.2.0.0
# see https://github.com/phadej/travis-meta-yaml
sudo: false
language: c
before_install:
- export PATH=/opt/ghc/$GHCVER/bin:$PATH
- if [ -n "$CABALVER" ]; then export PATH=/opt/cabal/$CABALVER/bin:$PATH; fi
- if [ -n "$HAPPYVER" ]; then export PATH=/opt/happy/$HAPPYVER/bin:$PATH; fi
- if [ -n "$ALEXVER" ]; then export PATH=/opt/alex/$ALEXVER/bin:$PATH; fi
- export PATH=~/.local/bin:$PATH
- if [ ! -e ~/.local/bin/stack ]; then mkdir -p ~/.local/bin; travis_retry curl -L
  https://github.com/commercialhaskell/stack/releases/download/v0.1.5.0/stack-0.1.5.0-x86_64-linux.tar.gz
  | tar xz --strip-components=1 -C ~/.local/bin; fi
- echo "$(ghc --version) [$(ghc --print-project-git-commit-id 2> /dev/null || echo
  '?')]"
- stack +RTS -N2 -RTS --version
install:
- if [ "$STACK_SOLVER" = "YES" ]; then rm -f stack.yaml; stack update; stack init
  --solver; fi; stack --no-terminal --skip-ghc-check list-dependencies|sort > installplan.txt;
  cat installplan.txt; stack --no-terminal --skip-ghc-check setup; if diff -u $HOME/.stack-work-cache/installplan.txt
  installplan.txt; then echo "cabal build-cache HIT"; rm -rf .stack-work; cp -a $HOME/.stack-work-cache
  .stack-work; rm -f .stack-work/installplan.txt; else echo "cabal build-cache MISS";
  rm -rf $HOME/.stack-work-cache; stack --no-terminal --skip-ghc-check build --test
  --only-dependencies; fi; if [ ! -d $HOME/.stack-work-cache ]; then echo "snapshotting
  package-db to build-cache"; cp -a .stack-work $HOME/.stack-work-cache; cp -a installplan.txt
  $HOME/.stack-work-cache/installplan.txt; fi;
script:
- stack --no-terminal --skip-ghc-check build --test
- stack --no-terminal --skip-ghc-check sdist
matrix:
  fast_finish: true
  include:
  - env: GHCVER=7.8.4 CABALVER=1.18 HAPPYVER=1.19.5 ALEXVER=3.1.4 STACK_SOLVER=YES
    addons:
      apt:
        sources:
        - hvr-ghc
        packages:
        - ghc-7.8.4
        - cabal-install-1.18
        - libgmp-dev
        - happy-1.19.5
        - alex-3.1.4
    compiler: ! ': # ghc-7.8.4  YES'
  - env: GHCVER=7.10.2 CABALVER=1.22 HAPPYVER=1.19.5 ALEXVER=3.1.4 STACK_SOLVER=YES
    addons:
      apt:
        sources:
        - hvr-ghc
        packages:
        - ghc-7.10.2
        - cabal-install-1.22
        - libgmp-dev
        - happy-1.19.5
        - alex-3.1.4
    compiler: ! ': # ghc-7.10.2  YES'
branches:
  only:
  - master
cache:
  directories:
  - ~/.stack
  - ~/.local
  - ~/.stack-work-cache
  apt: true
## 0.1.0

* First release
Copyright (c) 2015 Junji Hashimoto

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# th-cas : Compile-time CAS(Computer Algebra System)

[![Hackage version](https://img.shields.io/hackage/v/th-cas.svg?style=flat)](https://hackage.haskell.org/package/th-cas)  [![Build Status](https://travis-ci.org/junjihashimoto/th-cas.png?branch=master)](https://travis-ci.org/junjihashimoto/th-cas)

CAS(Computer Algebra System) operations like diff are done at compile-time.
Compile time operations is done in TemplateHaskell.

## Interactive Usage

```th-cas``` supports interactive usage like mathematica.
To start repl, type "stack ghci".

Variables are defined by ```V``` of data-constructor.

A example of intertative usage is below.

```
$ stack ghci
...
*Algebra.CAS> 
*Algebra.CAS> let x = V "x" 
*Algebra.CAS> let y = V "y" 
*Algebra.CAS> x^2 + 2*x + x^2
2*x + 2*(x^2)
*Algebra.CAS> diff (x^2 + 2*x + x^2) x
2 + 4*x
*Algebra.CAS> linsolve [x+y=:2,x-y=:3]
Just [(x,5/2),(y,-1/2)]
*Algebra.CAS> subst [(x,1)] $ diff (x^2 + 2*x + x^2) x
6
```

## Usage at compile time

Write ```diff function var``` with Quotes of TemplateHaskell.
```diff``` makes a diffirential of the function at compile-time.
So there is no overhead at execution-time.

A example is below.

Write following code with quotes.

```
import Algebra.CAS.TH

myfunc :: Int -> Int
myfunc x = $(diff [|x*x+2*x+1|] [|x|])
```

At compile time, the quotes is translated to ```2*x+2```.

```
import Algebra.CAS.TH

myfunc :: Int -> Int
myfunc x = 2*x+2
```
# For more information, see: https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md

# Specifies the GHC version and set of packages available (e.g., lts-3.5, nightly-2015-09-21, ghc-7.10.2)
resolver: lts-9.0

# Local packages, usually specified by relative directory name
packages:
- '.'

# Packages to be pulled from upstream that are not in the resolver (e.g., acme-missiles-0.3)
extra-deps:
- find-conduit-0.4.4

# Override default flag values for local packages and extra-deps
#flags:
#  yesod-raml-docs:
#    utils: true

# Control whether we use the GHC we find on the path
# system-ghc: true

# Require a specific version of stack, using version ranges
# require-stack-version: -any # Default
# require-stack-version: >= 0.1.4.0

# Override the architecture used by stack, especially useful on Windows
# arch: i386
# arch: x86_64

# Extra directories used by stack for building
# extra-include-dirs: [/path/to/dir]
# extra-lib-dirs: [/path/to/dir]
name:                th-cas
version:             0.2.0
synopsis:            Compile-time CAS(Computer Algebra System)
description:         Compile-time CAS(Computer Algebra System)
homepage:            https://github.com/junjihashimoto/th-cas
license:             MIT
license-file:        LICENSE
author:              Junji Hashimoto
maintainer:          junji.hashimoto@gmail.com
-- copyright:           
category:            Math, Numeric
build-type:          Simple
cabal-version:       >=1.18
extra-source-files:  ChangeLog.md
                   , README.md


bug-reports:         https://github.com/junjihashimoto/th-cas/issues

source-repository head
  type:     git
  location: https://github.com/junjihashimoto/th-cas

library
  -- hs-source-dirs:      src
  exposed-modules:     Algebra.CAS
                     , Algebra.CAS.Base
                     , Algebra.CAS.Diff
                     , Algebra.CAS.GrobnerBasis
                     , Algebra.CAS.Integrate
                     , Algebra.CAS.Solve
                     , Algebra.CAS.TH
  build-depends:       base == 4.*
                     , template-haskell
                     , text
                     , containers
  ghc-options:         -Wall
  default-language:    Haskell2010

-- executable haskell-cas
--   hs-source-dirs:      app
--   main-is:             Main.hs
--   ghc-options:         -Wall
--   build-depends:       base
--                      , haskell-cas
--   default-language:    Haskell2010

test-suite spec
  type:                exitcode-stdio-1.0
  hs-source-dirs:      test
  main-is:             Spec.hs
  other-modules:       Algebra.CAS.THSpec
                     , Algebra.CAS.BasicSpec
                     , Algebra.CAS.DiffSpec
                     , Algebra.CAS.SolveSpec
                     , Algebra.CAS.GrobnerBasisSpec
  build-depends:       base
                     , th-cas
                     , hspec
                     , template-haskell
  ghc-options:         -Wall
  default-language:    Haskell2010

test-suite doctests
  type:            exitcode-stdio-1.0
  hs-source-dirs:  test
  main-is:         doctests.hs
  ghc-options:     -Wall -threaded
  build-depends:   base,
                   doctest
ref: refs/heads/master
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = git@github.com:junjihashimoto/th-cas.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
	remote = origin
	merge = refs/heads/master
Unnamed repository; edit this file 'description' to name the repository.
DIRC      Z.”—ŸÀîZ.”—ŸÀî    È  Å§  Ë  Ë  	«¬›2Õ"9Å“”q ¡]qÉsõ[ .travis.yml       Z.”—MÿÙZ.”—MÿÙ    Î  Å§  Ë  Ë  6"¡3ÜNæù¡ëÇcˇwº'-1⁄ › Algebra/CAS.hs    Z.”—‘Õ Z.”—‘Õ     Ì  Å§  Ë  Ë  æJ˜:L)ááË4˜£HÀ˜Ç˙â¥ Algebra/CAS/Base.hs       Z.”—T¨Z.”—T¨    Ó  Å§  Ë  Ë  R®IR%µ“ıA£§J¡gOx<§‹F
 Algebra/CAS/Diff.hs       Z.”—qq∏Z.”—qq∏    Ô  Å§  Ë  Ë  øÎü?N∏Bócd±9-5d>©≈ Algebra/CAS/GrobnerBasis.hs       Z.”—ŒzËZ.”—ŒzË      Å§  Ë  Ë  r´òi'˚Ìr⁄˘∂≤záä◊ Algebra/CAS/Integrate.hs  Z.”—9_\Z.”—9_\    Ò  Å§  Ë  Ë  ˙BL<∏%¡N±‰Y‡Û{úOSu© Algebra/CAS/Solve.hs      Z.”—´∏hZ.”—´∏h    Ú  Å§  Ë  Ë  O4mñôÑ$¥π∏∑;ô_ÖîCÂfÌ≤ Algebra/CAS/TH.hs Z.”—tZ.”—t    Û  Å§  Ë  Ë   Nˆ>Õ|Ú"à˘Ìÿ∏lﬁ‰ö%ÎjR ChangeLog.md      Z.”—öåZ.”—öå    Ù  Å§  Ë  Ë  #≈ä≤;N¬£ñÉ˘˛s¬hG©¨ LICENSE   Z.”—◊‹Z.”—◊‹    ı  Å§  Ë  Ë  ì}‡¨ï	ÓZKB)ß‘∑/™±øµ 	README.md Z.”—ßdhZ.”—ßdh    ˆ  Å§  Ë  Ë  ÷*ò7oV©º•PÇ•XuNÒ%Ó 
stack.yaml        Z.”—$C¸Z.”—$C¸    ˙  Å§  Ë  Ë  R∏
M£ç˙ë(Ä÷]m˝ñÒ°—úãÒ test/Algebra/CAS/BasicSpec.hs     Z.”—ï‘Z.”—ï‘    ˚  Å§  Ë  Ë  ACbóÀGa¥ÿ;Úw‚ﬂ\WwaH test/Algebra/CAS/DiffSpec.hs      Z.”—|Z.”—|    ¸  Å§  Ë  Ë  Ñ√£ó›7Ò=“/ÏÅ†ƒ>ﬁeV $test/Algebra/CAS/GrobnerBasisSpec.hs      Z.”—LàZ.”—Là    ˝  Å§  Ë  Ë  4“|ˆ?;jƒ6PîKö˚çJË‚È„ test/Algebra/CAS/SolveSpec.hs     Z.”—¥3îZ.”—¥3î    ˇ  Å§  Ë  Ë  vH#ûÒï&‘ƒB}ƒ√CÊæˆ YÒC test/Algebra/CAS/THSpec.hs        Z.”—ÄZ.”—Ä       Å§  Ë  Ë   ,®$¯√ç£N”J’ÅSÂüï∑o test/Spec.hs      Z.”—s∏‡Z.”—s∏‡      Å§  Ë  Ë   ◊TÆÇˇº<ﬁ.∂¥ı}íä2°ÀÔ∑ test/doctests.hs  Z.”—Ã∞DZ.”—Ã∞D      Å§  Ë  Ë  ≠˛π∂6Ö·§öA“´ë∑¿v∞h±9 th-cas.cabal      TREE   Ø 20 2
„}^≤vü÷≠Ñ8ΩÁ
ƒ‡FÑtest 7 1
Ê‡Wˆ¸´Œ˙G2LV›æuyˇ´Algebra 5 1
‹é•ÉS¢ãéòo¢Àá(*™û!CAS 5 0
J¸„›xEŒ.¨0Q¿∂4;ßŒ¸Algebra 7 1

"6…‡Ÿ˜·ïk6≈ÎZÕGnCAS 6 0
¡¥”u];úr–®ú£ö}·Öäl‹“ÊV√)˘"Ö,BtÖ# pack-refs with: peeled fully-peeled 
a2689c0420924ddff2e77429e23fded9144c923f refs/remotes/origin/master
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local sha1> <remote ref> <remote sha1>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

z40=0000000000000000000000000000000000000000

while read local_ref local_sha remote_ref remote_sha
do
	if [ "$local_sha" = $z40 ]
	then
		# Handle delete
		:
	else
		if [ "$remote_sha" = $z40 ]
		then
			# New branch, examine all commits
			range="$local_sha"
		else
			# Update to existing branch, examine new commits
			range="$remote_sha..$local_sha"
		fi

		# Check for WIP commit
		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
		if [ -n "$commit" ]
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up-to-date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples.  The first comments out the
# "Conflicts:" part of a merge commit.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

case "$2,$3" in
  merge,)
    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;

# ,|template,)
#   /usr/bin/perl -i.bak -pe '
#      print "\n" . `git diff --cached --name-status -r`
#	 if /^#/ && $first++ == 0' "$1" ;;

  *) ;;
esac

# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --bool hooks.allowunannotated)
allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
denycreatebranch=$(git config --bool hooks.denycreatebranch)
allowdeletetag=$(git config --bool hooks.allowdeletetag)
allowmodifytag=$(git config --bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero="0000000000000000000000000000000000000000"
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~
0000000000000000000000000000000000000000 a2689c0420924ddff2e77429e23fded9144c923f Junji Hashimoto <junji.hashimoto@gmail.com> 1513018321 +0900	clone: from git@github.com:junjihashimoto/th-cas.git
0000000000000000000000000000000000000000 a2689c0420924ddff2e77429e23fded9144c923f Junji Hashimoto <junji.hashimoto@gmail.com> 1513018321 +0900	clone: from git@github.com:junjihashimoto/th-cas.git
0000000000000000000000000000000000000000 a2689c0420924ddff2e77429e23fded9144c923f Junji Hashimoto <junji.hashimoto@gmail.com> 1513018321 +0900	clone: from git@github.com:junjihashimoto/th-cas.git
ˇtOc                  	   	   
                                                                            !   "   %   '   (   *   *   +   +   -   -   /   0   3   3   3   5   6   6   7   8   ;   ;   <   <   =   =   =   >   ?   ?   @   A   B   B   C   E   F   F   F   G   I   J   M   M   N   N   Q   Q   T   T   T   T   U   V   V   W   W   Y   [   [   [   \   \   ]   _   _   `   `   `   `   `   b   d   e   f   g   h   j   k   l   m   m   n   o   o   p   q   s   t   u   v   v   v   w   x   x   x   y   z   z   z   |   ~      Å   Å   Å   Å   É   Ñ   Ü   Ü   á   à   â   â   â   â   ä   ä   ä   ä   ã   ã   å   ç   é   é   ë   ë   ì   î   ó   ô   õ   û   °   °   °   §   §   ¶   ¶   ¶   ß   ß   ß   ®   ©   ´   ´   ´   ¨   Æ   Ø   ±   ≥   µ   ∂   ∏   π   ∫   º   Ω   Ω   ø   ø   ¿   ¡   ¡   ¬   √   ƒ   ≈   «   «   «   …       Õ   ”   ‘   ‘   ÿ   ÿ   ÿ   ÿ   ÿ   ‹   ‹   ›   ﬁ   ﬁ   ·   ‚   „   ‰   ‰   Ë   È   Í   Í   Í   Ì   Ó   Ô   Ò   Ù   Ù   ˆ   ˜   ˘   ˙   ¸   ¸   ˛   ˇ            	   AÖ}ï¢ñÑ$ˆÂ¡F
Çd  ïÁú%ºﬁº®.WBîU–üç~°o:Àâ12é…W<®ûc∆¸È=ﬂV¢;ı+#]”›π5Ç?6È›Íÿe0QÜ0+5Úü{ˆäx∫$§§±í„ôt^∏±MØ|∫Ï_v{ˆBn‰öìtíç›ºöC*ª
9L(2≠qkÅ¬2Fıôƒè∆QÏúçÌ›Q‘T˝ÚﬂL\–≤]
>/°Ø}u[' ]ı™UÚÍáO=NÕöF¢
<Ìèá¬1‰¿éﬁH±JÍ•û)$€2Ré1©πò≥…`ﬂ—›}aÕ7iGf¸?MR»	Xkâ3.A˙gFbqh¿)¡Ç∫5	YÈ¸†ã!0í Ñ»øM¸Qazd
"6…‡Ÿ˜·ïk6≈ÎZÕGn
Ú$—˚ÓË™qºeÏw'û§~b ÖŸê·Ïˇ}—…ˇ!Z'ª1m=Aîj®ÅÁbÓ´ë≥J\¡&‘§™€»LÍyÇÒ[˜»˚	À≈¡¥”u];úr–®ú£ö}·Ö@àæ.ÑS∫Zﬁ∂Q¶≥Íùã1K‚VsD*_Â◊6üL’ø‰êœfO¢ êÕO≤ä∂ e¿‘B^°ÏùawÍÙl∆-^\ÌUØÌ¨ET∑Õäë¬Ñ2ïhO): FTÑˇu¬3#– ∆LÑZ©D©¥Q{  †€2jÄ+!…Æá∂⁄Rï`jÓX»˜=ÊJ‹Òµ^@‹ LÛ◊ÅüÃ›ã¯˝Îü?N∏Bócd±9-5d>©≈y&Æ‡ä∞Œ-∂≤…c±§¨´eŒ) Ì‹4±ª–Ôß¯ázBB_ ◊$ÔΩGéˇ.∏m®n⁄·Æ!8ørñQË¿ñ¿IÕ?Àg◊Ê!d?Ü¡N¯aw–^ôòƒ`≤Z!¬üJ´ †π©aÎÎTì$$ ≤“"và3)Fà‡D@¥º‹P™v„„æ"¡3ÜNæù¡ëÇcˇwº'-1⁄ ›#RÜp=ûí√cábëù{do$ƒ÷ï∫=Ù›k±€˛^‚Zm—R$Ÿ∏f ¨±˚‰G÷„ƒÜ@Èè¢&ª ˝ÅÀøUw¸©º‡l¥∑“4≤(G⁄œ~ì∂	ø-ˇÀ≥Ò◊CD(cõèΩU_Ì¬ú¸X>g?]Ø'p/*Vˇ°À(√G\àÃR%AI…ô*ò7oV©º•PÇ•XuNÒ%Ó+éG€Õ‚1·´%r$GwEg>, Ê‘,v9r}≈zRÖr†N,{föç∞	1:€´¿Ω7ﬂJi1,§•ç\p
Å˚’∏dr
Èel/,…~[–≈/~-¢(Í±™~`/<r¡y≥Öá¯6¯ZÏ˙}≠<0o¸0g¿•™lÌ“ãid~è[ëfÚ±„2'5âIzO¡Yµ¨˘/¡ë˜Ö3√ÊÇÉ˚ÈQr N˚ªu0∆£Õá`4√y@˘Jo∆r.“J/kBK4mñôÑ$¥π∏∑;ô_ÖîCÂfÌ≤4¥Ù‘µlO'
—&‘nø’¨Ü[60¨†9Œm\Q»Â».÷†ùí«8uÊüd1ä‚M<dÛÎÚP≥ç¯3;Q–-IΩÛÙõÙ©wäª\ÅbÜ<b˙vˆè5Ø$‹˜¥.·äË>Úóa<æ∞À˘ÉjÍihe?îLƒ∞^8‰7g“ßUîÆ¢8@ù@⁄%h9tKgJ¶JÉ82AGBL<∏%¡N±‰Y‡Û{úOSu©CbóÀGa¥ÿ;Úw‚ﬂ\WwaHCu¬fìE<ç≥l∆xw› |CãóDà‘–&›ŒöQµq’ıCn“iGÇ£cÑ;‡∆ÑéëΩæΩX&4H#ûÒï&‘ƒB}ƒ√CÊæˆ YÒCHGH,Æ˛7Çô·ÿ>™˚íƒiÈI˜„áR&!2ﬁfõè |…‹¢2J¸„›xEŒ.¨0Q¿∂4;ßŒ¸JòÑ 86¢<ﬁÆË|ÕLÌU∂óΩJ˜:L)ááË4˜£HÀ˜Ç˙â¥Lç„¸gÚ%=§“Ì£˚Ö\%J˚§NârΩF˚ ‘2b¨{±(‚ﬁÓI~N¢6ß2º{	•hr∫ÏkΩòuNˆ>Õ|Ú"à˘Ìÿ∏lﬁ‰ö%ÎjRP;∆0yŒ ›~D˚{~Wmz∞ P•4¶H–˝FAà∂ay:qç‰ÏP›çëõ%,TÜ-‡∫u,«TÆÇˇº<ﬁ.∂¥ı}íä2°ÀÔ∑UvÄ¢<¢6l
ùÛà Ñ,ÚÌ&äWÕ≈ﬂk˛jeˇÇ”æπíXﬂ"ÎY7"/RPKmn,»πﬁC”0õ∑YA†{ag…¨lÔ_≠)2<ÆkπZ•1ØOﬂõüŒ˛±ÿ˝öòÛ?2Z‚f¡øÊ“ÍJ+gc(÷ÖaN_wØ]›Qç>LÍoÌ·	5√ÅÏ•g‹|%_üº√.póËéÅ¨åπ6™`çollaMXvËJQÏÊM‚µ§`î	2nMU•Œ&AnÅ›eÌ3b¥,püB◊ùtëî,2}ÙPg/ƒ§xÀp´=Ü ®›&/g37+-Ö≥#≠Tæ”P»LhQæ^4"Ä≈£∞	—Qú˙  hŒ˝÷'js≈vÓÁ∂/ñﬁä¯‡ibßbÚ‘ ºU˚—√<õ„L-ïjvú(
ﬁ{«-+v]âÔYŸFk+G·¶|*0°uY9…iºÛ¯J≠lôgÙÌﬂ§xˇmÿÊgìOÙQTˆm’ﬁ†#5ËÇ©ïπ;èΩ˙0˚mG»ıæ◊<^Õvfï%VÒ/‰÷#nƒo©ÿ⁄å9Ö~lix<⁄Po∆Xåê-HøY¥∂ù 5·p#ÀﬁH‹fæRå{@*∏©! TrÍ{fÓìÎ#”]˙µB"˘YsMÓŸ,U["≤ÛC„%ßŒù›Qu„ZºÜ5«†˚p¯I—ÛÑ¡vb«ÿü≠ÙÒ´˜‹a∏ò:ÆhFuΩw<Ô∆KH¸ıNtMí{•‘˙»≥Qw`ÓLI7úKú—&Îéƒ∆¸ÜÏxÏ˛ﬁIŒÖ˛¢†±⁄[†O•ãyoÇ)…Z~ í|ñAÎh∏á oz∑ZíSîùQ;…˙Ä3¶≤ÎÈVÙ}‡¨ï	ÓZKB)ß‘∑/™±øµ~ÔR=ˆ»@†ôdû˙‚Õc‚Ó Å†¯≥ˇöh)∑Í¢È•ƒÍ‡S˜ªÇÉ\‹!Ò‹¶»¢ÉB5ä÷k±2ŸÖˇ§E˝`⁄Ÿ?QQ◊·ü#◊‘Ö&Ço7á;Î}R—ÈØî„äÍò‡^ÜNà7’\ê·S+πnÔµSOÌ·Ü\<¸∆≠Yö‰v^~…S¯ü¿”´áÚ3°]ŒÒápo%ù#”1ƒ£µEà¯Qòìõáô*?Ü(ª∆ÜZPàﬂóvÎ›0„ËEøﬂïK}îlrÒÊå.◊π$3ö˛û$û£∞wH¡*åòä«ª)”‰Z
"%R¿D-0êß”ç?D>»Ü≠ìÖ¢gôS√eÅ«c‰é`‹Ì–Ú0ÁN§ó‹CW5éc_zVú9∫aIj‚¢ph{.∂6‹êj0yÎ}‡T“±3îˆ˜U4àÜëòÈõÁÄÇp[‹Œ^∂Jí Í’VIqp@£Bá?.â4r;ñΩ=ÏwÃËâ¢2¡Zo
(´‡Éö^ÑçET
%ú%ê∂øC∑∂)oú/‹¨RŸO“Ï¬´¿c¸„- ùùM-?èÁÁ‘‘ô´‡E¿œÃù$û&€9πäõ«∏fè·©@&Q†RÓmUé4≥+.G~Ãã©˘7e†`ÃÒ∫Iµ~‹;[ùŒòﬁYf™†ÌJå&Eô{ˆÍÀ‡c≈„ﬂ[¢›z{Ã}Éÿâ.0:ÁŒwk«¢hú íMﬂÚÁt)‚?ﬁŸLí?£N{µ|áG<î#G5™|.˝˜˛§›w5‰LﬂÆûΩΩ|·†ódıj§b(»IÕybâ_†^8%<±¶$§cù∑¸d’XØåqw/1<Æºï!•ì0¥˜U“9fŸÖ…!wü•£ÿí+$v{¬m“ˆ<Ú)≠v™Z¶¡tPôp∞V3¯ƒÚÚrRÎ_È¶˘¯›<ÅmàÓ@õalí*l˘∫ßpcØÿÙ8Ä®]™ZZ◊¿}!Ôjß£®›Y<WA≠?ﬂ8|M•√;ößı√È ÿÇC}º.CZhŸ˙U"®$¯√ç£N”J’ÅSÂüï∑o®IR%µ“ıA£§J¡gOx<§‹F
®‚-Ì√/\ˇê5˝©Æàπß©´)«¬£—˝ÂÍÑ7
∑Åë[=¯Q´òi'˚Ìr⁄˘∂≤záä◊´ƒ;E _!¨≥<ìçÔ"Íñ2≠∞H-êmd1!⁄'áj”CÏ=[*≠Ë ÷Fq.EïÓ¥ø¬GØâæç$∞”Ìqít#òa©√ºøÉfh©éo≥–Ò>¶¸¬»¢ÇåˇÊc&e›¥‚ãmò®†´II“ S>Õªµ{µX*
`0 éü¯ê£;<cµ⁄˜‘ØÀf$≈rÚíA‰ímM∏
M£ç˙ë(Ä÷]m˝ñÒ°—úãÒπPÍAú9=C¨<e§4î!$¿øâEπØ‚°pÓÃyàa*AQ±nÜ)[∫#»Ho-	h◊tQŸ˛Ã,ùÔªKI– ª0≠DÁŒÛÇp_fïÌ/ªÊ>°Á0$Ω1èÌ/…©Ë’ı'Fº5Å«°ÉY[@€næR¯–µ»3…ºÕ_™Ü•(“N'-ñÚﬂc”öfΩ)e†9qÿ∏?'Á˚Ù±_–9Ωlπ¡€◊\+7l‘EúƒæîCâ∞˚ R»CtœÂtlv¨ødÕÓ¨°¯qf#|cbﬁ]ˇÄø+NÓ—S&Í<"Î≤ß@9ä€ﬁ—¿[=ä$SﬂVv(^H©°BÜº!=£¡' Wedº‡°Cµ° vë&≈)¬¡ı∑Á3∞Œ¬≠}.é¡{Àﬁ¬›2Õ"9Å“”q ¡]qÉsõ[√£ó›7Ò=“/ÏÅ†ƒ>ﬁeV≈kH!¢Z√iq9£k¨Œ&ÖŸΩ≈ä≤;N¬£ñÉ˘˛s¬hG©¨«)’ Aå\JtÌÜ*©ßÖ+–»ë»µÖÕÒT.Í‡àS∑m^ñT?ˇ ;iÁº†‚¬¨’æt>Ë§À…rıLúF_”Ö†¢∞å¶ÈW
Ã».°Ïˇc#≈Íf»µ?új◊ÕWW˘¶Ã8PÉ˝¨Ωl¨"y√¥öÇŒ@•U–ôíˆ˜¶Ÿâ8“0&WÎŒÑ2◊ ‚—œü–Fu±Ê·°Y—î[˜~‹¡Oòc¬„πdß˘—›?wÆ´Ê«5X}´Ce—–[ì“|ˆ?;jƒ6PîKö˚çJË‚È„”ôÃP	˛FOÙ ¶µøHÇª”~mQì[”y;¯ó…ﬂ¨±$Ú¬”ä9osÇ«Ù◊ÔÒïí1º2"Ä¶‘gå‰àû˚áU’‰9§Áπu— ,‘ì"%ÔCCqøÜqORâxÃÁE‘·úáÃ·ïmµm¬'T⁄dæ§‘·mæ{vu2)«¶Y$˛ÎoÌ›∫‘‚¯"ë] ˚≠ß„±¨∑Îo0Ä
‘ÙGÇ¥Ï•yïÒ‘Íæºröe$#’ç|›j1i¸ã!a∏J◊|À`ó«#>"¡ÊuR0◊rïöäæmç≈}Æ˘ˆßZŒÓ˚/2◊ª.l¡‰≠¨ﬁÑ` =¢õÛ◊· bËÖ÷î}Âï6†äE∑≠>T‹ZÊ°Âw®˜≠∑»·ZﬁπÀ‹<^~äêw3à˙˛@‚ıˆ_c‹é•ÉS¢ãéòo¢Àá(*™û!‹ ız_◊±¿˙‹ˇGE)WÙ«œﬁî9ÈÊwç¿πßIN¶ƒ¨*sÎﬂË¯≈∆∑r26#œÈûÀ¿§⁄X·4ágHÚŸ#+¢Ûƒ>``ÜŒoé·R∞∏™ô`7á¸A.jÚê·¬eµü»w˙ œ™nÁΩ?Êﬁ˚‚ÌÈcù£·)jàÊáÇ~ˇº„}^≤vü÷≠Ñ8ΩÁ
ƒ‡FÑ‰ÑZ9Hﬂ¨êœπ~c5‡&{≤éÊF0\EÓıÌÍ∫B7w |D[òqÊë{NHô@¿Z–
˚¥C¿7‰Ê‡Wˆ¸´Œ˙G2LV›æuyˇ´ÊÛtsÂw€$∞2‹jJ”õöÖË‹HÁpn4“Ém-∆˚òõâ éË¶ˆÆ}g´ÑJÂ\k£æ7äètÎXàÆßÎ÷ŸÀ8Ya Ú8n≤ø∫ÎÈÂp◊o4Êÿñ>ó∫›+‘0∆vÎÙ◊ÜıF‘n/a”œ|∫rV€∑Ï®ù2d¬VxE>ÑÎÌR¬£!è	Òƒ¯ﬂ:ßG[@zB[„Ó4E¬&îMA¸¶˚Å-ı[- ≠4Óë◊sÜuÍË‹@{õêFc#ŸB—/Ôq NPH_[vµÏ‚†Î.PÔôuç"6W;œmF2%ÀV)hÔı·˛YhHœD,-˛ÙNˆªIïÜpÒÙ·sÿfê∫`ˇı
|BFË¶ÆÒn!√dáÊù&¢e`CˇM2∑Ú*uô‡y-gúÌ≈èU»¯ãƒ£ºÛÿ†èÌx)pO`|ÅtFˆ
ÙÿÛ~“_èÍ”WâZ;Ó;6≈ ÙÙ<mÃåÌ»ß”/≈ô¢è>ı{Cˇ©≈\u3Zà:*†0∂ª…Lõı«rsÎ∞Ä’ÒS3ÎOıãK˜,X!ñûUe\“Ù¯ô	ÏwÑ“y˜KgÎﬁºÖü(õE3U«Ó^r_:¯ç/\Ëv≠™*_”¬–»˘z"˘ˆ;J@‡úcÛ~ÍrMÚã4&˘]ÿM®`≥ÎZ‘s' ú¬√˘≠ám¡œ≈tæC˙jÚU¬/“47˙g=&ﬂÉ“sg$†ƒæZ:÷˙¸+°À$%sÍOMû›	<m¬j6l¸k8*ò+âäç[ﬁæBr–ù|˝ôâ≈9úsÚ7#ºætîíaØ˝˜#·≠Ç$«8,¸Ωü≠˛>s˛—˛0©fΩ|Ö˜mùMuì£iˆm⁄Ω˛π∂6Ö·§öA“´ë∑¿v∞h±9ˇNÆ±_ê‘¶k(¢18›∂0ﬁ-ˇÇ3	´Xbæ*¬æé¿ﬁêπñ;ˇä$x„Œ{‰Pû”Z"@›yéù†›⁄›X´T	∫Òw“jQ¥ù€"¶?p:ŒÏK≈tWi¿·[ i,Q¢cù”˝0„∑¢MÖ‹ÇŸSn+iã⁄◊]˚Åè€K≤yˇéßmäÛ°}Õ)	Ü¿´	g5C9G1°º}Ò.È:ò«"qÿ˘ª¢öWÈ£[ZHµI˚·ÏÉ˚ÄÔ:ÿSªÚÓ@°‰å&–lYO/aÒ&7Ì∑MFÏ$ﬁ;¬ã*∂ÿè™Å4?˘GÚ"^ˆe5∂Z ç∫C÷Ì≠%Qv¸ÛﬂÃW¿kÂ¿`Î<,›"ñâ#ïˇM[ ⁄π¬óîtf¢/œ;∂ﬁ	™3V‘{˜l-\0€ÉßZ?Pœ`◊ú·l∏‡œæ˘Ê
èg”´íÄ.ä‹≠Z€R¯DG(aá<éPl´VÆ«“ÿ•#£Ògì„O·Lπh•!\2OÄIﬂs´~—¯ÛπOüÑê	áÆ◊ÜˆfYôp:—8=K@Ç.>7·N—jW/Z`
,/ñ?·ıëpV´¨T°ˆ˜^…tˇHf«=òª%¢ó•≈≈"∫—Ã_≤‰ûn∂∂¥◊|‹aÏ©ûˆÙ5iœ!µÉ¢,
2Æ19ZÎ ˚˝
WY‚8 7ﬂ-‡ÖRÉâ°„0‚ü€‘îUª¨a§–Ä0íòjàUßI3´ßÎ¶]”}ƒq=∑Róˆ!¥ÓGTëæ¬•®≥^übæF`±¡⁄$√ù°qéÚí“Lz¯¡?≠˘«ú€èp;ÿc)&+Ë§C-Õ‡EYÍ∂ÈAªë˛Sì@r˘Ø|:§ä£rUÆakŒ^≈â`RÒ#w>À9›ŒP6g o<e≥s!—ƒ¡È%ï÷eˇØø˚EH˜£•’X›ˇíóêÕ|ÊW[!;h–uI BE¢ˆ;©õ.rΩ-ΩWŸ# Ïe˙{ı¢U≤–º¶˝-Êöt÷u- ùÀXk‹˝7bûb-°K∏bK¶®˝z‘\2ûHª‰,Zƒ≈M_[
B8◊Ñ©&Ê{‘)l ¯ﬂ‚ _œ÷)°‡~«SãÑ¢(Z#åAú2§D8è»≤x¸ò–5 aw\ãÊhMú≠	€òŸ\@Å!l.È‰y˝…–.v∆πŸΩ„]7HLr¿˘5W'‚°`€s∏˚≤⁄£8t«Å∑LÀâ±»S∂Irë
GR/1≠Á2ìöÇ x9•ã¿ò%◊[´ë¬ÂQK∂„º‹¯√›óï!øﬂµí‰íÒSCGØ¶Ád∑Ìy÷‡N©W-ŸÚà†2Ò^4.∆è‚,æt⁄@DBÍ"°≤$˝CÉ·ø“4‡zπi«i›MI: ty}´úÔKºO9{1›6√”ÑºÊkâêî9óqÑœ:›ˆ¢g	vSÔ1åYÿ ó+á£“AV∏"f¡£-rI°Œõ•⁄ÔT¸bç{5=T„fHG
ıR´Tg~  ëÁ  µÅ  ˛‰  Œ•  ”Û  ã  Î  ‘Ë  ”  Qâ  ‘!  …=  m≤  Z%  øù  †  Ÿ˚  £t  œ*  î
  \  Í¬  îœ  ±7  ˛ô  Ø´  «∑  ¥Œ  ÈÚ  ô“  Ró  
˜  3  Ô  ≤Ó  £Ÿ  ÕO  »?  È  ≤  »√  ñH  ∆Í  —f  …ç  K  l¸  è  æÓ  ¬ì  –ï  Êœ  rÉ  ≈w  ƒU  l√  _  e1  Èî  Ò  êò  ¸±  ïˇ  ≥{  ã  zy  _=  uº  ∞“   ≤  Í:  ~  Ï\  ≤0  n_  Ë  H±  N  s  ±  eF  ≥ì  ◊Ï  ñœ  ¶  æ«  %  Ç„  í/  u—  øx  ◊q  Ì  ¥F  r  •  ì“  —ÿ  `—  „Ü  úé  r  «o  äƒ  ƒÌ  ê  6  ¡X  —Ô  M!  +  õΩ  ñÎ  Â  6W  ÔH  ˛N  ï8  g‡  ìª  ¬π  Ê  éï  »±  ¬˛  ÃÈ  –ﬁ  ë`  î^  √G  ≈±  îˆ  5  ëä  ¿€  ≥3  Êq  L=  º  ö†  ë  ¿+  æW  Œ  ∞  ¯     ^]  ä,  ∞Ä  Õ  w  ’1  ÈÇ  Ë6  õx  –  Á  ~(  Lﬁ  Ÿ]  ÈO  Rª  Â$  õM  ‰ñ  |O  É,  Ôp  „+  –  sî  ⁄  …$  œ  Õ‘  ’ÿ  å  ôπ  ô{  ƒ  ‰  ò<    x  ]  ¬{  ‹  w˝  È!  ej  ¡  Î  J?  ú  ót  ï  √˘  Ô  ‡  ò  {p  ÷¸  ËL  À≠  t  ÷J  ö	  ã◊  1  Ïâ  ≥˝  å0  ˘;  ≤  ut  ‘¶  
Q  mã  A˜  	  ò(  ñ  µÔ  ñπ  í˘  y  ’O  Ò  jå  m  åy    ‚˝  ê≈  òo  ËÎ  	≤  ô˙  ï∫  Éˆ  √œ  ÌY  ï#  á¢  ”»  ≤∆  π  Ï  ƒ∆  n§  ∞ß  ø‚  ≤°  ¡…  ≈é  Ï@  „∆  §˛  {'  öy  äù  –  ~^  Ç±  Áü  ¿≥  Ï—’Øˇñº/p
@Y¬§R∫ /úòóaˇ:ÕNgò¬”ÏëCŒ∞œõ 4ªPACK     óxúùÃK
¬0 –}NëΩP&…‰"ÆDºE⁄ô⁄H€Hõä«WA/‡ˆ-^]ò%Oñ[Ì]Ï¡êKPiZb©Cï–˜¥\%"¯	¥#ÍLLVµ÷+’íÌ-«§]i´CY‰eõoYû”:‰©‘"˜∑4√é◊)Â±È tê Çé—˘Är@ºu µÚ?ç˜&|q O9Êy-„É≈l|Lêóxú•ÃM
¬0Ü·}N1{°§ìI⁄Çà+o1˘kSl#mﬂ∫Æ>x‡{ÀêÎ}P—ôÆçQ+œ‰1xV—ˆZ;‘ƒ—2âoa-†HFß∫·òÅÿ«VuàA¢G‚v¿h,!Y¡µLyÉG]Áwﬁß¥‰í·<°ô~pNœ∆ÂÂ-i-çQ™áì§á.©îgF‹“∂‡´+)Ø¿´áΩ⁄ΩÄ≠„.>˙Sûxú•ÃA¬  ¿;Øÿªâa)Ö%1Fo∆_@w±)M≈ˇ´_‡u”7¿Ï∆IL0Zòß¡&Lâ5í‰Ë3ë˜—k∆¨÷∏…“Aº◊Ëù†«4X6®iplXß…Â($˙\$*æ˙‹6∏æñ{ÅK|Œ•∂ﬁ‡pˇ¬~˛¡ÈVcyÏßVèÄv»y§ ;¥V≠•w˘≥Qgf(KBÀP„˙ı¬3NÍïxú•ÕK
¬0@—yVÒÊBy˘º&G"Ó"ø⁄”îöBóo∏ßgpo[S$é¥„Fí%Ø0˙>˘Db0=#e∞lqköÙÇØxA£î‡>jµBmπU"H°„†ô€⁄XWxlÛî·Óﬁc.µU8O_Ë∆\ü≈ÂWjπ W$MO«NhŸ°%∑ñ˛Ã∞[ﬁ!Ìãõ#˚ j«Kõxú•Ã1¬  –ùS∞‡Â'∆8„-Ä~Zö∂òñèØû¿ıØÆD\k»b≤§Û§t—Íí2"ÄÎ§JÄ=¸JKÂ õíó1('(ÇP∫5Q¢s1•åñ#"2ø◊°¨¸æ/cÊ7øy.µ”¯Öf¯¡•ü}ûöXÊ3ó⁄Ä3Z¥»Ö`ùs≠Ùg√Æ˘≈ßºlez“1Ï={?ÜMsùxú•Ã1n√0 ¿]Ø–^4†EãíÄ ê•»/häçXñ·»ˇo3Ù]o∏æ´⁄®Ñ˛;∞ß$ò&¶aLƒÍÿ†&ß!e1Ô∫vãÑ¿¬ÄIe/~ê®^¢”L)√êú√G/m∑˜c}Œˆã_eÆ≠7{~æ·T˛‡˙®</'iıbá—cƒ‡F¥ê ÃØ÷πw˝gcnÖ◊á⁄⁄Ú±ËÁ∆ΩòRNøôxú•Ã1¬  –ùS∞õ>cúåÒü¥4RöJìﬂ:x◊7º∫Ü¿Cê–9P$Ñ∂ ∫H®£3ùQ)'<!z	l¡5ÃïìWΩÍ£EM$çjçå…yMxΩ%È¿¢∑:ñï?∑yJ¸ÅÔ1ÂRøL_h∆‹ÜåÈ’P…WﬁÅíΩë?µ∂mŸ°9’˛lÿ=Ì<ÏŒ˛Ï∂Å} Nxñxú•ÃA¬ @—=ß`ol)0$∆∏2∆[å¥4RL•â«∑.<Å˘ª∑¯mâQís`5%∆‘ká@hò»l±‡¯†b≤$û¥ƒπICØhõ»32aÄ®=m∞ﬁ°Ú:0¥∂±.Ú∂ŒSñWzçπ‘VÂq˙B7˛‡< è.‘rí™7⁄Y‘Â<Äÿ¥‰÷‚üq…o9ﬁﬂ◊A| ï3LYôxú•ŒA
¬0@—}NëΩP&ôI”W"ﬁbí¶mƒ¥RS¯÷Ö'p˚ü_◊î¥ó‡ù∞u»ƒΩ3"“¢iÉM!±kROY”\u`I»pD∆ûP"∆÷	!1Yc)B:&ßd´”≤Í€6ﬂ≥æ k e©ã>ﬁø–L?8èEÚ£âK9iCΩÒ VÄ‘Æ%◊ö˛Ã®K~ÎaüßËõN} ÆOK–ñxú•Ã;é¬0 –ﬁßò)Ú¯7∂Ñ–≤4hK‡∂3˘ ú†`äΩ=P —”æ‚’Ö¢’>u§Ç≥»>K¡eiBnuóì#‘-±◊∏TA%œÜ⁄î[VË52∆§,)eIOd¨#ÕÿâxØ√º¿ﬂ}:è∞è∑a,sùa}~A3º·ß/qº4y.@cµs*h+§O-c≠¸e#<≈¬∞ΩÙúñÿÏ∂«ÊÙexFüˆo,¢Uìóxú•ÃA¬  ¿;Ø‡n“,P∫%1∆ì1˛b)ã•)≈¥‘¯|ı‡ºŒaÍ ,-?t–¨AQ»m=zd0ªÄ‰AÉx– Kï°e{≠ù≤ACÙŸxEÉGÖÏªh† A{À*o˚2%y•mLπ‘"è”öÒÁ{¶47C…'©ZkZßù<ÄÕ©V˛≥óÙísZ∂2?YºÓ—MQñxúùÃA¬ @—=ß`o“t®LbåK„-(#•Rzk¢pıì∑¯≠Ü ÅäﬁÅµÍÅ4ÄEo«®"rÙFÍËã´an0xÚñ3≈h0r‘—ña‘Ü¡	∑µ©Ty€ÊGíW∑N)óV‰ÈÒÅn˙¡Âû]zvæ‰≥Th˙iè< à]sj-¸∑!¸nƒ∂∞kAÆØ⁄ƒ§-Mîxú•ÃKÇ0Ö·yWqÁ&§o⁄ƒùwqKo•ÑR≈ıãW‡ÙÀN[â¿	‰…ïíGÎ∏ñ>ÙÑ(…£4!q£R{·JKÀΩ>&^IK:sT$≠ñúCå÷PTJxÜ{Î
è}ô2‹qs©≠¬y˙B7˛‡˙,òÁn®ÂB%ù ¡â{ŒŸ°%∑Fﬁ∞[å∞’˘MÏˆÔK¨õxú•Ã1¬  –ùS∞õ4@i)â1é∆Ÿ¸ˇ˘ÿ6•4HoØ∆x◊7ºZò•È	b4!∆Æs.x$V=°U]0≠E#6(ºVÿ€÷≥Áﬁπ!Ëézp÷+kz≤@\À(`Øc.Ú∫ØÛ$/ßîkñ«˘Õ¯ÉÛ=¡¥4î”Ij€È¡h=xyP^)Ò÷4’ 6‚∆iÀîß¸é‚/kPíxú•ÃMÇ0@·}O—Ω	ôô˛@ctgº≈¥B¡`πø∏nøºº∫âh¬D°∑ÃÄ!¡KîËl0d…D §^º…Rµ§∂Á˚#Õòyõ»y§∂≥ŒHg%ÇÉQÒ^áu”è}ôF}Á˜0ñµÆ˙<}°~p}Á&≠Â¢—:0àÇ>A Páñ±V˘s£n9Î9ı®)I¿óxú•ÃA¬ @—=ßòΩI(ê£;„-Ff∞5RLKÔo]x∑/?ø-"@ûê≥ãÜ19oçAbÃú1¯dô\BºGRoZdn¿iØƒK†®ΩGAs¶,VKüù…&Ê¡Âmm¨‹∂˘9¡ï÷q*µU8>ø–ç?8?
MØ.’rcùÓ{kúÉÉéZ´]À‘ö¸πQf‡öö¨mUIƒMqöxú•ÃM
¬0@·}NëΩP&iöq).ıìtbSö¶‘Tˆ÷Ö'p˚Òxu%‚Qhí"¥ZYC⁄ı†§F	ΩÓ4®6Fê™o•7l¡ïÊ ∑D`¨á@≤˜⁄À‡L‘≠Pa@œp´CY˘uõ«ƒ/¯R.µ„¯Öf¯¡˘ë1MM(˘ƒÖÍ@Bgç‡p l◊új•?7ÏFπºàﬂS^¶ﬂÏMøM‘îxú•ÃK
¬0@—yVëπP^>ÕD'‚.^í1ç¥È˛≠W‡Ïr∑/D<EA#íÅÑ{ Yã.[L¡FGbƒD¡ÉâÅΩq°πsJ;k¨vY&/ï(≥äZÌ–úâd≤#Ü[ü⁄¬Ô€¸,¸ÜÎTjÎçü_¶úÀkà≠û∏–⁄õ—É~ ¿v≠•w˙s√.)Òkõ◊Œ>zˆL óxú•ÃA
¬0@—}NëΩP&Õ§I@Dw‚-ÜÃ‘¶òF⁄Ù˛÷Ö'p˚¯¸∂ähñQG¬Åz 06	á1¯‘[#ò àâ,ÍM´,M7 8„∆F‚çE!åûZÁ≠S¥∑©Æ˙±/s÷w⁄¶\j´˙<°õ~p} Ø.’r——«Ä÷}Ç†-π5˘s£nÃökj≤µM} ≥Lƒìxú•Ã¡Nƒ  –;_¡›d3¿¥”IåÒË˙S,õRd7ÒÔ’É_‡ıﬁË™ñ}ï4M32 9	Ë
ŸÎ¬í´9•Î1lråîß5iä—aÂe—kXyFÁÑ2g0r[Îˆ˝~‹ä}ìœ≠‘6ö}æ˝¬e˚É◊è*eøƒV_¨C§≈Ò‰Ç}0?ZÀ˙œ∆\ÎŸ€CÌŸˆØ£’"ªïî¥õoö‘P≥ìxú•Ã¡Nƒ  –;_1wìÕ¥Lõ„—ı/,õRd7ÒÔ’É_‡ıﬁË™`)P&‰D¡˘Hyfî4Õ>ë◊…Öúúƒ≈ª`NÈz∞y%äHë:µãíeåò=ßYÿπïDe∂ãë˚ÿZá˜˚q+&ü[©m4xæ˝¬e˚É◊è*eøƒV_`"b^yaÑ'\Õè÷2Ü˛≥1◊zˆˆP8€˛u¥ZdIIª˘F˙Qqîxú•ÃM
¬0Ü·}NëΩPÚ3i2 ‚Jƒ[Lì©M1ç‘<æu·	‹>/ﬂ◊Vf	<eM$Ÿ˙`Yß`ôh–DËëQ≥x“ KìﬁBbN{pŒ∆f¥`µ˜˚ÿ8Úë1•‰¥†≠Muï∑mô≥º“k •∂*èÛ∫ÈÁ{°¸Ëb-'©|ﬂ/
ïªñ‹ˇy#.˘-#ÙÙEKœõxú•ÕA¬ @—=ß`o“–ÅHå—∏1∆KLô°¥ëb*Ωøu·	‹æ≈ˇueñ.xÁ0ÿa OöMá
†Î (cÄ¥Ú
-iÒ¬ïó*#Eö[$`Ç’B˘ÿHë5[ôZÅ[Meï˜mô'y√wör©EÁ/4ÈÁ1„ÙlB…'Ÿc{›;Â‰aﬂ*±kûjÂ?3‚B$Ø	óëel2âh÷N©ìxúùÃA
¬0Ö·}NëΩP“ÈdíÄàÓƒ[dö©≠òF⁄Ù˛V–∏xõﬁ_¢è>°µh¢°ñ¿Ü~üa‚;vLhPØ∏»\5ä8!&a±wÃ-x√ID08Qq´cYÙmõìæ∆uúr©Eh∆úÔ9Nœ¶/˘§[DGÏw}0¡µkûjï2D‡øuIIWY´zJ ëxú•ÃA¬ @—=ß`o“¿t
%1∆•qÔ,çî¶“˚[û¿Ì˚…o≥ÙC§d#*§º1Äa∞ê¿jFöòàQ¨¥Ò“§O‡ëô£z0L} –âΩ≤®z7RÙÒ®Çˆ6’Mﬁ˜eŒÚFÔ)ó⁄™<œ_Ë¶\üÖÚ´µ\§FçuZ9yRN)qh…≠ÒüÒX#5ï–Kööxú•ŒAÇ0Ö·}O—Ω	ZÏîƒó∆ΩòvÅX 0‹_\x∑_Úø<]E,9»ÃHòrÆ#rÙcÎƒÉ'¡,à!eÑhZeRÀòRú Ü#êÜò2Kl@‡2π6uﬁ–Æ˝º⁄«>çÉΩ”÷e÷Ÿ^∆/T˝nØB√ª sπ⁄∫q1xàÁ`O–òCÀ†*ŒòÁ¬§bª„è ¶ÊGàN≤óxú•ÃK
¬0 –}N1{°Lb>DAƒ[ƒ…hRÈÙ˛~¿∏}ã'ùÙ6YkÎ5”òºÅ#“›z"oícGú¶‚*πu∏Æœ©¿%.π‘&ˆ”Ü¸É„£∆2‘Í¥5;\–’[k·?u.}8}7ı"?ô¶x340031Q–+)J,À,÷´ÃÕa8t◊Ë¨†íe„•ÀÖcõãgGÛõ ÅÇcNzjRQ"CŒÃt°/oÔ/©¯ü{„Y˙dˇ/Å!ﬂ!9g$Ê•ß˙‰ßÎÂ¶0¯}≥;[ÛI©„Á€;rÓ=ô•˙:+™Œ«”Ÿ’/ÿï·®|◊&køCãY¶5¸¸W|(√}Â®í WG_Wê9µ÷LÂ|ÂÌ§π¸ v}éU˜oÖ**.ILŒ÷´L∫€¯≥¶Êﬂ/ã¸~Ô.58∂¯l{ƒ›%©≈%KÔñõ>ÒπønﬁﬁΩ5eLO˘ö5§$C79±X/91)1á·ﬂŒmf≠óÃrº¥z‚ˆe26Z …Î|ÌÓÅxú[∆¥åiÇ©H§πí®~PÄwnøŒâù˜ú/Ãﬁ>—Û. ô—Â+xúU ™ˇ¶¶ê5
"6…‡Ÿ˜·ïk6≈ÎZÕGnëIÇ3*ò7oV©º•PÇ•XuNÒ%Ó40000 test Ê‡Wˆ¸´Œ˙G2LV›æuyˇ´ë˛(W'H∑úxúÕUmo€6˛Ó_qsd≈@…ˆ“.ì·^Ã≈“5®çaEQîDY¨)R )◊.Ç˝ˆ)Àñ„:»>XÄ$‚Ò¯‹›so0œπÅå953&a…$”‘≤‚-XM◊‹êÇYJ∂¥–ÜA?Ëw.¿0|dmi¢0\rõWqê®",sö≤œ·„áS•*Çå
√:Ç eEó,Ç§≥Li∂‡“X*D‘!¿6•“Ó'ÛÈ8T•óyˆ~õﬁ¸y˚>åπåzÓ
yÅHËˆn&øNÓ∫üF`så‚$°1·^Û 4¬¯è¿¶ì˚˚OÉÂ¥,∑·^Û	∞…›Ì_OcQ¡6a£wÇ‘Vˇ;ÑJ0äæ¬†}"õ…jo¥X•\)ètFªÏ.4≥zI•êª|+´¯[0ùp*∞NVLà⁄@®ô`‘0¶Íãä¶·∫ÇóAøV ªŸ\øZº∫"ÇÀjX™ÉÂW¥Ù ¯	õØ@à±öóÌîJ2iÕx ‰Êëø5#IÆêÿÔ±*Ÿöi√ï|I©π¥¯W}fâ%É-Oa¯¬î≠CY	›∏¸ÂÚ≈ß.b◊¨˝~>Ú«àˇhltZ5ÍYÔˆfÛ…ÕÔãŸª∫ˆ∆–˝p;;§Z@≤3p=0⁄·Weä˝’ú∏‰}@î@K. Êä©àe∫‡í
ß±Bä0Jí‰Ø7ñ§¨d2e2·Ã<W+ØaÁhâ}ÿç!|BÌâ¯yV≥U9rß<ÀÄT–õæ{{uÇø(Ω"	E›>Z=±X∑Äœ†oHà+.“˙=LﬂÃª#œöŒ†?Ç§BœŸE;G 5Ì-—c«F¿p
ùu„ÌõŸ¨Î8€yr∆Ï3ÈÛ»(∂Ã‘iVRlè≤VgºÈ„ÙúΩ√Ò~IKì+kπ\"nâ 8QIÉUÌp∫{-¿Û!’™ßâ|f }(ì`+€hﬂOˇÜ°gæ1)÷~ß†846˙óQc∂í…#kÛ≈óà*eÓßÜ\GPÔêÒO¡upÕ&Ç¡54£‹ù~^¬nèƒ˘uÌ>cè#$ MS%M‰øÒ‰"Ü›èQïNò9‰kÌ¸ﬂKv	;“qÒyÁZ2_üd«3qæ∂.èóEâ’¥n[rÀâ‘q¥ƒnœé∫Iã{_GXtó\å`Ñóﬂ`mÄÀøM€p¯¢Õy˜o√· õÁ¶&.÷Tbïz]≥◊X`Ö2›Òm„$∏êq?)ÕkE‚Vù/˝Ê‡˜ﬁ—ÕÒÃsÃ’•˛©ä¯™†xú340031Qpv÷À(fP:h‹Ê∑oÓ¡âM…ˇÀ˜®ÎﬁR∏kb  º∑\.ïÂéµûSta≈é≈≥j∂ ‹Û˘∂xúuéA@0E˜säYíà;âX;ASöî (ÆOXà€˜ÊOå°[=°Ú=÷y©ZL ÒãÛB/ôd*g≠ljf">ßnë/ö)Rœ:˛ºnÉﬂR‹bp„8~≥~E	¸ï$¯'HêwÚg}Æxú340031QpJ,N’À(f˙n≈Ì£Ÿﬁ.Û¬‰˚bè”ﬂõ~un1Ñ(q…LK)Y·§∫ı“W«≈Kº¶˚Wÿ,π„∆U‚^îüîóZ4,≥§TÊı|>{øN”ìS6ZÚÈö¶ÿ≠<
UÍôWíö^îX∂uıåLYVFu¡ﬂoãn˝‹∂©J¢ΩÎ:T]p~NXçìèÕ’É~åüD>¯\=«?∏Tz%TMàHÅIÓ¥ô-*[vÓÿn=3æuäÛ”¥∑õ äJV≠≥ÒxÕ]ks∑í˝Œ_Å“U])ÍÂ|S]•¢(r‚-'q,≠∑jΩâ2é$÷•HÜØ+'ŸˇæÁt„9úQI∂vUek ÙçF£—¿å~;¸€€ãÔæ˛˜ãØØÃı*üéÚ…lZ~U.∆õÒÙ˛oáˇ›˘-Ç∏)Áì|U~ì/ˇYN&’Ê÷˘r¸√z∂*ó’¶Ô7Âb2ÀGÂËzµ Â-ÄÀwÔà”yúç÷ì“\LÓÀ·"?∫º∏>∫˘4/Õø EŸÈåÁ≥≈ ºÕß˜Î¸æ<≤í›|„öæ W˘ë2I™æÕ?Å_÷˘d|7.Gu§éﬁÕ&_öwé@ÄÍ7Â”äÌ7ù√C+PUﬁNß|öø⁄‰svfÆûÊÊsÛ!ü¨!Åk»ﬁLÔ∆OW&˚∑ı‰z&˚ê/ÆÃlé'©ˆzc~Gç9?7›Ï†gŒç√ŒÕÅ&`á)ÿaX?Î7Äß`«`˝*π-z+‡ø∆Àí}X,f≥Á∫r|lä|j¶≥ïôÁãeπÈËb>áÜD1wÎijíæ‚ô:1›…ÏØÕæyãß}/]ûÇ-Å—(‹5!ìÖª¬S#ÿr˛¬ˆOç`≈li¡.Ò‘Üyg¡n‘Ü…Â‡.¯ÿ¯^±0pæ‡c# ÿ=Ñ?4ÇùDó[ ¡Œ¢”-ÄÏµÉd∑€@#ÓÏxhƒü]oùñ˜pyË˝•….ﬂòÏ¥◊3}ì9Ûµ&9€6äU;ÑÏÌx£~3]ï˜Â‚-lösL©ÉXÏ}æœ¶˘$Ü{o≤ª≈Ï—5ëB@ì…wÚª…≈oÃ«†˛nå	Q˘Ågâd˛`Ú0ÔÚ/nÅ§Ûtøy¶ûÌôÉ≥|ò˝ã»vØ <=û∏:˙º´ßπØœrsvpfÜÏmÍ¸2áJUËlßªsé–7√#ˆr˝›…ıw wº;π„»˝¥;9¯œ˙ﬁÜÓ^õå>N≠%ã#ù ê#&H‚j∞Ë[–0ruº0¿-H◊pKu¨∆p›±Ä&ëû¢3∏n£ì9≈JXâ„¨ëê^¶≤‘1À∑dLπAòZ¥v!°≈á:4zø!°∆Z4»ÿÜ=÷¢A∆64ı≈™lE§<u›£2[)Q-bç®aúc•€ŸÚº)ÿ{K]¡ú{}k≤’Ãë"ΩÜüÖcÚ‘$–Rº„∏ò∫≤KÛ˝¥$¸“pö˙œr1´:	@Ô∆CÄÓ|ƒÑo'û4Ï«Æ∫‚Áù©Fd©üG‡º2ÙÚ©õ◊ÍscâtX>0xtDæ>ÓŸÖ¡≠
%BD'§+Ï∞'ƒ^’k¢≈2E3˘¿™PVüµ≤zÜgÃ˙3Àz¥Û »®◊ÈÃÂjıÈˆK´T›ÿ™qï lÚx‹≠ßÛº¯ßŸﬂ^Ô—∏(±+J≥˜ı7óGﬂ≠èˆÃﬁﬁ.∞Ø±y[Ì˝æÃ'm¿*°˚Ê›—˚≠}?ˆËIß”agÆ∞Ûb¯Éû©ùùª‡bd˜®&ªF¸1∏˙e˝ÇJºÀŸ{™sÍÄì¶É`åø¡ŸŸ%•◊Æ‰~KÌ{Û’l=ú aã8åA;üBã`hîìÓNç)fèÿ¬î¬Tˇ;7W?@å§¢†Coo™ı/e¢:ËÃ’
nv©˛Tñ˜1G∂ ÈŒ∏òÖPAYµ%«i"áÇlâqj™b(`Eäîñe≈_∫>a¬F˝ÒPØ9è—'¥3)WfÉ˛1ñ1]`ª=4«iE¡©„ÜXàP	¢=&tµ©„˘>ïl©"©’«©0£D÷ì™∞yUÿaEXvssZE+™h£
Z‘«Õ	$›ÚæU6i£ √S$td\≥Àäz“Åß.ÉU‰ÿ˙;≈·gwRˇˆÜÓÚkŒÉ_,»ƒ0ò7‚HËt∞ce™Iª•7≤Ît
ŒÙkda∞ä|ÚPƒT¥ùÜt¬9!^aªÌîm0€
YÊâπmD§JUµ´ôÏ±Û—ETŸ€Å±˚6ÆÜîÑz©˘I6oM@T˚}1íe»™ºÜö1ß¢2°ô⁄=ÅR±˜tìÂ?è∆õüπ⁄ß≠ﬁΩoQ¸{’ﬁ∂‚±Ée∏‚=.ñ¨ä«ıìø\`àÏ¿ö‡PÕ˘£öåÅIöC·ÎË=d/œD[ﬁÌö!˛ù—Ü®1CÂ ï=gª≠h†Q£+¥´ıò0®§C¯O™¿ıU®EiíuäÖtßhåÄ1@¨û—% "Ã–‰"ê$Ô⁄ÂQ˙J‹¬√'wM—¿"ªE∑ü†∞RYƒVπ*„“ÌEp§t±]3jfùw˚#*§OÒ JVôÅº`hgKä„¥äEÁMxD’⁄≠X˘@MÑˆè•f»›“eF.¿ïŒ⁄d⁄ˆ¿dÙé}¨QƒG÷[Æ“1\¯πƒöc€’ydöc
»<÷V{∆à@g/¥ü?o<”óœ5õ‘ßt1<∞”J\‘∞ìŸÑ‹÷yûs/n8ºy¡(‘ºÚ·“•÷¨X<Ô Y∂¡ñzGVàS‘Y∏ä”ó6¯¸ÛSÔaHã`/«˜S∏nrU∑{∞ï‰Øï\"C}"áÖçâEë0 æ#óC€öæ◊>2Në`X@≥ıt°D+ÃÎE^h¬µf°q[˚ÍJ„Î”•∆WÀZ≥ù¥Öxã≤#œÜ˛g8i°*ƒ‡Y\úçt›,∆ÍSY|™s52{ ÚNÚFÂóü®˚=p¨,F`*°S0´Ìs“≤Â5ñTäiI—ó2F÷&55◊$Zgóöc>4ÅvŒÖ&eVmUí5·Ü∆òûé›ÄK,ˆ$ÿ0ÿUX˘JƒZmG(ÏÃ±ÿ59Ie≈aP_áÕ’∑è∂lé™á%ëvN«ƒwÈ:1ËRVózˆ ï{qÛ‡TíT›ávÙ ˆS	Ÿ˝Ÿ´HÑa4D'Ú˚!Ö®<g'[å™ä¿6.%§äë‡˝…•lÛ›Ê{π.
ôJ˘w<»û0ÏE y»‚j&([FÓ˘»JZ≠É¢wÚuÍI¬Wy◊‰k®P_Œ∆◊TöΩı ’H„ÏL∑¨=≥µnƒ&Z*ZàRï∂7QMvrvÛ¶EEµ⁄√®";≠cØ7t˛$µŸÛgA|Ôcƒ4Æ¬Ië€¥˜Z y)§¬*Jê3/»Ç$®·ô∞[y8ä,Zá,ÁùX8ﬁYÔ«‚¿…·±«ê“s(<ñV≠r@ÉûœQ»x¢~À-5π%KπláÆv˛›ú≠Âˆ
ÿØú¶ùãµ‹«ëf≥¢ƒç=¯í;K´ñè´j!Ç§.‹c3ì}#pÃt≈¬s∫B6. ∞œ!x(`HÈYîD*$3ü+O‰í“s\x$ì“s(ê$Bë“s(<ò	\§Ù
u·hÒY§T6*çÛÕ√i@=≈úvœfâØÁàæÚ…ÎıTB>∂Æ1“íkñL0l√n0Ñæ ∞áP∫§æÄQÈöm/*°áQItÊ…4¶#⁄≠<üıÖ∑(æpÅx‹Æ«Q¿d⁄Jk√+1„´Ò›ùñBùâp"A› é€¸·!∂∞ﬂÊ∏]àÙ}Å5
NwQ.óHÂkÇ^…H˜“Ë2§üÙ1«y«F.KÅé¥‰Göyç9¸Êª¸Jå≈8G“W≈∆≈É/Õzâ`5C‡TAö3EFÄΩ‘x1·f)+iúó	
y^õ™µ(å≠5Œà∞¬(@z9–•;çrU¡o˛n’wÜõ^ﬂ™ä3\e®V·≤Dµ
7lU–˝’/qH¿”Ö±wÊ∞Ä…8Í¯@	iµMÒ$CÂp¡îK’fó‚¥/uâqµÅª`∞ë≥«‰PCÎ3ó§Nk⁄xÀ$©ëzx4l[»Ìz9Ôƒ@À≤Ë§¨»,Bø»Æ)‹Ô0µBÆg6≠vó˛üÊ_—Û/¿¥≤B0»ÿÿTù ßf∑’˛ìÚqòyöÇ◊.Ï"|J.
‡™|›™,ƒcz’&√q
û§cP’π·¡f*^[«R9ﬁP‚JŸ≠cV†k¬Ñ⁄kî&öÒi“ÔJ{¡hDDuÚ÷”¨®J—>T
ûÍG[;W«ƒ’ΩåïÇHZè4?4ålÎ~v!Ì æCÇv8‹Äúä’ΩÑ8„Pán}QMpiˇ€∂£WÃ˛R€Åv@5há™°Ì`ü]Qä^6£R•Ö€<BëÍ“Ç'˘¨ß£	H»õ–D9â›≈j4Ω‰<`>pOpüˆ»(ªY¨Àˇì‰Éúc´!µØÛ…R´≠J2©	–vÊ⁄Í n-V∏;kâNTÃDãü¯…È`|>àkÿÊo„;ÛÌõÔn?\Ωø~Û˝w∑+{U˝ˆAÔ™gØß'\ï!l	â˘‡◊P¿ƒÖëïBMG„ªNgµ¯Ùn≤^rØ§K$dÚr´\ãÀw}p™Ó·‹»Önl∆lÕ6,7á(˜≠ -°mÙ‹vi∂»∏Ìî kÂ§v´“–ÆN——Bêâ[»W∏¬D◊Œê∫˛'u%ﬂ·Ú(Ô†§åËE∞*7[¯,É ÌÃ≥Êäô¡Y∆≠©ìãƒä≠¿0©`Ùû›ôz 3ÆãîBîµ°=Zµmpˆ¬È¥’¿CôçW$ÎS≤¨¿oŒr†¿TÌ⁄ây˙IÉ# PÀ¶ºNv◊C'÷Îù$ÄY!Å·¿ÓZyFòt™	YÀ¶◊j¬IÒFß/ñ‹®è[	'ùñ	óãUÛ<◊†;Ç ª_8£€`EﬁòúK.$A≠\xñÊ†T~RõŒª ﬁƒí‰ ¿…“L[Íıif‹íüîä≤dpèëˇv-ÔüxoÂ*nãpPµz-Ü”÷∆µ Q∫0n∏™ŒåÙ≈óâIydqeñwΩ'„
h˚Òº#”x2XwVUî”Z™0gñMf˘–wø®ÑÛ,G—ó’íÂ;<¿ı3«„πﬂ≠2∏Æf—N¢ïıÈ¨[9nı⁄rnÎ≠ú’µ˜ÛûÍÕ@oŒi”ûÛŸjO»)4∏Ïæ∫lÆıl® b« bâ_ó_„TpÃQÓ¶öå%’‹Bﬂªáüz´zÖîÜ2§S[~^•Q‡∂¸L≥I¢«^•±≥_6\O8eiÄÙ1ß¸%ruà$*©|N
πRÉ]<£RÈπpq∫—T∑ƒ˙’åÀo‚`ª+},™uîániè(\¥®%T925W1º>ú—ßJñÀ<∞É¬ù\^»`ø˚€˝÷±ÙF	j[:PÍ’^+ÃÓù∂êñÁ˜Gºi¬b|ÿn´ôMDu∞¢Ë∏|€ò¸ë
/fyÌ%Ÿ‹™9yoOˆd04PØÈ±π_v®q9:∑ó∑P∂ée˚ÓÇg\÷qW£6wè√ùYp˜∞8/9®ﬂEóI4ÿv\}√	ª~2øÜ3vô#ˆÇè<ÎÊM$ p´—àhº-Uò¬'Âx‘ <Â"á¢Î®PRKåÌê-´hîx{õßdÈÕ«y3ågb–¢ˆ,LpVÎ»ÔÀK¨î’üÜÒ•ÀkféYã”∞Îª◊´Ê®	jO∂jÿIÍπ~Û≈˚®/WhuÜC.;≥tjyûû¥ûIeX¿9˜8ë EtZEπ!ãØaüê°ßŸôÎ1„Ò≤ÚZæ…YfŒ^Àó≥% <Õ∞ÃÓ≥&†\‡ë5ââ|‘ R_d6®§´#÷ “’Äk»ÀUëô‘Eàd'u*>D≥ÙÕR_®å?g¢mê7/:‹ˆ˛éód~á≠Gˆ‹%Œ·EÌFwÉt:Cìã©~0Ÿ„?%EøÅ≥v(gÏ©˛áˆë%%˜®∑ˆX9º˜Vπ;N¢NDLö≠“Ω…9öyÄÙù¨º 'Úi„cnµ‚çº.’o£CDû§3É”&˜®9õè˝ΩZWxi)RQ\[{ ®-≠Ω¿≠B‰ËECnOé&”˚_	‡ÏÅ;º©±oXÒæ|¥3v°Oh] E≠¥5*≈+æ≠FÚt]‚ Øe˚DoãØ
%¡Ï””¶ºÀ_Ø„ÉrqâzYu¯≥HÑÛ ¢N™ã:Ú‰j`_ÏLW4.¬íùD`Ÿ„&<nBÆè-˙4hTÇFlq1#‡&ÜTëïG/~a˚ß≤(Ÿµ“"ö—¨\ ˇÀı\æË∏û¨∆ﬁ◊Ïy3Ïo;B«CÊÚW,À∫T◊»ÂÅ‚·!b6bøÛAë˜ŒGÂ˝¢‘ªwûÊhHµä°o÷†L∞ËÛ¨˘q7lË E≥ ÓÃ–UuÊbeõºﬂOCeHt8í<GA`ú‰«·ıt,—¯j&à"–Ïo6}-há]opwù(∏@ËÕ	ahƒ¬;˝·B¶◊e@∆jÑ<Ñ≈¿0H⁄òÏd`Øyí?L∫»õlîLy#N∑√Nk”≥¢t¿’V"ı ûW3∑Áàº|“y¯§ﬁ≈tPé˝{T¢ˆ‰Kx√=r"ı∏3†Fo›K¸É(°2Ôﬂs‡íx√‡ß3tÉRxâùÉê:ªÜTü•]ÖK¿t9s†Cõ–°SG(Ö»nuÉçC:ï|Ëp—"È“Ìñúq˘.Å]7ìQéßw§«|»œ≥X~≥yπê◊˜*öƒÌ?|Êæî "º™KÑLp]@·h‰ÅÔí(æ˚Q0ÜÅî∑ø8¥5à…`ß‘·À vC,∫±~JÏ≤B´+=†°∆„™lÌ‹ l¢⁄DÓÚ Y\ükî˚•Ú-±v^˛4°)__‚z(ø” ÄÅ(wƒm‰<
S…vù¢¿?	‰∫¶„bÛ‚ûæ˝l%&tA"íØ∑TÅéœ‰ß‹·—<òS¿ÎE∂µGßjîvÆ<v£ª GŒƒÙ˙&NU˚ìZZ®g3çÄ~\¸ø∑ÊŸ…‡ÕS†à9Å‘x‡‰>ôaHG;˙[∫ÇÕü·¢~ÊâyÖ
†|∆πì© ãÀ]Ù§xlUú¥ª%[ñ‘ÑË∆-˚°l;‰4|9ßeDıÛ;ôl~ZEÓ ∂¬èi\ö®pãémdúgΩ kÚ≈ä◊¶ÏM˘+4oˆ`Z˛vÿYÕﬁéó+ÂO)_õ@àw€cÇ∑	á>‚ª"ˆô*k∑≠å)Ù§Î4ÏÀ[6–—j,Zò%˝—•Ìã∆Ñ*µÏUe∂ﬁÛ¿ˇÖÃ‰ã˜ûëôü”:<T_ÏÆ2%ÛT≠¿Øa¢êVPj%âc∞Ä!Ú›ìBù÷B›zÉÍ<î˘ËbTÁÄ]èæq üã°‰Cèë36Fyïè'ı\ãΩÖÄ(ë>À’“ÆO:è˘‹"áµHu·}òp¿≤Ë‹Õ[·avöÕ‘xÔÑ‡¡çπL∆Ã2ëZ|vÔm) √¥`›‹ËªN[Íj“®wBªz—M5û"∑o±ó^ΩâqGz´ß@fl°ﬁê^éÙ∆ZÍÌ¥#læB¯V/ [ÏùÖD ÷«W•˚&ä!t4ß%bàUÈ≤)ˆMùŒr=Ñ˚ÿ»èü∞ê≥≈=ÉŒÆÒci0RÍ$‚1NFIµ2‹`¥A*i)	36¯îù#qv≥,ÂÀ≈‡Hn’ÒãÅöoñÎ_çÌíh¬mCÂ≤rçÂP≥íÂCi?ËEàn*´ã•]∞ê˘ä∞X⁄>DhR‹R≈xR‹r≈xR‹è)ªHN)ÓÑW$ dFo'Ω0Ûcq'~ê3Ó†§w√Ñh	¶îw‚	·L)ÔÇâò#Í$Kª`1¨ö•]∞x∞X⁄ã'%ã•]∞\^ﬂ|ÿBìŒ![ÕE$rÑ„’™WΩöy)Y˙H˝bÖXû‹OEë™*”]Â∞π@‹"OâÜ˙?D9«ﬁZ"É¥Gx¥_qZ√j'ÌÂúÛ
ﬂ!Mâ’`⁄0Ö„˛*≠©¡<Æ˜x¡’r6¡÷WÇ~Ïœ™È
i=3—g¯8Ôô∏jà-ö‰ıˇÉŸ∑Œ˘‹xZL÷8æri˛Å]  Z/¶¯“)n˛±·Ûœq´ﬂ`ç?yz9[îYtª\ÆŸñ¥'òÒﬁÑrw◊{Â˙âÑÂZ†Á`[¯RÔ4{Íı?k˘ÏË√E@<	cJ€q]p\πÚõ/g≥âoqlÓoüßµv¡T)Èt•tµ∏¬c≈O◊DWõ∂ﬂxw]ﬂ~‹r=¿eæı ‡‡úl=@¥D5 pÒQˇ—  «›≠.$¢U§BVá61¬™PO!¯ˇ˙ˆ‡ÈÎ€ÉOØo˜ﬁõﬂ‹ÔÌ·NÃﬂˇé$É5|ë«=Jòñ⁄„/∫Ë∂Æ™k~⁄b≥ÚU†%Ã Ã€P\nÚ∫.4ˆH‡y%Â%ÿ›Ω◊õüÉáäkwΩ÷¯∂sûCŸ~Ò+¶˙“Oz·◊|îÖ˜«®Ÿπèèi•ıI≠ª–un>Ê	tjŒõòMX7√G“9ìf†»°4EN•(r,-@¡π¥ ”9ô®»—¥@EŒ¶*8úfò‡töaÇ„iÜ	Œßf€E∞'¸2á~Yô∏°ƒfeqn("°®‚ä"¿VéMig¸ƒ-ΩÀ;ßayı",Ô®⁄±p23ù=˙)§)¥66h‰!m
gêà„G¸TGÎ%©ks7ZcsˆÃ1•©gMP∏≥+mgäb#U5^,W7Â‚q ó>Cæ 7 “Â≠Ù‰Eä? ,w⁄Ï÷z¯œëq˘cèëPƒ}ÕõK§≈J!‰“Q≈Ä\òÇ*˙rµdâÔæ≠8c§}Ò –Ü›(Ë·øoêsÆú}cJ˛Î/b∫·Ç ™Xê§ºë¸|Å´ãC†“–Ö∏8"O≤EYë6∏ﬁ¨¬ÌÈaV<twµà“-Ö∏'uÃª¯˙
ØÕù:|{≈‹Òmñ∏®¢Ç'íUzÜˇ J¬ Úƒß6WÏDFŸ6=ôáyér∑A2Zˇ†‚O=bÅ(ı™å¶‡V1'pIS†a¿Zt¬è–æX«›j2 HÙW§Ú°Sö5xËd®Ç G„Õ≈d“>‚F5Y∫˜ïûi˘AéÅ¬¨à≥∏*/ˇ¯Äﬁ∂pY\Ùœ€ø‰ãy≤ÕI{ûê¶îœä ïÊÜ/f‡÷ÜSˇîMZ
-6i!úM⁄¢≥Iﬂ ±8Ö`πˆ¶´“6ô•E´öeª8À¢Õ¥[•c~L√Æ∑ ¿ÈˇèU.1òwÊÛ∆1’P˘gx0+ü.—åx„›œdÜ©ÍıÔêr.˘ŒyU51˘oøΩòÊ}DÛæ2m+^NøÓYır˜bÃihÌ}úÊji;ØŒ
ù‚Ò}ò]U⁄ƒâΩ$2‘)¶”¡gÅ÷˙ΩáZ´Nè ,¢ˆöFàj{-∑¬xÉ≈Òp„ï›·~N—«µps/‡Hg≈ÅΩ<FSñZΩ8¥ræA<Æ`<Ë Æ∏  ô˜üï%KIxòÕ%Ó@–˛2ÕërÏ⁄TÒèÙmŒ´iﬂË‡µò± ÷πæ^ì
 Om¿ÓÆBÿ„Hc¯¯#ﬁ≈∏w&ª?ª«üp7AÙít¨xåG_˚Â€Ä˛B >›Zg[ŸO®àß5D)˜ÀN'üLﬁÂ„Ö
Ç(Ÿï≥ß≥'
¡ƒù…˛ÎIéd≥ß¡S√¸¥d¿Ì@üx∏søòßÂ‚kFQü›Ê“7€,oﬂç'+ÑxYv|ﬁ„'T%çl2\ÑY/ü|Îá»k ˜ú«¢Ïf~
‚Pmw&≈)Ë∆D¸!3‡[;å'ÈEãæ[rRAﬁQ∏iªîÔ´Z›az¿¥%˙∫3=6
–ã'ª˙Õx¬ÛúùŸöÌRÎÚ°ëØı·⁄¯˜â MÀD“É‡TÁ›Í 'ûÂGˆ∑2Ó2ëñ’Óïˆ2œ(GrA¨ˇL˛öãN	±˘ÿûπ§ >Äb-πË§∫aåÖ∫-ì$Ü¡~¿98¯X¸à®9n}Û}•ﬂ®®Î'™ÿGJ!Í^ç•UÿÌ†ÁF"F¢lÕw{¡∂8yâ∑µé+≠P÷\>÷øÁ‡ˆ|ï´Ò{pê°9ßÅY‰<™µ√P;µ◊PüπQÌã®µ’∏¿Ïj5Fùh„ò9À©±åƒñı¿a~¸⁄;Áà·AvK¯˝…˛˛u&Ó‰cñùÚ‚Dv¯ô¸¶'n3pJ&∑)§ô>Û≥íà~?ıËÄÇAïñ,A˝§tˆ«Œˇ ⁄†ÍÂ†ª2xúµY]åWñ5•C[h7?õ-Ñ7âglÔ⁄n
¥NºM≤õmŸÏfΩ›®I˚ŒxlOk{6„±ª+M´
©o•~$}‡
B’æÄÑxâóä(®• ÑºÙ°<†rŒΩw˛º„ŸÕQ¥û{ŒwŒπÁÃΩÁûs«}?ı⁄ª©7_8ÒÊ7]∫H:yπ£[∫$ΩM”≤…"µÈ\Õ∂å~[ífg…≤LÌéﬁ£∂°—.—Ã˛¿¶}õË[õñ>fﬂ˝ÌCáB {ã\◊-SôïæN	ë≤P%’æ≠∑uãì≈Ä±ñ|ñ˜À1KT≥¡ © §?Ï£©˜ÕZ#ãÊPÌÍzí¨È0ª+√ûä:õ∫eå¿"_∫ùØuÃóÛ¿nÓî>ÛÒ√«dò	U@}úT*Ñ¢v†î$óf?ÁŒû»6â	aˇhÉ€πeô=6ClÅérYÃ¡Éñ jô√~•ÄÎ;…Ÿ`1Y¯≥s‚ƒÔ8∂	.`X…Ï<{[’}9Œ«†Ç‰WÜ 9IäÇä!ˆâ%AŒ˘t*Ëu ]1Ì{´=∫π>‹Ñ»=ñeäfUˇ 4OŸë’º™¿≤T‘+∑Õ√∏í¡ñÇ&¶ã1an∏Ê˘õéÃÌ“<ˇY≥≈¬ ≥ô—Lû˝™fœ7$≥ıUÉµÿ5Z€sUú∏=4Ì5ΩBÄgJÍ(d¥ÂUàJ`}ˆâ\ ¢waEÀ≈‡àÎ,ûû±+Çõ	[]<t•çEŒ˝`Ò≤˚Ò…„ŒíiıÜ] ö9 °·:Ìáá5£ﬂ!Qtg_˘ZT˝ı;QÅŒ∏Dg\$B∏¥µ^6€∏:à:–CRptèÅ‚&ççV+'ñÉ£$ÿò˛ÆÃ√]±öJ8€∏ç””˜	!˜kßüÃV˘©£G€FüZ€˛~á∏oû¥‹_úﬁ8(èdÆ{oíîoï√sÙ…Ÿxr.û\(«˘†'‡Ç\)≥¥‡	Ã.Õœ˛#áQXπòfâ
[©el»4Â–∂Ç®xÓgÂZ™Í.ÀœÊI˜·3Î∞z5≥∑I-ù¨¯øB.]ç´Ó+rÂZ÷våPïÀå—™„jPzÉã_é@›∑Âc˜˚ö›w‰©É\!>ŒT«U£H.ÚÇ˚'˘¯Œ/Â˚ŒŸ÷ˆjw8àƒ+.ûΩ|µÌ0A∑[<ñ™Ó¸°0‡ÛÒbû¿ÏôüUˆ°XÇy,ª¬yë8H_oÔ‹ÛƒÏ^Fñæ¸£yñ¥ç—dO<S>íf0ôe¿†‰~X>‚˛ß¸Ëa&¶´|ùÂD>ê‹Ÿ≥ p gÂU¡¿¸ÖKQÖ¯Bbf∆¢AHπTÄG8p$˜≠≥i˜ÁSúAòêñêfmL—âÀ‚9Ô9˘a£l”=sqo9åØmv±î5JûÁ˜=mÓ@rÌ;/Nï3ÃB:∞}2{ÃB	!G˜x„ËSHü’Ñ¥k`ØÎVÃè2>yD!√k˘¨UFsıq_mLªﬂj($∞© 4˘@Ê—V FöÇã®(˘0öaDâ˚:>Ìò5r°9'Ö∞ŸÖáW’7•”˝D=x~_ÒΩ–Ìä CF°ÿ8Ilí#rß†∫Ø.œ∏T;7CF¯~˝Tâ“”∞s‡…gÔÒìÎâGg‹À/•+Ñ9YÍöPÛı˝”¡˝ËÏ¬≤X¢ä8RyY$÷?QâfŒï#¨‘"Á0π¡À
ôYöQ‹∑¶éé‘a∏Ò∞Cé[Trj@©qç“¯À˛ˇfæ@™Ìú;∑ìÚcıQÂ¨_å¿Ëá´ô¬¨Hoêë8”.-€C⁄fPCõ≠ 1Ö1˙4O!d–ÈQË]Ío’›öﬂüËçßˇ{≠´ıñM®ïÆ7yQÖ¡|eeÉ¿æ’TàJàÌÆ–s∆åˆTÏ#a9¿«,˘UÀ@Á%ù¿ÿòÌ.0≈^xf˛FkÓÀë)ë[î"eƒ]H:NtˇL˚î?∏WΩ™Í©`∞©æq∆“õCﬁ©L»x2€9ﬁæ7h9’˘‚”`<C
d§*Yç4ÿææﬁÒ3ÚÜxæŒ2ﬂÈ<û™ªøÈºplwaÓaÃÛW>;¡”%Ú€gö —ıÒ‰+vH>rT˙≥˛R6ï¡=Ä2!˛`…x$Ü|˚ôiß´€òxÛj&Ø±•!ã¨FÛ‚Aı‡(ÉÍY@&ã9ü†2Ç‰Û1ó´P…Ò,>¡é≥/Cjƒ7î+´QÒ~0≠∞∂s∞≤=K˘Ûl¢˚ìáº8-i|É¿ú`x»ï–	iï
–Y#ø¨Ú,dB-îKJpnPè√Wø$µµÊ™Ÿ›ﬁo⁄@¯LÄ«Ãqá˜dòöUó>4%›¡t¬Ó√≈√ê‘t5u4u[π˘ä◊»±Vì7r*ˆq‡Ù#ê ,ûñﬁkÊ¸—¿yÔ0,»•àªüÄ%Ïgë=Ìù¢≈Œ°◊ı÷ÚÚÕ›D 
g©í:◊ÜŸ:QT;Ñ4ã¨Úo¿ô€ mèàâIÉ%x$≤ÕRöw¨.4õÒSÛπr[˜«óO≈mª.ï›‰I{∑∏|ÚJsYãSıªÂ'‚»GØî‚»WûòûXﬂÔ YÁ∆Æ¢ÔÊÑ»Ü*Í7níñ‡Uº'¡íe”jÁ{f3£îMxÌñÇr#Cp{tì´MQ˜—ï≈†g,˚y{Ô8Iæ* ƒÛ^wƒá±Äçƒ”aÎ©&*®∆1›≠Ã¯µ¿É´'éEÑFa‰B"w;ë˚”’«∏O‰~·j˜Z"˜çDÓØπü\=ï¿}j-â;H‰˛d-)VM‰´%qWπ_ØÂãQ.dxy|•åW¬B¨%ij˝Ù›´‘÷ãŒ›
y]W˘?ˇv≠oíÕÓ"™q
ÿÍƒjÿüÇ‹§‰ˆ'_ y9VAa∑˜oœ≠¡Cb$“[ÈP2wÌç€ﬁﬁ›˘«∆ÔIUw^{˛˘TªC‘2(ﬁxO<ñ.öfW
#[¨q–ªzè`'>ÙiAß–˝˜ı‚°paÁïö;Öˇƒ…H∑^OÂw[óÿ≈<;w≤ê5Î, 
´æ_Wä1¸>_ÊWpPß uﬁmcÂÔæWWN%îœ
;È6¯=¿óRwΩÒí√z≠UK∑Ìm≤	mîç	ﬂèΩΩ©œa?&ôtÃóIkÿÁµª1¿ÍÄhO'üç¡ú¥πiçÖ[|AF®N”éG›p∫îˆ(^'\·&i@_¬™ ƒ!π\∫êŒÂÿHpkªÂŸ…ê~˜n•äÀ?mx&!4ÒatT#2ﬁ˘åò¬¥.ß¡(AŒ≠+iÖ7«’5€ìq¨C9˘ó◊ø;…Æå[dãCõ0
∞-ƒÊ¡wlEÂÇ+e!ú6<äØ¿I‘¿/∂u?‹ËQ›∑M·7Õ4·H˜œ„00&∆¡!2ﬁ≠‡ù(ÍNX[?–÷ü+¸ pö9òå√/à√˜m_¬k¬/	ÅÂN¢ÈN»ví}ﬂ‡H≠'@Ÿß°î&zŒ>äx»DﬂŸÁÅth¢˜¸CJ»~“TµP hr¯Á¿:úˇúc+9∑“'v:ﬁõ’!÷¯£˘–@≥ûŒ—<uY_ﬁk8ÂÅ<çﬁ…Ê€Ñm‹*K÷8˚`‚™d*ëòÚÿåË…y7<õckJÊ±ˇcù™“x˜2¶·ÉìØaÌn58aU·≤ÊX∂åPdQ{Gâ1‘hh¸Ÿ7q¯1ã¯ÂèwI…r5”$Ó◊·H'ÚD≈/#€jˆûÇ˚¿‡¥b2~+®¡báÜ…Ç£è®€°ÉåQÔ$õìP{®âŸ˝Æ¬ ºöco¢ŒúN"p2å‰'Œ™•b®”’¥‰Dïä3'/§ô^∂‡9j›√Ì´âI÷&N“Ò†˛>KPOﬂ¯10=∆QcˆÿdUYOï≥ßÆ‹^∫r˚ûVa∑™lTWa≤.È2‰[ßÊÊñ xúùXOè€DW9PaïU)U’◊’äÿâ”¸)™à,[∂¥ZZïä›Fï¢l;qÏƒ‘±S€qù“8p‡Çæ °⁄;p‡Œ'(H|
∏Òf¸ﬂŸÿYVeÊΩﬂ{Ûf<~ø˜Ú›Á~¯˜‹èáıÈÃ≤]∏C\r„ÅÓ∏¢9JØ~˙¨„Ä;QM¸–5tª–‚S&Q!e(7%.RGÂXÌ^ZæΩ{yπΩ˚Àª¢b»û!A&*ı¿P¶ïì◊ªç7ñøIÁ©0R«∂™Ç∏O¶ôzyI(h≈Ç¸◊M$&Ö^Zªg9⁄Cb“5∫û˚.R£Û"ımáN◊Íï¬–oª§hﬂÃ{·ÍJ<-_‰‡V†}`çã&;£ß{ë1∫˛ú8(lÇ◊‚®)ÒAå†M)∑§»ëûæG˚©…„`…¯¨_ÛéÆigZp˘∫ônòà^;G&B«^™q Õ¶a6uZ;<´EcÉìΩ;Œ”zæg>t\›ùª*®˛ÃVG∑LUÏ≥≥≥ÜÍBﬂóÚÒÄ;ùA˙[˛ñºµ¿œÒ÷ rO–}˘¶$ã˘#i €‡◊p+èr…uSÙ%˘Q8a„jµ]√Õ ∞58>j/ﬁøFÎp,°Å•Å;ü™hŸ˙ÿ$∏™=ï¡T_ÚQêº Í;p◊≤ßsÉ‡ò3∏ŒZ ^á≥’ôAu„x®ÀÔÔﬂª∆GÙ4Ü©5™ƒà RYæíÆ/gW/–éÖ¬†+ºÀƒòxì0xÚE†$]PÿYZ(˛ë› ØbÃ$+Ì•≈4í„ãíáÓØ˜V]¶S1j≤È6‰vÊeM¬¸L#6/≥9$ôeÿ¥Ã$Œ‰Ihì¥]\∆äœ7àníØ‹àÜl[ÒyôULëë≤¡È≈ƒ±9-µrr'6âpíÒ3zJêì|îÂÀE§±iôI¿T4∂aÛ“]≥«>,?ıà”‚˚ó]ÖÆ	-`∫xm)!ã˘1wØ»⁄R.éàË¢@ÿ|Ú˘'I¿Ÿ0∏Ï≈∞o∫»'ƒMÌå>ÕŸ§—!è.#P≠Êe√åaµC◊Y÷÷≠X+∂k‰ÌÆDÜçU√ìK˛~s˘œ◊_ûÏX¬;åp2|¥¸´yÒV@D¢b©ö¶+∫jr÷”tÈè≥ùGlù’… O~¸˛Ñ±jÓ1[Ët‡¿µusÃ‚√Á¡æ˙!›ÚΩ¶˚p"Y%b\/'™Ù2RómM√ßkÄh[ss¢ﬁd⁄jÇòA	oÜÇÓƒt\LNáÅOò§Œƒz	fr∏`†óªÜòK]ÚojÍÿâà»ÿ*q°“¨HP´â1tu/XË¯¥€D∑˝¡ÚÁ⁄ôSµµZõèX––Yu)A‡u”]˜éïù?ñnL0oTF—ıuwÍÄËWµ„Üœ¢–2πYıè⁄u÷GÌ∏√$œ +L⁄AïÖ»Àƒ≤/äÅ¿ÒK˝…ï´°e∞ãºL*Çñﬂ<yüÜ„∏·ÎÑD‘[ëEÂ
IFöÈ˝H'“x9L“zËêî;JuÉÖ´ïÄh∂5\Ô*.	
AJn{ßÇ‹‘ˆh—zD•îÓ0◊=ÊP4Kö»ıÆíV≤`πa˘!DLKÀ5ó)lìΩÔiA+∂Ê˝eÍ“ÓØ‹·ò{{%qÊzM1Äƒ#8e}≤ª¸≥ˇ›úÌ9s€[áØnÄßiÉ⁄hî„Ö)qû˜b"C~à˙0Œ~_—\øÜ,§+–0-ò±:JQ˚Kır‹«√cÆZà°âè?îèY=√…8Ù£E`[ıTõıisSq1…Kπ˝h‡sÜc	ﬂc)T”‰≈FW_¬)aÒ®«s-∆G=º⁄–•<ÅzRZ≈öƒÇ^à`+ÉÃΩ∂‚·ÙXü±@D÷∫sgûY(^;B$jä˙hö#v√ˆù{f±cnµäHô∑òÔŸ*„DîZ”©e¬H˜t«≤y?¡V7)qÇZ&z÷∫K'x∆ŒLU∞∂±‚≥b GU,d›Ë‰Îƒ;∏ZûbWßàÌ]VUâı´å_?Æ2‚üÈEJ’Ö‹√ä ©µQo„L"ì¸=Õ˛ö∞zÛèx4ºSceT«=ŒW›4Q≤d˙*±c∆´¸∞ìæo"÷Ñù
€FXõ*Ú”‰áZ≠ä« '#Vm·Rè,caZSùΩe¨éÚ@ë¬«âZ[÷‡ŸãπÂ>cX[˛a‰nÈ"å:xúuê?K√P≈È “†ÿ¢≈?Öz,-iõàB0Ç
ä•\™ E”&±Åÿ‘‰U*˙~%ªÉ NÇnNÇ_@\t—óXZD‹ÔwŒªÁﬁ≥è–ıWËÚ<óEúÇ8«pÕÉ¶efM%¶›Äa;8hYƒlZ«tscÑ
'Ò$ÛïZ2Ì\.#JŸ,⁄ÀZ.Åƒê^≠«È}:Í›Â∂C1”@U–e§Æ7 A∑\ù&ÚßcåHÇE¡/zë'£AL˙ÈÄX§ØB|ZF5ã+^ıM5(?RPÈKaú>Ù“Ω|ƒ+ã7·!’7A3è÷ñ¡¥79ˇ€uŸ™dI” ÀXµ∂®
q;]·∫£C®©¨!Åm0=¯Î&w}Yó3›°O≈OÔ±4ëÛPy÷SÂÈõ3E#ÓƒA@√%2MG◊bwî±Ø7Vl›0x∞W√lÛ=Ãq£e’qÈÛarÿ[HÒìt‹πçˆíΩë	ˇs(üÏø·Áz[Ól¯⁄Ê∞∞LxÖSMo⁄@Ω˚W<A•ÆAÜ&G+TBnîFä⁄F§zH¥Ñ¨⁄ª÷⁄;°ˇΩ≥kÉ?∞Tx>ﬁõyª≥ÛÓÊﬂÓ~ŒÔnÒ$‚$‚ô¯ ”ﬂ"äÜﬁ_ÁΩë~‹Û4|‹´L§&ÂƒjΩèÊ—V¨4üÛ≈Ñl•√lOæÑõ;°Ö„Ñq¢t÷>âp<Ø'(¢ÙfÍ‚‚E·¶pgm˙¯>ñ<⁄xü;FôgK‰]–ß†œëÃfdcÜ ﬂ•pp˘;Be$ˇ¶¬¬~	≠™j9¸±è¬≈eòUê„Õ≈∏r
rjË®:BA£^ ¥¶4 é◊·∏òÇT¶ht|ˆÀcïO˙jE6œÇ{\πˇÖ\WêkÍQÀ5«Ì©'+0€hﬂÀLl5è ]sL"”+¡§G
lˆ$ÚTu∂•ôö[ŒâQ$Pi9›ÕëZ	iÏh=0√:◊i≥¥€<Èt:G⁄úÍπ± /.^:œ‚Gxb¡≤iT=®m£ßØ°—@UﬁÑ9X’çcEùÑ÷J„6?ùØ\B™	◊ÙD}0#›©∏±—Æ r“,ãç–óÎréÿ;ï¯DµÃ9yÂ_ëo‘XdVai√GH‹•#VûïÆ§ÿÚ,¸#lÖ	§_´ñ≠-lØüÖKÿSmuwI¿?ÎGQ#ÊÇ~xú;¿9ìkÇﬂƒ˘zßƒ‚T..]]ÖÖÄƒ¢íÃƒÖî‘¢Ã≤ƒíÃ≤Tê∏ùùùBNjâBtÖNe¨Ç≠BnbÅBòB¥RÖíéR•R,LIJfZöÇFÖV•¶BH¨U¢83O£B!´•ëú_q”D3 Œ™ƒX»1“‰ã[Y)∏ÂÂñÊ$*Ë⁄aanºØ»,ãW≈dqñï .wGÈÊÄ!xúõ…uâkBﬂ∆ÆÔLj)ôii
â¡
!ây
Íöö
ïÍ
∂


âZZF
⁄
Ü
öõãòó3 Í>ä±…x≠VMo€FΩÛWîZÍ√∂öõQïã@–6ö˙‚˙∞§HâËJHJ°bÙø˜ÕÏí\ ≤õuõúùùyÛÊÌ,ü¶o~^¸∫¸c±|GüíÌﬁË*˘Ió%∆ºô˛<yÀ∫Ã>Ú*)y)ÿÊ´ÉIha÷ITË´ø_·9/≤j≥ΩZy¥Kä;l)ÈÛ&)í »∂˚º®z>ùˆX0ÒvyG∑∑tØÕ!°È˜gŒASDsÇÛ=≈ö‚àF¸≤º“Q”1
»%"¸®XOé:Ñˇ&—´{“Xek49Fù5rπáˇö|H3¸õ”ÃbíñW›ºŒ`ò#ãd°"gñ“ËÊ¿!´M≤kPWö*.B±«hD[]”fØÒ?
±51e“ÏˇŒmÁ"»è—Ö@§Q≥U‹dø√ÉT~&d·∂/ÏÃ&lEÂﬁd’ªzOﬂwøÍrNúÑøN‹ Äc*ùônäÏL†|ï∆ºﬁÒ÷«2ô‘{Ω[QEcÄΩÇ:¯$‡>/V+áµÇ%÷ P1±áîßëËÜ5v„^é¸“Ê;%–•¥Fê6sÎ°ZS˚ µç‚()°€ 1•!†:T)Û}ˆ3Ì≤~uÃµs}÷√3…€bœ%ø˛ÀÀÇøÀs√Ì)]ÒVπ(jÙ›ÁáÎ•L\/oç1AP$´C\e˘Ó2
%c`"øCœY 8S=`|Ñ]ìT§ÙD⁄Âh∏U)M)≠√ê÷‚ûÌ0∆ÏèW>-b’l´F,"u3ŸÿV,ñÀy*V∫Ã±y,€˛7Ê8¥ØuK<¿⁄Û≈2∑¶„êÆ1√Q¨ØcË∫%•ﬂˇ°˙±ºæ_Jèñˆmj}ª.1,¿ÿe2–+¨Å°3jÿÏùºò∂g»√÷t,Fß  –∆¸¶≥¬yxlﬂU}[3Œ=©?Î!«Sı§¢≈uI„15[ÎhÇµΩîñ,;Øf˜ÿ-ßy±=]r›ô©íÇî∫ûátbI≤√.>≈â0'ÿ÷§i6bÇ∏\ˆ|5üui∂∫rL<C\?»êZó	ü¶˛M∫®9-˘Ù1Êv1DX‡«éd-◊pJ!/ä”>Ëvf˙áùø∏òg∑ªX]I “Í†}h÷Æ°!†yÂŸvı9ó+›oro™à÷œ˙.}X∂∫wRËı”s“˙%#Á6«*ÏëÕ˚zÊÎàmî%WëÃñz,·P∂ﬂáTd<~à√~ŸÔ?úâÜKu¬‹Ñ˘~¸˜ºÚ.(≠«;üâ˚9œ/B	ŸERä]ÏY¶Òs÷iïÉ¨}ëÌ*4~É÷‘XZ√ ∑\∑¨Y`n≥ˆÃù5Í¨QgE_;ªj∫‹≠ﬁÍ´z‡ÀÂkU„>_^ÏY£ú⁄A'û©Û4˘Œ’Q‘|6„Ô…˝˝2Ä¿dú<(5„è/5}ÚGkÕﬂõﬂÜµ0 À[˚¨¶3v8Ö≈?ÿãlïï˛÷ìçc}É ‚ü•èÈ áhxúõ(yõwÇﬂƒıßƒ‚T.Æ‚Ä¸ú º¸‹Ãƒ++∑¸¢‹“úD];,L≈i
È
∂
©ây)
*
)ôeé99ì€ò8|Û!J&á0kL.a@\¡Ï#ôòìêòY≤0∫$dC¥FâNâfÏ‰≈l·"P€ ‚PŒd.v3.ÑÌìùÿ5∞´´b˜”RP(œH-JÂR ÇúdCÏ˛ÀNÆÊ–1@@#9Q'~Ú.U];4†<(≠âbu,◊‰yÏ‚ì•9U';s™ ;6ì3OŸ OÑ{_q∆Ía	≤ñ\ÆK
”ïÄÆ.( Ã+Q–@äû…˛‹»N®‰Fq—|Ó$  y™.ÁÅxúªÕªüw¬ïâw√7€2Z1NÆ`⁄≤Ÿîy3 ~	_≤áxú≈XYo€F~◊Ø»L“+[îúK®Ç∫Nè Aë†©_']âîEî"eííIµ˝Ô˝fwIë:jM—‚rˆõùŸπvñ≠?:GÔ.˛Ò◊Àøßè˛| ÃˇI¶ø˚ax‘˘´Uü˛∞îiag~ S≠yÏ-Cü.√[ú»≥´À_ŒﬁFôõ`	∫ü˘âﬂjÛEúdÃw2ı˜—ﬂ”iI#3yˆ.H3+ZéE
í›ju:Ù'ïÑÈ2ödA1ùˇø~˝öB?£úÜtMÌº]7,9ÂL¥‹ÛûÌX˘ÁûΩãQ‰
◊W∏˛>\Dîó»é‡$N≠‹∂[–`@?ƒ…|JÍºﬁ3l’Â“‡t@ÖMkl¿™+Ω∂È¥N)@©s o≠+≤Æﬁ“€¶ÅS-"…°◊”ó«„µi˝6ØŒ6NVπ3˚˛±›N¿Xú¿ü˘	á<R«àc∫äSÜ¥Ë‡ü?)Œa˜AÍÉ”Oí8°ˆDF≈-dí˙Ì-±fÕ]±uùæûDxÛÛ†4Sœfπ,VIÂÂÜ;ıÈú˙ˇ ı_ãéˆânB¨Ë‘µvN÷4âÁ&âC3ÒïµªÊ§¡/bÆÆk•¶`î4È˚i5qí∆ÏxHj”È)•≥¯@å⁄ttD5‚∏’2eÁÖ%ÛìyJÒî¶&y∑
œ(≈§ÕÂhÑ
$⁄E˚¶ÑhvSÇF˘Ω0Ù-r£ @ ^QbÑÆ4€X˜‹¿‚5`Uôq	ú“
˚A	ÜÌ∏„1BÃëıiz¬ä6a∏¢Û!um Pß<?ØÕfd[Ï`Ì®4$ûèÉHrAg˚<Âû™Ûª÷æı£˜pèã‘·mé∫oÑz∫ÍÈ™wW—o∂ÿzáŸ∫¢WcÁß¶˜jÀÈß´û◊3bÃ˙0/Rà ‚3ˆüìáXÙ˝z‡òXÜM*`ËG∑ŸåA Ù5»h–fuäËˆäËﬁia(0rœŒÓÅnÊÃ=£]õáZwzx˜Ï,⁄F◊3Ãã1)ÈõŒ:Ê7£çuP‰≠{úòI¸lôD9óé5ª–ßè»†äˇç^≥Ø√‹=4ﬂHûﬁATÓ8Ââﬂomœ÷sÖ˝¥Â¬ÍO=ë∑íI «°øX9]€fG&ÚéõóO˝FA>VÒdï&µ´°•sãSﬂÆj÷£Ã-÷ªÌı£ó€+πîAeJ ÁNŒèW∫ß‚aﬂ)¯Ò“…ı‡ôcf u÷¸xÅ)5∏p
=Ë9÷ö[≤âAUôö÷MwOâ=ˆ›ái8k◊R;:@bJ±X∫ús!ÉÖNß5ìÿáÒ=ó¿Oñõ•pGeM„–C≈tlxÙÿd†ïâH!2«i˙6Pº¶π‡º“Õ4kÆÂ‘R#ëÄ+üO∂cŒœ+ElÀ6^MyÅÇ
è'–&á=≤Ã4K¥´ºMÇïÆ«(J«íÏ
È
Ÿ≤/‰ÖêœÑ|.‰!_
˘ÍÊ∞nn˜…!…¿çB√ˇ$ç®çÆ*Å•é®ˇk—A¡™tQÒÀÙËëk·Öƒ´´kB·X“5¬çhÕ—sT£ø∆|ﬂË≠'ûÈ5.0_ÍÂÁÂ„ˆiÇéä]=µfÂ Ê)6 k“cE˝v±1eø4Â∫4∂ﬁ*ÆXÿí6´ﬁDijm·}ä?)”ÕÒÿƒ´BàÄ}êÔÅÆáRdﬂuQøµÆ™ä:n	^]	¥I8gπh8ˇ®…ÍîıV\^‘é7k≠™ñ*]ÑAV*C„¬T	éµ÷ˇú¡\Ø˛˜ 4˙(S©]Fﬁµ	ö™6—Ç\[X¨¶@/Ÿï4QÄjP∞zª¨ü0˘¸B¨y¸êµÇ(Âåb¢PD∞∞^7≠˝5;˜ëe^Ñy‰+É NÒì[üâi÷8Z≠·gv·Ãóﬁ5_ xÂKœk§à^é”vWóC*n¯F&£:≈≤&]±Í⁄ÉöSÃô◊Ωk‚äïkÚîØí´.ﬂ%WnµG∆ù2§´ Oª∆V2™µ*Y»/ïH„n)øÌl£jNêã?È≠j≠ÙLWÖAΩIh≈u≠⁄ÖuuÕüW œä™‰Ô/^D:6~êìΩ¯¡;`Â∞íh7¯Í”IÀ®dU◊¡åyÉ¥⁄¨.Kô˛‰rLÊæáÆHÌa§Ç√rÖjoÚﬂ^î÷\¨â∏cÁObÙDhÂ r≥mË‚
¸ÙQWlQ,ÂÓf‚Ωè√"äÁ⁄™;£—kDø›-„Ï∑√ª!p¶$ŒvDZwÂBà¿R<Æ¡¥ºı§ì›r1ƒWdvpÁ®=î3~»∆‰G…sRµGGã5®É_@˘ÙIÇt2˚ì∏ëÖ∑qd≥93|ú)CKx Å^+?åsÿı¨U„9y¯Se≠o(õ∆ß∫ÅóV_ {>0„Õ]•DQs9U}µ"‡ÊÜIÊMóZ=‚ØFOæ U0W-s∑.Iµû¬YùΩ;∑¢Ë≤Î=™πú⁄∏¥o_t£ˇUÔÏÉÖπ
Œ¸•Ú]£Õ˙g_Ôc“.o¨¯îÖJ˛ø˜k–Ωºx≠V[oõH~ÁWúµ"∂¡⁄'´éeµU≥MïÀµx®ë∞qL)?æÁÃ'Ì™UúásÆﬂπŒæ⁄ûJ◊ÂwëJúﬁ\ﬂMÈ\…¢ŸÌßwUŸ
x‹	)<Øÿ+Ÿ8ú_üè¬ﬁ?ú∞,ÚBl·lpzãG¿n-˘¶:4≤*ß◊«cYdÿ-©‹cìÌ`±Ä+π?ïì	|É#6çêÙorÂíïô…µÃÄÌüS´¿hãÃˇp≠ıZ¡eÅ)Å>b!k„B
KP,>«jMö5tˆ√Pz_≠]&ˆ.û›æ·À«O}V|∆jÄÒ‚€"çC0·SBY7‰∂2˙⁄>L¨ó&Ãaà÷Ç4éX∞ ;Ç,˛‹¿&å≤DB¬“ëä≤ñK»í¡m≥ê¢9…√¿BîdËø™ŸáÔù¿Ü„cê§1§	¥Z€ ›∏CGß7–¿i=8£Ecnï’Å‚ÀN1ùﬁSÒ¨SLßwSº°ÏnBÿ–ﬂ“	‰+H:¡N	∏Ar*†RØb§Éˇß
)ùN–7ãŸØ!‹√Ú=<Î"~Å'Æ∞gÇÚÈDE}qVS\WŒÔ®¿Ñ|,®÷ﬁrUﬂSYõ.Ë5S#EòÑ[=&,n7‡^Õ£/qf”`]ÅÈ[3b÷ñ?á÷¶§¨0J◊t±ßiH≠F8äFÈàGKYV€≤‘◊„ˆ2Å{ì˜$t;ÕeµˇÃ|ÃL”s´	{"ˇEcjF£I1\{⁄ã˘oz=Ì5¶|xπÃ»T?˘0SàÄ.˘gaEŸ¿¢Q¶¿)F0PAV«„˘eF √ÅÆ3§AêF1%àÑá\+Ù£‘è2ﬂ’UÑ…£µêÄ>§>dæ∫dT<'ﬂÀˇîı?L∂˙h˝±Ôc9ú/a>FS'¶~X÷¥§/@<Ò∞•°ÔS–'€8ÛmDM]–Æ¨&©ŒpìÓl+…)$^ÕÓŒÌ◊û^∞v±â|÷%öçíÙ(§ÆUSz™€tröÊ£≤Ù<Ø,ÍõùYŸ~”öå;µ1HÔm˛Ï`¨wZÛö‚jèºSI˙˙˙óDó¢í∆Õ¶/b{ ö¢:‘ê◊‰]˜=VÔœ/ﬁ PCCû¿íƒiÒ6jÒ6º*’¬5Ω` Y2À‚pú«DWk7gŒﬁm⁄ÌQC/Ü%ÏnÔA1ÀE≠´Ó:·w j' §∞ˇQhª;+ÓIz.µ˘"ØŸJæpØπ7(ÈDtºÕ’}ˇ∫‚Dv÷úÂìfœ}“„ì5_Éﬁ‰>Mô⁄˜<ìQ∑tHıÎÍ∞¨çë¥@»¨zE°~?©Ç°°DOÀ+⁄˝pVÑß}PüRB∫“¥5ª√àïúz	)+	#ıoDÛjRX›ß'¬AGpFx…pZ© m”Q9z? ru<'„á8xú;+˛FB(7?•4'U¡1'=5©(QœŸ1x¢å"≥SbÒDÅÃ‹Ç¸¢óƒíD=üÃ‚íç’›ñôi
9©yÈ%
â
∂∂0vYbQfbRNj±∫BIFjûÇWiq	PAjNq™Ç_~IFf^˙dQNıÖ¢‘≤‘"†®äB1»¥b.  ö•PúüSñ™P@2–V!Ø4	®>-?'•HAC[[S!:»œM,Ä+€l≈©¡®≠†Åf∫äBNPjJirIf~^±ÇFZ–
i@K57WrÖ0 ª¥SÚ‚3Ä`xú•QMK√@O1Ù–É
C)d”n IøÊ‚ÕÉ° !»T7m!65€Ê$‰G¸=
˛-Åq≤€Rã'uyª3Ûﬁõôºü~úønå"Dó£«—Áÿ‚ÿÊÿ·ÿÂÿ„ÿÁ8à‡2ëãL
®√DÃ/S«P√xÆπ»“1ÑD8‡éM¿>}ò„Ÿí’ÿ€"©∑ 
%ŒüBÖO"ìk;2M«ÅgêiíHfsÅàß.gÈ\ñπ  K¯e”#Ã‰ÆÁo*•t°¥ˇ9ƒ¡[ÉÉæ≈∑∫ ¶¯õ:-Go)ú
|ÿõ©Ç´ï§1ÚtÌüå˙æöÕ[ΩKˇÄËë3öúZ"Ùı≥•°≠°£°´°ß°ØaPØ7∆®
,«l6Nœ1Y	{˝i&”l	høé_éä≤ ©BBilù0'ÄÏFıKÀ≠·E’‡Èﬂ™y<¢Â÷éY=ZJÑÂGÀÓ‘ÿ#.Ä…’XMJ…*e#õ\Ï≠¿∫R9;—◊Ît9ùÕ'•Nô_….’∂πıxçW]s⁄8}˜Ø∏Côâc≥°oLì©óÊ´√$$–<Ùa;hb,Wñ	ùvˇ˚^Ÿ∂¿ˆ:OóËú˚•´#Î∑˚a‚?ﬁ}ÛÔn`NwQ@$Ω'ÒÇÓø÷Ô“ÚsBbˆúpI„”•ß='+∫öI¡¬M
∞v|ï¸`CÇxcÊÕÔ·}Kµ,∂ã∏ê0!·&!ÍÂA·Õ~Öíéê2ˇoSM˝ôêÄ≠]Õì€ù˜Ö≠◊@bœ	UQßëPËÈ9˙ëƒõ”ÉTÎsΩ>Ê°<¸(
ÿíH∂«™Ë!ÓI £‹"pØ·ñã]êb…~◊Ïpˆ◊$FèÿØD‹ è–Jˇµp‡˛ÆÆ‡¬Ó;p⁄1Å˛—^0◊Ñπ5∞û	Î’¿&lPÎù∫;Û'qªﬂYLUBp] ` KB»%DDƒ¥SÍ6;î6fùÑ∂)≠m’∏¯Œ†¥∫«Ïà	ã‚àe∏ô2kÅòSéS€Vã∆O√Œ–™Ö-yú√∆h’¬$Vüyõ£U√Sßqæ2ÎÅE\_ôı¿"≤ØÃZ Ü€oÎÅN±‰ Ü”@,∫®™÷HUv¥]ﬁ-≈W•7@C∫A-ƒÍ«`è¿v/z`ÎÒÕGíü¯…TkÇ=aá˙!îtC≈gZù±Ã;:;ÅΩ†¢êe‹ÿk¡wzIy(hÈa!üÌG≤£`?-ó©±w‡∆˘$ìàa»)√S“Ê5®T›+ÏãJ>ˇ@OŸâÓ÷üÈQ˙}à∑¸PQáX¶R«\ïBﬁ¢„äM`‘¡Bu∆J[ìU€2eP“®EÛ∏åÍÈÓzÌ›ıZ∏¥w7h·ÓüˆÓPk´´- ùÅ≠Ù0õ,ª$¢J0ë\Í°AJ≈±Ç•Ù≥ÅÜ;W∑∏Å4C	´
≈PÊÀ	Çë!™JO{%¶äÖﬂd°Rë≠»P)Rs©
FŒr4£a2ï¥Ê$±ã€*öR Ü$±çï4Ã±âÜ}¨§aéM¥L∑kZŸHT˘TïßöŸHTU+R-ˆAã∞íù3ï6a/π˜¶•x∂‰˙áBò§[î_¶£wçDö…îöR6Üßê.é◊»•Î;ºÙWö2L#Ω,."V§˘äYÎÖ.Ïﬁ“€£§Ÿ'ÇØï‰Ù#Œ|¸>ó†‰˛TÔ≥Ö+»›XÍ˜e
¥K7Cn:˘-°/ãå≈|u]ÏÒj^8©√aù√“w˘âÔrà°⁄4X÷).≥Ä[¸ﬂÿÂ>Ê)¨⁄%Q$¥r,+T _S|è…”-ÄÏôf@ˆD`îπóÑYæA∑‚aÓ	ä/ƒ%ÖŒ›˝ÿ{Lv^:ù6ÿ[| ÷ËJÇ&pñaˆ]—Ö©·€≠{ú¨ƒ≤\wE€„cfÍÛCèUˆ¸t]»øJ∞Êr£p‚WÍ›à3˚¨üp¶ë≠g”g´QÇÔ)éü∫◊∏aüz◊∞∞˛xöj#já`xúª)w^n¬≈ç∑Î¯ ∞^∫xúSVV0–3‘3‡‚“RpÀ,*.Q(JÕIM,NÂ K≈≥Bxú]QKèõ0æ˚Wår⁄ï–ˆ!ı“õŒ‚ñ`dúMs$‡Øé∞i¥ˇæc'˚™ÑÑlœ˜ú‘û_&sÏ=‹µ˜˝Î∑kü‰çÎÕ…zKH•ßìqŒÿåÉ^Ozˇ«©ΩÓ8LZÉ=@€7”Q'‡-4„úı‰`˜æ1£è§Åµ¬§Ôë∆ŸÉø4ì∆·Álk‰ÉŒ∂ÛIèæÒAÔ`Ì‡Œ˜ö,ÍbqE:›`Fd”˙„{;{ò¥ÛìiGÇCÌ0w¡√ÎÛ`NÊ¶‡± Hgá	ÇœN∂3á◊1÷yﬁ∆ı	ÈL†ﬁœ/]∏lıPò„ãù¿Èa}«¨ÔÓ‚™ês(‘ﬂ*ä∫óﬁû>'¡äÛ4¢§Ób\ãïE≈g›˙¿∆vÏ£°‰ÿôê»˝$D·S≥∑uÃr›Ôh=ZΩZ8øoıˆ‰˙ΩÔı≠0›¨∑˘g
ÚŒ„‚v∂S‘˚?ÊÍÁj±R[**)ûx∆2X–œã∂\Âb£ '$-’ƒ
hπÉﬂºÃ¬˛Tí’5	|]úe	2-6/aâ∏R((¯ö+$UÇ‡çä3ƒ≠»ö…4«#]ÚÇ´]+Æ ¿πBR
ïäßõÇJ®6≤5C˘iK^Æ$™∞5+’·%ﬁ{¬‘9-ä(E7Ë^F©®ví?Ê
rQd/óù—e¡ÆRÂé§ÂÎ2∫¶è,¢≤»8vs∑ÕYºB=ä_™∏(C'©(ïƒcBîêÍ∫Â5KÄJ^áBVR }®"í ÆdWñPupMﬁ6Ç#!≈¶fÔ^2F‰™¯„˙»?)–Qπ≥Yxú•TMo⁄@ΩÔØòí0£–èâh.ioiz@TYÏoX{››1±•¸¯ŒÆAI[©Í≈ﬁèy3oﬁ<˚(%“¡nL^*ç#R9¬Õ|—˜°Öπﬁ‚⁄JX4é0èÑXæYﬁ d'∑{¥Nôb’œàJ7èUæç]¶Pß.Vfúµq„˝∏-ª˝ˆ⁄Q£q∂—í¢∞ãå3Èv®ulÏv\vËpÂèï“),HRÂh≤rØ‹(Q˜Xèäe*7d^Jó≈ˆö˚(ílñKn≈FˇÑÁ∆ˇ&ò≠$√ÅV;ÑTm6 -/LÅ 	í#Öc—ÈAÔ#¨r-@páy…"·m'âgg©‡‚2!µG¯ÍX!Zäº Wï•±ƒâé+ÿ“ %e»ï»X‹p$-Å≈RÅö°«'…∂Y¢z\Ú^Z%◊]€nTÅ)¨‡b˜æ†Ÿ@*IéfO∂J»XÜÕk…Ù—ﬂ*<±Órç⁄<≈ÅΩ8áCQ«±tÍ∆,˘úl5‘0É{Ë’Ωﬂ]6ÌeÛÍ≤˛>Åòj~ÚZ¥´…†œõË$6ÃØÇà†˛‡›†>≠´
g47∏¨/öŸt2¨G¸zªü+G∞Ï◊√˜„I4Ï7√—%/V'pW≠ª∞ÀhÁÆ˛!Êù¶d¨`%!æYEËßRl™"Ò∆ÇΩ¥~ZOä2¯R‚ÅÚd^Y¨√˘–\Ó¸‘e± %µ«∞i_˘za|Ä#.˛Cd(Sà5&ïGu°G&9ÚCÀc4oU±ÂÙ)∂¥⁄ùeTÓmG"∆w∑B‰çß”©ˇP`tÂ_/áﬁ3Á˝ ÀÚπ‘,Ï≈ÂÛ ÔûWQ+Ï¸W=á°›∂≤g…?ä¬y≈R „Uˆ9&¸˛?Z!KHä∑÷„Ω=xuS…n‘@Ω˚+JöCà4mœd#XÇKÿHDp‡ÄPT∂Àv+’›C/3ÒﬂSÌY¢ 8¯–vı´∑yù„<Å∂ΩÛ£vv	Å®Ü1∆M®´j–qLMŸ:S…c»∑yƒHÃUàÿ>Vª¶2"˘™sm5°·á÷Ÿ^…œò•Èäbﬂ7‘Í^SÄ8|˙|[ÚAv⁄N÷Fp=lô¡-j∆Ü	^Q9îK‡‘eyΩ´á1Ú§.VÎkµz£.÷K∆VΩ.◊´Ú‚ºt}∏≤^ÁÌ_\ã|Ç_B
	ô'V4xbaº%Ë¥ß6:?ÅEC≈ëU](8+œäxd4õƒLÙﬁHõ=°°≈aÎ¢∏<?“;Í¬÷ê2:Õ‘™º</Ù=™é$Éb°`Eù2Ë;∑≥2#BWô√WëÈu'|©«ƒz∆∂»IîLÅ_®ûç~∆.y<ØÄ√
/Ÿ)	qˇ EÕ°ÜËÂuwŒFÔv#IÑv$6“)N9ˆZ¢îDs¬å£\
ìT√(IËË˝N‚0‡—˛ˆ‘È¿‹´úê∂"Ê–èVj!x~WÕSÍπÖvÇºﬂÒˇπwoA¸+Ø˛20Fﬂé:JÓI®â∞π24˜dnå|Ègï?D≠€eR˘j˙ÚˆÊtx∫Ωy∏π ∂}»iû*ïÄ‡sPM“‹â^ﬂ§mÀ©#%Mî~VŸÕ*∫JŒøNC¨õ¸^LÀÌÉ7xúªÀ~É}√lFÖ‘äí¢D›î‘Çb+.]Ö¥Ãº›‰¸ºî“Ã]==ìÕeô z;6‚9xúª¡~ç}¬sfK=ÉâØÉ6€1Œb I¡*¨xú31 «úÙ‘§¢DÜ;}KõÉu˜ÕÕ_t∫]Ck’<IEC3Ö‡Ç‘dΩåbÜ*?ÛÙ≤0-ˆªÏuµ1¯È¸©€Û°JRÚìKRãKäA B÷5˝ﬂcsOo€ñØµì∫åûñ}ø ¿K,ÁÆxú31 g«`/È?èÔVªû”[cx`õâıÚs ô¡\´xú340031QpJ,ŒL.HM÷À(f–∑):Xππµ˝áŸè®7øj◊⁄‰ˇ1Ñ®s…LKÉ)sN‚ô~⁄=qÀÎOÂèÓ«Ñó'z0CïπÂ'Â•ÅL-Ü)?ºx˙]s˘è∂óÙﬂ7.8bwè)5™<8?ß,¶Óèˆ¬”*™≈Ø¸}Á›Â¥…=î≈fñU‚S‰°<Ô„Tµ+Gújèv~∂ÔõB‰Gg ÅmP˚ÊÄ-xú6 …ˇÀÀê∏
M£ç˙ë(Ä÷]m˝ñÒ°—úãÒë(j“|ˆ?;jƒ6PîKö˚çJË‚È„ë¶%‚úm±†xçV€N€@}˜WLM|â!xâ0R†•çTï"”ºî"úxñú8µù∞‘ÔÏ:∂gW$‰ùsÊÃum^Ω#¯2˘˙È˚‰”Gò≈ÏÂ[X,[ÂGﬁ„ïÇ∑õ0èo7i¡r8 o∂,K“0bQPdÒÍ©É·*
ìt≈>∞,ﬁ"ÈPÊ:a<û'l∫ ëΩËä,“5ãÓƒöÕ¬,ë\∆2ñi¥ILí'6œ¬„´Ip|â/Ç5[Äµ„Ur|∂·ÂôeÃ0‚Â:Õ
∏cyq¸Y"ïÖJ»@Ü!Ωa<ÜÈXvyÚ·Y˙(I√‡ùÖ…Ü·£&7—òÑ4	”ÿ5¶ù4ÌL√P"Ë»‘¡á(5 "ñ/≤xŒ¿Ã1”$˛%¨¸wVÿ&º/	 qÅ ⁄¨S|ÜHX[år⁄ı#=yÃü”M]≤Gb8¢÷Wj˝Nµ˛€j}]m†‘ùjÉ∑’∫⁄H©≤ÑQß‰Ëm… ¨R¿÷µΩ2’ißÆ˜πNkΩ©3ïÒÙ≤•ï¥›ìµ5c£àDñ≥ÂÁÇX L˝Ô2\∑jr‚úk\<SÓuò‰ôüs«—◊•4QMû_8\HÍ–ä·
ﬂÆûwµ
Æ@HzpwË¥™ñ ç£(çf· Tê$/ÅS>kÕP¶=á†‚÷Z⁄Â¯[)π£V.5¡›—åPHR›*5]níÇ§°&Íp,Ò†ïé6+â◊)qUèr“æhË7"~Nﬂ◊◊Ò>Â7WÀ¬ímG¿;8ñ!⁄	V8ˆ∑&P%}ÚåØÒU÷ﬁK›ÿNŸ"ôMÂ ZK£x€ÓË	v¥UÁâ÷Œ¶L‘Dãh-ò2ìÿ¢Ó¢P›wv•˙;;Ä‡ƒ_ÒjKŒ”Âv©Qù∆'c˝jTÄû|eïÙZ—ìù≈∑ïÀ=·ç‘ãf(<˝>WΩUî ¡¶CÛpôΩ°°ı7carx¯qx!ï™/öÆ”∑:$(Íﬁ`Ò¨∑âF2-k˜&ø7aÏé°9<å·
¨´)m€Vò‰â{”6ÎbUJ]q`…D£k·˜)’äÎåÖÄ5˛£BÔgY…?*‡‡Í‡_¸é”KûoÊyõÇë¶®vI ~Xº7∞{ñËÌü®-;„∑>]J¢ìIvjdx^ıÆ/8™dÂWŒˆ	î<¨Ü$ C´-tëJTœåøB≥ŒÈ	Öyxúky-4—Jy‚…pfßƒ‚… åöÜn˘Eπ•9â\
∂
JJ\ï
VV
0¡Jê`•Wí‡‰r∆v˚£'[rr0ì
ˇ+◊‰’L⁄(b_ò¨ë˘õ}ô∑∞ Ù4`Ó+fxú{-¥_|?[ΩÇBfâÇRjEAb^äÇÜ°vÖ¶ñÜò‘®S@RÀH»TRPQH…ÁR òº:4ä3ÚKsRúRå¥*¥Ãµ4*‚å4a,c”ƒ4±Ã¥*¥*Å¥%DòmVaUVB¥U¬ÿµ`ﬁf∂F†ßRRãìã2ìRî“ìSê\Ú,P$ ?ß2/?731GAË0MÖ
[[ Å‚GÏÍêº§PÅ›Ãzh¯® ›¶]	t[Ö∂08∞ÖÅVÉ˘¯l'≈¿zdGÇ%∏êC$'9-DÄ"Hva3’ªe@7†8bPy&!ªûæ⁄†™6Á∞Ød ∑‘¿ÏÅxú€/~IbC4ªå~ÖVÖÇ≠≠B•íÇäBJ>óhTÍWhjMvfˇß´»,QPR––0“™–‘◊®‘‘‘“–5‘‘™È‘5™ÄÍÖ(UPH≠(HÃK*«PØ©êPúë_öì‚îö ‘®U±ŸÜ£ô î# ∏0xuêÕN√0ÑÔ~äU °È*G§J	UJœ∏Ò∂±ÍƒëÌPßàw«NÑ$\,{fˆ€ë?∆=xú?≠^Á´[ÿr<ΩPcPe∫7˛$Ms]PÕ◊Ö4®°e>ø£í2dëQ<;tD"C3FÖÃpâäøªPs'–Úù¿áLªt‹µ)äeélSÊ∏•äSÆwëT≤B Ã≈wäNÛh≤‰˚}îc˝îÚl⁄›C8%®êûÊRÿ†6ì{Ô¥ï…∫‡Òqë`|¸6õx_¢Kw©∏I“™ !~9\_√√3Ù√˙5ÉƒØ¨bΩª•¢@wùA`R˛H•ó Äú§≥óŒ!ƒGæıòìÄ°éﬂ!Ã}B µ¿M-ıÌ∞Ÿ∞·∏!oÑÓ·M'≤Ïﬂ`ÍêÕŸ¡ˇ”ﬁjÕ_ÏoÇÊYﬂl8,áÁÓÕD/ñ∫¸yp›ªëµ◊ÇM/-˘ÎpËOÌÅixúÎ`;Õ2—Jy‚IØ…å<ÃNâ≈ìÌΩ›ÚãrKsπ*lî*î∏*¨¨`Çï ¡J%Æ*$¡Õ[ÉùöfjHxú;Õrêe¬ƒç≥70 k≥æXxïS€n⁄@}ﬂØ9}∞¡ãd»•çƒâZZ©jH˚Ç@ÒeÉ-˘Ç÷&]SU øˆG:≥6ŒZ–KxaÊÃÏŸ≥g∆?¯|û}ôùÕﬂ√›ìêi·G"ZT2…7%úÒüåeE¥KÃ“ç§?∫ù-FsYπê7~ôîã≠¡Œ¸$w°ƒÿÅÔ±êÇ±$€≤Ç{QV£èT9 &RàS8ˆ2©‚¨wä¡{‡˙>›ÅÌ4Ÿbb◊ó3¶®˙°êŸ.ı1ôÇ•,Võ`M`m±Ω	Ó	‹[å˘&Í#z˚,ﬂbÅâ-X,4Ò∞≈C$z,≥%Ä\A˚„0‘É¡ÜÄóuè¢!(*ruW[^1¶_à/[êè:ôBT`=e(ì@Ä%E¥´§»-x”‘ í ¿¡V√‹⁄1 ∫c•Æ;∞¨WP∆≈.çnƒ(-‚àH˛EÖØ"CqS÷–aSOùÕ…±°réUÍ˜hôK<Â™’±ªƒ◊ª‚ÑH˝X˛ô.~ÿ vÂ'©éLG·msœÿ —·Ñ¬ı∏IGÁ∞Ö ä{cﬁﬂ^3»_œœú√.èÑƒuxi±ÕD^uéò'éÖ˜™∏¥/£◊¥ñÀ.¢m>°Ωn¥◊kc£{≠á˙¯e„·’6ògπ7!!⁄8ÌïßÌ4=TÎÛ#Cµù}û+‚yK–›„K
<M2iyh-´Z_ö4ûfy◊±pÔ §i≈i$¿’˙¢3u’FÏ7T9uÇjÉ,xúÎ„n·û0s„‚◊, Jï±nxïT—nõ0}˜W\—=@¿Q	y™ƒC÷m]ß©]Góó™Rç±äUG`Rhµüâ Ö§ÎˆπGÁ__¸äO‡Á‚Í‚œ‚‚+,9{˛EîbyVú‡øËµ_º)I¡oJ©XÉ‚ıÜÂBíÑ%ë yˆ8Bâ…"d∆æ∞úo4i(ÛM∞ä«Ç]fÖf”1ßà 5KnÎ5[íúMnΩ–J&•`∞è,Œ…Ù|M#)6,Z3
ˆäÃÉBØxNYŒ‚´µÃ‹≤BMøõ ôﬁîú>ùßå>Ìä}}ìb◊ôsïÆ⁄w8;ÉÀk∞ùvBj<õHU¶∫$¢dzÇUY®Ó†⁄@µÖ^:Ë≈@/B§√à∆Œó`≈o—ÿB¥CÈ•Z¢…°˝#”ÉfB"@¬
öÛòÅµ"ä¶|jq Æt∆…dõÃ∑Wh»`‹Ÿ}äTñ"˘Ã‡GY(∏ª◊˙≠ôºß‘2kŸƒÛù∑Çn<©é≈kEkL¯J™TèËõê}M7òTc«Ë¢Éÿ±8ﬁ¡Ë.›Öﬂ»’C›¥˚êıNµ’G›˘Ò≥ÌY∫Û±ÛQo˛S¿≥IÂ˙ˇÈ⁄í«]˝∆œzÕÌy-Eù…'
Û:‰=C3‘˙Æ¿Ö@ˇßΩ
¥d∞uŸ®Ü◊â˝n õy∆†§µ¸CZ˚¨QQﬂ™Œè'‹™nY£™A´⁄5Eåë|º!ÊÊ˝ÒΩ
p≥
`Ø3‚7KJ™∏Ã
∏´‹k&ÆqpﬂÔ—∂†;ÇÁΩ>çhá°Ón3ØÒ˛4ËîÕïvi_ªÚÃ›◊6è¬?3˛‚.ÊÉgxú{»ªäw¢ïÚƒìﬁì=yòùã';0˙‘ªÂÂñÊ$rU(ÿ*(U(qU*XY)¿+AÇïJ\U»ÇU ¡*%.ÆDd—D†®sòÇR¢W≤xT<Iâ+Y<"æ˘?„#U »,⁄Ø]©]ek§S°m§U©m¨Uek®c§ù<èMJJªJIZ.≠k4˘ õò†Å¶éF•é)ê¨“—5÷åÂ ÁC≠„Ä.xú[≈ªîw¬§çsRYπm≠u*t+m≠åc'odû,ÀÊ'cke§S°m§U©m¨UR`§U°]©dAMg ∫ê¢‰Ixú≠é=
¬@FëA±Ü`a‚61ÊßaR∏J $≈÷CÏÏ-¨=Éç•wqñµ n±èæÔ1◊˛}p{ÿ÷
Ñz€c’Èé,·jkO‘”~]|Ù+O‡‰cËQÜ~ s†îøô∏hò|!-t"AJyÚ*‰ôªK§®p`
ª¶˜5TÚ9	dÖ\E-‡dåî\¥Ç≤V– ≥lèíÀYoπﬂÉC‚«T÷«¶:K¯◊©†¨ÓpÕ-„åØÉ»`i$©A∆(z)R…∏=xïìQk€0«ﬂı)é¥í“¡
Ñn≠c]∞◊ó≠≈æ4"äÌIr+”ÏªOrVÊƒ)l·”›_ˇﬂÈå_¢3¯<˚rÛmvÛ	2‹÷íL∏ﬁ†îp˝"/}¡ù¿ÁØ‹T•◊b—Tı‰Ì*YÒã‘(Q>ûê§ÜóóUâQâ''⁄\K¥b)q^jßŒOë“º™±»⁄Ô∏‹â˜,≤≠äF"Ã‰#.èØfiú%iç9–-Â¥ã<ØQ!!b[W ∏ëh'æ2ÃƒãF‰õ´5Êõ◊bœ¸5ı≥·R¨Gd‡≤ÑœÜÀKòﬂe˚›÷ûÿ5DH:AÍõË6S(*P†ŒïX"åÃ:*ƒj5ÇÛ}†VU#ü§6úå-Ûµ‘v§“0à>Ä≥œ9Õíÿ+·˚Œiw˜˛Ωªg0ùL:QﬂÌ·"¸/«¿©CÁ◊s•ÅÖ&Ïÿ|ﬂÔ√ª?Ñ–˛s„óÏ14Ñ£ﬁ{≈Äo√6¯À§v‹2?0:/Õÿ-ˆˆÿ1hó⁄-JöWöZ∆Ø◊ÓyÛ”Ùép Íj`Y‡]›r!˘™>Ï‰Ç8xúª¡˛çmÇﬁDo«âó€ô447G1÷1 X‰Éºxú´÷UVÒÙ˜éw˜pV–uS–-HœuS»(.HM÷M…,NŒ/K-RP÷≠Â ##iºxuO]k¬0}ÔØ8t.Ìª8AÙaléŸáÅ»à…mh{Kö(˚˜ãïmÙ%·ûØ{O√&‘Ñe[ú*rî$∂Èÿy‰‘˚tÕ˙¸'IsÃfx⁄`<πL0ú R¢√\.¥Ô‘spöråPÿ÷@§„≤Êƒù
ûKj3≠™˛lîv‹ßï¿|Ge®ïõ`4˙éC¨:)Î/{ ≠zä8? zèN˘
rè \ãùê‹˘7i[]C&ÅÈtPÓˇ‹ØÏ+€ñˇºg⁄∞ˆ±xÏ˚≈Ç—Q`7ºB~lé‰jVÜÃ÷ªò–ã˚µ¨K:8ï≠ñ€¥∫ÜfQ¡Œ˙™…÷∂(nàÚ«ƒä›†ÚØn†ÜCˆ…7ÎSÜ‚‰Åxúª√¸êqÇgJ~rIjqâÇ dm∆v~ßƒ‚TΩåb%. àÂ Â÷
√i/xú{»xùq¬îâÛú3Qæ£xïUﬂo⁄0~˜_·«m¬™=Lì:≠£¨Ì‘ˆaT⁄≥qéÿù[∂S¡øsê@“%ñx ˜˚ÓªÔ
û√WzˆÇdÇ{ÚŒ+S¥≈≥‰*ôø+åı ∑dì[•Åï]‹¨>ƒe Gotk«ÈjÁ‰I
^8eCÀ˚psir∞<k'.C∞˛Îtö© Àu"L>}-ãW%πó*7¡LÎ≤¥P¯∂1}zx!µÄm∞àcaèãÂÛjIx§q«œ˚é˝äË˝!…π*˛†©Xeë”¯û°ñé˘∆®0vÁT&C”3<@f‹Æ˘ë>Ò 'ÙπÃ¡)A÷•“);{Jï“ï ≠4_sÕŒ∆˜ÌzûÃøÿ«ô7•PUg∏êº»‡—dIûí30ƒø˙{ys˚¥åbÇ°3Ê¿Û⁄˛©ÚæOHùBt‰U¿b©£üj¬Q‚m∞RÜ∆ 8JÑõ€°5ˆX˙CΩ©ráîΩ(Ö-FáîÂ&-5‘≤≠	BU:ﬁ‰ Ë®í¸‡‚(ª^[sa‹@ML¡8r>$Å£rr´6õqwŒ¨ÆXÉÚ„,WFøç≠&Yn-/“a›:ïU¡ZmvcÌ
\#áª4÷NåŒÒß„"¢tl®}ª∞É[◊@bÚrèÛŸo}
äÙÄd∫F “Îk˙9˘‘7Bd]´±iË/h›Ø∑ç+◊Ò&HU5∑E†dR0S¯1‹µ?ºrù¬Üó:0ç¨RxY2FæöÕg$6	∂  ¿◊hùTut™EÍ‹XnÌæπëeŸŸÌAvTE"˝^„ùÏ*ˇΩmÏõŒ‚"…ˇW¿ÊKÄzëoN‹÷h1lU&ÊC™õ„}•›§¢¨≥+å@©	\õ“Ëî¢2jvº6Ë"/à° ë}ÜÍV∞™‹$©⁄¶Ç5≈Vˇ©ÙÔ4§cyﬁ•£ÄëßÁvéa¿Ë≈¡ÛWÀJYêœ.ƒ√{—”H,ì.ò‘Æ…?Æçæ#ÂÑxxú€'≤VpÉÛ‰&Â…Áò5&±pzÊï§¶%ñ§Nn‰PŸ‹»∫ó ¯Ò†xú340031Qpv÷À(fP:h‹Ê∑oÓ¡âM…ˇÀ˜®ÎﬁR∏kb  õ/|‰µ[ˆÁ–âEM"‚=ˇü%´•ﬁ ˘îõÆxú340031QpJ,N’À(f∏sÍ+_U¸ıçr~›˘ÔÓ™˛Â¯yCàóÃ¥4êíûA™[/}u\ºƒÎ`∫ÖÕí;n\P%ÓE˘Iy©E@√2ãAJe^œÁ≥˜€·4=9e£%üÆiä› £P•ûy%©ÈEâ%`[?≤≤}yX|#m¬ÆÑˇ_πjú‹^,[UúüSV≥ÿOºzkMªªÕewS˘U5zøˇÉ™	Ò )0…ù6≥EeÀŒ€≠g∆∑Nq~öˆv UﬁY¢ªøx≠V€n⁄@}˜WåúJ¨Nº!ï“RT5"ÕM™%,âUcSØ!Ü¶ˇﬁ3∂±Õ%5ë)“2{fŒÃÓÏÒ¸vN.{_>}Î}˙@◊j6˜d§>K˝SyﬁâÛ«¯]⁄æZHÌ^-ÇHiﬁ2f¡d·)Íyj ”~ox:#ı"==™PÜ;õa¥Öy'µ:dÔNß˚{…”KWG¬_å-√pz&7>]¯˜ë¯lø∏∏ OESón»åÕç±Ä«≥Q4œZñ-‚ªñµèIÃ9Æù‡⁄áp⁄ı)∂2§”>–"∂,£ ÏtËcŒû$Á‚¿≤1uÍZY¥F¢à”⁄¢zŸ≤Ç•Ï)ﬂä>â˛Ä~XuÏ<à$ªtV⁄s˙q<>eê`HÚ+~⁄€q˚$sV;ªCC>∑‚¨j∏À∏F›./ª‰4ÅCzC˝@3ƒ†ˇû)à–XOÆVTaÑdﬁKü¸ ¢πµ2À≈Ç6ãπO∆<ßˇ«à€ºÎÄ5πóñ≈ÂrµI±\Uk€¶6ùQ˚¨…º≤ÿ-jˇ5˜ZëùÎM†,§"¶a0§œÀ£t„?gw√èF‹p£óœÉ{>Ÿ¬°¥êIÎ⁄cŒ¢tÛí∆yºŸÈÍêIı:È«‡â$ØL:9°íqldäÛ—ı'xJ©pÊ˙–5M¡î–o*ûáJÎ≈çUc}ÍôúCçFê£Üπ¬ˇ⁄º-4Ò4âÿ^’◊gq¢1ô„.§mC¨ ùU&Z‹ãIÇ Ÿ©Ÿv*o£‘⁄à©˝«ìoãç2• ˜ªÕ=M¡5(x‚U£
∑7=t•K£M$6›ÏŸ†Z£,ê∞fÔqâéÏíÏlxóy)ÜtÊ7TÖÅ=VÇ@V[5®áÎ®§Î·™™A—’1›IÅÔ´Q‚yeÍó¡C%¶7Æ>Ç°[\<i–Úúñ–πÌû:Ág_n≤fﬁe_›ÌlˇÃıÜö™„Å¶D/J=}éO;»{º†O„gZå9™Hˇ8y‘åƒsÇ¥‡¸g¡ó‡1;º
èÅÂU¯≥j<§ÔA˘ÉBlr]‚ 0XÅıéïf¨ùq(„K^ç¶…y≥(ãÔS8·ªﬂ§ã˛DÖÓRFÓR]K∏Ôîícv6BW?~¡$àª≠ü•‘≥e;M¶Ÿlº·—c¥ßf
_Ëââ/d:\Ûê†]°“√ÅWÚı‘‹¡ºÅ;X2ˆNçpœÈHÜ,xúeSMã€0•¥'˜Zhi/√àÂƒ!)Ù6ΩˆRˆPzq“]≈ñbÅ,9≤≤IÀÇØ=∂‰óÙÙ–ﬂU:íÌ|–@lYÛfﬁÃõôø/_<	~¸˘ı;y∂ˇÃ_'0@AKÁºÒ{»Á¿˚˚«‡K¨ò∫—[òN·ZYgm_IÇá≈¢≥ÉÇ-<‡ÛrcòA“t–1Åd2m'øÙ@Ù—'‡Ñ/>çîCÔ>}UgO.„„˝“}µ‘°ä)ÅpOZ≥£†t∫Ç™î¬^—‘j%Ï˙0CHJ+!“2É¥æQ}¶F–•DãØﬂ"öå#jï1[AI@sÙNNÜ•£€MoÒ”◊%ôÖ0Æ	îje
ÖúáöCLf2ƒ«[á8Õ,EÆ¨B„*Õn¥¸™t!®¨a›Ê¥v9¡›z£Ì›9ÊBŒsOôˇ«Æª@Åé_(2∂2åπD∞ó‘M0õ3’÷∞é|ìNOgâ<aT˘*£Ü∑EAcÀÍ≤2‘2‡ïZ°™
FTi˛QõÇb/ÂJaÛ¬9| EıõlÇ¡ÃÓô‘eÅ“éÁ¥ßœáuÁ
vN{™2ë!2osfXSZÊÑUõ•ki”QÓø=7ÍÒN=Dﬂ˙õv6πe≥;‚åm√⁄eÕ‘ Êá€ˇ3‡F◊M≠∫CäFW\∏ÓxdmhÀf”∫›ÍÆf›®gé”_ﬂSSyËïÆM±ëtqºˆöaËzÅÏ≤…Cy–A óßñ√Ä‡÷ˆ¿óÈ˛Üù‹ÃCäÔ&üBÑz4n¡ı}◊k˜7¥CÂ!6ä¬3îﬂ$”µ'˛$,PÍ¨xú31 «úÙ‘§¢DÜø3;EèZŒ)˛dÆºg_…∆Iâ,ÎÃLLÇRìı2äV®¸8Ã”À¬¥ÿÔ≤◊’∆‡ßÛßnœá*I…O.I-.))Y◊ÙèÕ=Ωm[æ÷NÍ2ZxZˆ˝v Õ!-Æxú31 g«`éÕ'Ó_º[õx÷<”=Ì≥Ωo–	 °∫˙†xú340031Qpv÷À(fP:h‹Ê∑oÓ¡âM…ˇÀ˜®ÎﬁR∏kb  WÊ≤Ó´.+5“<æ,RÂﬂÎ¸∑ww ÏëÆx340031QpJ,N’À(f(Ox«·„i>«{ŒEµ◊B}Gé˝i{cQ‚íôñR2mØÌõÚ3/:¸ïœ•±˙A≥,Tâ{Q~R^j–∞ÃbêRô◊Û˘Ï˝v8MONŸh…ßköb∑Ú(T©g^IjzQb	ÿ÷\˜_˜]∑â;[ñ6UU4Ï£˛ìk Pu¡˘9e`5ã˝ƒ´∑÷¥ª€LQv7ï_U£˜˜˚?®öêe&π”f∂®lŸπcªıÃ¯÷)ŒO”ﬁn gpXÓÄJxú ·ˇﬁﬁêÖÓë◊sÜuÍË‹@{õêFc#ŸB—/ëôE˜®ñÓÄÙQxú[∆¥åiÇ©»u…â”‚	”è+€){&,^d0—Û. ™⁄f†xú340031Qpv÷À(fP:h‹Ê∑oÓ¡âM…ˇÀ˜®ÎﬁR∏kb  ÃK6Nz<≥$n«Fﬂı5ªﬁƒÛîU Ób6±]x≠T€j€@}◊W‰Ä%π$~µ©%5î–ê‘è-Îx/ï¥bwç•$˝˜ŒZæ¨'‘Éa4ósf4gÙwæèoÆéØø‚ûUŒˇ∆ÙûÁù¯Ø˜ÏÑoóLã€•4\€êW»˘2ÁÁè|¶X?ﬂı…ñJòE—üîÜ?*√j¡˜<QTRôÉÏ˚¶‚ß¸©§Ç˘{Ù;äÊ"k<œãcº@Ïÿ≤e˘`Ñ,≠4·åÖ*≈çi~(™∑π97®1Ñ_˚HLYæ‰€òìèhÇMe©Ÿ{ÓµM˜ÉQÑ´üpÂü‘QDe. ¿¢|oœ≤ÌÒ®mqg8I‘B“K–Ñx¢ÅÇ}uçß=◊”ê«≠d_ÇtÇﬂ!íh¿9sR≈q¡9˘ÑŒ6}µftàóÓ√÷:äﬁâu7D”•Ω◊]á÷"ïö=ú¸Ω@í·JhN©\)©‡?∞•4®ò“‹}√Aãıö#æ§n⁄>Üà∂Ù+Ω⁄zcÁYècGíM"ÿÌø¡EYgŒµ£+_”Y≈P/v˜AŸªC+º S≤ò¥«ïo¸÷Õuà`jEÍNnı∫Ÿ≤'Ù·ˇÃÓ»îa∂[˝≈—Úë¿GØΩê+0k˘Ët‡8gÔ~h¥¿ÁòdŒçF{Ú≠+(XÖπ»2z¶≥#aÉ%Ù‚F™Ç‘¯Œi;YŸ˙#µ±∞˝ÚÇ”öÊæ˜a”´Í*ÉxúçíœKA«qW&:Ô π„∂®Q∂CFTÑå‘d¬›–5vm≥¨ÑNì˘#:ˆ'ÙtÒ?Ë–“Ã6Ü§Bs˙Œ{Ô˚yo~Áø^äÉ≥§∫C¸A?›•é3xØƒ˜⁄^Î∫Iâ¨≥£]ï{0∂aR≤è»a¥¬‘0[V ã°&√X\À-{R≤k†ï®›Oﬁ¶‡û+∞,!-(A
müá*	ˆ©ƒÿ±ö—K‹Üßxå§9rDeŸË
+™y$õn`Ãû’<Gm±Gu.#√.(A
A¿ü≥Êπ9WsıfK—Õ–€ãæı©[∑;>òÊ¯î•Æ"ôÆqRπäêa\⁄Ó)Ò(πh⁄°Î∑T¯Íÿ^Î/m*¯ß–ÈC Üîm∫-rZ≈ıu˛p‡@Ä«Jƒu€£È–¿>˘o√IÁBŒ‘3êG˝FëWw6jÙ-^cÈ}ÄõÜÌŸH‹±O≈ì…Û@W∆xH$fáÁêÒÄæœ«≤Ï
Çxú{¬ªàw¬˙˙ú‘Ö
[Ö0•
%.]];;;ÖÃºí‘Ù¢ƒíT†THP√PﬂHSK£"ŒHSXÆŒ¨Œõ∫‚Ã<Ö
òJ]C†¬d∂¸bç
MÕÕååìò98TúÛã*‘'0{OfañŸ¨ ºü &x-…Óàxú ·ˇ¶¶ê5ÎXàÆßÎ÷ŸÀ8Ya Ú8n≤ø∫ëI›Âd¸†xú340031Qpv÷À(fP:h‹Ê∑oÓ¡âM…ˇÀ˜®ÎﬁR∏kb  sÁ˙Í⁄˜?~Â Ã’\Yú?3W Ù¶„ãxúC ºˇﬁﬁ#100644 Base.hs à¯Qòìõáô*?Ü(ª∆ÜZPë#:>/°Ø}u[' ]ı™UÚÍáOëqmTjÏÄµ	xúk>œ∏˘„>∑…n⁄ú
ôy

âÍZIõ'π}T  íp	ﬁÓäxúN ±ˇ¶¶ê5 AÖ}ï¢ñÑ$ˆÂ¡F
Çd ëI\§™€»LÍyÇÒ[˜»˚	À≈ëπ1àﬂóvÎ›0„ËEøﬂïK}îlrÒÊë˛(7&Q†xú340031Qpv÷À(fP:h‹Ê∑oÓ¡âM…ˇÀ˜®ÎﬁR∏kb  ëé™”OÆ…y/¥V”»fùtˆN ‹Æxú340031QpJ,N’À(fxÙˆ•PÚ‹≈5≥;ûµ36’˝ﬂ#jQ‚íôñRR˜>»ˆ€	á3SÊ˝z$tV<˘—;®˜¢¸§º‘"†aô≈ •lv˙◊◊ñF´+àƒ~]˙ÈïDª?T©g^IjzQb	ÿ÷VñˇK\ˇ&‹∫ix˝°Ï|ÂÎ¬W†ÍÇÛs ¿j“ı≈è,©Ø8]¿∂⁄∂çÅy≈]n5}®öêì‹i3[T∂Ï‹±›zf|ÎÁßio7 ”WùÌÄ∏"xúk>œ∏ˆ,„Ñp£îƒíD◊¬“ƒíÃ¸<[∑¸¢‹“úD+[+8;%µ(≥,3/]A#8#ø|Ú\iôçÈÔe6œîÂì›¸”j;Wµ.WJfŸ‰ö“RN˘˘9 N±BöB:–¿≤D[[Öú‰\ı…~∂≤ìW:òÚÍ÷rq•¶î&ÉÏúºQSjÚ}°ÕgÏ72NNq‹‹Áÿ¿2Y¿MõS!3OA!Q]+iÛ$∑õ‚õ˜«Y≥mNOïa áB§kÄç~xúõ…ıücBÒf^F ≠ÎÈuxú{#qX|B—∆Ê.~Ø“‚Ö¢‡¸ú≤TÖ¢…núÍõès™1N‚ñÿ,…Ã eH`Á◊*xúõÃΩùuC5£±Ff^IjzQbI™nZi^rIf~ûBf±Bi^JjëBJjYjN~Anj^âû&ó≤≤Bhqb˙‰ãÃá'˚±*M~«¢ †•q¨xú31 «úÙ‘§¢D˛π|›ÜÏﬁè¬ä]¥ƒ‚ü^7õÔs’–¿¿ÃƒD!∏ 5Y/£òaÖ è√<Ω,Lã˝.{]m~:Íˆ|®íî¸‰í‘‚íbê≤êuMˇ˜ÿ‹”€∂ÂkÌ§.£Ößeﬂo *m+kÆxú31 g«`Ü^{ªmk'∑.Jü|8U¶ÒxÚ ñàÓÕDxú ·ˇÀÀêíÔı·˛YhHœD,-˛ÙNˆªIïÜpë¶%˚'(j¥*xú[≈ªÄw¬§çs¯ÿ rË„ë4xús åˇ¶¶ê5ø‰êœfO¢ êÕO≤ä∂ e¿ëI\§™€»LÍyÇÒ[˜»˚	À≈ëπ1<˜KgÎﬁºÖü(õE3U«Ó^r_:100644 th-cas.cabal Ûÿ†èÌx)pO`|ÅtFˆ
Ùÿs4jÊÄxú6 …ˇ¶¶ê5<b˙vˆè5Ø$‹˜¥.·äËëI°‘·úáÃ·ïmµm¬'T⁄dæ§ë˛(¢‘Ú†xú340031Qpv÷À(f∏€;q∂™Nàtõ.ÀÉ]•:‚ºéõ HCY“ÒÛ◊~˘∏˙˚ùƒ3¨÷e∏ïÓ »€-ºx„ ÕO)ÕIUpÃIOM*J‘svV–‡RP¿÷©,HÂ“¡&„ú_ÑChl~QfIFÆûKfZóÆ.V˝U¡ôπ9ôiï\ö
Â©@SπÄ˘E%»ÓÉ8ã8ÿXƒ∆CÅW‹	\ ö_"lqxúõ√ÙäqÇÎƒ¯‹âO, !™i‰xú{≈¯äqÇ6≥SbÒDΩ05◊ NÆj´xú31 «úÙ¸¢Ãíå\Ü˚Ã/~=∂ΩH¿»L˘¸Àyß,πah``fb¢‡îXú™óQÃËÌK°‰πãjf1v<kgl™˚øG™ƒ9ø¨‰m–°≈ä˝úè¸∏oµ‹=⁄° )˙1TIàHAF`˝æ8•Ü£¬ã7p^úÛÎ+ «˙9_°x340031Qp…LK”À(fÿœûrˆ›öÖ?
”îkíìÓ≈≤¸ók0Ñ(q/ O K-rJ,Œ,)}˝Úi¡ı|ìg7¶ŸMﬂuW˚ä¡±2^®Rœºí‘Ù¢ƒíTê∫Ωö©,oÏ∞T˛˚ÀFÊ¯ñPu¡ôπ9ôiï eä)ˆm2Ã˝~$ñ_àõ9„H¬¶(Vò≤¸ú2∞Q{Œ∆Øj[™q…O]w⁄'Å˚…‹óg• ¨MöiÄ4xú;»8ãqB›ƒ•2 ˜æ·Äö}xú;¿yÜsB9≥SbÒƒ*?Y∑¸¢‹“úD];LÊ∆˚äÃ¯ULgY	 ê*Ê ÄïNxúõ(˘îwB}àSbq*Wq@~Ne^~nfbéÇïïÇ[~QniN¢ÇÆ&ä‚4Öt[Ö‘äÇƒºÖîÃ2«úú…mÃ
æ˘%ìCò5&ó0†
Æ`ˆëLÃ…	HÃ,Y]≤!Z£DßD3vÚb∂p®mq(g2ª¬ˆ…NÏÿ’U±˚i)(îg§•r) AN≤!vÅe'WsËãÉ †ëú®?yá™.äPûî÷D±:ñkÚ<vÒ…“ú™ìù9Uêõ…ô'élêß?¬ΩØ8cıà∞YK.◊%ÑÈJ@WeÊï(h Eœdnd'Tr£∏h>w Ê©Y‚ôxúª»}ü{B≥SbÒƒ˙9Ïn˘Eπ•9âìu&˚0f B˘
∫v
òÃÕgè0„W2y9´ œ"yn˛xú;+~V|Ç-≥SbÒFá^n )·8ÍÅÇ-xúõ|èq∑ÃD•ËâDòùÛã&.◊û¯√}≥#c8/ ë§
@e(xú€-S=° (^¨xú31 «úÙ‘§¢DÜ?ŸZ3¥;ªX∏{£ÔÌs*∫0∑F“–¿¿ÃƒD!∏ 5Y/£òaÖ è√<Ω,Lã˝.{]m~:Íˆ|®íî¸‰í‘‚íbê≤•Ã&l˘*}…2Mà˚fÎI≈Ú˘ g·)ÕÆxú31 g«`Üµ<t'‰¶*ﬁRoœ∫Ï¸∆6Z âÍ
:´x340031QpJ,ŒL.HM÷À(f»*ô£¡uØ˙∏ÆvôLlÁ˚»õnıÜu.ôii0e◊2$ΩhΩ6•ˆÈT≥]Æ€◊⁄	á@ïπÂ'Â•ÅL-Ü)èZj∏ﬁˇ˛lô˘Á˛m∫Òw÷åœˆFPÂ¡˘9e©0usn©fXñ∞xß{-Ûj∂0rtá™ÒÄ)ÚPû˜q™⁄ï#NµG;?€˜M!Ú£3 I´NÇÓÄ-xú;ÕxöqÇààæM—¡ Õ≠Ì?Ã~DΩ˘Uª÷∆ ˇœDç≈ ‘ÛÍÊã@xú6 …ˇ¶¶ê5u„ZºÜ5«†˚p¯I—ÛÑ¡ëI°†ÌJå&Eô{ˆÍÀ‡c≈„ﬂ[ë˛(™ÿ†xú340031Qpv÷À(f∏€;q∂™Nàtõ.ÀÉ]•:‚ºéõ H√ÈìE_e|Ê∏≈_n]∞hCœ≤ó·\ ≠ˇ´xú31 «úÙ¸¢Ãíå\Ü3'Ùæ˘/ö¨,pÙU⁄â≠Úˆs≤Æòôò(8%ßÍe3àÑÆª∆5d˚Y°ÆâáÍ[å¶f¯Cï8ÁÅïº:¥X±üÛ„ë˜≠ñªG;T9E?Ü*	Ò )»¨ﬂg¢‘pTxÒŒãÅs~ùb` Áw6˚∏Äx’X[o”H~˜Ø8
à:MZ*ÌC§V§ÅÖJ,µ[∫›‚8ì÷¬âÉÌGîˇæﬂ9„±«©ù¶<,‡Ãú˘Œ˝2Û£˚‰›‡˝õøo^”πöŒC/UoΩ‰´
√'›üŒk˚”¬KÇOã(U	o9”hº¬5äΩﬁpp÷√wÈÌ¥w +ò¨Ë˚≠äï„‡gß‚Û’\ôıW^ÍıﬁIÍ8N∑KwîòÛ—\≈^D≥Ñ¢	˘¯?ıf)-Ωp°¶=>>¶Ùa+w´4]}åÉY⁄6¥°J)£#je-Í˜ÈÇÅÃûEOOEÜ!3ƒwFª¥œd≠˝÷v‘BùmA}H:Í?Z+Æô·®{úKYÓπÔ’-€PcxJn˜†M˝›æ%“¬qá‰Qø”ß!ç‰π^g‘ÆPúí”ú®ÎDY≤œ •(ôî”ú“&¢!ÌT∂j=L§π≠∆!ÚΩDëk	∂W~É&öÄÜ»e‰=˛ßÕÜÂk}µ#´´ΩñÌîîYπñSe;¢àmàµªkwÎ¨Õ$∂µ◊à†õÄl2dN#∫4∫D¨(±68J¥Ï69êÌ!ú∑#◊¸îÇ> Ï]V∞çt≠Ûíƒ Ç›:ø0âÌó5¢k…4URâ£ßå2Ê»«F‰ π”ÿﬁ5ß¥	B\
F◊u2È@§x8ª¿˝!ˇ•{¡5\2Ó„ËàF–[÷ˇ+æê4‚¥ªˇÁé¢Ω·{Ä¨="ﬂŒ!ı“’Ëöè_!ø »u⁄òYÏ´|—öJˇÅØQ
#Ík˛`[2^”–ı∑fŸØsÆ—Kæblq_˚Òñ⁄[Ü∏'Oià<ê9Øa‘«VÑd•™^SYA%÷Y u’™°à!ŒUÀ∫e=Ø$ÎÛ∫de;YÈÀ8X~A@⁄`»8ÅíîUq≈‘Y0V4Z˙yUq°›î~9^û¡€në–‡€ú–ÿ4πâ_•ÃïÃ6ñ˝z(…Ïm±PÕ@˙ãÉ†Œ\51¡å+}ÂÖ<3Œ£0òE”¿…èUl&≤ﬂ3Ç≈«(\a
|±õu2ô‘—`0€ô-ÃjzF„Ëœß5≥áQU“àO|'<u^^ ‹yuï◊,Y?¢©7ß±J“x·ß-B<Õœ¡xL|‹:ÄÒl5“gL›26⁄à;∞ŸM-Ê'+a8Êê`2Oıå…|ÅÃ»ı£ŸR≈7™å¨6Ë'Q8é»≈¸»?˘xi0>ªC5.—π;¯_ÏVg≥êˇÅq∂∞Ba>÷÷’*bAäb±&Nq`≤ò˘ÏŸ“Ï7≥™ΩLhâ’#+–<gX‘Ò†Bt—5ƒ<}$H÷xsÒ è:ü˜Ú∞Ì’m:ééøÊ]!‡6Ç{áåáˆ¡å:ùJ`Ø*«¯vvô]ïÃ$*‹Ú®ø*Œ	â’∂
xŸ®0îïícq2Øu5'9Í›ñí€(∞∫ „ˆÂ•4dª*M°å;˙Ã˛öDÒtz4éTB≥(EÊ˘·çhÈ≈Å7
’…PÆù∏Ω.b\|œ„ÖÍ˝ÍgòH=˚π\‹ÇÕﬂÄgn÷ﬁïÀi…ao•ê	Ò%ólñ÷1Z{tEa±√£∫4©
=:Õ‚Ö^‘"ËÚlVñ%¯Jö‹èkˆÜQ“∏wÓ5üÊm„AÄ6oµys „5¬¸¬“|∞òw√.Äõw_gÛFÆÔ¢¸]¢∆ÓÉQ≥›œÇÊs¿<·ª˝rüñ2óÿ˚ÙÏ∫Wû.ÀÉ¬ˇ‘êj`ù}√˚SSHº
&®∞€„„¶Åo/:.ıLÛîZ>¸¡YÌﬂ*ˇk!ﬁ≠Z\Òí€Ë;ï©·Çﬂ0∂’IË1+?äÂ˜QÙx(x=äÊCÙŒè{∫
SäÙ:)Â“ieÀk¥1<πqπ∑ß§=Z^£I.î5Ù¨Ûı:∆0?ª!˜ﬁ{˝mÔCåÎêcÊî¢qî¨ä∆\∫Ëø"ÄåiEõ—◊¶|Cœi¶!»lÄi◊4D(∑£Ä˘j∆ñ°‰QJû°⁄˙=3ë˚≠n‰ë,≠9cA1«‡ƒLló´rÙ,µ)q8yÿÏËº¡‰˝"!n¶à"ªpæÕ/=Å7~‘5î.Bøóì√Lœ¬_˝ÃFÃ¡±âÂ©Ü?0÷\^ë4ól¡+íy{éSô_Kmµ⁄˜Ü‡ 1Ïdzù å˚‘Ã≈ËÎn˙∆ ÚêQ¸¬„˙ ‘<Yï¥~4ù{±¬õ∂Ω¢£fY◊•™ÛE`úón÷œÚ†…[Ï⁄BY“9¬&æ0)ÚàNnß”f+Í›ÏÊ≤Ò€mF’rÛüüŒ"‚åfxúÎ0X§∏acΩ≥ßÇÅ¶Ç≠BTjQ>WqfnÅs~^qâÇP‹$Óüóä"åC5V≈â
V⁄V
I Ñh¢Ç62/	MÉ.∫H<tıZX‘k!´ﬂƒö µ9Yd)3 Ü†K…Á)exú[§¯GqB5≥SbÒƒ∫fv∑¸¢‹“úƒ…lå3Ñ†l];(sÛ∆Ølp5À8l-ë‘¿q%¶§‰ÁT*î%Ê(ÿr)(‰§ñÄÿ≈
VV
——0›búÆpì8‡ÏVN8˚ßû0&Ûs…≥2gó°L/»vu.Æ‰¸º≤‘¢ÙTêK4∞ò¨â‰Y$ÊdAÓ<,¡1πó€Ÿ}pø=ÁéA6.∆≥V œ,…pŒœ+.áLÅ4Øúî◊Q(ã∫æ‚d∏9·º
F0@f"«GI>L€B^Ix¯ÏÁ] sc,J‡ÊÛ…¡M‚€‡ÇlO4∫E±(˛Cs•Âó8U¬™„Øí≈ÆƒöpkÌí÷m‚X‚ÅòYxúµY[lW÷∆m
#⁄∫πÿÅp<Mº3{ÒÓ6⁄M6µ„K≤‘∑x]WIöxœÃŒ^⁄›{ˆ[$öV)o°:\$$y B’æ B<¬#BZ	‘RB	^˙PP˘œefg÷≥câ(≤Á¸ˇ˜Á¸ˇ9Á?ˇ9&ÔDæ˜€»Î/Mº˛ï'Á/·ñÅnWÀê§ZcÀ¥⁄h∑ÒT°m’öIJ&K–DÛ€‹ÆôMîC¶’Ë‘1 Ê≤Œ7…M∆Gu≥Ÿj„f;[ñ—jö¸Ê»Q°d›B◊Àî–¥“4ê¡'ïÃÊQæŸ6*Ü≈≈¢¡TÆ ˘Õ1X√H≥” E…höf¥ÜÊÃéV7Ù4Z3p-wÂ,V≠û!e~;Q®ö∑†.ı2ü¸‡Ò1FÇU`¿O£\a íåDpÏS$9+!*ƒ˛·4 Z€2•lô6B˙élVå¡Åf jôùfâZÅ÷uí´°Cäâ¡èﬁƒƒÔGÏ∂	
ú•aE…ãh	ÔjÜk«ı4®`˘Ö@N£¥ê“ª¬å
Á\9ÚM-õÌ*õÌﬁZÔlA‰^ÄûLª’T˙S¡	Ã>ê¢%4µ,SïFyï2¬	hÉV™±•†ã·“ò07à9}”Vxø8¡É≠YfaPÿ»p4¡~kQ÷ü€ë¬÷W÷hΩVﬁùöÕ´‡ƒv«lØ0<#Ÿ§Fµ2ùº“Pªj4ëíI§Ud‘a•+ÈpÑÿsìS"vi0c#a´ãá.„ì±»ëwÁ…ßOŸb…≥Öf∂êßπéõﬁf°÷¨"?∫: ˜µgZ5ü˝åÓßüiS~€oP¥®ö¯Û;[ﬁÊ¢YÒ¡µñﬂÅ  íÖm∏	¿•õ¿”û´ïÀA8±⁄$˝çÈÓ l—´§“,∆Kfì'O<‚§ùªìœƒÚ|â‘—¿ïZ[ªÓ~á∏o ûÃ»œ'7ãœc—Î∂õ»neΩct≈±`q<Xú ˘POº[<b»Í¡cJ!í'K ï⁄§õËÚ:,=›llaÀ@´5˙?áÊØ˙ÖyÚ™í{13¿(œmd˘AjΩ¡Õ}PÚÜ2ˆqóôº©åÊÑÙs<?HMY 3(≥‰è ©ﬁ/îGOµ≠›’zßEìóÿìûOû…úI|>ıı ©ß«"˘ﬁ€©ã#ü6sígí; ±„XÍ‘ÖÛ"ÎÕ¢¶QÈ:ó‹ØìÖœˇ"À8sµÓpOúÆ\$é“LÖ%Ú^ˆ˘wˆ‰Q&Õ5âMñ–xC"…ÛÍ,h ·$4°†…áÆ#‚Yï	ò
;] ïL
>·¥ê»ÉÛ2˘ÈË'ŒRò∞ñZê#€tØ˚ÆàÔÑ„‰{≈‘ïR≠{˘“˛rÜîöÉπov!ñäéQ—ÒºHﬁ“ßF¢ê(ﬂ|y4e> TÖµ›g™ŸçíS≈„œRÅ˜†E®\≥ZÌu√j@˜›®+ÓbHœz¢kï…àQD‰µ‚	Úµ¢Z§6TGa3+<⁄*ƒHWÈ‚)|J.GôP‚æ;`çÃî¶$O ∂J]oÛ™6N"∆W…á⁄·È≈w¶^Ü

C•pµQ)’îF^['Xø0é∫t~›\YŒaËç<sÂêõ'Néìó≥Ø»9ƒúÒò,‘M®‰önj'Ôüü]KTÁ!Øiƒ˙„«!·Ë4Hy%¡Í$t—(Kë€$qT%FèıQt„—BäjHZ=b@R‡å“‡dˇ™*◊z.Ù"n¨ﬁœùüw¶°è81X¡„Uu¡zu=·úoˆßÄÏ\|«eΩÒ‹ÆIR]o,ôPó÷8o¯Ç˘B …Çm¶k‡ÑGMVõ∫» ˚ªHò=ò ˙ãñWtfêÛÚIÌ√XõmË
+Ô»‹}Q:ê#QîA∂Ü|BÃÑ{êxPH˛Ñü˙ò€xXª‘o‰µ3˝∆ñvˇîÙ≈$›FCrØå‹v1ÍjRÚÆ$YF©√ÔC√8ò±zß*G˙}ü©~ˆ9r•ÄSçÈ8•kﬁ¡Ò‹ﬂ7ΩÉ˚Fı˛ÿﬁ¢Ÿ—ö”À
,tá&
\eyãﬁﬁD,¶≠˜ˆÙ˜GÇzË.Tπoú-ìa¶`±Oæ”uÔ⁄|,Û¿Ä:$~w°ˆDÄx˚Úh/u˘D‰˙™Yﬂ›o¯èÓä^Ú—ΩpáWÙ≥æ+èFëQrÔ c—&y<}≤À£‰ó£«„u£MÛ~ÇØsz!∏òsÆÏ¬¬ØΩ<=Ò”‚+æhç"ƒ«üáíl©äÈòΩ∏-qˇH-∂[†Â3√ˆ.8…$˘Y~<MU]ÍØHÒêJË…7S*YµﬂZ<€w”Í^Ò∞	J/ùçlí“íDıª•¿é/gÇƒÀÁN-ÂæΩ|ﬁæ±Á|ø9$K¥:Ã·çõ®,t9ÁK®≈¥*âÜYä™Yàπa©(á01&pM‰¥LNÆÃık˚¨ª{˜èì‰≤`QL;Ö0o6œy!¨|JêRíÆåª'…£´c>£Æ9™›’˛xı©ÌﬂBµüπ¶}1T{?T˚´PÌáWœÑhü]”∂Bµ?Zã’_BµcÖ0ÌJ®ˆÀÖD⁄ØÕ¿=∏R∫O´^£?¬Ç4∫>˘—)ıı¥˝QçúÓ–Ïhœ˙F±ÿ°D£v √¡‚√F?ò}
Ïï@Ç‘^Ú◊Vé—3f,‰ŸìΩI{c€ŸªΩøo¸‡‹jøtÌZ§R≈≠l’0}ôz^2Õ∫‰EñY—i‘ç¢óÆÆê∑P™– BÚØÎÈ'Ωß∑SpÙR7˛A#›∫IÏÌ]b®HŸd/ &ç®Fæ≥©¶¯ª´¬üJ6˘≈äVç‰≠MıLH•≤ÉoÉ_˘>âíı‚+ˆ÷ñ5ÒMûKäúñë∏£»W‚‹O‡å®ö∑!Ø∫Úz{4(óSr<ŒZö¥e;¿µΩ,ãÀø~ïwC≥∂\s∫/(∫Àõ˛V)Ù&ﬁe|≤°»–)¢ö.Ì]ï]‘¢Y±X›¨≤ãì ˛˘ﬁ7áŸ+\Ìph	Z}lôb‡;mÏ;[ˆüÈÑµ\s$˚0Ù}aXp¬M⁄t-1¸ñmi˝Q€‹øZ≈qØUâ}Æ∏;~–O∞†Çs…ö√…Ë[n◊Ê@›l“W^A’z»,—«Ÿ~œ’–Æ“f}á@Ÿõqø˜${MHÍ9{gÊH[∆°æ≥'há4‘{˛6ÌÈ?l®∫ õÇ√#¿ü¥=cÜuè$∂‚®Êñ,pö@Dß!À≈ i¡ù˘œ∞Q¿∆“(“æòÀÂÑ1Ÿ¡8åŒ!‰ˆ	áœ`Ø,Ø“—˜Œ†jJ±]¨DbÏ√2"åÕyè·âÆ*:∫òCi~Q°L:ø¶x:”ÈáìÀ∞∆Ïˇë"/\÷Kñ>â" døp÷/µôÿ∑Ø˛õ˝ÅÁÈà•j∆$IÙ€sÿ</Äæâ∞˘òE6Ô∂8@∑^(?Vk~);ÚÚ ©8d¯xIf¥ly¬∑Ë‡(Ã¡ƒ(aÑ≤øÚÂ>“QÚEIˇ‚!hËí≥∏b˚q≈Çπ®‚˚QU‚ÊJÌ«ïN%˝≠.sÖ·î-xú[vôÒ‹e∆æ^ìÿpLéˆíd6P∞ù‹Ë%√
§'*	OP‚ù|∆´ç39±8U°H!?(*≈n††kßê§bã≈Éÿôi@I[†&uÖíå‘<√ÕYﬁ6r Ù$ﬂ¨xú31 «úÙ‘§¢DÜ%I'<œV&u∆/à≥PµŸ∏åQE¿–¿¿ÃƒD!∏ 5Y/£òaÖ è√<Ω,Lã˝.{]m~:Íˆ|®íî¸‰í‘‚íbê≤•Ã&l˘*}…2Mà˚fÎI≈Ú˘ #r(◊Æxú31 g«`ÜØ«•ää_oh∏*ëõ#ÿ¯µˇ◊no £ﬁ6Ó´xú;ÕxöqÇààsÈ°¥…Æ‹6ΩõséUîﬂU®qÓû>Qc1 ΩÎË˚Oxú€/˛Kd?€ÊlïLõïπÊ0ÜÈÍ* AfâÇRqiRqâBÖÇ°ÇFEúëvÖ∂±¶Ç≠Ç©íÇäBJ>DùÇDU¥FÖé°f,P•ñTiBqF~iNäSjÇÇ) a†xú340031Qpv÷À(f∏€;q∂™Nàtõ.ÀÉ]•:‚ºéõ HÉrPcÅèÌºIáì€ì&Œ≠NÕ Ö'´x31 «úÙ¸¢Ãíå\Ü3'Ùæ˘/ö¨,pÙU⁄â≠Úˆs≤Æòôò(8%ßÍe3¸J∑Uªﬂ|©8]e¡ë˚X¢¨Æ˝‚á*qŒ/+yth±b?Á«#?Ó[-wèv®rä~U‚2√Ó”ÙDñ}Nˇlfî`Ãzïô!ö
 Mÿ8%ÎÄ	xúÎfÏfúP.íXø/ŒD©·®‚úÁ¸:≈¿
 í%¨x31 «úÙ‘§¢DÜOZ•3TÍ¶œy{¥?TÚƒèÓ#ã˜òôò(§&Îe3¨P˘qòßóÖi±ﬂeØ´ç¡OÁO›ûUííü\íZ\RRˆœ`e⁄ﬁö÷Ôπs}K'/Œ‰˛ñ{k/ k‘.µÈqxúÀ…ô!≤î˘√dÉ-ﬂC•/Y¶	qﬂl=©X> è¬7Æxú31 g«`Ü9˙w÷›Ùø$ÚÊ–Í…¢Î*» ß◊{Ê∫6xú6 …ˇ¶¶ê5ëòÈõÁÄÇp[‹Œ^∂JëI°I˜„áR&!2ﬁfõè |…‹¢2ë˛(o>†xú340031Qpv÷À(f∏€;q∂™Nàtõ.ÀÉ]•:‚ºéõ HÉﬂ"3ˆÂF{™9ófÌz#îΩWrF) îÄYlÄ§*xúª)∑OnÉ1„f?Fn> ≈”Îª[xú[ §ˇ¶¶ê5’ç|›j1i¸ã!a∏JëI°<†RÓmUé4≥+.G~Ãã©˘7e100644 th-cas.cabal Z‚f¡øÊ“ÍJ+gc(÷ÖaN_wØ*Q$N†xú340031Qpv÷À(fxx(uÎ¸ÂøŒØ „xŒ∫◊˛ŸΩﬂ&@ R¿ê–õüìì»ÌQˆ¬+Õ3ﬂG[ó  /Œ˙´xú31 «úÙ¸¢Ãíå\âï.+∑VübXp€(KV∫A[Ò‰:C3Á¸¢TΩåbÜ∑Aá+ˆs~<Ú„æ’r˜há*ßË«P%! SüKœQ›soœ
Ωp'q±)°Ê˜¬TÄÕxƒ∂a«™3Ã⁄ˇH…9Íe}ö  ﬁ5{°xú340031Qp…LK”À(f8eù˘\tœÇGá÷\›']¬«'b˜bâ!Dâ{Q~R^jëSbqf1Hi—+IûÍ4Ÿwì_+_é˝ıa´ì“œH®Rœºí‘Ù¢ƒíTê∫güKäüñﬂVŸ`t'ÀÎÚÏY≠/Óx@’gÊ‰d¶UÇîq')¥ﬁú¿˝ÕˇZéã'ˇ+F©Ô6Ñ)Àœ)≈ë›i¨Á¯+›-©0„ÄÊ¡&°]¶ CJM€Ó
Ä®0xúª)∑Hn¬zÊê Çâõ%∏R+
å s¨¨\+
tÌ¬sJS7g0
∞≤Bòıl/°Ã…˘< |`\·‰%<ˆ‚®Bp∆$ﬁRHjƒ&ÛÛÚLû«Îµ„Ôw(Î_& —:·ëÅ∫JxúµX_åGósU*V–◊\s	)sõˆºÎ?±/â†ı≈…]Ó_‹ﬁøúØÆí£±gÌ={[{◊∑koÔD™-BHÂâ¢ ˙¿CA™¸Bƒ#‚µ®® Ñº	û 7≥≥Î]ﬂz/} ∫‹Õ|ﬂÔ˚Õ˜}3ÛÕÏê˜˝:Ò∆◊ØÓu’ÚënËGùínı∞^W≠ãŸWÖ/g/Æ/nÆ=ø∏∂ÇV€Í°¶¥UÕ√óóq_*˜LMo
B6€Ä.Z9Ë„ûfË®àV≥”ocT(º6)Œ¶'Î„Ë!ı∞k™ñhÚªGŒ8e≥Ë∫´öÜÄÓ£-]E\M*Y*°íﬁSõ™Èäyá©V}ï˜◊≈¨‚:w zøäÜ™f¥Éñç>≈†O¢∑—fø£PŒÜjj6DÜ§ïÉLπeºíuc0˜Ë>3-Å'X|ãSvêÃ	ß>G≤3©BØ¥Tºfˇp÷ÅŸC“æitòá&åÖ˜¡ÉŒ‘4˙zÉZÅ÷“U√ÄìÇ_ÉôôO8<≥,√BÅÓ.÷É›≤¶∑P›Åá˙ãñ≤_¨áÈ{îﬂ	¥F-Z£&!¡ a7ÿ]7ö!∏bÖhéÄobÀQ˝uÑ“\˙À⁄˛~éœD/Çd8ˇ˛‰g`%lôô.v0ﬁ¿ΩñJj≥gˆV˜´≥OßJÓDÒ⁄¡MM«Êëø¨ Ô‰ÓÚãŸ iﬁúJﬁu¸˝rØÙ—ß¢≈ÈhqÆD@#Åz∞ÈQ∑˚*ﬂ™”*h|#‘ﬂµüñ âŸênePU¯⁄.,«∫—ÈbSE€˝)¢ï€aaâº&_(!i)¬®‰⁄å»J£4‘∫‚öØá†‰'“Ù'|fÚé4y⁄%§Õs•Qj õMZ"îû¸Rz¯Ù•ûy¥›Ó[tãy9À^67ë‚ØÚ\Ó;‡ iÁß•¡{πÎ¢Õ<ÉÏïüÄX ?6˙m¸≥}´áûDKHWõÉSW≥'≤˙≈_gÂtY≥«G‚Â#q2â¯_D˘†0E˛[8íI+o2
&nG Ÿyy	4PÄ3
W–∫LWó˘ïpÜ	ò
{Ç:GJs9hB©»õÛ"˘˘‰'ØP∑¨n[Î—
v\‚Ìå‰µ‹≠ÜfØ›<9BÜë°A¥6‰R™cTÛ"ØëwÎó&íìw^ö,$Yµ`G$OB Ì$y¢ˆ¯3T¨ÚÌk¶’€UÕo'}±çMp#c√Ze2¢÷˘JÌ,˘vMÆQsU¬Iÿ‚íõmrTóÈ‚)4ÜìL(∏±é∫±FóÑ@∫;ÿΩ≠ú#	ı[è˘˚
ïg:òx˙÷)ø∏Õú?G^*º,9P*V€ú˘∫_ù…áÛK|=—Ú‡Ω{˙Ò≈RDsû'@Í®ÏDE◊=-K∞n\õ,N ‰Õ…©3°„ñÓz‰R…Àè8eêî]Fatf˛?ÁØà Ék◊	?WÁWº5i√@¿√ã>ùTŸ`]Av ù+˙p
»·ı˜=÷¡ﬁçGáC[—]L~µ0≈É˜v∫“Ä»Tut1Û 2°“„-Ì¡ùïT"Ä{ yÃä˙—™ˆŸÒ¡⁄‰ ∑v!_≥ı[‚	ÚΩRÈ›jãçFÙ˙&ﬂ_øÂ¬ü÷ÛÚqÒ∏8ÚWU“ÿ®GQ˝~#rÑ«7Á¢ƒïÕ´g«û?ÿúwˆéî«‘0´Ø¿!∞˜"⁄Á∫¢◊‚*I2Ãf¶c4ír¡Ä+à)†.ÑâaCtp◊•M`r~kyx≈(¯Ó‰<	>Ê%h¡;y›n$†Å∏Ñ∞Ûz,A)JI˛πuŒﬂ ü⁄ûôŸA‰R¨ˆ(V˚”Ìã1⁄ø≈j?;N˚B¨ˆ±⁄ﬂƒj?∫˝Tåˆôù8≠´}{'.Wâ’Nó„¥[±⁄Øï3˘∞vnp£+≈æ,ç˛PéK“‰ÓÏ«ß¨ÔÊùèk‰ùËpïWË.8∂æQ*uL®D§(Å…`Èq§Ã>ˆR$AÓ8˘ÎÛ[Smµá¡B<’õÙ*˛Iˆ˜ [ß‡˝’;wÕ∂*ÿ‘0˝{ôπim!à‹gß⁄V;àﬁÚl.∑–>ú§QÑ‰_wÛèπ=œô‹ﬁ?®3¬Ω◊ô„£Ïπ IUˆ&UYBhFÚ√™úè0p_$˜ãMR¿†Íﬁ‰` ÚnU~*x4è=¯*ÓÛâ$Ÿ≠ΩÏtªÊHj¯´U.Zb^ÙD¸û%Œ˘Ôég|–B]ıÂ´Ù∆–†tZÃâÈ4Î)B◊ÒÄ;«	X˚ö;≠⁄¢Ê	QP¥Ìv√Ω2|ã¬’ﬂf|¢*â0(¢õé.ã>
>Û÷6ö„ÅÏÚ«Å~˝ª„ÅÏ1`∫–ÙÜÿ}äÕ@Ï¥s»Ìn8|-‡÷¢ÊIN`∆r[™ünP’∑ƒWdD¥ßΩv‹¯¥¶û•≈‰Åæöp‹˝0Ë~ Yö>$”«ì—'%€qÅu√§èMún±1≥DﬂàÜ#∑báÊHáçeOW√—cêÏQã#ql‰ÏπÀE:"éçùΩÑy§±—ªOdÅÒ„\≠{	p(8>ÓÀZ¿áqXˇHb+éjÓâßp|ëU°tUe¯UgÒ3l∞íá≠á(S.%S˚º≤VB‡Ù»¯pçz¿j¨KHÉpÜúπ!)èj¯›DﬂÈ¸È}˛±R≈F⁄‹Äèó”  
f>,!«ucXaÿ ‘≠Å€ZX jaI!ÂUPÑ∆óDFÀ¶⁄a†á£0'WÊ^¬àwr8Û‚È)›â†è‚àÜ¶Ÿâ‡JùƒïäÊä†JüD’L?0WÓ$Æ‹x*·4w™Ÿ¨xú31 «úÙ‘§¢DÜ–≤ÈE6ãÃr∏Ê~ÓPh—˘ÙV≠À–¿¿ÃƒD!∏ 5Y/£òaÖ è√<Ω,Lã˝.{]m~:Íˆ|®íî¸‰í‘‚íbê≤+”ˆ÷¥~œùÎ[:yq&˜∑‹[{ê+ÓÆxú31 g«`ÖgWt$ ,ãjèVµ1.‡ ‘	g¨	xú340031QpJ,ŒL.HM÷À(f¯ZÌ¸Â—òR„®+≠€vüÙômQÁíôñSv%ΩÁI«ºﬂÌ°ÏWüX.yæ≥Ù¢ÇTYp~NY*L›Åh€.ï‡˚aeq+:µÌQ¥]U‚S¥·Ú€¬I% 3Wﬁ≥ø9-ce_>+ ∏æ>ÊÈ˛?xú€'“%≤¡ôô9§≤`r≥˙Ê\fq÷Õ;8⁄m-Êó
xú6 …ˇ¶¶ê5˜,X!ñûUe\“Ù¯ô	ÏwÑ“yëI°o∆Xåê-HøY¥∂ù 5·ë˛(äÃª†xú340031Qpv÷À(fxx(uÎ¸ÂøŒØ „xŒ∫◊˛ŸΩﬂ&@ R¿0OFÌ∂ÂŒ˙ÆŸ«w§ı?dî[È† :k´xú31 «úÙ¸¢Ãíå\ÜˇM,∆ú´#íˆi±⁄◊w‡ﬁÑù”¨ÃLLúÛãRı2äﬁZ¨ÿœ˘Ò»è˚VÀ›£™ú¢CïÑxÄ0L}.=GuœΩ=+Ù¬ùƒ≈¶Ñ^òﬂSPY 6„a€Ü´>ÃL0hˇ#%Á®óıi ™66ÃÎñexú;»xêq¬Zë	YïØkÑ\í‹h<Â€˜Pìé6 ≥˛‡ÄÃ6xú;+˛V»∫ZWŸ«—œ=‘—›U!$5∑ '±$’#±8;5'GY∑ñY:∞4±83∞4ø$µ$≈µa+´PÆÇØû¢BíÇæÇÑô∏˘4+;Ûd].N>]]Ö8Ö≤ƒ¢Ãƒ§ú‘…G8xÀäl¸ÚK22Û“π N&ÿ¨xú31 «úÙ‘§¢DÜΩ˙1/ƒ ÷Æ“äø|H˙ˇâüUJÜf&&
¡©…z≈+T~ÊÈeaZÏwŸÎjc”˘S∑ÁCï§‰'ó§óÉî˝3Xô∂∑¶ı{Ó\ﬂ“…ã3πøÂﬁ⁄ ÙK-5Æxú31 g«`Ü„ºöW{bºJﬁ∂i≠e]ﬁ™} á'
L¨	xú340031QpJ,ŒL.HM÷À(f8tÎˆÁ∆¯Œ	íY[´◊w∞˙Ù=Cà:óÃ¥4ò≤+È=O:Ê˝neø˙ƒr…Ûù•t† ÇÛs RaÍt™”fı
Ún‡4¥∫Ω˙¿^Û˚^ôÜPu!0E.ø-úT¢<#qÂ·=˚õ”2VˆÂ≥ AØ?ÎlÄ¶WxúkY-ºa=˚fVé?å dwËÄîxú{»€≈ª¡ìu≤ÎÎ…ŸY¢+t*'`S q&¢Êù&xú6 …ˇ¶¶ê5ÜNà7’\ê·S+πnÔµSOÌ·ëI°2'5âIzO¡Yµ¨˘/¡ë˜Öë˛(v<E†xú340031Qpv÷À(fxx(uÎ¸ÂøŒØ „xŒ∫◊˛ŸΩﬂ&@ R¿–£wùmßäÒ¨ÛTÊ-ﬁ¿_Ó!wP 3ƒ´xú31 «úÙ¸¢Ãíå\Ü˜Ö¨
~Ò—e[?ºy¥ÄÒ5ø^Ä°ÅÅôââÇs~Q™^F1√€†Cã˚9?˘qﬂjπ{¥CïSÙc®íêÜ©œ•Á®Óπ∑gÖ^∏ì∏ÿî–Û{a
*¿fÏÕŸyˆufÓQmÛú+“Æ2sé Zí4ÎÎùxú ‰ˇ¡¡ê≠Œ@•U–ôíˆ˜¶Ÿâ8“0&WÎΩlÜgÖxú{+t]p√u +wÌõxú˚êÒ’^∆2"õüã*lˆ3sò,¢"69@ó}≤è.èDqiRqâB~Q∫Bn~ä∫BZ~QniN¢ÇÌf˜Ôí ¡Õ¬¨xú31 «úÙ‘§¢DÜ/_lrœÙº=±¸≤˛—ô≤Ãã˚ÂÌÃLLÇRìı2äV®¸8Ã”À¬¥ÿÔ≤◊’∆‡ßÛßnœá*I…O.I-.))˚g∞2moMÎ˜‹πæ•ìgrÀΩµ q-IÆxú31 g«`Ü\Å´˜(õæhY9ußu?Îﬁ_øò>:¨	xú340031QpJ,ŒL.HM÷À(f0H?∞tUŒ€K›ô)u˝—ı”>m|lQÁíôñSv%ΩÁI«ºﬂÌ°ÏWüX.yæ≥Ù¢ÇTYp~NY*L›O¶o÷^Ê$Æ{U‰˚©õÕDç	™.ƒ¶h√Â∑ÖìJîg$Æ<ºgsZ∆ æ|V }èAlÑ|xú[-¸Éw√∆Õ›Ã!¨ #i≥ÂÄô|xú{»˚ñ{√ñ…øY¸&{±Æb5‘1éÂ ipÛ©x340031Q–+)J,À,÷´ÃÕa8t◊Ë¨†íe„•ÀÖcõãgGÛõ ÅÇcNzjRQ"√ï/ÓM[ﬁ,≠ú˙Ò ´}{äf•
´(BrŒHÃKOı…O◊ÀMa˚fw∂ÊìR«œ∑7v‰‹{2KıuVTùèß≥´_∞+√Q˘ÆM÷~á≥Lk¯˘Ø¯PÜ˚ 5P%AÆé.æÆ sxñ¨∫}¬ÁUe”GëËÔ'~sû> Uîtí^F1√AY1ıS·©){,tﬁ∫TŸDµ£öP%≈%â…Ÿzïâ@Ø=õXÕÔÁ1ì…·@‘Æﬂı[úò?Åx≠$µ∏Ñ·\ãê—ıSè.ûüA ≠t„3Êá#°ÜîdË&'Î%'&%Ê0\ºk_ænı≥„¶≤µ´ùS/^àû,	 võàaÊÅ9xúv âˇ…¶ê5k+G·¶|*0°uY9…iºÛ¯J≠ëIw>stack.yaml 3√ÊÇÉ˚ÈQr N˚ªu0∆£Õá`40000 test H±JÍ•û)$€2Ré1©πòì!§cù∑¸d’XØåqw/1<Æºï!˚‹3[†xú340031Qpv÷À(fPππ#çaÕ∆ﬂO‹Ø=9“Ê≤üoëâÄ0à1jZ)∏Ö¥¸ó-=d¨|A·òOK È˚y´xú31 «úÙ¸¢Ãíå\•≤ézcM∑é.[ˆ‹	XUˆ¯Ò>C3Á¸¢TΩåbÜ∑Aá+ˆs~<Ú„æ’r˜há*ßË«P%! ;◊?bZXÓLeG¢ñc ˇ∆º6ÕhòÇ ∞·¨gèﬁœ˛óï˙øÈÚæù,ì"Ó+Ω 
Ù9µ¢xú340031Qp…LK”À(f8eù˘\tœÇGá÷\›']¬«'b˜bâ!Dâg^IjzQbI*H]´ZSæyªıÎ⁄†ã/◊Oy‹ıj∆É8®∫‡Ã‹ÇúÃ¥Jê2Ó$Ö÷õ∏æ˘_ÀqÒ‰≈(ı›Ü ˇ9/g˜8xúª»ΩíkÉ&+ ‹nÊÄŒrxúª)◊ <¡jb¥™∞s~^IQ~éûcAANfrbIfYÍƒ
ÊÄÇ"Âìô4±Byb•¥l`i~I*WfnA~QâÇcNzjRQ¢û≥c∞ûs~—ƒM∆ìÖ¯›DéIoaxúkeneﬁ¿¡»RY0ôõ±
 !%#™xú340031Q.HM÷À(fhã±˘sl-K‰¨'equ'ÉÃ?pyµ!DIJ~rIjqI1HŸ?Éïi{kZøÁŒı-ùº8ì˚[Ó≠Ω Z# ≤∞[x≠SMo⁄@Ω˚Wåú¸£ Rër†iH(ôˆëfaXuYªªk≤V»Ô‚⁄B´™ˆ¡ÚÃõyÛﬁÏ>Gg0Ë‹vøv∫üaÃV© Üıà˛¡ÑÄ≥Ë≈yÆæqˆ4"∆0%ıAÚ.#öﬂeâa˙∞r∏fJ$Ñ2≈Â‚$6DR"…>1≈◊:lÛE0ÀßÇı•FÙ¨∆4ç˚√€¯{∑w—\&—Q2JT∫$RCDi∂J#ù
^9|ï& †hm=ù≤YÈàõ*“∏ÈƒeËgFüsF°ñlå{@4å{%j@‰"#÷x5çQ™N•|z*Á“{
±5‹qVÑK∏∫Ç˛<˜wÀBúM  ÙLÒ)◊,# Ás∑Ã pnÚlÿº∞~- ò◊¿îJ∏.∂*ûs≈5pø¡™Õ§¯n&><Íeí	˙ë=Bsã≠ö?¥¬Ìcù,±ÔëÓ^+∞B”ﬂgŸÈxhøRÖˆ=A«¯ˆTˆ-{µQÍJΩÙÕ$6ÃÉ?≤^ÊhoÛÚÚò˛gÚJˇ)‰;⁄jª3¢k˚´ÃÛ˜åXÆ-[¥çÊeT„moªo<$πûıOÓ˝¯ÑE≥CJî_≠o± f¶CiM}uzˇF#zXˆ@y'∫ü•}≠˜òº@uerÚ{å¬¶Êﬂy‹¬ïZ|QpÌ*°÷∞‰Œ/ÙSû`Ë'É xú€¿ΩÑ{¬I)G?˜PGwWÖ‡‰¸Ç‘îê Ç‘∞ƒ¢Ãƒ§úâüECRãKÙ<äRìıK3ì≥ù3Rì≥'Û0ZM>Œh__Pî_††îíôñ¶Q°m®S°©§†¢£Q°`e•‡ôW¢©†kß¿• *!z ï
—5@µ5± ∫&VS¡÷VA¡¨Ÿ¥8#m¬&Nû $-
‘Øa§U°†≠`®	7fÚi&y~4mìˇ0Ÿ€ÉTõiç÷ƒ∞RªR´n°FÖN•&H∑Pª»à=Ã*ıPµ*±òb®_úôßQ°âÍr∑ú¸Dú¡”É&∫
…˘≈@Q®dúPkJjqÚ‰3ÃöJJ`É√sJS°fÇ@•Ç≠ÇR%í‹dEñíTãL^∆‚DÇV÷dT∑≤j ôo•“ÁÅ<xú[¬›ƒµ·Û‰øÃì´X¥&õ≥zNneï qõÅ‰ÄôTxú€'rRpÉ33KHeAÍ‰Fï…πÃiìÉXı7Á≥,g‹l¡f¿»RíZ\29á=cÚzV…Õ9r÷3áÊéxúv âˇ…¶ê5ªKI– ª0≠DÁŒÛÇp_fïÌ/ëIw>stack.yaml 3√ÊÇÉ˚ÈQr N˚ªu0∆£Õá`40000 test H±JÍ•û)$€2Ré1©πòì!§cù∑¸d’XØåqw/1<Æºï!2Â3À†xú340031Qpv÷À(fPππ#çaÕ∆ﬂO‹Ø=9“Ê≤üoëâÄ0,H8ÛqóòÁ÷∫;÷—sœÕ∏ô∂ä !g ´xú31 «úÙ¸¢Ãíå\&€˚aã¨øj+«^æÀæì≈¥…ﬁÏ•°ÅÅôââÇs~Q™^F1É4˜«≠qw|>_oúÊÆT˜èøP%! *GÆM›e˚Ân∂¿∆€ˇ‚EÂJ\Ç)®, õ¡ùkÎ8%kE„Û§w´'nˆà9®v r∫7Ú¢xú340031Qp…LK”À(fÿ%≠|¬#_ó3„zI‡Õ¨gtÑÁæ7Ñ(ÒÃ+IM/J,I©kUk 7o∑~]tÒÂ˙)èª^ÕxUúô[êìôV	R∆ù§–zs˜√7ˇk9.û¸Ø•æ€ ëv.gÅàXxú;¿˘Ü}√f  \·ÅÌxúõ|èÒ·|∆	;C7œ‰€»2yÇ∞èBNjâB∫Ç≠Bzr dπ…	Z<LôyõùDŒ≥O÷ì	`M“T–µ€ºQ∆úqÛ?Ÿcúìµ¯≈7sk4o^fΩâesò√:ˆÕ6+Îπ
ãJ2s‹äìK2ÛÛ\+
ÛäÅ++Ö∞ƒú“T†9
æâïI©.nÒV˙VÒö@G˘ÂóddÊ•„VS¥Yﬂk5”‰Ô∆ºì˙Kyïó($rï$fÊ8¶§ TÂ•OﬁÂV&Èá¢Ã∑4YŸfk??A z’k¢Êì_xúv âˇ…¶ê5,§•ç\p
Å˚’∏dr
ÈelëIw>stack.yaml 3√ÊÇÉ˚ÈQr N˚ªu0∆£Õá`40000 test H±JÍ•û)$€2Ré1©πòì!§cù∑¸d’XØåqw/1<Æºï!çπ2&†xú340031Qpv÷À(fPππ#çaÕ∆ﬂO‹Ø=9“Ê≤üoëâÄ0¥2^{Óc{AæÍ\ÂÀÜGou  Áa´xú31 «úÙ¸¢Ãíå\wë[ÃÁÎ&o„‹Ø˚ˇÙÊØ;ªòôò(8Á•Íe3Hs‹Ápá¡ÁÛı∆˘gÓJuˇ¯+U‚R†r‰⁄‘]∂_Óflº˝/ÓQTÆƒ≈ òÇ ∞ ßÔy‹I€‘SÌ†µc•"ÔáS! h@:O¢xú340031Qp…LK”À(fH76◊ñê—Âj›¨º6dﬂÂÄ>Ü%ûy%©ÈEâ%© u≠jM˘ÊÌ÷ØkÉ.æ\?Âq◊´‚†ÍÇ3sr2”*A ∏ìZoN‡~¯Ê-«≈ìˇ£‘w Ωg+…kÅéxú;¿yï}CÛ‰RÊr ï9‡!ÑExúMêÀk‘P∆π…(Ãı∞2Ã4tz[õÿ	ìêLãè©+Î™"Vg#En2w4ò«8Õ§\âKÌŸÎJEQπ>˛ BqÌ“«¢†;Aq„∆õ°ÇgqŒ·w/ﬂ9ﬂ˘˙à|‹˜ÚœÇGKU’ø)”ƒDWΩà+jóJäÑT	--(‚Ùﬁ≠≤p*õdñ¬-8πÁXÃãnV<Y¥<JÇ,L|\}é˜jáÒuÌ~Æ}/1|‘&g«‰3¬°~â¯‚óæC0ö*„}[ıªÑâ7ıÌÉ‚©•©  ƒ˜ˆ±Òß}Ñ8Xw¶døÏ‰å8gÕ8˜MH˚U∑â/ˆËRw?v›E|‡6Ê”ÏnÑÎ¨%∏1J≥<û>ÖqåÀÜ¸√)Ó∏§ûÆı¬<≈–ÅÄµü‚)oØx6¢7Å[ûÅΩYÌ)ËP‘⁄˙>9*√n2ìbßÌä¥Ω†Ã≥H>D<É|NjˆÂY gëdaaL;P ±Ωx]¡∆…öx{¢¢îoZt=çr>‹<^Yª‹e—àØÌí›© 7îŒz¨∞‡f˘«f∂Kf˙œ\a”Ë«bM…Â"=~u»90j›øœdD‹9˚J˝π˘§ÓÜ8xú[∆¥åi¬+¶ªØn§∂hõ~ö_˝≠´bó íâˇ4 ◊Ìπ£xú340031Q.HM÷À(fhã±˘sl-K‰¨'equ'ÉÃ?py5 ‹9èÊõpxúv âˇ…¶ê5˘≠ám¡œ≈tæC˙jÚU¬/“47ëIw>stack.yaml 3√ÊÇÉ˚ÈQr N˚ªu0∆£Õá`40000 test Ë¶ˆÆ}g´ÑJÂ\k£æ7äètì!µ{µX*
`0 éü¯ê£;<c⁄{4—„Äxú3 Ãˇ¶¶ê5L(2≠qkÅ¬2Fıôƒè∆QëI…hŒ˝÷'js≈vÓÁ∂/ñﬁä¯‡çƒ†xú340031Qpv÷À(fX∫¯∆$mï≤jôCπóæŸ|“\[∂* ƒ @
û¥DYz|∏øf¬˘ùu…¶å‘™7ı L·¸ixúõ√4ÉiBﬁƒÇÊâe'ˆs2r ?dn´xú31 «úÙ¸¢Ãíå\Ü›œÏ>7PŸkÿˇVˇ‰ /Æ~Uw340031QpŒ/J’À(fXÒH˜Ìa˝òˇ¬LˇÆ\◊!±Sx˘J®íêï#◊¶Ó≤˝r7[`„Ìqè¢r%.¡TÄÕ‡˙§rÒ˜;·´§
˜§æ)Wü∑§N ı<+¢xú340031Qp…LK”À(f∏,2Ûå` Á?7ˇ/R
À$∂Ó˜h⁄mQ‚ôWíö^îXí
R◊™÷îoﬁn˝∫6Ë‚ÀıSwΩöÒ ™.83∑ '3≠§,ˆn`Øùœ´¸∑9M7æYö~ßF £E.ŸÌÅóxú;¿πÑ}BÕƒ:	∂Ã‹Ç¸¢íâé‚∑˙0{*NfeT“ìuM≈t≠*5™l4R2”“*™4t'70äNNb,*3ö¨ƒ§§Û&˚3y÷gÊ)T®k*T™É48ÁÉyZ0ΩÍ@	M.0.	V™kR’çUΩkEí—0ö“…zÃˆû
Òö
Ò@UŒ@O¿l√»DW‰ìü4hr=s. ºGJçÔÄ2xú[¬˛î}¬fˇº‘IåJ,Q©E˘ì’Ø ˘ö
U
∂
)ôii

U\`ÜFÖÇUúïÇ≥ßÇ!™Ù‰wåªxÛR”¨¥¨44Ç3Û&72	O>Ãdß	2™€Y!^S!®!ê	ò¨≈\ ∏C,ÂÙcxúÎ0X≠ΩacΩ≥ßÇÅ¶Ç≠BTjQ>WqfnÅs~^qâÇP‹$Óüóä"åC5V≈â
V⁄V
I Ñh¢Ç62/	MÉ.∫H<tıZX‘k!´ﬂƒZ≈-r/PQHQi*Wf1DËX®–‰BÔÕ7ÿ¬WxÍ˚xú5èÀJ√@ÜIsô$ı≤j±%ä’*NA≈•îP*EDã]bh5âM(›˙ Í‚Ï|AËRp„Ù!ü@‹x93—’¸ˇôoÜÛ=WøKOANÌD}º— ˘‰zî:áŒ9¢[˛$¶⁄ûƒ≤%A(.ÉP6/J®µ¢D4=∫√]µ¶πâ*v∏û$Vò»D	⁄&d˜ï¢UB®‚ó∫°vAédûjıúÎ·è∫<Ùzˇ1K°ﬂá‘ß…âﬂw÷ZvoC];RèÈ<–◊¿°˛°pTÿ∂¬ßMcQ—…ñ.{åÎBñ9Rze\#I¿Oë•Ü…uZä“•πc9ä&7Ñ≈ôà©L´°ã≠õ7ZB
pL±r˙hqÊ&Òf5òÎe»Ã,‡æ]bnöq=ªÜ/¶UZ∞E~u7é€N˝Fmg3≥∆+ª,ÔÏ’¢Ñ:AJÃ§A¬∞„¿tê/‰~æå≈Ö⁄/ßŒëáÏÅqxú˚'Ÿ'Ωa2ãp^j∫ÇïñïÇFjEÅQYbéB¢ÊÊE,˝¨ìSπ¸Õ˝ÛRl|2K\4<ÛJR”Sã|5πÄÍåÄÍ¢RãÚ1l^≈% $ƒ•Ä&ÔÁë™«V—+J-»ILNUPr˜p÷sÀ…O,—SRPRRP!¨:(51ü‚Çƒ‰lÖ‚å¸r 0˘5è0 —?∑Óxú≈Y[s€∂~ÁØ@ÌÃ‘≈ñÚ®©2„:NÍécª∂èéÍ* 	âúP$CRä‘8ˇΩª∏ê‡E≤|Úp‘iLÏ~ÿ]Ï.Ú˚‡¯ÍÏ˙„Œ>^ê˚úE„àøÁi∞¢≈Ò‡áı›@<e≤úˇŒ≤/<ÎÏ?W,˛\≈9œÍ¨Û€[$YÀÿ[ÖúúÖÓ§Ï‰¸Ï˛‰aõpÚÕÁ)∑¨`ôƒiNÆX¥X±?QäN~◊¨˜,g'˜y
÷YñrGYN&!‰¸ø<ç-ÚLŒo".˛^íÀ(Áûä—πcyG,√◊D›ÒîΩ˜„o˝ãØ˝õ‘≥-À ÒâÂ>_Ç$óÖÑoíîgHïÊ<≤p≈•9⁄må4…5[
‚}…)gÂ‡ÅÄ˘ú_£≥ÃîxÊö"œrS&"˝*‘Øbç·≈&)WÒ¬ :ôiÁ¢˚çe\π§ƒ|Ö8£˜¡|^G‹ÄST)|%x„ø«%_ë∫MRØI4IßcSˇ:¯o[¨]Å°Ω
≤‹Ô˝jI¶Ìâ<#Ò”*l?§Ã≈º#ﬂqDH¥Z¬˙∆„R"“˚†=äó˙)‰<ÊÛ˘Y‰Iî$3*√)S©P
Z≥4`N»ÎúªH‰
o„p&ê◊∏Dc(ıπhCMh©Èüÿ÷)"π[üÒô‡˛§ÉèÉ9˘ty={º∏ªøºπûÂ™“Ã|YË€˛hÿ⁄÷13nRX>ã\N@™Hòcy¡*âf\Cî§Àdç!dû∆KΩÔá`Ñå|Ö<≤ÿµ*S¥√¿yÑˆl‡:¿ón¬¨ß¨Ôÿ$û
E%}¸«&ÉwZ•¶;ÇËH
+aLR¿í>¸/H†ˇmIÖë”±!ãùôL»`Tn˛ûIåõÍ[ ñI1‘ÈÙF∂îC÷ë:û·Èı≤X)Kÿu†YuIU£^aSS´ØÆp§]√ù+$&L(ïŸpò'@ç±ÇÛ√’¢¥u•ÖFà"HQ´›w;"kê‹#8x*◊:}iú/ñrÙ≥‘ı@DJq
_⁄–¿îxG‚Y_±ŸJrÁ<„Óöà-Tsç9y®°X<∫ƒ;Ø´vﬁﬁç7´Ì∫Y€Vƒƒ≠ÌDΩÎXK"ÒÓ∂≈[á¶d>"Û±H±⁄‚êA∫]µØ˜¯M ≈©Wê*JKºª2ﬁM¯)∫æzj¶u$Ã0∑EuÂ≥◊ÇG^9ØH∫Ó+ìÆ{H“i°Z,Êÿ∫`h≥`G≤ a√å„C›PÈõßàÓ&Î«HAØû#Y$Ú)iËùîªA"ÿÙ‘∆ô¬<|˛©Øˆ8§v§Ë*cl ‘,"{‡F6•|©B£ÏÇﬂ∞‹&üΩ`˝YÔ¯’+ßJ&!tÁv:uYdn•z¡¨ÁÄZîﬁ0Ü DãZpì BÄlÔÖOã@"Ñ±»ÏfEÊà†Ñ–£ãî@"∞mÒÏä¢U´hrû¬ÇH°˘œRñË©'∫ªÈâÃç‡;¸	^	,Ï÷2L¥8√îó Ï˘q$aÿ„„HÒ •˘Rú/Â˘R†/%˙R§Ød˙J®Ø§˙J¨Ø‰˙J∞o8˝2ì∏ñ•Ë)Cu€∫
Ê9QÙ<.õÕX],ÄbÁ©1gÉ±YèÑ.ø‡Öã¨±ïáæçã^’hoattöó ÊÖ<Z‰>î/Ÿı"Êá–õﬂÜ+≥∆ÈÕ«I7„Mf∫o·t”€⁄„ÇΩ…»6k†ßOÄ‹TPSC&∞y€±I6e¡P»ÅôÇà◊ìÉÏF h,Tî÷-Y…I∂6k¬,Sc
‡mSDE?T¢;æ‹mUœ}ı◊6g	·ê*.0¸U?o1ÅÈçyÍÉ]m”å67œâ∑)£®©Í··ﬂög Ùó_`≤¶!x+i[- X„â2¡	p`j2îH®V∞©æpT˛Üò—•4ÂI∏pÌ!‘€<p±,·Ωûr˚_kt“`ç«©–`KwKÈhùNïttÃîÑ‚-no(¥–*&ÏW<ïäûl¢[VRÏõõÑß,è≈]ñÓM*Q¬´n◊®M~ã7lHË´,'Î!¥ŒHsF6ûÎ!ûk<ày ÉçÏRNK{ˇø˛™-+OSX¡Qy'á ïCGW÷9¡(è~jıS6z"◊†
°›∫dDòã~Y€îôª}›–&&.˝ú∂÷&& ’)–m3¯Øäx¬¢‹Hêë(Œâf’^&zwΩQ0≠%©0©˘ö¡ƒ¬Èø j–ñ˜Oƒòão$í!IPEãä
 0≈=¨]ñ’^ù•œ ∏áŸ"¬ÎëæãΩ†œ≠Rw·*ËsèœÉà{Ç5b)Â®⁄¶∑ÃQ‹˙¥2xQ{Ù≤ïÎVó«∆lã™geΩë-Ym”‡†´OôB "6I¡¿√Tçim*JGãÆ_Jîµ]ÊXÈú;¨Á‰qqC©ÿb◊c∏rÃ–¥ﬁ7ÁıSnÉ∂I∞gähH^;	v^€ú—Ó)≥xh∂∏⁄€-.˝∫äs’Ÿ∑Ï˙≤‡@úCÕ|cû·@◊∑ÄT_êêEﬁN	p™√l4ÀÿÉÖd‚ZRK∫¡µ>§–T∑dç€ö)˛Ü/pç⁄¸—ıöÕ¯ΩŒì’Êô(}	ﬂd‘zíó QûÜ;@˙0$ÔäÁj=CΩ¯ü¡_üÅiÔ÷XvÊØ.dQ–°‰¡ô¸}`·éU+‘∑
ó°ø±∫-W!3Ù·{°íØõå*¿_)Xâ*/Tø–!¿~#2ÚjUC’”≈÷óﬂ}∏dX9œ!${–I—ÛàVcá^JÊ´»ï◊Ë7‰ü zÄ·……ìå≠ﬁl(lP’Y⁄K∞Ôƒ_ı«Ä w+.hq∫tçoÊhÂ$∂Ìûãw”Ñ•9ò¶ﬂ]l·w@p$D0èÀœEeﬂüvLú›±É+√Úë<|€Ÿ”œNeUähJ6>;ô¶øJ®WG¶ZVæ™AΩ¨#ﬂî5HÍ∏=™€‹ì6„ó∞ˇáÕ®˜eõ!´ˇﬂ*ˆ£xú340031Q.HM÷À(f∏‹eô_‹t\ÚÀı˜ßN2‹c§‘∞ ‚]˜Ó´xú;)ÿ 8¡ò—p£…eÊ…¬L¬ì∞HqgÊ‰d¶UrMvd1bÂÕ÷¨ΩÃL:\ìôÖ9ìÛÛRJ3K <Ó¢‘‚¸“¢‰T(ü7-3/E™Ñ 3f¯Ï[xúk‹/∏a:À‰.&˜‰…ÇL¢ìX§8‹äìK2ÛÛ&;ràÄXÉÛs R°<ÅÕ”Yzôπ ˜#†xú340031Qpv÷À(fX∫¯∆$mï≤jôCπóæŸ|“\[∂* ƒ @
ˆMqÓ‹õÉA"ËÑs…˘ß%9eLk ı⁄´xú31 «úÙ¸¢Ãíå\Üµ/ÿÆπÍπN}∑eˇ!˜ıù˚zUÃLLúÛãRı2äñö,Û∏◊Õ±c[b•UaØ¯Ê7P%! *GÆM›e˚Ân∂¿∆€ˇ‚EÂJ\Ç)®, õ—‘sGÒ„ùer'5;ôv]Àﬁht ˙9≠¢xú340031Qp…LK”À(f∏2YIıΩ≥ús·˛∂Bˇ†Œä3œ\!J<ÛJR”ãKRAÍ mﬁÛˆ¯Û’ØƒwRı“+øNlîÖ™ŒÃ-»…L´)ÀLZûÙÈ
√Ÿ–ﬂ¢€Ã~Ï£; °Ã.oÄ∞xúª»}Ö}¬¡Õ+O0Mæ«‚ ;?ÔÌï)xú{n˚åk¬aÀ∞ƒú“T[.gOœºí‘Ù‘".ÖgÖ†ƒíÃ¸ºƒ/L¡/17ƒÚKMW iö\√¯É) sr”Ñ…â,ì;X'ﬂ`—ò¨À™¢ü®`•m•ê4TCWS!Q!I¡HZÈB≈¥êƒ¥Äbì?sÖL.„VëpV0‘3–T∞“∑RH)‘á*ú¸ñ«BœV¡µ¢ (Z\XT‘§Äºú¸t «'?l0–d[´8+Õ…Îx˜MŒÊ3-KÃQ(äÜ)h‰fÉ<°P¶… b∫F6ÓÄ`xú{∆uê{¬>]]Öﬂƒíå‘‹ƒíÃ‰ƒÖ‘äÇ¢‘‚‚Ã¸ºç{Y&À≥ŸÅ˘d¶ï(óeÊ•+î‰+î%e&&Â§*‰ß)Ñ%Êî¶rï5[Y)¿‘Ë⁄)@$&∞ä äI%ÜÔ¿@xúO ∞ˇ…¶ê5/,…~[–≈/~-¢(Í±™~`ëIwë„*≈kH!¢Z√iq9£k¨Œ&ÖŸΩì!¶¡tPôp∞V3¯ƒÚÚrRÎ_È	#†xú340031Qpv÷À(fX∫¯∆$mï≤jôCπóæŸ|“\[∂* ƒ @
ñÂ?¸R·FìsÌ=Á®ÈõøBï  ’É´xú31 «úÙ¸¢Ãíå\Ø-fãlÓ≠{Qs÷ÁmË6˘È{ÃLLúÛãRı2ä^πﬁˆ’ÌJû~‚ÂÛ5ªä¬nÛ≤ná*	Ò )P9rmÍ.€/w≥6ﬁ˛˜(*W‚bLAeÿå’G¨]•O≈+ÆŸl3YÆW‚Ω“´iF yI9®¢x340031Qp…LK”À(fXˆÛ«]qõ∆‹éw≥s&iÂ¸dﬂeQ‚ôWíö^îXí
RWnÛ˛ò∑«üØ~%æì™ó^˘ubs†,T]pfnANfZ%HüÄC«>nΩ-¡ªD£Ómì\∂˘  Ò.ûÈrxú+*ö'rπ.7pr4”ÂJÎ”Oﬁ_≥QÂì‰! ú8Úk¢lxú[¬>õ}C&Û‰"f# 7§ÈÄñ>xúÎ08,7a“Êâå[YÄ`Û=ñ(∆Õbìô6[∞]aú\√ŒÕõ®`´ê»≈≈Uúô[‡8ŸÅ[ö¬ä·^;YçWô,·ìü_09êWìŒi‚ıBpÆji¬8
 Üs~^qâ¶ÿ§îîÄ¸úJ=òÇÕ |Nåì#T&Oô\- :˘∫êg<–nâ9≈©õìDñ1 ¯=XÁ†xú' ÿˇ˛ä∞ì∫≥92ì˛
≥ëC≥Ì≥˛
êìØO Ï£xú340031Q.HM÷À(fX≠y¸–‚ãüÚΩj1Á⁄ﬁ81⁄ˆG  Á˛„æBxú€¿=Å{ã†RÖóT*ÿNÓcëòl ‚ÄU&
ã(#k:—FV} Úï”gãWxúkºÀ∑!ñ GëÔ∆cxúO ∞ˇ…¶ê5á∂⁄Rï`jÓX»˜=ÊJ‹ëIwë„*Û~“_èÍ”WâZ;Ó;6≈ ì!˘]ÿM®`≥ÎZ‘s' ú¬√wª#Q†xú340031Qpv÷À(fX∫¯∆$mï≤jôCπóæŸ|“\[∂* ƒ @
‹õ'∑X?8÷¬—7QpÔæΩj&< ıÑ´xú31 «úÙ¸¢Ãíå\Üˇ~Î∏7∆O∏≤,[cë°≈›mÚ˜tÃLLúÛãRı2äXúÚûÃö,S2âO≤˜ÓûYŒZªπ,°JB<@
Té\õ∫ÀˆÀ›lÅç∑ˇ≈=ä ï∏SPY 6„ƒƒ[[œ~—{ı†#x{n‹¥˚ˇ e,8ªÓÉvxú;,∑^j¬ŒçOÉY5lπ∏∏ä3sÚs*¨¨¬sJStÌ†,∞‰f7é9åõür∆± ûP√mÉxúÎí< >¡jb¥”∆◊.‹ %º^Î°"xú{nªÅs¢í’ƒ|kÆîƒíDÖ∞ƒú“T[.Ö0øƒ‹T.ÖgÖ†ƒíÃ¸ºƒ0œS¡3Ø$5=µƒÛKMáhö<ü)yr#„g¶ÄÃ…LÜìY$&ﬂdQü¨À™¢ü®`•m•ê4UCWS!Q!I¡HZÈB≈¥êƒ¥Äbì?sÖL.„VëpV0‘3–T∞“∑RH)‘á*ú¸ñ«BœV¡µ¢ (Z\XT‘§Äºú¸t «'?l0–d[´8+Õ…Îx˜Èî%Ê(XY)óeÊ•+Ë⁄A\Œ.*S–»ÕyZ°Lì ƒ{Nƒ£xú340031Q.HM÷À(f–Hû›ø74˛Ì°9"Ï“Ìc◊´Ë ‘q_‡Ñ>xúªÀwêo√sñ…rÏˆõùX•ô 8ﬂdÓÃ+xú ·ˇ…¶ê¿ë„R˘]ÿM®`≥ÎZ‘s' ú¬√Ê=ï†xú340031Qpv÷À(fX∫¯∆$mï≤jôCπóæŸ|“\[∂* ƒ @
˛w	©T<>W˝$`ﬁÂ(%áªïı}s%b´xú31 «úÙ¸¢Ãíå\Ü˜3K{ï$Ã¬Y¨œÁ∫©û”d 040031QpŒ/J’À(f`q {2k≤L…$>…ﬁª{f9kÌÊ≤Ñ*	Ò )P9rmÍ.€/w≥6ﬁ˛˜(*W‚bLAeÿÖ◊U>æﬂÎﬁ˜_FoGÓäº[◊ 4á5ΩÈä:xú+*ö'?;”aΩÇÈ/˙ÿ◊àˆHÏ4[ á™
ûºPxú≠ëÀn¬0E˜˛ä,)‡t©ï"TQKU%Ì68≈î®AAy¥âPˇΩ;4l—EWqÓô{Ó=MáOﬁÛ‚≈[<¿Zéœƒ#O?Dßﬂ‰‘¬Àúß·2è3ëVà‚m	¢w$|6˜V3<«IòÌ≥Uà≥¬]	_{ëB7N≤NÒ∫<"HëÄÎ¬+èr”{uPÚh‹Êå·?#~åœêù)´1Î¢nu*&•¢KòaπÑ≈%aF§ÊïïN ﬁx*`§
&ÚÉ$ﬁ!5e¢n∆]´CK/-©ññ“
´©,≠Æ*,u´m√Ïéavœ0ªgX√˝∫’©ô”¨'ı€ã≈˝Û8C”ÙHá˙Ωú/uìÛ∫fÏQ®"˘S"~/t!uÕ∑•˘§Ì<Ì8O{Œ”ûÛ∞ŸÜüh˚O˝I'0¿äp+ (¡4´Qc¥â„Íc:‘ê≠ùVæ„ü&&]/ªﬁ¨ûÙ/yÈˆ÷ƒGU|r<«wqÚ⁄jG»lÜfxú€¿πÜsÉ?”Ê`¶X& ˙◊£xú340031Q.HM÷À(f®xÛÔûÁ9˛÷ãlºΩ¿©`w= É§Î ;xú€¿˝ûs√d&]›…ìY'´±O^∆"∆R°]¡ }Ø˙ºx}è¡j√0DÔ˙äÅ‰–¶ÿ˜⁄L	…!L”S…A4GDñÑ,á∫ˇ^INB≈∑ùŸ∑√,˚I&Î¸}˘ô/ÿPe$w¥‚ıë§ú$øÏv]4ºE£’a≈De¥uXsU6º§Ù|ñnV#´4\Ä∑¸„:jÂ¨ñinåﬂ‹âñ;ËËp¬”áùÿÔ	_}7ÎÑnvÍ∑Aı€«¿—ï´ù%å–û›ÚÌ8œíúsﬂbß√Hr˛~éÁAz'ñ<K€®”˚™åU\®!!-^c*ã X°úøiΩºÃ·˚d˜˝ce—˚&tàÏÔÄmxú;√¸òy¬|&]›âÛE%2”*låJ2RÛ*¥*RsäS&ÓºT1y2£% wt¶ÁçxúªÀ∑óo¬ç…˚ôƒ7~˛¬<Yé›~≥´4 ÇA	3i’xú;…¥êiB¿ƒäã !)•xú340031Qpv÷À(fxÊf„˙ÓÎ€WªúÃÀ8j\¢gBT$Ê§ßÇîly‘-ê;c≈Ç’ûûóNÿùÂŸÕ bJ\∑∑xµYmS€F˛Ó_±ôA6±yI?1ußÆKwí «2gXScπ≤lÏÑ˛˜>œû‰;Yí„LS>Änﬂowoo˜¯“ﬁøË]æ˚£˜Ó\Æ√ßÈÿ§·{3˚+è˜€ˇ4æxËOs3ã>Õ„4ú’xäÔÁ„P˙Ω+yÖIÿhDO”8IÂ¬LÁÊ1ÏdÇ:◊Ô∑†:*rsÁ"~]@ΩÚŒ’jíöe.‚›˚~Ár˛‘h‹õ‘»çœCÈ6D‰F.ÕSÿêÈÀÔ&ç‚âÎj ÉI>Ü	Wó·£e‚¬rü˝yVµ †√2®]y†´h‚˜„ô[\≤ëCÅŒ[Å–[ıfæƒﬁù/≤ó˙2IÈ3Ç‘_Ç÷[û/ßNˇEÏ9®7Ùåæä<»~1≥–Ú9Óè˝zı7ÚHùÀ’Ø—√√&›á9'P‹ê˚0â—‰QÇ´Q¸¸˙¸Ô&≤i2Éâw° “´MRëá$~ ‚)F∫“H∞Ü%f,¶âlõ¿Å7rÜ»	k{0ÑNa-Ü†f∞iJÊÊ÷≥Ëq3¢ågﬁ€ƒ‹ŸL´∞2OBÂÏ[+åV&·]4Ut–óìŒqSŒê?‘yv6Ùïéc§7f”7wÃ4ÇÅÙøÑàg◊:Wf«`∆nW;™haÔ]	ê˛¥(®¢˘”çõû‡õÈ’ïk√o&<œm,é+K∆d‰ 2Q±≈»äa
Æ ê+Ppë\Q&ó™ÎåòbuùëS®ÅR¿;ÀNû¥ <ìX|p#ÀÉ¶‡œ
^∞ênﬂT;ê®-˝ºHÃ<}éêËJuúâZjR≠öÚ@’/ÂsS≥≈
Gä\+ì∂+IëÇe“ñ¨ y)≠JdGŒ‚YBûˆOSé$XAÃ 3≈€?µ[9“È·ñ‹.,·$€s·»€¿àﬂD0iü4õä];)ìxÖ‹b<4 Ø´|ã¢îëÊH%müPWŒ]IœzÊDÁ´“\ˆ@nõr[oø˚m·9-ˆ$√Íñÿç“˛,1m
ì$N‰ïÏ›· M‚T¶&AZù…û •Ö _{≤ø/'üÄe9õ·¢ÑUÀÓ∂˜˛∂‡à%÷√<c"œ_—$vÀ¿¸ S‡≠3ó•v$‡ÏQÜo°átì•ó˝lÂıö_ƒ∂€N{YxïÉ5O“ÌÈ85—›rù]H∏bù–,≠™(≈ba√]ˆûÔ/©:4ømzE¯˙åØ∏-{¨u]ûıñºAYxS£Î€˜µVá l™cÚ¡¶Q09‘ Ää¥Q1ˇ_¨—Z]PˆmuÀãﬁ>“=«•+ÀÇ—ÿÆ•/C^—ËÃ·∞ô#qJÙ√ãozx{¿˚Çn"+Àå3√*P WôÀ¥‘°¨<îíÆ `wl›◊Úµ˛&~–P2‚«Ø˘´…Îôú˜1†(òÃ `y‡(óñQ°∆j≥à‹'t	™íÁ∞÷Ü√àıÊ∑´:LMSÎô¨*Ú§‰ìåC∑ìı¥%ı0‰°~X–¯©û:œW±@~èµô!Ÿ)"0¶é[qÆwAB@<Á√ ^mæÁ—Çxû?ÇÁ€mÎAdà˜}O
ãá'ïY}ü’Ã{å˜°WrºÁ2W… nÕd°¯™Ñ⁄»@|ed ◊»¿~¯+µ;?QÙëBKº9˘fƒ
ÚæK¨™ˆùü%/tTá–È8Œ`î¡¨p∫¿‘ÑRƒFi›2Ø¡`Ú-œ%¯m>KyÌ7&9óxä/µ\„ˆ√–—ïN^]é *-Õ˙õ≥ï#√0Êìµk»tFq“Z5dó|iG5dv‰Òƒï‰y˝~ıÓ”õN·ı∆√Wâû/Ço:B÷√˙µµJı¡öƒõŒÍâ¿ãÕù„wΩú|P´'¡®)Ï:j•`∫	&≤zo⁄€Bduq:€Bdµq§´'‚¸ì–çÍâ†&üÎâ†ÜDÿ‹IÖπ≥^ñ…4Í¯πÖ,”©Sk=Ÿ$|d˜ﬁ’ß©Õÿ¯Ûgu>Êô\D)“q`ü∫.êç<¨ø.c-I˛±¶ÒI4ùq _P∑yú›´Îâ˜SlwoXKPGNô¨~[É¥]√€∑h”R,+AŒJ´Ìëb!…KÃçZ”,à„3˜πÉ∏ˆ‚p∑Ì*ÆµÉ8‘€]≈Ì ≠ÛÆ‚PË™ùÁº«˘ÅÜÔºB∆¢F/éA_ı ¨au,,Ze‰HC%£ÃÄÛVdgNté^ë√1Q©ÇÉgøñT±îÏÚ¥¿Ç*ñ-Üiï+ovçÍÉªFZ`W-¸U≈ªjYË±*-óu¶Ÿ‚XﬁéœZ&öQ±!≥Õ<>Èóıÿ≤∫°»’(N$ T*õ.Ü˙ﬁÄ˜P-¨~’\ì‡U®ã«FÙC(îk(ûU¥"^±2ÚπFh>Â]VÒ##¿¡HÑ›XWÓct
°¸®}˛s!…|2¯Ä[‰9â“mÑ›Ïç‚«§ì.”=¿ıâè∂2AH=œiÅg¬qòÍÎí}i
`ávo!‹ó/Ù¡∫⁄à
ŸÁQ ;L¢wÅ5[xS‡6$”yÇ„ÉV5M*¸f¡Í≠ÃS∫i¿ºéüÁ>Y®îo•ßÉp¡Œ,…˝ΩEäªò!Ô_¢·≠…•xú340031Qpv÷À(f∏^4uV◊æ‹ﬁ£µÎ~~[uÓ›o}#CàäƒúÙTêí |Å&ÕìQ|uìj¶9æŒÿ—Æê «E+Ëtè xúÖTÀn€FÖSßçô¢-‡ Aãã¿ÄHÀ2¨»¬	ΩH¨ ö&jPoT!ã#ã09TÜCôJpù]˝A—}Zı˙]tﬂ?ËÆª†gÜ¢ƒ»F¨5sÊ‹sÔÃ}¸wÔS„˝oOπbdòåy3lëYÌÛn<[>g ˘„çuÕ€˛E˘A∂‰Jç ﬂ˙˚ìÜÂ1H≤ ·‰ZDtH/îÙ≈±EczD˚Qrp≥>†°¯1ó”˚+„ïuèKŸ/˙—È÷œúy”ø.^˛∂V#_%S|RΩ|˚+´Võ¸≥vmÚÔ⁄˙*Tv¶ï+˜W&~˝›s•Uú…«µÎø∫PÙá6…^¶X÷±°ˆ“°ó‰ÍËv>;9ˇ`Ú˙õõﬂ/INÉ´ØNˇ∏˙n5≥*Ov‘◊´ıqÖI†|⁄›•üX»©∂GxÎ÷‚@ÄﬁìΩaôlí@‹¡“0ÆÀÉgd;s¿%/“¢Ä+J5Ag „9®)Hát'Ω≥ÄFèó1CïhXº>ái‡3‰! ;•ÕMj8îU·vöUj,)PäÜ˘7ÉmcéËﬂë~∏;ñ
sJ«π¿iƒÛ{Zøï∞ÿo%ë‚“†`∑å“õ‹˛ïﬁ·—qöoQÒsÈ#–±ÚåóÓCéFQ0'ù†ÄOËÅ[á¬cƒ˚Hıπ<ı±vID:∂å<§≤C6¿'ÚËƒiﬂ›ﬁ>©’;(<¡Sıeü¨ƒpQ∏◊À.ÁL[TÎê˜¢Ïu˝i≥òÖlhôwS7ëíˆ(‘•ÿ)¿≤;Mÿ-mΩÉ”¬˛<N›Lãî#ñ5–ãñ)a‰Ã˛Z∫	äSë;S)2”V?^N4…ÁIû%83∂πØ„¶Û¬¨J§†m*fúi"C«ò˚2[œA«“≈∑UÆ†≤ÅíLƒΩHÜMmîÕ|X¶¿˙—q~Òµ!’ô.…D Ú∆§tåÓ¡=3*öﬁ+⁄4•˙ΩÚ	k.W[zâË“πŒ
Ì~|ë¯í˙—ätC¶<=–√ö˘B÷í0‘˙òsÖÚ≈Áÿ≈wè˚Lö
n∑õB˘j¥œ{ùRÑf}˛ëUì3Û^l∆_O∑aÿçDóÈÓƒÓ)Ü,•HJ÷ã∫g k/œërƒÊ›ö≤¸?ÃF!H±8xúïP]k¬@|ø_1ÿÇâi+¥ Xê*˝@ZÇ÷È√Y/Èa>$πìÿ⁄ˇﬁ€Kµ•¥˜ê‹ÏŒŒÕ˚NÜΩ«€ÁﬁÌ c/#Æƒœ"äNºO∂ﬂˆ5œ•ØS%rj1/”La»ìPÛP¥™±÷¯ÓóVÀ
l	7ΩciËt0·ë%Í2 
∫ò†V‘¶≥.Òö∞L®X4
4Õw›4ÕR´~(Vˇá⁄\¨ÉÇ±∑4sÒJj#ï…$Ñw]Í“≈«¥/^_v¨¬ ÚÛº@'v≤üÍYdéo[R985Ooúç⁄.mÑÜ©7—ﬁºîN¸˙åí’\Ò»hf:1Õ∑|cmUQ\kêjÃeBö˜Op‹u1OwaÌR,”˙ûﬁa?N:ûá˜cé≠“Vˇ¥¯ÒËÃ⁄Êæ4	(ú:Êg∏ºrMñ€≠∫c≠ˆ¯»Ñ“YÁ>	d1ÄÛ†sg(’ÄjJÑ"‚‹u]8ûôbºx‰±@≠Y£⁄èÙó≥ãQjº2I~*œÊÈXGJ¢Œ›mØÚÑ˚¬˙ÚÄÁÇxúkdod€∞åëIWwÚ2FUuöÒ_tFjQjJ~rç°∂QMÏ‰Lr

Eôy%
e\0ñäBJfZö∫BôB 5B•xú340031Qpv÷À(f`¨[òou∫”–®Oˆd∏Õäy…«˛º4Ñ®HÃIO)±º†ÎπóÒÛóŸ_Vñw	ÏéiLj Lπ<Óä)xú˚g¸Ks√T∂…3Ÿ‘&ÔÊî€¸ÅÕöq≥á;˚f	ë˘¨ »£&’Øˇñº/p
@Y¬§R∫ /úòa2689c0420924ddff2e77429e23fded9144c923f
ref: refs/remotes/origin/master

module Algebra.CAS (
  module Algebra.CAS.Base
, module Algebra.CAS.Diff
, module Algebra.CAS.GrobnerBasis
, module Algebra.CAS.Integrate
, module Algebra.CAS.Solve
) where

import Algebra.CAS.Base
import Algebra.CAS.Diff
import Algebra.CAS.GrobnerBasis
import Algebra.CAS.Integrate
import Algebra.CAS.Solve

{-#LANGUAGE OverloadedStrings#-}

module Algebra.CAS.Base where

--import Data.String
import Data.List(nub)

-- | Mathematical constant expression
data Const =
   Zero  -- ^ Zero
 | One   -- ^ One
 | CI Integer -- ^ Integer
 | CF Integer Integer  -- ^ Faction = CF numer denom
 | CR Double -- ^ Real Number
 deriving (Eq,Show,Read)

instance Ord Const where
  compare Zero Zero = EQ
  compare Zero One = LT
  compare Zero (CI a) = compare 0 a
  compare Zero (CF a b) = compare 0 (a*b)
  compare Zero (CR a) = compare 0 a
  compare One One = EQ
  compare One (CI a) = compare 1 a
  compare One (CF a b) = compare 1 (a*b)
  compare One (CR a) = compare 1 a
  compare (CI a) (CI b) = compare a b
  compare (CI a) (CF b c) =
    let v = fromIntegral b / fromIntegral c :: Double
    in compare (fromIntegral a) v
  compare (CI a) (CR b) = compare (fromIntegral a)  b
  compare (CF a b) (CF c d) =
    let v0 = fromIntegral a / fromIntegral b :: Double
        v1 = fromIntegral c / fromIntegral d :: Double
    in compare v0 v1
  compare (CF a b) (CR c) = compare (fromIntegral a / fromIntegral b) c
  compare (CR a) (CR b) = compare a b
  compare a b =
    case compare b a of
    LT -> GT
    GT -> LT
    EQ -> EQ

neg :: Const
neg = CI (-1)

constSimplify :: Const -> Const
constSimplify (CI 0) = Zero
constSimplify (CI 1) = One
constSimplify (CF 0 _) = Zero
constSimplify (CF a 1) = (CI a)
constSimplify (CF a (-1)) = (CI (-a))
constSimplify (CF a b) | a == b = One
                       | otherwise =
                         case gcd a b of
                         1 -> CF a b
                         g -> constSimplify $ CF (a`div`g) (b`div`g)
constSimplify (CR 0) = Zero
constSimplify (CR 1) = One
constSimplify a = a

instance Num Const where
  fromInteger 0 = Zero
  fromInteger 1 = One
  fromInteger a = CI (fromIntegral a)
  (+) a'' b'' = 
    case (a'',b'') of
    (Zero,Zero) -> Zero
    (Zero,b) -> b
    (One,One) -> CI 2
    (One,CI b') -> constSimplify $ CI (1+b')
    (One,CF a' b') -> constSimplify $ CF (a'+b') b'
    (One,CR b') -> constSimplify $ CR (1+b')
    (CI a',CI b') -> constSimplify $ CI (a'+b')
    (CI a',CF b' c') -> constSimplify $ CF (b'+c'*a') c'
    (CI a',CR b') -> constSimplify $ CR ((fromIntegral a')+b')
    (CF a' b',CF c' d') -> constSimplify $ CF (a'*d'+b'*c') (b'*d')
    (CF a' b',CR c') -> constSimplify $ CR ((fromIntegral a')/(fromIntegral b')+c')
    (CR a',CR b') -> constSimplify $ CR (a'+b')
    (a,b) -> (+) b a
  (-) a b | a == b = Zero
          | otherwise = a + (neg * b)
  (*) a'' b'' =
    case (a'',b'') of
    (Zero,Zero) -> Zero
    (Zero,_) -> Zero
    (One,One) -> One
    (One,a') -> a'
    (CI a',CI b') -> constSimplify $ CI (a'*b')
    (CI a',CF b' c') -> constSimplify $ CF (b'*a') c'
    (CI a',CR b') -> constSimplify $ CR ((fromIntegral a')*b')
    (CF a' b',CF c' d') -> constSimplify $ CF (a'*c') (b'*d')
    (CF a' b',CR c') -> constSimplify $ CR (fromIntegral a' * c' / fromIntegral b')
    (CR a',CR b') -> constSimplify $ CR (a'*b')
    (_,Zero) -> Zero
    (a',One) -> a'
    (a,b) -> (*) b a
  abs Zero = Zero
  abs One = One
  abs (CI a) = CI (abs a)
  abs (CF a b) = CF (abs a) (abs b)
  abs (CR a) = CR (abs a)
  signum Zero = CI 0
  signum One  = CI (-1)
  signum (CI a) = CI (signum a)
  signum (CF a b) = CI $ signum a * signum b
  signum (CR a) = CI $ round $ signum a

instance Fractional Const where
  fromRational 0 = Zero
  fromRational 1 = One
  fromRational a = CR (fromRational a)
  recip a = (/) One a
  (/) a' b' =
    case (a',b') of
    (Zero,_) -> Zero
    (_,Zero) -> error "DivideByZero"
    (One,One) -> One
    (One,CI (-1)) -> CI (-1)
    (One,CI a) -> CF 1 a
    (One,CF a b) -> CF b a
    (One,CR a) -> CR (1/a)
    (CI a,CI (-1)) -> CI (-a)
    (CI a,CI b) -> constSimplify $ CF a b
    (CI a,CF b c) -> constSimplify $ CF (a*c) b
    (CI a,CR b) -> constSimplify $ CR (fromIntegral a /b)
    (CF a b,CF c d) -> constSimplify $ CF (a*d) (b*c)
    (CF a b,CR c) -> constSimplify $ CR (fromIntegral a /fromIntegral b * c)
    (CR a,CR b) -> constSimplify $ CR (a/b)
    (a,One) -> a
    (a,CI (-1)) -> -a
    (CF b c,CI a) -> constSimplify $ CF b (a*c)
    (CR b,CI a) -> constSimplify $ CR (b/fromIntegral a)
    (CR c,CF a b) -> constSimplify $ CR (fromIntegral b /fromIntegral a * c)

instance Enum Const where
  succ a = a+1
  pred a = a-1
  toEnum v = fromIntegral v
  fromEnum Zero = 0
  fromEnum One = 1
  fromEnum (CI a) = fromEnum a
  fromEnum (CR a) = fromEnum a
  fromEnum (CF a b) = fromEnum ((fromIntegral a::Double)  / fromIntegral b)

instance Real Const where
  toRational Zero = toRational (0::Int)
  toRational One = toRational (1::Int)
  toRational (CI v) = toRational v
  toRational (CR v) = toRational v
  toRational (CF a b) = toRational ((fromIntegral a :: Double) / fromIntegral b)

instance Floating Const where
  pi = CR pi
  exp Zero = 1
  exp a = CR $ exp $ fromRational $ toRational a
  sqrt (CI a) | a2 == a = CI a1
              | otherwise = CR $ sqrt $ fromRational $ toRational a
    where
      a0 = sqrt (fromIntegral a) :: Double
      a1 = round a0 :: Integer
      a2 = a1 * a1
  sqrt a = CR $ sqrt $ fromRational $ toRational a
  log One = Zero
  log a = CR $ log $ fromRational $ toRational a
  (**) _ Zero = 1
  (**) a One = a
  (**) a (CI b) = a^b
  (**) a b = CR $ (fromRational $ toRational a :: Double) ** (fromRational $ toRational b :: Double)
  logBase a b = CR $ logBase (fromRational $ toRational $ a) (fromRational $ toRational $ b)
  sin a = CR $ sin $ fromRational $ toRational a
  tan a = CR $ tan $ fromRational $ toRational a
  cos a = CR $ cos $ fromRational $ toRational a
  asin a = CR $ asin $ fromRational $ toRational a
  atan a = CR $ atan $ fromRational $ toRational a
  acos a = CR $ acos $ fromRational $ toRational a
  sinh a = CR $ sinh $ fromRational $ toRational a
  tanh a = CR $ tanh $ fromRational $ toRational a
  cosh a = CR $ cosh $ fromRational $ toRational a
  asinh a = CR $ asinh $ fromRational $ toRational a
  atanh a = CR $ atanh $ fromRational $ toRational a
  acosh a = CR $ acosh $ fromRational $ toRational a

toInt :: Const -> Maybe Integer
toInt Zero = Just $ 0
toInt One = Just $ 1
toInt (CI a) = Just $ a
toInt _ = Nothing

mapTuple :: (a -> b) -> (a,a) ->  (b,b)
mapTuple f (a,b) = (f a, f b)

instance Integral Const where
  quot a b = fst $ quotRem a b
  rem a b = snd $ quotRem a b
  quotRem a b =
    case (toInt a,toInt b) of
    (Just a',Just b') -> mapTuple (constSimplify.CI) $ quotRem a' b'
    _ -> if a == b then (1,0) else (0,a)
  div = quot
  mod = rem
  toInteger Zero = 0
  toInteger One = 1
  toInteger (CI a) = toInteger a
  toInteger a = error $ "can not do toInteger:" ++ show a


data SpecialFunction =
   Sin Formula
 | Cos Formula
 | Tan Formula
 | Sinh Formula
 | Cosh Formula
 | Tanh Formula
 | Asin Formula
 | Acos Formula
 | Atan Formula
 | Asinh Formula
 | Acosh Formula
 | Atanh Formula
 | Exp Formula
 | Log Formula
 | Abs Formula
 | Sig Formula
 | LogBase Formula Formula
 | Sqrt Formula
 | Diff Formula Formula
 | Integrate Formula Formula
 deriving (Show,Read,Eq,Ord)

-- | Mathematical expression
data Formula =
   C Const -- ^ Constant value
 | Pi      -- ^ Pi
 | I       -- ^ Imaginary Number
 | CV String -- ^ Constant variable which is used to deal variable(V Name) as constant value
 | V String  -- ^ Variable
 | S SpecialFunction  -- ^ Special Functions (sin, cos, exp and etc..)
 | Formula :^: Formula
 | Formula :*: Formula
 | Formula :+: Formula
 | Formula :/: Formula
 deriving (Eq,Read)

(=:) :: Formula -> Formula -> Formula
(=:) a b = a - b
infix 0 =:

instance Ord Formula where
  compare (C a) (C b) = compare a b
  compare (C _) Pi = LT
  compare (C _) I = LT
  compare (C _) (CV _) = LT
  compare (C _) _ = LT
  compare Pi (C _) = GT
  compare Pi Pi = EQ
  compare Pi I = LT
  compare Pi (CV _) = LT
  compare Pi _ = LT
  compare I (C _) = GT
  compare I Pi = GT
  compare I I = EQ
  compare I (CV _) = LT
  compare I _ = LT
  compare (CV _) (C _) = GT
  compare (CV _) Pi = GT
  compare (CV _) I = GT
  compare (CV a) (CV b) = compare a b
  compare (CV _) _ = LT
  compare (V a) (V b) = compare a b
  compare (V _) b@(S _) | isConst b = GT
                        | otherwise = LT
  compare a@(V _) (c@(V _):^:d) | a == c = compare 1 d
                                | otherwise = compare a c
  compare (V _) b | isConst b = GT
                  | otherwise = LT
  compare (S a) (S b) = compare a b
  compare (a :*: b) (c :*: d) | b == d = compare a c
                              | otherwise = compare b d
  compare (_ :*: b) c | b == c = GT
                      | otherwise = compare b c
  compare a (_ :*: c) | a == c = LT
                      | otherwise = compare a c
  compare (a :^: b) (c :^: d) | a == c = compare b d
                              | otherwise = compare a c
  compare (a :^: b) c | a == c = compare b 1
                      | otherwise = compare a c
  compare a (b :^: c) | a == b = compare 1 c
                      | otherwise = compare a b
  compare (a :+: b) (c :+: d) | b == d = compare a c
                              | otherwise = compare b d
  compare (_ :+: b) c | b == c = GT
                      | otherwise = compare b c
  compare a (b :+: c) | a == c = LT
                      | otherwise = compare b c
  compare (a :/: b) (c :/: d) = compare (a*d) (c*b)
  compare (_ :/: b) c = compare b (c*b)
  compare a (b :/: c) = compare (a*c) b
  compare a b =
    case (isConst a,isConst b) of
    (True,True) -> EQ
    (True,False) -> LT
    (False,True) -> GT
    (False,False) -> 
      case compare b a of
      LT -> GT
      GT -> LT
      EQ -> EQ

tryPlus :: Formula -> Formula -> Maybe Formula
tryPlus (C Zero) (C Zero) = Just $ (C Zero)
tryPlus (C Zero) a = Just $ a
tryPlus a (C Zero) = Just $ a
tryPlus (C a) (C b) = Just $ C (a+b)
tryPlus I I = Just $ (C (CI 2)) :*: I
tryPlus a@(V _) b@(V _) | a == b = Just $ (C (CI 2)) :*: a
                        | otherwise = Nothing
tryPlus a@(V _:^: _) b@(V _:^: _) | a == b = Just $ (C (CI 2)) :*: a
                                  | otherwise = Nothing
tryPlus (a:+:b) c =
  case tryPlus b c of
  Nothing ->
    case tryPlus a c of
    Nothing -> Nothing
    Just v -> Just $ v + b
  Just v -> Just $ a + v
tryPlus (a:*:b) (c:*:d) =
  if b == d then
    case tryPlus a c of
    Nothing -> Nothing
    Just v -> Just $ v * b
  else
    Nothing
tryPlus (a:*:b) d =
  if b == d then
    case tryPlus a (C One) of
    Nothing -> Nothing
    Just v -> Just $ v * b
  else
    Nothing
tryPlus a (c:*:d) =
  if a == d then
    case tryPlus (C One) c of
    Nothing -> Nothing
    Just v -> Just $ v * a
  else
    Nothing
tryPlus _ _ = Nothing

insertPlus :: Formula -> Formula -> Formula
insertPlus a'@(a:+:b) v | v <= b = insertPlus a v :+: b
                       | otherwise = a':+:v
insertPlus a v | a <= v = a :+: v
               | otherwise = v :+: a

-- | try simplification for multiply
-- 
-- >>> let [x,y] = map V ["x","y"]
-- >>> tryMul (x**(-1)) x
-- Just 1
tryMul :: Formula -> Formula -> Maybe Formula
tryMul I I = Just $ C neg
tryMul (C Zero) _ = Just $ C Zero
tryMul _ (C Zero) = Just $ C Zero
tryMul (C One) a = Just $ a
tryMul a (C One) = Just $ a
tryMul (C a) (C b) = Just $ C (a*b)
tryMul a@(V _) b@(V _) | a == b = Just $ a :^: (C (CI 2))
                       | otherwise = Nothing
tryMul (a@(V _):^: b@_) (c@(V _):^:d@_) | a == c = Just $ if b+d==0 then 1 else a :^: (b+d)
                                        | otherwise = Nothing
tryMul a@(V _) (c@(V _):^:d@_) | a == c = Just $ if 1+d == 0 then 1 else  a :^: (1+d)
                               | otherwise = Nothing
tryMul (a@(V _):^: b@_) c@(V _) | a == c = Just $ if b+1 == 0 then 1 else a :^: (b+1)
                                | otherwise = Nothing
tryMul (a@(V _):/: b) c | b == c = Just $ a
                        | otherwise = Nothing
tryMul (a:*:b) c = 
  case tryMul b c of
  Nothing ->
    case tryMul a c of
    Nothing -> Nothing
    Just v -> Just $ v * b
  Just v -> Just $ a * v
tryMul _ _ = Nothing

insertMul :: Formula -> Formula -> Formula
insertMul a'@(a:*:b) v | v <= b = insertMul a v :*: b
                       | otherwise = a':*:v
insertMul a v | a <= v = a :*: v
              | otherwise = v :*: a


constDiv :: Formula -> Formula -> Formula
constDiv a'' b'' = 
  case (a'',b'') of
  (C a',C b') -> C (a'/b')
  (C Zero,_) -> C Zero
  (_,C Zero) -> error "divide by zero"
  (C One,b) -> C One :/: b
  (a,C One) -> a
  (a,C c) -> C (1/c) * a
  (a,b) | a == b -> C One
        | otherwise -> a :/: b

splitExp :: Formula -> (Formula,Formula)
splitExp (a:^:b) = (a,b)
splitExp a = (a,1)

divGB :: Formula -> Formula -> Formula
divGB a b = conv $ (ca `constDiv` cb) * divGB' va vb
  where
    (ca,va) = head' a
    (cb,vb) = head' b
    head' :: Formula -> (Formula,Formula)
    head' v' = var (firstTerm,1)
      where
        firstTerm = v'
        var (c,v) =
          case (isConst c) of
          True -> (c,v)
          False -> var (tailMul c,headMul c*v)
    conv (a':*:((C One):/:c)) = a':/:c
    conv a' = a'

divGB' :: Formula -> Formula -> Formula
divGB' 1 1 = 1
divGB' a 1 = a
divGB' 1 a = 1 `constDiv` a
divGB' a b =
  if hva == hvb
  then divGB' ta tb * (hva ** (hpa- hpb))
  else if hva < hvb
       then divGB' a tb `constDiv` (hvb ** hpb)
       else divGB' ta b * (hva ** hpa)
  where
    (hva,hpa) = splitExp $ headMul a
    (hvb,hpb) = splitExp $ headMul b
    ta = tailMul a
    tb = tailMul b

divAll :: Formula -> Formula -> Formula
divAll a b = expand $ t + (h/b)
  where
    h = headAdd a
    t = case (tailAdd a) of
      0 -> 0
      v -> divAll v b

instance Num Formula where
  fromInteger 0 = C Zero
  fromInteger 1 = C One
  fromInteger a = C $ CI (fromIntegral a)
  (+) a (b:+:c) =
    case tryPlus a c of
    Just v -> v + b
    Nothing -> insertPlus a c + b
  (+) a b =
    case tryPlus a b of
    Just v -> v
    Nothing -> insertPlus a b
  (-) a b | a == b = C Zero
          | otherwise = a + (b * (C neg))
  (*) a (b:*:c) =
    case tryMul a c of
    Just v -> v * b
    Nothing -> insertMul a c * b
  (*) a b =
    case tryMul a b of
    Just v -> v
    Nothing -> insertMul a b
  abs a = S (Abs a)
  signum a = S (Sig a)

instance Fractional Formula where
  fromRational 0 = C Zero
  fromRational 1 = C One
  fromRational a = C $ CR (fromRational a)
  recip a = (/) (C One) a
  (/) a b = divGB a b

instance Floating Formula where
  pi = Pi
  exp (C Zero) = C One
  exp a = S $ Exp a
  sqrt (C Zero) = 0
  sqrt (C One) = 1
  sqrt a'@(C (CI a)) | a < 0 = I * sqrt (-a')
                     | a2 == a = C $ CI a1
                     | otherwise = S $ Sqrt a'
    where
      a0 = sqrt (fromIntegral a) :: Double
      a1 = round a0 :: Integer
      a2 = a1 * a1
  sqrt a = S $ Sqrt a
  log (C One) = C Zero
  log a = S $ Log a
  (**) _ (C Zero) = C One
  (**) (C (CI a)) (C (CI b)) = C (CI (a^b))
  (**) a (C One) = a
  (**) a b = (:^:) a b
  logBase a b = S $ LogBase a b 
  sin = S . Sin
  tan = S . Tan
  cos = S . Cos
  asin = S . Asin
  atan = S . Atan
  acos = S . Acos
  sinh = S . Sinh
  tanh = S . Tanh
  cosh = S . Cosh
  asinh = S . Asinh
  atanh = S . Atanh
  acosh = S . Acosh

--instance IsString Formula where
--  fromString = val

-- | Lift String to variable of Formula
val ::  String ->  Formula
val v = V v

-- | Lift String to constant of Formula
cval :: String ->  Formula
cval v = CV v

instance Enum Formula where
  succ a = a+1
  pred a = a-1
  toEnum v = fromIntegral v
  fromEnum (C Zero) = 0
  fromEnum (C One) = 1
  fromEnum (C (CI a)) = fromIntegral a
  fromEnum a = error $ "can not do fromEnum:" ++ show a

instance Real Formula where
  toRational (C (CI v)) = toRational v
  toRational (C (CR v)) = toRational v
  toRational Pi = toRational (pi::Double)
  toRational (C Zero) = toRational (0::Int)
  toRational (C One) = toRational (1::Int)
  toRational _ = toRational (0::Int)


lcmMonomial :: Formula -> Formula -> Formula
lcmMonomial a b = lcmV ca cb * lcmMonomial' va vb
  where
    (ca,va) = headV a
    (cb,vb) = headV b
    lcmV :: Formula -> Formula -> Formula
    lcmV (C a') (C b') = C (lcm a' b')
    lcmV a' b' = a' * b'

lcmMonomial' :: Formula -> Formula -> Formula
lcmMonomial' 1 1 = 1
lcmMonomial' a 1 = a
lcmMonomial' 1 a = a
lcmMonomial' a b = 
  if hva == hvb
  then lcmMonomial' ta tb * (hva ** max hpa hpb)
  else if hva < hvb
       then lcmMonomial' a tb * (hvb ** hpb)
       else lcmMonomial' ta b * (hva ** hpa)
  where
    (hva,hpa) = splitExp $ headMul a
    (hvb,hpb) = splitExp $ headMul b
    ta = tailMul a
    tb = tailMul b

reduction :: Formula -> Formula -> (Formula,Formula)
reduction f g =
  if va == vl
  then
    if va == 1
    then (ca/cb,0)
    else
      let (a,b) = reduction (expand (f - c*g)) g
      in (c+a,b)
  else
    case mt of
    0 -> (0,h)
    t -> let (a,b) = reduction t g
         in (a,b+h)
  where
    (ca,va) = headV f
    (cb,vb) = headV g
    lcm' = lcmMonomial va vb
    (cl,vl) = headV lcm'
    h = headAdd f
    mt = tailAdd f
    c = (lcm' / vb)*ca/cb

reductions :: Formula -> [Formula] -> Formula
reductions f [] = f
reductions f (g:gs) =
  let (_,b) = reduction f g
  in case b of
     0 -> 0
     c -> expand $ reductions (expand c) gs

instance Integral Formula where
  quot a b = fst $ quotRem a b
  rem a b = snd $ quotRem a b
  quotRem = reduction
  div = quot
  mod = rem
  toInteger (C Zero) = 0
  toInteger (C One) = 1
  toInteger (C (CI a)) = toInteger a
  toInteger a = error $ "can not do toInteger:" ++ show a

degree :: Formula -> Formula
degree (C _) = 0
degree (CV _) = 0
degree (V _) = 1
degree (S (Sin v)) = degree v
degree (S (Cos v)) = degree v
degree (S (Tan v)) = degree v
degree (S (Sinh v)) = degree v
degree (S (Cosh v)) = degree v
degree (S (Tanh v)) = degree v
degree (S (Asin v)) = degree v
degree (S (Acos v)) = degree v
degree (S (Atan v)) = degree v
degree (S (Asinh v)) = degree v
degree (S (Acosh v)) = degree v
degree (S (Atanh v)) = degree v
degree (S (Exp v)) = degree v
degree (S (Log v)) = degree v
degree (S (Abs v)) = degree v
degree (S (Sig v)) = degree v
degree (S (LogBase v0 v1)) = max (degree v0) (degree v1)
degree Pi = 0
degree I = 0
degree (S (Sqrt v)) = degree v
degree (S (Diff v0 v1)) = max (degree v0) (degree v1)
degree (S (Integrate v0 v1)) =  max (degree v0) (degree v1)
degree (v0 :^: v1) = v1 * degree v0
degree (v0 :*: v1) = max (degree v0) (degree v1)
degree (v0 :+: v1) = max (degree v0) (degree v1)
degree (v0 :/: v1) = max (degree v0) (degree v1)


converge ::  (Formula ->  Formula) -> Formula -> Formula
converge func v =
  let v' = func v
  in if v' ==  v
     then v'
     else converge func v'

expand :: Formula -> Formula
expand ((a:+:b):*:c) = let (a',b',c') = (expand a,expand b,expand c) in expand (a'*c') + expand (b'*c')
expand (a:*:(b:+:c)) = let (a',b',c') = (expand a,expand b,expand c) in expand (a'*b') + expand (a'*c')
expand (a:+:b) = let (a',b') = (expand a,expand b) in  a'+b'
expand c@(a:*:b) = let (a',b') = (expand a,expand b)
                       c' = a'*b'
                   in if c==c' then c' else expand c'
expand (a:/:1) = expand a
expand a = a


gcdPolynomial :: Formula -> Formula -> Formula
gcdPolynomial a b | a == 0 = b
                  | b == 0 = a
                  | otherwise =
                      let (a',b') = if a>=b then (a,b) else (b,a)
                          r = a' `rem` b'
                      in case r of
                         0 -> b'
                         _ -> if r == a' then 1 else gcdPolynomial r b'

lcmPolynomial :: Formula -> Formula -> Formula
lcmPolynomial a b =
  let g = gcdPolynomial a b
      d0 = a `div` g
      d1 = b `div` g
  in expand $ d0*d1*g

headAdd :: Formula -> Formula
headAdd (_ :+: ab) = ab
headAdd ab = ab
tailAdd :: Formula -> Formula
tailAdd (a :+: _) = a
tailAdd _ = 0
mapAdd :: (Formula -> Formula) -> Formula -> Formula
mapAdd func formula =
  case t of
  0 -> func h
  _ -> (mapAdd func t) + (func h)
  where
    h = headAdd formula
    t = tailAdd formula

splitAdd :: Formula -> [Formula]
splitAdd formula =
  case t of
  0 -> [h]
  _ -> h:(splitAdd t)
  where
    h = headAdd formula
    t = tailAdd formula

headMul :: Formula -> Formula
headMul (_ :*: ab) = ab
headMul ab = ab
tailMul :: Formula -> Formula
tailMul (a :*: _) = a
tailMul _ = 1

headDiv :: Formula -> Formula
headDiv (_ :/: ab) = ab

headDiv ab = ab
tailDiv :: Formula -> Maybe Formula
tailDiv (a :/: _) = Just a
tailDiv _ = Nothing


-- | substitute expression
-- 
-- >>> let [x,y,z] = map V ["x","y","z"]
-- >>> subst [(x,3),(y,5)] $ x+y
-- 8
-- >>> subst [(tan(x),z)] (tan(x)**2+1)
-- 1 + z^2
subst :: [(Formula,Formula)] -- ^ List of tuple(orignal term, new term)
      -> Formula  -- ^ original formula
      -> Formula  -- ^ replaced formula
subst [] formula = formula
subst ((org,mod'):other) formula = subst other $ subst' org mod' formula

subst' :: Formula -> Formula -> Formula -> Formula
subst' org new formula =
  if org == formula
  then new
  else case formula of
         a@(C _) -> a
         a@(CV _) -> a
         a@Pi -> a
         a@I -> a
         a@(V _) -> a
         (S (Sin v)) -> S $ Sin $ subst' org new v
         (S (Cos v)) -> S $ Cos $ subst' org new v
         (S (Tan v)) -> S $ Tan $ subst' org new v
         (S (Sinh v)) -> S $ Sinh $ subst' org new v
         (S (Cosh v)) -> S $ Cosh $ subst' org new v
         (S (Tanh v)) -> S $ Tanh $ subst' org new v
         (S (Asin v)) -> S $ Asin $ subst' org new v
         (S (Acos v)) -> S $ Acos $ subst' org new v
         (S (Atan v)) -> S $ Atan $ subst' org new v
         (S (Asinh v)) -> S $ Asinh $ subst' org new v
         (S (Acosh v)) -> S $ Acosh $ subst' org new v
         (S (Atanh v)) -> S $ Atanh $ subst' org new v
         (S (Exp v)) -> S $ Exp $ subst' org new v
         (S (Log v)) -> S $ Log $ subst' org new v
         (S (Abs v)) -> S $ Abs $ subst' org new v
         (S (Sig v)) -> S $ Sig $ subst' org new v
         (S (LogBase v1 v2)) -> S $ LogBase (subst' org new v1) (subst' org new v2)
         (S (Sqrt v)) -> S $ Sqrt $ subst' org new v
         (S (Diff v1 v2)) -> S $ Diff (subst' org new v1) (subst' org new v2)
         (S (Integrate v1 v2)) -> S $ Integrate (subst' org new v1) (subst' org new v2)
         (a:^:b) -> subst' org new a ** subst' org new b
         (a:*:b) -> subst' org new a * subst' org new b
         (a:+:b) -> subst' org new a + subst' org new b
         (a:/:b) -> subst' org new a / subst' org new b


mapFormula :: (Formula -> Formula) -> Formula -> Formula
mapFormula conv a@(C _) = conv a
mapFormula conv a@(CV _) = conv a
mapFormula conv a@Pi = conv a
mapFormula conv a@I = conv a
mapFormula conv a@(V _) = conv a
mapFormula conv (S (Sin v)) = S $ Sin $ mapFormula conv v
mapFormula conv (S (Cos v)) = S $ Cos $ mapFormula conv v
mapFormula conv (S (Tan v)) = S $ Tan $ mapFormula conv v
mapFormula conv (S (Sinh v)) = S $ Sinh $ mapFormula conv v
mapFormula conv (S (Cosh v)) = S $ Cosh $ mapFormula conv v
mapFormula conv (S (Tanh v)) = S $ Tanh $ mapFormula conv v
mapFormula conv (S (Asin v)) = S $ Asin $ mapFormula conv v
mapFormula conv (S (Acos v)) = S $ Acos $ mapFormula conv v
mapFormula conv (S (Atan v)) = S $ Atan $ mapFormula conv v
mapFormula conv (S (Asinh v)) = S $ Asinh $ mapFormula conv v
mapFormula conv (S (Acosh v)) = S $ Acosh $ mapFormula conv v
mapFormula conv (S (Atanh v)) = S $ Atanh $ mapFormula conv v
mapFormula conv (S (Exp v)) = S $ Exp $ mapFormula conv v
mapFormula conv (S (Log v)) = S $ Log $ mapFormula conv v
mapFormula conv (S (Abs v)) = S $ Abs $ mapFormula conv v
mapFormula conv (S (Sig v)) = S $ Sig $ mapFormula conv v
mapFormula conv (S (LogBase v1 v2)) = S $ LogBase (mapFormula conv v1) (mapFormula conv v2)
mapFormula conv (S (Sqrt v)) = S $ Sqrt $ mapFormula conv v
mapFormula conv (S (Diff v1 v2)) = S $ Diff (mapFormula conv v1) (mapFormula conv v2)
mapFormula conv (S (Integrate v1 v2)) = S $ Integrate (mapFormula conv v1) (mapFormula conv v2)
mapFormula conv (a:^:b) = mapFormula conv a ** mapFormula conv b
mapFormula conv (a:*:b) = mapFormula conv a * mapFormula conv b
mapFormula conv (a:+:b) = mapFormula conv a + mapFormula conv b
mapFormula conv (a:/:b) = mapFormula conv a / mapFormula conv b


-- | When formula does not include variable,
-- isConst returns True.
-- 
-- >>> let x = "x" :: Formula
-- >>> isConst x
-- False
-- >>> isConst $ sin(x)*3
-- False
-- >>> isConst $ 3.0 * sin(3.0)
-- True
isConst :: Formula ->  Bool
isConst (C _) = True
isConst (CV _) = True
isConst (V _) = False
isConst (S (Sin v)) = isConst v
isConst (S (Cos v)) = isConst v
isConst (S (Tan v)) = isConst v
isConst (S (Sinh v)) = isConst v
isConst (S (Cosh v)) = isConst v
isConst (S (Tanh v)) = isConst v
isConst (S (Asin v)) = isConst v
isConst (S (Acos v)) = isConst v
isConst (S (Atan v)) = isConst v
isConst (S (Asinh v)) = isConst v
isConst (S (Acosh v)) = isConst v
isConst (S (Atanh v)) = isConst v
isConst (S (Exp v)) = isConst v
isConst (S (Log v)) = isConst v
isConst (S (Abs v)) = isConst v
isConst (S (Sig v)) = isConst v
isConst (S (LogBase v0 v1)) = isConst v0 &&  isConst v1
isConst Pi = True
isConst I = True
isConst (S (Sqrt v)) = isConst v
isConst (S (Diff v0 v1)) = isConst v0 &&  isConst v1
isConst (S (Integrate v0 v1)) = isConst v0 &&  isConst v1
isConst (v0 :^: v1) = isConst v0 &&  isConst v1
isConst (v0 :*: v1) = isConst v0 &&  isConst v1
isConst (v0 :+: v1) = isConst v0 &&  isConst v1
isConst (v0 :/: v1) = isConst v0 &&  isConst v1

hasVariable :: Formula -> Formula -> Bool
hasVariable f v = elem v $ variables f

isVariable :: Formula -> Bool
isVariable = not.isConst

variables :: Formula ->  [Formula]
variables (C _) = []
variables (CV _) = []
variables a@(V _) = [a]
variables (S (Sin v)) = variables v
variables (S (Cos v)) = variables v
variables (S (Tan v)) = variables v
variables (S (Sinh v)) = variables v
variables (S (Cosh v)) = variables v
variables (S (Tanh v)) = variables v
variables (S (Asin v)) = variables v
variables (S (Acos v)) = variables v
variables (S (Atan v)) = variables v
variables (S (Asinh v)) = variables v
variables (S (Acosh v)) = variables v
variables (S (Atanh v)) = variables v
variables (S (Exp v)) = variables v
variables (S (Log v)) = variables v
variables (S (Abs v)) = variables v
variables (S (Sig v)) = variables v
variables (S (LogBase v0 v1)) = variables v0 ++  variables v1
variables Pi = []
variables I = []
variables (S (Sqrt v)) = variables v
variables (S (Diff v0 v1)) = variables v0 ++  variables v1
variables (S (Integrate v0 v1)) = variables v0 ++  variables v1
variables (v0 :^: v1) = variables v0 ++  variables v1
variables (v0 :*: v1) = variables v0 ++  variables v1
variables (v0 :+: v1) = variables v0 ++  variables v1
variables (v0 :/: v1) = variables v0 ++  variables v1

denom :: Formula -> Formula
denom (_ :*: (_:/:b)) = b
denom (_:/:b) = b
denom _ = 1

numer :: Formula -> Formula
numer (a :*: (b:/:_)) = a * b
numer (a:/:_) = a
numer a = a

headV :: Formula -- ^ formula
      -> (Formula,Formula) -- ^ (coefficient of first term,variables of first term)
headV v' = var (firstTerm,1)
  where
    firstTerm = headAdd v'
    var (c,v) =
      case (isConst c) of
      True -> (c,v)
      False -> var (tailMul c,headMul c*v)

-- | Pretty print for Formula type.
-- Formula's show function is the same as this.
ppr :: Formula -> String
ppr (C Zero) = "0"
ppr (C One) = "1"
ppr (C (CI a)) = show a
ppr (C (CF a b)) = show a ++"/"++show b
ppr (C (CR a)) = show a
ppr Pi = "œÄ"
ppr I = "i"
ppr (CV v) = v
ppr (V v) = v
ppr (S (Exp v)) = "e(" ++ ppr v ++")"
ppr (S (Log v)) = "log(" ++ ppr v ++")"
ppr (S (Sqrt v)) = "‚àö(" ++ ppr v ++")"
ppr (S (Diff f x)) = "diff(" ++ ppr f ++","++ppr x++")"
ppr (S (Integrate f x)) ="integrate(" ++ ppr f ++","++ppr x++")"
ppr (S (LogBase a b)) = "log_" ++ ppr a++ "(" ++ppr b ++")"
ppr (S (Sig v)) = "sig(" ++ ppr v ++")"
ppr (S (Abs v)) = "|" ++ ppr v ++"|"
ppr (S (Sin v)) = "sin(" ++ ppr v ++")"
ppr (S (Cos v)) = "cos(" ++ ppr v ++")"
ppr (S (Tan v)) = "tan(" ++ ppr v ++")"
ppr (S (Sinh v)) = "sinh(" ++ ppr v ++")"
ppr (S (Cosh v)) = "cosh(" ++ ppr v ++")"
ppr (S (Tanh v)) = "tanh(" ++ ppr v ++")"
ppr (S (Asin v)) = "asin(" ++ ppr v ++")"
ppr (S (Acos v)) = "acos(" ++ ppr v ++")"
ppr (S (Atan v)) = "atan(" ++ ppr v ++")"
ppr (S (Asinh v)) = "asinh(" ++ ppr v ++")"
ppr (S (Acosh v)) = "acosh(" ++ ppr v ++")"
ppr (S (Atanh v)) = "atanh(" ++ ppr v ++")"
ppr (a:^:b) = ppr a ++"^"++ ppr b
ppr (a'@(_:*:_):*:c) = ppr a'++"*" ++ ppr' c
ppr (a:*:b) = ppr' a ++"*"++ ppr' b
ppr (a:+:b) = ppr a ++" + "++ ppr b
ppr (a:/:b) = "(" ++ ppr a ++")/("++ ppr b ++")"

ppr' :: Formula -> String
ppr' c@(C (CI _)) = if c >= 0 then ppr c else "(" ++ ppr c ++ ")"
ppr' c@(C (CR _)) = if c >= 0 then ppr c else "(" ++ ppr c ++ ")"
ppr' c@I = ppr c
ppr' c@Pi = ppr c
ppr' c@(V _) = ppr c
ppr' c@(CV _) = ppr c
ppr' c = "(" ++ ppr c ++ ")"

instance Show Formula where
  show = ppr

-- | This print shows bare structure of Formula type.
-- This string can be read by Formula's read function.
showFormula :: Formula -> String
showFormula (C a) = "C (" ++ show a ++")"
showFormula Pi = "Pi"
showFormula I = "I"
showFormula (CV v) = "CV \"" ++ v ++"\""
showFormula (V v) = "V \"" ++ v ++"\""
showFormula (S a) = "S (" ++ show a ++")"
showFormula (a:^:b) = "(" ++ showFormula a ++" :^: "++ showFormula b ++")"
showFormula (a:*:b) = "(" ++ showFormula a ++" :*: "++ showFormula b ++")"
showFormula (a:+:b) = "(" ++ showFormula a ++" :+: "++ showFormula b ++")"
showFormula (a:/:b) = "(" ++ showFormula a ++" :/: "++ showFormula b ++")"



genCoeff :: String -> Int -> [Formula]
genCoeff prefix a = genCoeff' prefix a
  where
    len = fromIntegral (round (logBase 10 (fromIntegral a))) :: Int
    nstr n =
      let str = show n
          l = length str
      in take (len-l) (repeat '0') ++ str
    genCoeff' prefix' a' | a' <=0 = []
                         | otherwise = CV (prefix' ++ nstr (pred a')) : genCoeff' prefix' (pred a')


genVars :: String -> Int -> [Formula]
genVars prefix a = gen' prefix a
  where
    len = fromIntegral (round (logBase 10 (fromIntegral a))) :: Int
    nstr n =
      let str = show n
          l = length str
      in take (len-l) (repeat '0') ++ str
    gen' prefix' a' | a' <=0 = []
                    | otherwise = V (prefix' ++ nstr (pred a')) : gen' prefix' (pred a')


-- | Find indeterminates of an expression
-- 
-- >>> let [x,y,z] = map V ["x","y","z"]
-- >>> indets (x*y+z/x)
-- [x,y,z]
-- >>> indets (3*x^2-x*y-y^2)
-- [x,y]
-- >>> indets (sin(x)*cos(x)**2)
-- [sin(x),x,cos(x)]
indets :: Formula ->  [Formula]
indets = nub.indets'

indets' :: Formula ->  [Formula]
indets' (C _) = []
indets' (CV _) = []
indets' a@(V _) = [a]
indets' a@(S (Sin v)) = a:indets' v
indets' a@(S (Cos v)) = a:indets' v
indets' a@(S (Tan v)) = a:indets' v
indets' a@(S (Sinh v)) = a:indets' v
indets' a@(S (Cosh v)) = a:indets' v
indets' a@(S (Tanh v)) = a:indets' v
indets' a@(S (Asin v)) = a:indets' v
indets' a@(S (Acos v)) = a:indets' v
indets' a@(S (Atan v)) = a:indets' v
indets' a@(S (Asinh v)) = a:indets' v
indets' a@(S (Acosh v)) = a:indets' v
indets' a@(S (Atanh v)) = a:indets' v
indets' a@(S (Exp v)) = a:indets' v
indets' a@(S (Log v)) = a:indets' v
indets' a@(S (Abs v)) = a:indets' v
indets' a@(S (Sig v)) = a:indets' v
indets' a@(S (LogBase v0 v1)) = a:indets' v0 ++  a:indets' v1
indets' Pi = []
indets' I = []
indets' a@(S (Sqrt v)) = a:indets' v
indets' a@(S (Diff v0 v1)) = (a:indets' v0) ++  indets' v1
indets' a@(S (Integrate v0 v1)) = (a:indets' v0) ++  indets' v1
indets' (v0 :^: v1) = indets' v0 ++  indets' v1
indets' (v0 :*: v1) = indets' v0 ++  indets' v1
indets' (v0 :+: v1) = indets' v0 ++  indets' v1
indets' (v0 :/: v1) = indets' v0 ++  indets' v1

maskVariables :: Formula -- ^ Original formula which is not masked
              -> Formula -- ^ Not masked variable
              -> (Formula, (Formula -> Formula)) -- ^ (masked formula, reverse function)
maskVariables f x =
  let vs = filter ((/=) x) $ variables f
      toCV (V v) = (CV v)
      toCV a = a
      toV (CV v) = (V v)
      toV a = a
      v2cv = zip vs (map toCV vs)
      cv2v = zip (map toCV vs) (map toV vs)
      f' = subst v2cv f
  in (f',subst cv2v)


-- | Greatest common divisor of the coefficients of formula with respect to variable of second function-args
--
-- >>> let [x,y] = map V ["x","y"]
-- >>> content (-4*x*y+6*y^2) x
-- ((-4)*y,x + (3/-2)*y)
content :: Formula -- ^ formula
        -> Formula -- ^ variable
        -> (Formula,Formula) -- ^ (gcd-result,formula/gcd-result)
content f x =
  let (f',rev) = maskVariables (expand f) x
      (c,_) = headV f'
      gcdr = gcdPolynomial f (rev c)
  in (gcdr,f `quot` gcdr)
{-#LANGUAGE TemplateHaskell#-}
{-#LANGUAGE QuasiQuotes#-}

module Algebra.CAS.Diff where

import Algebra.CAS.Base

-- | Partial derivative
-- 
-- >>> let [x,y] = map V ["x","y"]
-- >>> diff (x*y) x
-- y
-- >>> diff (sin(x)*y) x
-- y*(cos(x))
-- >>> diff (x^3) x
-- 3*(x^2)
diff :: Formula -> Formula -> Formula
diff (V x') (V y') | x' == y' = C One
                   | otherwise = C Zero
diff (x :+: y) z = (diff x z) + (diff y z)
diff (x :*: y) z = (diff x z) * y + x * (diff y z)
diff (x :/: y) z = ((diff x z) * y - x * (diff y z)) / (y * y)
diff (x :^: C One) z = diff x z
diff (x :^: C (CI 1)) z = diff x z
diff (x :^: C (CI 2)) z = 2 * x * (diff x z)
diff (x :^: C (CI n)) z = (fromIntegral n) * (x ** (fromIntegral (n-1))) * (diff x z)
diff (S (Sin x')) y' = (S (Cos x')) * (diff x' y')
diff (S (Cos x')) y' = - ((S (Sin x')) * (diff x' y'))
diff (S (Exp x')) y' = (S (Exp x')) * (diff x' y')
diff a@(S (Tan x')) y' =  ( a**2 + 1 )* (diff x' y')

diff (C _) _ = C Zero
diff Pi _ = C Zero
diff (CV _) _ = C Zero
diff (S (Log x')) y' = recip x' * diff x' y'

diff a b = error $ "diff //  can not parse : " ++ show a ++ " ##  " ++ show b

diffn :: Integer -> Formula -> Formula -> Formula
diffn 0 a _ = a
diffn 1 a b = diff a b
diffn n a b | n < 0 = error $ "diffn can not do negative diff. n:" ++ show n
            | otherwise =  diffn (n-1) (diff a b) b
{-#LANGUAGE TemplateHaskell#-}
{-#LANGUAGE QuasiQuotes#-}

module Algebra.CAS.GrobnerBasis where

import Algebra.CAS.Base

sPolynomial :: Formula -> Formula -> Formula
sPolynomial f g = expand $ divAll (expand $ (ca*cb)*(lcmMonomial va vb)*f) (headAdd f)
                         - divAll (expand $ (ca*cb)*(lcmMonomial va vb)*g) (headAdd g)
  where
    (ca,va) = headV f
    (cb,vb) = headV g

allPair :: [t] -> [(t,t)]
allPair [] = []
allPair (x:xs) = map (\x' -> (x,x')) xs ++ allPair xs
  
grobnerG :: [Formula] -> [Formula]
grobnerG formulas = filter ((/=) 0) $ map (uncurry sPolynomial) $ allPair formulas

grobnerBasis :: [Formula] -> [Formula]
grobnerBasis formulas = map lc1 $ grobnerBasis' formulas $ allPair formulas
  where
    lc1 :: Formula -> Formula
    lc1 formula = expand $ formula / ca
      where
        (ca,_) = headV formula

grobnerBasis' :: [Formula] -> [(Formula,Formula)] -> [Formula]
grobnerBasis' formulas [] = formulas
grobnerBasis' formulas ((a,b):other) =
  case reductions (sPolynomial a b) formulas of
  0 -> grobnerBasis' formulas other
  c -> grobnerBasis (formulas++[c])

grobnerBasisIO :: [Formula] -> IO [Formula]
grobnerBasisIO formulas = grobnerBasisIO' formulas $ allPair formulas

grobnerBasisIO' :: [Formula] -> [(Formula,Formula)] -> IO [Formula]
grobnerBasisIO' formulas [] = return formulas
grobnerBasisIO' formulas aa@((a,b):other) = do
  print "formulas"
  print formulas
  print "div"
  print aa
  print "a"
  print a
  print "b"
  print b
  print "sPolynomial"
  print (sPolynomial a b)
  print "r"
  print (reductions (sPolynomial a b) formulas)
  case reductions (sPolynomial a b) formulas of
    0 -> grobnerBasisIO' formulas other
    c -> grobnerBasisIO (formulas++[c])

{-#LANGUAGE TemplateHaskell#-}
{-#LANGUAGE QuasiQuotes#-}

module Algebra.CAS.Integrate where

import Algebra.CAS.Base
import Algebra.CAS.Diff
import Data.List(nub,sort)

-- | integrate function
-- 
-- >>> let x = V "x"
-- >>> integrate x x
-- (1/2)*(x^2)
-- >>> integrate (x^2) x
-- (1/3)*(x^3)
-- >>> integrate (sin x) x
-- (-1)*(cos(x))
integrate :: Formula -> Formula -> Formula
integrate (x :+: y) z = (integrate x z) + (integrate y z)
integrate (a@(C (CI _)) :*: y) z = a * integrate y z
integrate (a@(C _) :*: y) z = a * integrate y z
integrate (C (CI a)) z = (C (CI a)) * z
integrate (C a) z = (C a) * z
integrate (S (Sin x')) y' | x' == y' = -1 * (S $ Cos x')
                          | otherwise = error "can not parse"
integrate (S (Cos x')) y' | x' == y' = (S (Sin x'))
                          | otherwise = error "can not parse"
integrate (x :^: (C (CI 2))) y | x == y    = x ** 3 / 3
                               | otherwise = error "can not parse"
integrate (x :^: (C (CI n))) y | x == y    = (x :^: (C (CI (n+1)))) / (fromIntegral (n+1))
                               | otherwise = error "can not parse"
integrate (V x) (V y) | x == y     = (V x) ** 2 / 2
                      | otherwise = error "can not parse"

integrate a b = error $ "can not parse : " ++ show a ++ " ##  " ++ show b



-- | get terms of formula
-- 
-- >>> let [x,y] = map V ["x","y"]
-- >>> terms x x
-- [x]
-- >>> terms y x
-- []
-- >>> terms (sin x) x
-- [x,sin(x),cos(x)]
-- >>> terms (1/(sin x)) x
-- [x,sin(x),cos(x)]
terms :: Formula -> Formula -> [Formula]
terms f v = nub $ sort $ filter (\f' -> diff f' v /= 0) $ (indets f) ++ map (\f' -> diff f' v) (indets f)


-- | combination for candidate formula
-- 
-- >>> genPow 1 3
-- [[0,0,0],[0,0,1],[0,1,0],[1,0,0]]
-- >>> genPow 2 3
-- [[0,0,0],[0,0,1],[0,0,2],[0,1,0],[0,1,1],[0,2,0],[1,0,0],[1,0,1],[1,1,0],[2,0,0]]
genPow :: Int -- ^ max degree of formula
       -> Int -- ^ length of terms
       -> [[Int]]
genPow  n w | n <= 0 = [map (\_ -> 0) [1..w]]
            | w <= 1 = map (\f -> [f]) [0..n]
            | otherwise = do
  a <- [0..n]
  b <- genPow (n-a) (w-1)
  return $ a:b


-- | degree for candidate formula
-- 
-- >>> let [x,y] = map V ["x","y"]
-- >>> candidateDegree 3 x
-- 1
-- >>> candidateDegree (sin x) x
-- 2
-- >>> candidateDegree (x**2) x
-- 3
candidateDegree :: Formula -- ^ formula
                -> Formula -- ^ variable
                -> Int -- ^ degree
candidateDegree  f x = 1 + (fromIntegral $ max (degree f) (degree (diff f x)))



-- | candidate formula
-- 
-- >>> let [x,y,z] = map V ["x","y","z"]
-- >>> candidateFormula [x,y,z] 2
-- a0 + a6*x + a9*(x^2) + a3*y + a8*x*y + a5*(y^2) + a1*z + a7*x*z + a4*y*z + a2*(z^2)
candidateFormula :: [Formula] -- ^ variables
                 -> Int -- ^ degree
                 -> Formula -- ^ candidate formula
candidateFormula vars d =
  sum $ flip map (zip coeff pow) $ \(a,p) -> a * (foldr (*) 1 $ map (\(t,n) -> t**(fromIntegral n)) $ zip vars p)
  where
    coeff :: [Formula]
    coeff = reverse $ genCoeff "a" $ length pow
    pow = genPow d (length vars)

-- | derivation of candidate formula
-- 
-- >>> let [a0,a1,a2,a3,a4,a5,a6,a7,a8,a9] = reverse $ genCoeff "a" 10
-- >>> let [x,y,z] = map V ["x","y","z"]
-- >>> let candidate = a0 + a6*x + a9*(x^2) + a3*y + a8*x*y + a5*(y^2) + a1*z + a7*x*z + a4*y*z + a2*(z^2)
-- >>> derivationCandidate [x,y,z] [1,z,-y] candidate
-- a6 + 2*a9*x + a8*y + a7*z + (-1)*y*(a1 + a7*x + a4*y + 2*a2*z) + z*(a3 + a8*x + 2*a5*y + a4*z)
-- >>> expand $ (derivationCandidate [x,y,z] [1,z,-y] candidate ) - y
-- a6 + 2*a9*x + (-1)*y + (-1)*a1*y + a8*y + (-1)*a7*x*y + (-1)*a4*(y^2) + a3*z + a7*z + a8*x*z + (-2)*a2*y*z + 2*a5*y*z + a4*(z^2)
derivationCandidate :: [Formula] -- ^ variables
                    -> [Formula] -- ^ diff of variables
                    -> Formula -- ^ candidate formula
                    -> Formula -- ^ derivation of candidate formula
derivationCandidate vars dvars candidate =
  sum $ do
    (dv,v) <- zip dvars vars
    return $ dv * (diff candidate v)


-- | split formula by coeff and vars
-- 
-- >>> let [a0,a1,a2,a3,a4,a5,a6,a7,a8,a9] = reverse $ genCoeff "a" 10
-- >>> let [x,y,z] = map V ["x","y","z"]
-- >>> let f = a6 + 2*a9*x + (-1)*y + (-1)*a1*y + a8*y + (-1)*a7*x*y + (-1)*a4*(y^2) + a3*z + a7*z + a8*x*z + (-2)*a2*y*z + 2*a5*y*z + a4*(z^2)
-- >>> splitCoeffAndVariable f
-- [(a6,1),(2*a9,x),(-1 + (-1)*a1 + a8,y),((-1)*a7,x*y),((-1)*a4,y^2),(a3 + a7,z),(a8,x*z),((-2)*a2 + 2*a5,y*z),(a4,z^2)]
splitCoeffAndVariable :: Formula -> [(Formula,Formula)]
splitCoeffAndVariable formula = merge prelist
  where
    prelist = reverse $ map headV $ splitAdd formula
    merge :: [(Formula,Formula)] -> [(Formula,Formula)]
    merge [] = []
    merge ((c0,v0):[]) = [(c0,v0)]
    merge ((c0,v0):(c1,v1):xs) | v0 == v1 = merge ((c0+c1,v0):xs)
                               | otherwise = (c0,v0):(merge ((c1,v1):xs))

coeffToVariable :: Formula -> Formula
coeffToVariable formula = mapFormula c2v formula
  where
    c2v f =
      case f of
        (CV a) -> V a
        a -> a
                      
splitFactor :: Formula -> Formula -> (Formula, Formula)
splitFactor p x' =
  case (filter (\t -> isVariable (diff t x')) $ indets p) of
  [] -> (1,p)
  x:_ ->
    let (c,q) = content p x
        (spl1,spl2) = splitFactor c x'
        s = gcdPolynomial q (diff q x') `quot` gcdPolynomial q (diff q x)
        (splh1,splh2) = splitFactor (q `quot` s)  x'
    in if degree s == 0
       then (spl1,q*spl2)
       else (spl1*splh1*s,spl2*splh2)
      

-- | integrate function of rischNorman-algorithm
-- This is under development.
rischNorman' :: Formula -> Formula -> Formula
rischNorman' f x = candidate
  where
    ids = nub $ indets f ++ indets (diff f x)
    ids_diff = map (flip diff x) ids
    len = length ids
    d   = fromIntegral $ max (degree f) (degree (diff f x))
    pow :: [[Int]]
    pow = genPow d len
    vars :: [Formula]
    vars = genCoeff "a" $ length pow
    candidate = foldr (+) 0 $ flip map (zip vars pow) $ \(a,p) -> a * (foldr (*) 1 $ map (\(t,n) -> t**(fromIntegral n)) $ zip ids p)



--heurischCandidate :: Formula -> Formula -> Formula
--heurischCandidate f x = 


--heurisch :: Formula -> Formula -> Formula
--heurisch f x = 
module Algebra.CAS.Solve where

import Algebra.CAS.Base
import qualified Data.Map as M
import Control.Applicative
import Data.List

match :: Formula -- ^ pattern
       -> Formula -- ^ matched formula
       -> Maybe [(Formula,Formula)] -- ^ matched variable pairs
match a b = match' a b []
  where
    match' :: Formula
           -> Formula
           -> [(Formula,Formula)]
           -> Maybe [(Formula,Formula)]
    match' (a0:^:b0) (a1:^:b1) lst = do
      v1 <- match' a0 a1 lst
      case (b0,b1) of
        (c0@(C _),c1@(C _)) ->
          if c0 == c1
          then return lst
          else Nothing
        _ -> match' b0 b1 v1
    match' (a0:*:b0) (a1:*:b1) lst = do
      v <- match' b0 b1 lst
      match' a0 a1 v
    match' (a0:+:b0) (a1:+:b1) lst = do
      v <- match' b0 b1 lst
      match' a0 a1 v
    match' (a0:/:b0) (a1:/:b1) lst = do
      v <- match' b0 b1 lst
      match' a0 a1 v
    match' (_:^:_) _ _ = Nothing
    match' (a0:+:b0) a1 lst = do
      v <- match' b0 a1 lst
      match' a0 0 v
    match' (a0:*:b0) a1 lst = do
      v <- match' b0 a1 lst
      match' a0 1 v
    match' (_:/:_) _ _ = Nothing
    match' (V x) (V y) lst | x == y = Just $ lst
                           | otherwise = Nothing
    match' a0@(CV _) a1 lst = Just $ (a0,a1):lst
    match' _ _ _ = Nothing
  
solve1 :: Formula -> Formula -> Maybe [Formula]
solve1 f v = do
  let [a,b] = map CV ["a","b"]
  list <- match (a*v+b) f
  let m = M.fromList list
  return [- (m M.! b /  m M.! a)]

solve2 :: Formula -> Formula -> Maybe [Formula]
solve2 f v = abc <|> ac
  where
    ac = do 
      let [a,b,c] = map CV ["a","b","c"]
      list <- (match (a*v**2+c) f)
      let m = M.fromList ((b,0):list)
      let [a',b',c'] = map (m M.!) [a,b,c]
      anser a' b' c'
    abc = do 
      let [a,b,c] = map CV ["a","b","c"]
      list <- (match (a*v**2+b*v+c) f)
      let m = M.fromList list
      let [a',b',c'] = map (m M.!) [a,b,c]
      anser a' b' c'
    anser a' b' c' = do
      let a2= 2*a'
      let sq=sqrt $ expand (b'**2-4*a'*c')
      return $ [(sq-b')/a2,(-sq-b')/a2]

solve :: Formula -- ^ formula
      -> Formula -- ^ variable
      -> Maybe [Formula] -- ^ answer
solve f v = solve2 f v <|> solve1 f v

[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9] = reverse $ genCoeff "a" 10
prob = [a6,2*a9,-1 + a8 + (-1)*a1,(-1)*a7,(-1)*a4,a3 + a7,a8,(-2)*a2 + 2*a5,a4]

-- | solve linear equations
-- >>> let [a0,a1,a2,a3,a4,a5,a6,a7,a8,a9] = reverse $ genVars "a" 10
-- >>> let equations = [a6,2*a9,-1 + a8 + (-1)*a1,(-1)*a7,(-1)*a4,a3 + a7,a8,(-2)*a2 + 2*a5,a4]
-- >>> equations
-- [a6,2*a9,-1 + (-1)*a1 + a8,(-1)*a7,(-1)*a4,a3 + a7,a8,(-2)*a2 + 2*a5,a4]
-- >>> linsolve [head equations]
-- Just [(a6,0)]
-- >>> linsolve $ equations ++ [a0,a2]
-- Just [(a0,0),(a1,-1),(a2,0),(a3,0),(a4,0),(a5,0),(a6,0),(a7,0),(a8,0),(a9,0)]
linsolve :: [Formula] -- ^ formulas
         -> Maybe [(Formula,Formula)] -- ^ answer (varible,value)
linsolve fs = if length a == length variables' then Just (sort a) else Nothing
  where
    r = reverse $ lReductions $ reverse $ sort fs
    a = rSolve r
    variables' = nub $ foldr (++) [] $ map variables fs

lReduction :: Formula
           -> Formula
           -> Formula
lReduction f0 f1 =
  if t0 == t1
  then expand $ f1 - (c1/c0)*f0
  else f1
  where
    (c0,t0) = headV f0
    (c1,t1) = headV f1


lReductions :: [Formula]
            -> [Formula]
lReductions [] = []
lReductions (f:fs) = f: (reverse $ sort $ lReductions (flist f fs))
  where
    flist :: Formula -> [Formula] -> [Formula]
    flist f' fs' =  map (lReduction f') fs'

rSolve :: [Formula] -> [(Formula,Formula)]
rSolve [] = []
rSolve (f:fs) =
  case variables f of
    [] -> rSolve fs
    v':_ ->
      case solve1 f v' of
        Just [a'] -> (v',a'): rSolve (map (subst [(v',a')]) fs)
        Just _ -> error "error"
        Nothing -> []
{-#LANGUAGE TemplateHaskell#-}
{-#LANGUAGE QuasiQuotes#-}
{-#LANGUAGE OverloadedStrings#-}

module Algebra.CAS.TH where

import Language.Haskell.TH.Syntax

import Algebra.CAS.Base
import qualified Algebra.CAS.Diff as A
import qualified Language.Haskell.TH.Ppr as P
import qualified Data.Text as T
import Control.Applicative

exp2val :: Exp -> Formula

exp2val (InfixE (Just a) (VarE op) (Just b))
  | op == '(+) = exp2val a + exp2val b
  | op == '(-) = exp2val a - exp2val b
  | op == '(*) = exp2val a * exp2val b
  | op == '(/) = exp2val a / exp2val b
  | op == '(**) = exp2val a ** exp2val b
  | otherwise = error "exp2val // can not parse"

exp2val (AppE (VarE fun) a)
  | fun ==  'log = S $ Log $ exp2val a
  | fun ==  'sqrt = S $ Sqrt $ exp2val a
  | fun ==  'exp = S $ Exp $ exp2val a
  | fun ==  'sin = S $ Sin $ exp2val a
  | fun ==  'cos = S $ Cos $ exp2val a
  | fun ==  'tan = S $ Tan $ exp2val a
  | fun ==  'asin = S $ Asin $ exp2val a
  | fun ==  'acos = S $ Acos $ exp2val a
  | fun ==  'atan = S $ Atan $ exp2val a
  | fun ==  'sinh = S $ Sinh $ exp2val a
  | fun ==  'cosh = S $ Cosh $ exp2val a
  | fun ==  'tanh = S $ Tanh $ exp2val a
  | fun ==  'asinh = S $ Asinh $ exp2val a
  | fun ==  'acosh = S $ Acosh $ exp2val a
  | fun ==  'atanh = S $ Atanh $ exp2val a
  | fun ==  'negate = C (CI (-1)) * (exp2val a)
  | otherwise = error "can not parse"
exp2val (LitE (IntegerL a)) = C (CI a)
exp2val (LitE (RationalL a)) = C (CR (fromRational a))
exp2val (VarE a@(Name (OccName v) _)) | a == 'pi = Pi
                                      | otherwise = V v

exp2val a@_ = error $ "exp2val // can not parse:" ++ show a

val2exp :: Formula -> Exp
val2exp (a :+: b) = (InfixE (Just (val2exp a)) (VarE '(+)) (Just (val2exp b)))
val2exp (a :*: b) = (InfixE (Just (val2exp a)) (VarE '(*)) (Just (val2exp b)))
val2exp (a :/: b) = (InfixE (Just (val2exp a)) (VarE '(/)) (Just (val2exp b)))
val2exp (a :^: b) = (InfixE (Just (val2exp a)) (VarE '(**)) (Just (val2exp b)))

val2exp (S (Log a)) = (AppE (VarE 'log) (val2exp a))
val2exp (S (Sqrt a)) = (AppE (VarE 'sqrt) (val2exp a))
val2exp (S (Exp a)) = (AppE (VarE 'exp) (val2exp a))
val2exp (S (Sin a)) = (AppE (VarE 'sin) (val2exp a)) 
val2exp (S (Cos a)) = (AppE (VarE 'cos) (val2exp a)) 
val2exp (S (Tan a)) = (AppE (VarE 'tan) (val2exp a))
val2exp (S (Asin a)) = (AppE (VarE 'asin) (val2exp a))
val2exp (S (Acos a)) = (AppE (VarE 'acos) (val2exp a))
val2exp (S (Atan a)) = (AppE (VarE 'atan) (val2exp a))
val2exp (S (Sinh a)) = (AppE (VarE 'sinh) (val2exp a))
val2exp (S (Cosh a)) = (AppE (VarE 'cosh) (val2exp a))
val2exp (S (Tanh a)) = (AppE (VarE 'tanh) (val2exp a))
val2exp (S (Asinh a)) = (AppE (VarE 'asinh) (val2exp a))
val2exp (S (Acosh a)) = (AppE (VarE 'acosh) (val2exp a))
val2exp (S (Atanh a)) = (AppE (VarE 'atanh) (val2exp a))

val2exp (C (CI a)) = LitE (IntegerL a)
val2exp (C (CR a)) = LitE (RationalL (toRational a))
val2exp (C (CF a b)) = LitE (RationalL ((toRational a)/(toRational b)))
val2exp (C One) = LitE (IntegerL 1)
val2exp (C Zero) = LitE (IntegerL 0)
val2exp Pi = VarE 'pi
val2exp (V a) = VarE $ mkName a

val2exp a@_ = error $ "val2exp // can not parse:" ++ show a

lift  ::  Formula -> Exp
lift  = val2exp
lift1 ::  (Formula -> Formula) -> Exp -> Exp
lift1 a b = val2exp $ a (exp2val b)
lift2 ::  (Formula -> Formula -> Formula) -> Exp -> Exp -> Exp
lift2 a b c = val2exp $ a (exp2val b) (exp2val c)
lift3 ::  (Formula -> Formula -> Formula -> Formula) -> Exp -> Exp -> Exp -> Exp
lift3 a b c d = val2exp $ a (exp2val b) (exp2val c) (exp2val d)

prettyPrint ::  Formula ->  String
prettyPrint var = T.unpack $
                  T.replace "GHC.Num." "" $
                  T.replace "GHC.Float." "" $
                  T.replace "GHC.Real." "" $
                  T.pack $ show $ P.ppr $ val2exp var

--deriving Show Formula where
--  show a = prettyPrint a

diff :: Q Exp -> Q Exp -> Q Exp
diff a b = (lift2 A.diff) <$> a <*> b
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
module Main where

import Test.DocTest

main :: IO ()
main = do
  doctest $
    [
    "-XOverloadedStrings",
    "Algebra/CAS.hs",
    "Algebra/CAS/Diff.hs",
    "Algebra/CAS/TH.hs",
    "Algebra/CAS/Base.hs"
    ]
{-# LANGUAGE OverloadedStrings #-}

module Algebra.CAS.BasicSpec (main, spec) where

import Test.Hspec
import Algebra.CAS.Base

main :: IO ()
main = hspec spec

x :: Formula
x = "x"
y :: Formula
y = "y"
z :: Formula
z = "z"

spec :: Spec
spec = do
  describe "simplify(sqrt)" $ do
    it "sqrt(4) == 2" $ do
      let v = 4 :: Formula
      sqrt v `shouldBe` 2
    it "sqrt(0) == 0" $ do
      let v = 0 :: Formula
      sqrt v `shouldBe` 0
    it "sqrt(1) == 1" $ do
      let v = 1 :: Formula
      sqrt v `shouldBe` 1
    it "sqrt(3) == Sqrt 3" $ do
      let v = 3 :: Formula
      sqrt v `shouldBe` S (Sqrt 3)
    it "sqrt(-1) == I" $ do
      let v = -1 :: Formula
      sqrt v `shouldBe` I
    it "I*I == -1" $ do
      I*I `shouldBe` -1
  describe "add" $ do
    it "x<y" $ do
      x<y `shouldBe` True
    it "y<x" $ do
      y<x `shouldBe` False
    it "x<x**2" $ do
      x<x**2 `shouldBe` True
    it "x>**2" $ do
      x>x**2 `shouldBe` False
    it "x+y==y+x" $ do
      x+y `shouldBe` y+x
    it "x+y+y==x+2*y" $ do
      x+y+y `shouldBe` x+2*y
    it "x**2+x**2+y == 2*x**2+y" $ do
      x**2+x**2+y `shouldBe` 2*x**2+y
    it "2*y+x+x+y == 2*x+3*y" $ do
      2*y+x+x+y+z `shouldBe` 2*x+3*y+z
  describe "mult" $ do
    it "x*x==x**2" $ do
      x*x `shouldBe` x**2
    it "x*x**2==x**3" $ do
      x*x**2 `shouldBe` x**3
    it "x**0=1" $ do
      x**0 `shouldBe` 1
    it "(x+y)*y != x*y+y**2" $ do
      (x+y)*y ==  x*y+y**2 `shouldBe` False
    it "expand ((x+y)*y) == x*y+y**2" $ do
      expand ((x+y)*y) `shouldBe` x*y+y**2 
    it "expand (1+x)*(2+x)*((y+x)*(y+x*2)+x)" $ do
      expand ((1+x)*(2+x)*((y+x)*(y+x*2)+x)) `shouldBe` 2*x + 7*(x^2) + 7*(x^3) + 2*(x^4) + 6*x*y + 9*(x^2)*y + 3*(x^3)*y + 2*(y^2) + 3*x*(y^2) + (x^2)*(y^2)
  describe "div" $ do
    it "x/x==1" $ do
      x/x `shouldBe` 1
    it "x*y/x == y" $ do
      x*y/x `shouldBe` y
    it "y/x*x == y" $ do
      (y/x)*x `shouldBe` y
    it "y*x**2*z/x == x*y*z" $ do
      y*x**2*z/x `shouldBe` x*y*z
    it "(x**2+x)/x == (x**2+x):/:x" $ do
      (x**2+x)/x `shouldBe` (x**2+x):/:x
    it "-(x+y-1)+x-y-3 == -2y-2" $ do
      expand (x-y-3-(x+y-1)) `shouldBe` -2*y-2
--    it " ((2*x)/(y))*(-1)*y == -2x" $ do
--      expand (((2*x)/(y))*(-1)*y) `shouldBe` -2*x
  describe "gcd" $ do
    it "gcdPolynomial (2*x) x == x " $ do
      gcdPolynomial (2*x) x `shouldBe`  x
    it "gcdPolynomial (expand $ (x+y)*(x+2)) (expand $ (x+y)*(x+3)) == (x+y)" $ do
      gcdPolynomial (expand $ (x+y)*(x+2)) (expand $ (x+y)*(x+3)) `shouldBe` (x+y)
  describe "lcm" $ do
    it "lcmPolynomial  (expand $ (x+y)*(x+1)) (expand $ (x+y)*(x+2))" $ do
      lcmPolynomial  (expand $ (x+y)*(x+1)) (expand $ (x+y)*(x+2)) `shouldBe` expand ((x+y)*(x+1)*(x+2))
  describe "read and show" $ do
    it "showFormula" $ do
      showFormula  (x^2+x+y) `shouldBe` "((V \"x\" :+: (V \"x\" :^: C (CI 2))) :+: V \"y\")"
    it "read Formula" $ do
      read (showFormula  (x^2+x+y)) `shouldBe` x^2+x+y
    it "pretty print" $ do
      show (x^2+x+y) `shouldBe` "x + x^2 + y"
  describe "substitute" $ do
    it "subst [(x,1),(y,2)] (x+y) = 3" $ do
      subst [(x,1),(y,2)] (x+y) `shouldBe` 3
{-# LANGUAGE OverloadedStrings #-}

module Algebra.CAS.DiffSpec (main, spec) where

import Test.Hspec
import Algebra.CAS.Base
import Algebra.CAS.Diff

main :: IO ()
main = hspec spec

x :: Formula
x = "x"
y :: Formula
y = "y"
z :: Formula
z = "z"

spec :: Spec
spec = do
  describe "diff" $ do
    it "diff(x+y,x)" $ do
      diff (x+y) (x) `shouldBe` 1
    it "diff(x*x+y,x)" $ do
      diff (x*x+y) (x) `shouldBe` 2*x
    it "diff(sin(x*x)+y+z,x)" $ do
      diff (sin(x*x)+y+z) (x) `shouldBe` 2*cos(x*x)*x
    it "diff(log(x),x)" $ do
      diff (log(x)) (x) `shouldBe` 1/x
{-# LANGUAGE OverloadedStrings #-}

module Algebra.CAS.GrobnerBasisSpec (main, spec) where

import Test.Hspec
import Algebra.CAS.Base
import Algebra.CAS.GrobnerBasis

main :: IO ()
main = hspec spec

x :: Formula
x = "x"
y :: Formula
y = "y"
z :: Formula
z = "z"

a :: Formula
a = CV "a"
b :: Formula
b = CV "b"
c :: Formula
c = CV "c"

fs  = [  1 -x        - 3*y**2 + y**3,
        -1    + x**2 -   y**2 
      ]

spec :: Spec
spec = do
  describe "reduction" $ do
    it "reduction (x+y ,y)" $ do
      reductions (x+y) [y] `shouldBe` x
    it "reduction (x+x*y ,y)" $ do
      reductions (x+x*y) [y] `shouldBe` x
    it "reduction (x+x*y ,x+y)" $ do
      reductions (x+x*y) [x+y] `shouldBe` (-x**2+x)
    it "reductions (x+x*y ,[x+y,x])" $ do
      reductions (x+x*y) [x+y,x**2] `shouldBe` x
    it "reductions (fs)" $ do
      reductions (head fs) (tail fs)  `shouldBe`  4 + (-1)*(x) + (-3)*(x^2) + (-1)*(y) + (x^2)*(y)
  describe "grobnerBasis" $ do„ÄÄ-- under development
    it "grobnerBasis (fs)" $ do
      grobnerBasis fs `shouldBe`
        [
          1 + (-1)*(x) + (-3)*(y^2) + y^3,
          1 + (-1)*(x^2) + y^2,
          4 + (-1)*(x) + (-3)*(x^2) + (-1)*(y) + (x^2)*(y),
          -13 + (3)*(x) + (11)*(x^2) + (-1)*(x^4) + (-1)*(y) + (x)*(y),
          -17 + (8)*(x) + (26)*(x^2) + (-6)*(x^3) + (-12)*(x^4) + x^6,
          17 + (9)*(x) + (-17)*(x^2) + (-11)*(x^3) + x^4 + x^5
        ]
      
{-# LANGUAGE OverloadedStrings #-}

module Algebra.CAS.SolveSpec (main, spec) where

import Test.Hspec
import Algebra.CAS.Base
import Algebra.CAS.Solve

main :: IO ()
main = hspec spec

x :: Formula
x = "x"
y :: Formula
y = "y"
z :: Formula
z = "z"

a :: Formula
a = CV "a"
b :: Formula
b = CV "b"
c :: Formula
c = CV "c"

spec :: Spec
spec = do
  describe "match" $ do
    it "x**2 vs x**2" $ do
      match (x**2) (x**2) `shouldBe` Just []
    it "a*x**2 vs x**2" $ do
      match (a*x**2) (x**2) `shouldBe` Just [(a,1)]
    it "a*x**2+b*x vs x**2" $ do
      match (a*x**2+b*x) (x**2) `shouldBe` Nothing
    it "a*x**2+b*x vs x**2+3*x" $ do
      match (a*x**2+b*x) (x**2+3*x) `shouldBe` Just [(b,3),(a,1)]
    it "a*x**2+b*x+c vs x**2+3*x" $ do
      match (a*x**2+b*x+c) (x**2+3*x) `shouldBe` Just [(c,0),(b,3),(a,1)]
    it "a*x**2+b*x+c vs x**2+3*x+4" $ do
      match (a*x**2+b*x+c) (x**2+3*x+4) `shouldBe` Just [(c,4),(b,3),(a,1)]
    it "a*x**2+b*x+c vs x**2 -2*x+1" $ do
      match (a*x**2+b*x+c) (x**2-2*x+1) `shouldBe` Just [(c,1),(b,-2),(a,1)]
  describe "polynomial solver" $ do
    it "3*x + 3 = 0" $ do
      solve (3*x+3) x `shouldBe` Just [-1]
    it "x**2 - 2*x + 1 = 0" $ do
      solve (x**2 - 2*x + 1) x `shouldBe` Just [1,1]
    it "x**2 - 4*x + 3 = 0" $ do
      solve (x**2 - 4*x + 3) x `shouldBe` Just [3,1]
  describe "linear solver" $ do
    it "x + y = 1,x - y = 3 " $ do
      lReductions [x+y-1,x-y-3] `shouldBe` [x+y-1,2*x-4]
    it "x = 0" $ do
      linsolve [x] `shouldBe` Just [(x,0)]
    it "x + y = 1,x - y = 3 == x = 2,y=-1" $ do
      linsolve [x+y=:1,x-y=:3] `shouldBe` Just [(x,2),(y,-1)]
    it "x+y+z=2,x+2*y+3*z=1,2*x+y+z=2" $ do
      linsolve [x+y+z=:2,x+2*y+3*z=:1,2*x+y+z=:2] `shouldBe` Just [(x,0),(y,5),(z,-3)]
--     it "[a6,2*a9,-1 + a8 + (-1)*a1,(-1)*a7,(-1)*a4,a3 + a7,a8,(-2)*a2 + 2*a5,a4]" $ do
--       let [a0,a1,a2,a3,a4,a5,a6,a7,a8,a9] = reverse $ genCoeff "a" 10
--       linsolve [a6,2*a9,-1 + a8 + (-1)*a1,(-1)*a7,(-1)*a4,a3 + a7,a8,(-2)*a2 + 2*a5,a4] `shouldBe` Just [(a1,-1),(a2,0),(a3,0),(a4,0),(a5,0),(a6,0),(a7,0),(a8,0),(a9,0)]
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Algebra.CAS.THSpec (main, spec) where

import Test.Hspec
import Test.Hspec.QuickCheck
import Algebra.CAS()
import qualified Algebra.CAS.TH as TH

main :: IO ()
main = hspec spec

spec :: Spec
spec = do
  describe "th-diff" $ do
    prop "diff(x+1,x)" $ \(x :: Int) -> 
      $(TH.diff [|x+1|] [|x|]) ==  1
    prop "diff(x^2+x+1,x)" $ \(x :: Int) -> 
      $(TH.diff [|x*x+1+x|] [|x|]) == (2*x + 1)
    prop "diff(diff(x^3+x+1,x)+x,x)" $ \(x :: Int) -> 
      $(TH.diff [|$(TH.diff [|x*x*x+1+x|] [|x|]) + x|] [|x|]) == (6*x+1)
    prop "diff(x+y*x,x)" $ \((x,y) :: (Int,Int)) -> 
      $(TH.diff [|x+x*x*y|] [|x|]) == (2*x*y+1)
    prop "diff(sin(cos(x)),x)" $ \(x ::  Float) -> 
      $(TH.diff [|sin(cos(x))|] [|x|]) ==  - (sin x)*cos(cos x)
